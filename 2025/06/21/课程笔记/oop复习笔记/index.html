<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="ffy">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
            <link rel="preconnect" href="https://evan.beee.top" crossorigin>
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2025/06/21/课程笔记/oop复习笔记/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="oop复习">
<meta property="og:url" content="http://example.com/2025/06/21/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/oop%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/redefine-og.webp">
<meta property="article:published_time" content="2025-06-21T10:55:00.000Z">
<meta property="article:modified_time" content="2025-06-26T06:57:33.038Z">
<meta property="article:author" content="ffy">
<meta property="article:tag" content="编程语言">
<meta property="article:tag" content="CS课程">
<meta property="article:tag" content="面向对象编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/img/avatar.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/avatar.svg">
    <meta name="theme-color" content="#f0ad7c">
    <link rel="shortcut icon" href="/img/avatar.svg">
    <!--- Page Info-->
    
    <title>
        
            oop复习 | ffyの四次元口袋
        
    </title>

    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    
        
            
    
            
    
            
                
                    <link rel="stylesheet" href="/css/custom.css">
                
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
        <link href="/fonts/custom-fonts.css" rel="stylesheet">
    
    
        <link href="/fonts/custom-fonts.css" rel="stylesheet">
    
    
        <link href="/fonts/custom-fonts.css" rel="stylesheet">
    
    
        <link href="/fonts/custom-fonts.css" rel="stylesheet">
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"mono, monospace","url":"/fonts/custom-fonts.css"}},"toc":{"enable":true,"max_depth":4,"number":true,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":true,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#f0ad7c","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":true,"family":"WenKai, sans-serif","url":"/fonts/custom-fonts.css"},"english":{"enable":true,"family":"mono, sans-serif","url":"/fonts/custom-fonts.css"},"title":{"enable":true,"family":"WenKai, sans-serif","url":"/fonts/custom-fonts.css"}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedsun.png?imageSlim","dark":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefineddark.png?imageSlim"},"title":"随机掉落生活碎片和学习记录~","subtitle":{"text":["This is the first message"],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn?c=a&c=d&c=k"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/ffy6511","instagram":null,"zhihu":null,"twitter":null,"email":"1253876012z@gmail.com"},"qrs":{"weixin":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedvx.JPG?imageSlim"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":true,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"Friends":{"path":"/links","icon":"fa-regular fa-heart"},"导航":{"icon":"fa-regular fa-compass","submenus":{"chatSQL":"https://chat-sql-hazel.vercel.app/"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"info","announcement":"在此分享个人的（补天）笔记、摸索技术中的经验心得，同时也会不时掉落一些随笔！欢迎交流与讨论～","show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","excerpt_length":130,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2025/5/8 19:11:00"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                ffyの四次元口袋
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags"
                                        >
                                    <i class="fa-regular fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories"
                                        >
                                    <i class="fa-regular fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/links"
                                        >
                                    <i class="fa-regular fa-heart fa-fw"></i>
                                    友情链接
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-compass fa-fw"></i>
                                    导航
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://chat-sql-hazel.vercel.app/">
                                                    CHATSQL
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/links"
                        >
                            <span>
                                友情链接
                            </span>
                            
                                <i class="fa-regular fa-heart fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-导航"
                        >
                            <span>
                                导航
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-导航">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://chat-sql-hazel.vercel.app/">CHATSQL</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">26</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">6</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">24</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			
			
			<img src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094812819.png?imageSlim" alt="oop复习" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75" />
			
			<div class="w-full flex items-center absolute bottom-0 justify-start">
				<h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-semibold backdrop-blur-lg rounded-xl border border-border-color ">oop复习</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/img/avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">ffy</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv3</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-06-21 18:55</span>
        <span class="mobile">2025-06-21 18:55</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-06-26 14:57:33</span>
            <span class="mobile">2025-06-26 14:57:33</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">课程笔记</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/CS%E8%AF%BE%E7%A8%8B/">CS课程</a>&nbsp;
                    </li>
                
                    <li>
                        | <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象编程</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>9.6k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>40 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<blockquote>
<p>任课老师：<strong>翁恺</strong></p>
</blockquote>
<h1 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h1><ul>
<li><p><code>end（）</code>返回的是容器最后一个位置的<strong>下一个位置</strong>的迭代器</p>
</li>
<li><p><code>string::npos</code>是 <code>size_t</code>类型的最大值;</p>
</li>
<li><p><code>to_string</code>将数字转换成字符串:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">string str = <span class="built_in">to_string</span>(num);</span><br></pre></td></tr></table></figure></div></li>
<li><p><code>stoi</code>将字符串转换成整数</p>
</li>
<li><p>参数的默认值只能从右到左给出；默认值只能出现在函数的原型或者将定义和声明放在一起，而不能在分离的定义中声明</p>
</li>
<li><p>列表初始化是按成员的<strong>声明顺序</strong>执行的，和成员在列表中的顺序无关。</p>
</li>
</ul>
<h2 id="实验操作"><a href="#实验操作" class="headerlink" title="实验操作"></a>实验操作</h2><h4 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h4><p>用邮箱地址的截取，说明 <code>rfind</code>与 <code>str</code>等方法的使用：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string email = <span class="string">"user.name@example.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户名的部分</span></span><br><span class="line"><span class="type">int</span> atPos = email.<span class="built_in">find</span>(<span class="string">'@'</span>);</span><br><span class="line">string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, atPos); <span class="comment">// result: "user.name"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取域名部分</span></span><br><span class="line">string domain =  email.<span class="built_in">substr</span>(atPos + <span class="number">1</span>); <span class="comment">// result: "example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顶级域名(最后一个.之后的部分)</span></span><br><span class="line"><span class="type">int</span> lastDotPos = email.<span class="built_in">rfind</span>(<span class="string">'.'</span>);</span><br><span class="line">string topLevelDomain = email.<span class="built_in">substr</span>(lastDotPos + <span class="number">1</span>); <span class="comment">// result: "com"</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><h3 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h3><ul>
<li>一个简单的输入/输出：流</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// 需要包含这个头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件输出（写入文件）</span></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"output.txt"</span>)</span></span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl;</span><br><span class="line">outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件输入（读取文件）</span></span><br><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">"input.txt"</span>)</span></span>; </span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(inFile, line);</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>getline()</code>函数可以显式指定终止符（第三个参数），默认为 <code>\n</code>也就是换行符。并且会将终止符丢弃</p>
</blockquote>
<h4 id="位或运算符指定模式"><a href="#位或运算符指定模式" class="headerlink" title="位或运算符指定模式"></a>位或运算符指定模式</h4><p>可以使用 <code>｜</code>来指定多个模式：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合使用打开模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"test.txt"</span>, ios::out | ios::app)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="字符串流"><a href="#字符串流" class="headerlink" title="字符串流"></a>字符串流</h3><p>字符串流的作用原理：</p>
<ul>
<li>作用: 将字符串转换成一个类似于输入流的对象;</li>
<li>内部维护了一个字符串和一个位置指针;</li>
<li>每次读取时, 位置指针向后移动, 且自动跳过空白字符.</li>
</ul>
<p><code>stringstream</code>表示双向字符串流</p>
<h4 id="字符串分词"><a href="#字符串分词" class="headerlink" title="字符串分词"></a>字符串分词</h4><p>我们可以将字符串转换成字符串流，来实现字符串的分词：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">name</span><span class="params">(<span class="string">"xiao ming"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">istringstream <span class="title">is</span><span class="params">(name)</span></span>;</span><br><span class="line">string token;</span><br><span class="line"><span class="keyword">while</span>(is &gt;&gt; token)</span><br><span class="line">	cout &lt;&lt; token &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>按照空白字符i.e. 空格、<code>\t</code>, <code>\n</code>来分词</p>
</blockquote>
<h4 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ostringstream oss;</span><br><span class="line">    string name = <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">25</span>;</span><br><span class="line">  </span><br><span class="line">    oss &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; name &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; age;</span><br><span class="line">    string result = oss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>Output:</strong></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name: Alice, Age: 25</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>通过 <code>.str()</code>方法可以对象转换为字符串类型, 从而<strong>格式化输出</strong>.</p>
<p><code>.str("")</code>方法可以<strong>清空</strong>字符串流:</p>
</blockquote>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h4 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h4><p>以更简单的方式遍历容器内元素:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">double</span>&gt; price;</span><br><span class="line"><span class="comment">// Assume we've inserted a lot of name-price pairs</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> [key, value]: price){</span><br><span class="line">    std::cout &lt;&lt; key &lt;&lt; <span class="string">": "</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><h4 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h4><p>使用～函数可以查找不小于某个值的第一个键：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; tags{{<span class="number">10</span>, <span class="number">1</span>}, {<span class="number">100</span>, <span class="number">2</span>}, {<span class="number">1000</span>, <span class="number">3</span>}, {<span class="number">10000</span>, <span class="number">4</span>}, {<span class="number">10000000000</span>, <span class="number">10</span>}};</span><br><span class="line">std::map&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt;::iterator it = tags.<span class="built_in">lower_bound</span>(<span class="number">2000</span>);</span><br><span class="line">std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl; <span class="comment">// it should be "10000 4"</span></span><br><span class="line">it++;</span><br><span class="line">std::cout &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" "</span> &lt;&lt; it-&gt;second &lt;&lt; std::endl; <span class="comment">// it should be "10000000000 10"</span></span><br></pre></td></tr></table></figure></div>

<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><h4 id="include机制"><a href="#include机制" class="headerlink" title="include机制"></a>include机制</h4><p><code>#include</code> 语句的作用是将某个文件插入到语句所在位置。根据搜索的顺序，可以划分不同的用法。</p>
<ul>
<li><code>#include "xx.h"</code>：先搜索当前文件夹，再搜索系统库</li>
<li><code>#include &lt;xx.h&gt;</code>：搜索系统库</li>
<li><code>#include &lt;xx&gt;</code>：搜索系统库</li>
</ul>
<p>注意权限的管理是<strong>针对于类</strong>的，同一类的不同对象可以在其成员函数内任意访问别的成员</p>
<p>友元不具有传递性：</p>
<ul>
<li><code>friend class</code>+一个类名，可以指定友元类</li>
<li><code>friend</code>+一个函数的声明，指定友元函数</li>
</ul>
<p>生命周期：</p>
<ul>
<li>main外的类的对象（i.e. 全局作用域），其构造函数调用的时间早于 <code>main</code>函数；其析构函数的调用也在 <code>main</code>函数返回之后</li>
</ul>
<h4 id="静态"><a href="#静态" class="headerlink" title="静态"></a>静态</h4><p>静态指的是：</p>
<ul>
<li>空间的静态</li>
<li>受限的访问</li>
<li>静态局部变量在第一次遇到的时候初始化</li>
<li>静态成员变量在 <code>.h</code>文件中的声明有 <code>static</code>标签，但是在 <code>.cpp</code> 中不应该有～标签；否则无法被其他文件中使用。 静态成员函数同理</li>
</ul>
<p>两种访问静态内容的方式：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="title class_">name</span>&gt;::&lt;<span class="type">static</span> member&gt;</span><br><span class="line">&lt;object name&gt;.&lt;<span class="type">static</span> member&gt;</span><br></pre></td></tr></table></figure></div>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>一般的字面量都是右值，但是字符串是例外，因为字符串实际上存储在静态内存区</p>
<p>一般来说，左值引用不能绑定右值，但是<strong>常量左值引用可以绑定右值</strong>，因为常量的特性确定了不会对右值进行修改</p>
<blockquote>
<p>但是如果同时存在右值引用，右值作为参数时还是会优先重载右值引用的版本</p>
</blockquote>
<p><strong>规范：</strong></p>
<ul>
<li><p>不允许定义引用的引用；</p>
</li>
<li><p><strong>不允许定义引用的数组</strong>；</p>
<ul>
<li>引用不是单独存在的对象，无法按照数组存储</li>
</ul>
</li>
<li><p><strong>不允许定义指向引用的指针</strong></p>
<ul>
<li>指针必须指向对象，而引用不是对象</li>
</ul>
</li>
</ul>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>使用 <code>const</code>标记声明为常量</p>
<p>常量可以直接让编译器尝试替换：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> bufsize = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> index[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line"><span class="type">int</span> f[bufsize]; <span class="comment">// Ok: f[1024]</span></span><br><span class="line"><span class="type">int</span> f[index[<span class="number">3</span>]]; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></div>

<p>但是需要特别注意的是：<strong>对象的常量不是编译器常量！ i.e.</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> array[size]; <span class="comment">// Error！</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>可以使用枚举或者 <code>static</code>来解决上述的问题：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> {size = <span class="number">10</span>};</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> size = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></div></blockquote>
<p>常量和指针；</p>
<ul>
<li><code>const *p</code>表示不能通过指针改变指向的对象内容；</li>
<li><code>* const p</code>表示不能改变指针的指向位置</li>
</ul>
<blockquote>
<p>不需要关注类型与 <code>*</code>的位置关系</p>
</blockquote>
<p><strong>字符指针和字符数组；</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *sp = <span class="string">"Hello World!"</span>; <span class="comment">// 字符指针可以移动，不能修改</span></span><br><span class="line"><span class="type">char</span> array[] = <span class="string">"Hello World!"</span>; <span class="comment">// 字符数组不能移动，可以修改</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'h'</span> ; <span class="comment">// 合法</span></span><br><span class="line">array = <span class="string">'hello'</span>; <span class="comment">// 非法！</span></span><br><span class="line"></span><br><span class="line">sp = <span class="string">'world'</span>; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>实际上，<code>char *sp</code>就是 <code>const char *sp</code>，所以不能改变字符串的值，但是可以改变sp的指向</p>
<p>而字符串数组的数组名是栈中的固定地址，无法移动，但是可以修改</p>
</blockquote>
<p>注意区分<strong>常量函数</strong>和返回值的常量：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getName</span><span class="params">(<span class="type">int</span> id)</span> <span class="type">const</span></span>; <span class="comment">// 常量函数，无法改变成员变量，常量对象只能调用自己的常量成员函数（与静态成员函数）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">getAge</span><span class="params">(<span class="type">int</span> id)</span></span>; <span class="comment">// 限制了返回值是一个常量</span></span><br></pre></td></tr></table></figure></div>

<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>注意 <code>[]</code>搭配的使用：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">...</span><br><span class="line"><span class="keyword">delete</span> [] p;</span><br></pre></td></tr></table></figure></div>

<h2 id="Inside-class"><a href="#Inside-class" class="headerlink" title="Inside class"></a>Inside class</h2><h4 id="代理构造"><a href="#代理构造" class="headerlink" title="代理构造"></a>代理构造</h4><p>可以在一个构造函数中调用另一个构造函数，减少代码的重复：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">sorted</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">sorted</span>(){}</span><br><span class="line">    <span class="built_in">sorted</span>(<span class="type">int</span> _x){</span><br><span class="line">        x = _x &gt; <span class="number">0</span>? _x: <span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sorted</span>(<span class="type">int</span> _x, <span class="type">int</span> _z): <span class="built_in">sorted</span>(_x){</span><br><span class="line">        z = _z &gt; <span class="number">0</span> &amp;&amp; _z &lt; x? _z: <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">sorted</span>(<span class="type">int</span> _x, <span class="type">int</span> _y, <span class="type">int</span> _z): <span class="built_in">sorted</span>(_x, _z){</span><br><span class="line">        y = _y &lt; x &amp;&amp; _y &gt; z? _y: <span class="number">5</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y, z;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>通过 <code>inline</code>关键字，<strong>建议编译器将函数调用处替换为函数体代码本身</strong> ，从而避免函数调用开销。</p>
<blockquote>
<p>是否作为内联函数，实际上由编译器所决定</p>
</blockquote>
<p>内联函数必须提供完整的函数定义</p>
<blockquote>
<p>i.e. 内联函数的声明必需伴随实现（在同一个头文件中即可，二者可以分离）</p>
</blockquote>
<h2 id="组合与继承"><a href="#组合与继承" class="headerlink" title="组合与继承"></a>组合与继承</h2><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合的对象分为完全包含和引用包含，什么时候使用引用包含呢？</p>
<ul>
<li>逻辑上子对象应该在对象的外部；</li>
<li>子对象的大小不确定</li>
<li>子对象的空间应该在运行时被分配或者链接</li>
</ul>
<h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> sp1{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">namespace</span> sp2{</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">}<span class="comment">// No terminating end colon!</span></span><br><span class="line"><span class="keyword">namespace</span> alias = sp1;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    sp1::<span class="built_in">f</span>();</span><br><span class="line">    sp2::<span class="built_in">f</span>();</span><br><span class="line">    ::<span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">f</span>();<span class="comment">// the same as ::f()</span></span><br><span class="line">    alias::<span class="built_in">f</span>();<span class="comment">// the same as sp1::f()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li>可以为命名空间声明别名；</li>
<li>命名空间的末尾没有分号 <code>；</code></li>
</ul>
</blockquote>
<h4 id="using"><a href="#using" class="headerlink" title="using"></a>using</h4><p>使用 <code>using</code>可以在当前的作用域引入其他的命名空间的成员、函数：</p>
<ul>
<li><code>using &lt;namespace&gt;::&lt;member&gt;</code> 引入部分的成员</li>
<li><code>using namespace &lt;namespace&gt;</code> 引入该命名空间的全部成员</li>
</ul>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cin; <span class="comment">// 只引入 cin</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="comment">// 引入std的所有成员</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果引入同名的对象或者函数，将会导致编译器链接失败</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>父类的析构函数更晚调用</p>
<p>父类的<strong>私有成员变量在子类的对象中依旧存在</strong>，但是不可直接访问（只能通过父类方法来间接访问）</p>
<p>父类的受保护成员可以被子类访问，但是无法被外界访问</p>
<h4 id="非公开的继承"><a href="#非公开的继承" class="headerlink" title="非公开的继承"></a>非公开的继承</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">protected</span> A{</span><br><span class="line">    ...  </span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">private</span> A{<span class="comment">//default</span></span><br><span class="line">    ...</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果定义 <code>protected</code> 继承，只有子类及其派生类可以调用父类方法，外部是不可以的。</p>
<p>如果定义 <code>private</code> 继承，只有子类本身可以调用父类方法。</p>
</blockquote>
<h4 id="静态成员的继承"><a href="#静态成员的继承" class="headerlink" title="静态成员的继承"></a>静态成员的继承</h4><p>父类的静态成员不会在子类中具有自己的副本，<strong>子类和父类共享一个静态成员！</strong></p>
<p>以下介绍using相关的几个问题：</p>
<h4 id="name-hiding"><a href="#name-hiding" class="headerlink" title="name hiding"></a>name hiding</h4><p>如果子类重载了父类的函数，父类的同名函数将会失效，无法直接调用，需要使用 <code>using</code>来声明：</p>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span></span>{</span><br><span class="line">      cout &lt;&lt; <span class="string">"double\n"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="keyword">using</span> Base::f; <span class="comment">// 将基类中的私有函数本地使用</span></span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>{</span><br><span class="line">      cout &lt;&lt; <span class="string">"int\n"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h4 id="默认参数的重载传递"><a href="#默认参数的重载传递" class="headerlink" title="默认参数的重载传递"></a>默认参数的重载传递</h4><p>在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免 <strong>多重继承时参数值产生冲突或二义性</strong> 。</p>
<blockquote>
<p>默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.</p>
</blockquote>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>, <span class="type">double</span> b = <span class="number">2.0</span>)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::f;         <span class="comment">// ✅ 此时默认参数仍可见</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>;      <span class="comment">// ❌ 重载后，这个版本没有默认参数</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h4 id="子类重写父类函数"><a href="#子类重写父类函数" class="headerlink" title="子类重写父类函数"></a>子类重写父类函数</h4><p>如果子类直接重写了父类的函数，但是父类中的同名函数本身具有重载的版本，那么也需要使用 <code>using</code>来声明：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类中的重载函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base display(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base display(double): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子类重新定义了基类的 display(int)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived display(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">using</span> Base::display;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>(<span class="number">5</span>); <span class="comment">// 调用 Derived 的 display(int)</span></span><br><span class="line"></span><br><span class="line">    d.Base::<span class="built_in">display</span>(<span class="number">5.5</span>); <span class="comment">// 或者d.display(5.5);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ul>
<li>我们应当将所有类的析构函数都设置为<strong>虚析构函数</strong>，因为每个类都有成为父类的可能</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base Destructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived Destructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>子类和父类的析构函数先后调用</p>
</blockquote>
<ul>
<li><p><code>vptr</code>在构造的时候确定，虚继承的子类在调用父类的构造函数时，默认<strong>调用父类的成员函数</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>() {</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"A::f()"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>() {</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"B::f()"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line">B temp;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="虚函数的规范"><a href="#虚函数的规范" class="headerlink" title="虚函数的规范"></a>虚函数的规范</h4><p>注意 <code>virtual</code>与 <code>override</code>的搭配：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Animal speaks"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Dog barks"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>override是为了让编译器检查该函数在父类中是虚函数，但不是必须的</p>
</blockquote>
<ul>
<li>vtable是类级别的, 所有该类的对象共享一个vtable;</li>
<li>vptr是对象级别的, 隐含于各个对象当中.并且在内存的开头</li>
</ul>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>抽象类：至少包含一个<strong>纯虚函数</strong>的类是～</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，子类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>纯虚函数类似于协议，要求子类必须实现</p>
<p>只有完成了所有纯虚函数定义的、抽象类的子类，才能够实例化</p>
</blockquote>
<p><strong>接口类 Interface Class：</strong></p>
<ul>
<li>比抽象类更加抽象）</li>
<li>只定义接口, 不提供实现的抽象类</li>
<li>所有的<strong>成员函数都是纯虚函数</strong>;</li>
<li>一般不包含任何数据成员.</li>
</ul>
<h4 id="菱形继承与虚继承"><a href="#菱形继承与虚继承" class="headerlink" title="菱形继承与虚继承"></a>菱形继承与虚继承</h4><p>在继承时添加 <code>virtual</code> 关键字实现,子类中不存在父类的对象，而是保有父类的指针。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"value: "</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C {};</span><br></pre></td></tr></table></figure></div>

<p>上述的虚继承确保了B，C只会拥有A的一份value，从而避免了从D的对象访问 <code>value</code>时存在的<strong>二义性</strong></p>
<blockquote>
<p>并非所有的菱形继承都会因为二义性的访问而导致访问的问题！</p>
</blockquote>
<p>TODO：检查什么时候没有二义性？</p>
<p>由于虚继承带来的是“共享”的基类对象，所以：</p>
<ul>
<li>虚基类的构造 <strong>必须由最底层派生类负责</strong></li>
<li>派生类的构造函数中要<strong>显式初始化</strong>虚基类</li>
</ul>
<h2 id="Copy-Move"><a href="#Copy-Move" class="headerlink" title="Copy & Move"></a>Copy &amp; Move</h2><ul>
<li>拷贝构造函数的签名：<code>T::T(const T&amp;)</code></li>
<li>默认的拷贝构造函数的指针类型成员是直接赋值的，也就是共享同一地址<ul>
<li>因此我们需要显式定义类的拷贝构造函数，避免依赖默认的～</li>
<li>默认拷贝构造中，成员对象也会调用自己的拷贝构造函数</li>
</ul>
</li>
</ul>
<h4 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h4><ul>
<li><strong>按值传递参数时</strong>：当对象作为参数按值传递给函数时<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span></span>; <span class="comment">// 调用时会触发拷贝构造</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>对象初始化时</strong>：<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass a;</span><br><span class="line">MyClass b = a;    <span class="comment">// 初始化，调用拷贝构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">c</span><span class="params">(a)</span></span>;     <span class="comment">// 初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></div></li>
<li><strong>函数返回对象时</strong>：<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;   <span class="comment">// 可能触发拷贝构造（取决于编译器优化）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>一个简单的例子：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">StringHolder</span>(<span class="type">const</span> StringHolder &amp;other)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (other.data)</span><br><span class="line">        {</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"深拷贝构造函数: 为\""</span> &lt;&lt; data &lt;&lt; <span class="string">"\"分配新内存"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"深拷贝构造函数: 复制空字符串"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></div>

<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>两种可以同时输入左值和右值引用作为参数的方法:</p>
<ul>
<li><p><strong>重载</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载函数，分别处理左值和右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"重载函数 - 处理左值: "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"重载函数 - 处理右值: "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p><code>const int&amp; x </code></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受const左值引用的函数（可以接受左值和右值）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAny</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"处理任意值: "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><ul>
<li>签名：<code>T::T(T&amp;&amp; other)</code>, 也就是<strong>将右值引用作为参数的构造函数</strong></li>
<li>用于”窃取”即将销毁的对象的资源，避免不必要的深拷贝</li>
<li>通常将源对象的指针成员置为 <code>nullptr</code>，防止资源被错误释放. 其他成员设置为零值</li>
</ul>
<p>一个简单的例子：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DynamicArray</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *m_array;</span><br><span class="line">    <span class="type">size_t</span> m_size;</span><br><span class="line">...</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 移动构造函数</span></span><br><span class="line"><span class="built_in">DynamicArray</span>(DynamicArray &amp;&amp;other) <span class="keyword">noexcept</span> : <span class="built_in">m_array</span>(other.m_array), <span class="built_in">m_size</span>(other.m_size)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// "窃取"other的资源，并将other置为安全状态</span></span><br><span class="line">        other.m_array = <span class="literal">nullptr</span>;</span><br><span class="line">        other.m_size = <span class="number">0</span>;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"移动构造函数: 移动大小为"</span> &lt;&lt; m_size &lt;&lt; <span class="string">"的数组"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>noexcept</code>标记表示不会抛出异常；</p>
<p>标准库容器在进行元素移动时会<strong>优先选择不会抛异常的移动构造函数</strong>，如果不存在～会退而求其次选择拷贝构造函数（更慢）。</p>
</blockquote>
<h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><p>如果对象不是右值引用，我们可以使用 <code>std::move</code>来显式调用移动构造函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = v1; <span class="comment">// v2 是 v1 的副本</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = std::<span class="built_in">move</span>(v1); <span class="comment">// 调用移动构造函数</span></span><br></pre></td></tr></table></figure></div>

<h3 id="初始化的方式"><a href="#初始化的方式" class="headerlink" title="初始化的方式"></a>初始化的方式</h3><p>C++11提供了多种初始化对象的方式：</p>
<ul>
<li><p><strong>小括号初始化</strong>：<code>MyClass obj(arg1, arg2);</code></p>
</li>
<li><p><strong>等号初始化</strong>：<code>MyClass obj = value;</code></p>
</li>
<li><p><strong>大括号初始化</strong>（统一初始化）：<code>MyClass obj{arg1, arg2};</code></p>
</li>
<li><p><strong>列表初始化</strong>：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">MyClass* ptr = <span class="keyword">new</span> MyClass{arg1, arg2};</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="基本类型的初始化"><a href="#基本类型的初始化" class="headerlink" title="基本类型的初始化"></a>基本类型的初始化</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型的初始化方式</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;             <span class="comment">// 等号初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;              <span class="comment">// 小括号初始化</span></span><br><span class="line"><span class="type">int</span> c{<span class="number">30</span>};              <span class="comment">// 大括号初始化（C++11）</span></span><br><span class="line"><span class="type">int</span> d = {<span class="number">40</span>};           <span class="comment">// 等号+大括号初始化（C++11）</span></span><br><span class="line"><span class="type">int</span> arr1[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}; <span class="comment">// 数组初始化</span></span><br><span class="line"><span class="type">int</span> arr2[]{<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};    <span class="comment">// 数组大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div>

<h4 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的初始化方式</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"张三"</span>, <span class="number">25</span>)</span></span>;          <span class="comment">// 小括号初始化</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="string">"李四"</span>, <span class="number">30</span>); <span class="comment">// 等号+临时对象初始化</span></span><br><span class="line">Person p3{<span class="string">"王五"</span>, <span class="number">35</span>};          <span class="comment">// 大括号初始化（C++11）</span></span><br><span class="line">Person p4 = {<span class="string">"赵六"</span>, <span class="number">40</span>};       <span class="comment">// 等号+大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>动态分配对象的初始化</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态分配对象的初始化方式</span></span><br><span class="line">Person *pp1 = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">"动态张三"</span>, <span class="number">25</span>); <span class="comment">// 传统new</span></span><br><span class="line">Person *pp2 = <span class="keyword">new</span> Person{<span class="string">"动态李四"</span>, <span class="number">30</span>}; <span class="comment">// 大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="统一初始化"><a href="#统一初始化" class="headerlink" title="统一初始化"></a>统一初始化</h4><p>对于简单的类或者容器内部的类，我们可以不写构造函数，而是用花括号进行 <strong>统一初始化</strong> 。</p>
<p>如果类没有构造函数，参数应按照成员的声明顺序给出；如果有，参数应按照构造函数的参数顺序给出。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>{</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">};</span><br><span class="line">Test t{<span class="number">0</span>, <span class="number">0</span>};</span><br><span class="line">Test *pt = <span class="keyword">new</span> Test{<span class="number">1</span>, <span class="number">2</span>};</span><br><span class="line"><span class="type">int</span> *a = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>};</span><br><span class="line">vector&lt;string&gt; vec = { <span class="string">"first"</span>, <span class="string">"second"</span>, <span class="string">"third"</span>};</span><br></pre></td></tr></table></figure></div>

<h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>运算符重载本质上是一个以 <code>operator</code>关键字为前缀，后跟运算符的特殊函数</p>
<ul>
<li>赋值运算符首先要<strong>检查是否为自赋值</strong></li>
<li>必须在<strong>类或者枚举类</strong>上定义</li>
<li>类内成员函数的重载将第一个参数作为隐式的 <code>this</code>传递，操作符左端的类型决定了使用的操作符的类型<ul>
<li><code>3+a1</code>非法 if <code>a1</code>无法转换为 <code>int</code></li>
</ul>
</li>
</ul>
<h4 id="成员函数与自由函数"><a href="#成员函数与自由函数" class="headerlink" title="成员函数与自由函数"></a>成员函数与自由函数</h4><ul>
<li><code>=, (), [], -&gt;, -&gt;*</code> 必须是成员函数</li>
<li>单目运算符应该声明为成员；</li>
<li>二目运算符应该声明为自由函数</li>
</ul>
<h4 id="无法重载的运算符"><a href="#无法重载的运算符" class="headerlink" title="无法重载的运算符"></a>无法重载的运算符</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. .* :: ?:</span><br><span class="line"><span class="keyword">sizeof</span> <span class="keyword">typeid</span></span><br><span class="line"><span class="keyword">static_cast</span> <span class="keyword">dynamic_cast</span> <span class="keyword">const_cast</span></span><br><span class="line"><span class="keyword">reinterpret_cast</span></span><br></pre></td></tr></table></figure></div>

<h4 id="参数传递与返回类型"><a href="#参数传递与返回类型" class="headerlink" title="参数传递与返回类型"></a>参数传递与返回类型</h4><ul>
<li><code>+ - * / % ^ &amp; | ~</code> 返回新的对象<ul>
<li><code>const Tp operator X(const Tp &amp; l, const Tp &amp; r);</code></li>
</ul>
</li>
<li>布尔运算，返回 <code>bool</code>类型</li>
<li><code>[ ]</code> 返回可以修改的引用，类似于数组的赋值<ul>
<li><code>Tp &amp; operator X(int index);</code></li>
</ul>
</li>
<li><code>= += *= /= &lt;&lt;= &gt;&gt;=</code> 返回可以修改的引用，确保链式操作<ul>
<li><code>Tp &amp; operator X(const Tp &amp;l, const Tp &amp;r);</code></li>
</ul>
</li>
</ul>
<p>前缀自增和后缀自增需要区分，在后缀自增的参数列表中添加 <code>int</code>即可</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀自增返回引用</span></span><br><span class="line"><span class="type">const</span> Integer&amp; Integer::<span class="keyword">operator</span>++(){</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀自增返回对象</span></span><br><span class="line"><span class="type">const</span> Integer Integer::<span class="keyword">operator</span>++(<span class="type">int</span>){<span class="comment">// just leave the parameter unnamed</span></span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>考虑实现基础的 <code>==</code> 与 <code>&lt;</code> ，其余的比较重载在上述的基础上通过 <code>!</code> 运算实现，便于直接迁移</p>
<h4 id="流运算"><a href="#流运算" class="headerlink" title="流运算"></a>流运算</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, _Tp&amp; obj){</span><br><span class="line">    <span class="comment">// read obj from is</span></span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">}</span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> _Tp&amp; obj){</span><br><span class="line">    <span class="comment">// output obj in os</span></span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">}</span><br><span class="line"><span class="function">ostream&amp; <span class="title">tab</span><span class="params">(ostream&amp; os)</span></span>{<span class="comment">// manipulator</span></span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>输出流运算符的第一个参数不能是 <code>const</code>，因为输出会修改流</li>
<li>输入流运算符的第二个参数不能是 <code>const</code>，因为需要修改对象</li>
<li>通常需要声明为友元以访问私有成员</li>
</ul>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_Tp&amp; _Tp::<span class="keyword">operator</span>=(<span class="type">const</span> _Tp&amp; rhs){</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs){</span><br><span class="line">        size = rhs.size;</span><br><span class="line">        <span class="keyword">delete</span>[] p;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="type">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span> ; i &lt; size; ++i)</span><br><span class="line">            p[i] = rhs.p[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>首先检查是否为自赋值</p>
</blockquote>
<p>如果不希望进行赋值运算，将上述的 <code>=</code> 重载声明为 <code>private</code>，并且无需实现。</p>
<blockquote>
<p>这是因为 <code>a = b;  // 实际等价于：a.operator=(b)</code>， 发起调用的是当前代码片段所在的作用域，如果不是类内函数，那么就是非法的</p>
</blockquote>
<h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p><strong>1. 构造函数转换</strong>：从其他类型到当前类型</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PathName</span> {</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PathName</span>(<span class="type">const</span> string&amp; s) : <span class="built_in">name</span>(s) {}  <span class="comment">// string到PathName的转换</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">abc</span><span class="params">(<span class="string">"abc"</span>)</span></span>;</span><br><span class="line">PathName xyz = abc;  <span class="comment">// 隐式转换：abc =&gt; PathName</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>2.<strong>转换运算符</strong>：从当前类型到其他类型</p>
<blockquote>
<p><code>operator &lt;typename&gt; {}</code>关键字</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>{  <span class="comment">// Rational到double的转换</span></span><br><span class="line">        <span class="keyword">return</span> numerator_ / (<span class="type">double</span>)denominator_;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d = r;  <span class="comment">// 隐式转换：r =&gt; double</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>可以使用 <code>explicit</code>关键字要求显式转换：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">double</span> d = (<span class="type">double</span>)r;  <span class="comment">// 必须显式转换</span></span><br></pre></td></tr></table></figure></div>

<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><ul>
<li>构造函数的显式转换</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想要强制显式转换，应该这样声明：</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Rational</span><span class="params">(<span class="type">double</span> value)</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> PRECISION = <span class="number">10000</span>;</span><br><span class="line">    numerator = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(value * PRECISION);</span><br><span class="line">    denominator = PRECISION;</span><br><span class="line">    <span class="built_in">simplify</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Rational r1 = <span class="number">3.14</span>;        <span class="comment">// 错误：不允许隐式转换</span></span><br><span class="line"><span class="function">Rational <span class="title">r2</span><span class="params">(<span class="number">2.5</span>)</span></span>;          <span class="comment">// 正确：显式构造</span></span><br><span class="line">Rational r3 = <span class="built_in">Rational</span>(<span class="number">3.14</span>); <span class="comment">// 正确：显式转换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>类型转换运算符的显式转换</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">double</span> d = (<span class="type">double</span>)r;  <span class="comment">// 显式转换 or double(r)</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> d2 = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(r2);  <span class="comment">// 显式转换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="转换优先级"><a href="#转换优先级" class="headerlink" title="转换优先级"></a>转换优先级</h4><p>如果同时存在两种方向的转换，将优先采取<strong>构造函数</strong>的转换方式</p>
<blockquote>
<p>可以通过声明其中的一种情况必须显式调用来并存；比如必须显式调用构造函数的转换，那么下面的情况将会调用构造函数将A转换到B的对象：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>();</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(A)</span></span>; <span class="comment">// 从A到B的显式构造函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionTakingB</span><span class="params">(B thing)</span></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"OK"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">functionTakingB</span>(<span class="built_in">static_cast</span>&lt;B&gt;(a));</span><br></pre></td></tr></table></figure></div></blockquote>
<h4 id="转换运算符"><a href="#转换运算符" class="headerlink" title="转换运算符"></a>转换运算符</h4><p>C++ 中有四个<strong>转换运算符</strong> Cast Operator：</p>
<ul>
<li><p><code>static_cast</code>：</p>
<ul>
<li>基本类型的转换</li>
<li>子类向父类的指针/引用的转换</li>
<li><code>void</code>与其他类型指针的转换</li>
</ul>
</li>
<li><p><code>dynamic_cast</code>：<strong>down-cast</strong>，安全</p>
<ul>
<li>父类向子类的指针/引用的转换，不一定总是安全（要求原本指向的对象就是子类对象）</li>
<li>要求基类中<strong>至少存在一个虚函数</strong>（因此具有 <code>vptr</code>，从而可以通过不同类的 <code>vptr</code>进行类的区分）</li>
<li><pre><code class="language-cpp">Base* basePtr = new Derived();
Derived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);

if(derivedPtr){
...
}

<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* `const_cast`：修改 `const` 属性</span><br><span class="line"></span><br><span class="line">  * ```cpp</span><br><span class="line">    const int a = 10;</span><br><span class="line">    int *b = const_cast&lt;int*&gt;(&amp;a);</span><br><span class="line"></span><br><span class="line">    *b = 20; // 转换之后可以修改value</span><br></pre></td></tr></table></figure></div>

&gt; 但是更加常见的是将非const类型的属性修改为 `const`；原本是常量类型的属性可能被编译器存储在只读内存区域，如果编译器没有在 `const_cast`的转换中进行优化，可能导致运行问题？
&gt;
</code></pre>
</li>
</ul>
</li>
<li><p><code>reinterpret_cast</code>：忽略类型检查，强制转换，低安全性</p>
</li>
</ul>
<h2 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h2><p>一个模板完全都是声明，应该只有 <code>.h</code>，而不含有 <code>.cpp</code></p>
<blockquote>
<p>必须<strong>都放在头文件的实现</strong>包含:</p>
<ul>
<li>函数模板;</li>
<li>inline函数</li>
<li>带有default参数的声明.</li>
<li>类模板的成员函数</li>
</ul>
</blockquote>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">_Tp <span class="title">add</span><span class="params">(_Tp x, _Tp y)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; std::endl; </span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(<span class="number">1.1</span>, <span class="number">2.2</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/* T add(int, int) 和 T double add&lt;double&gt;(double, double) */</span></span><br></pre></td></tr></table></figure></div>

<ol>
<li>如果有原生的完全匹配的函数，优先使用原生函数，例如 <code>add(1, 2)</code> 调用 <code>add(int, int)</code>。</li>
<li>其次，如果有模板能完全匹配的函数，使用模板生成函数，例如 <code>add(1.1, 2.2)</code> 调用 <code>add&lt;double&gt;(dobule, double)</code>。</li>
<li>再其次，尝试使用类型转换来匹配其他原生函数。但是，类型转换不能用于匹配模板，例如 <code>add(1, 2.2)</code>。</li>
</ol>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><p>简单的示例：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">int</span> s):<span class="built_in">size</span>(s){</span><br><span class="line">        content = <span class="keyword">new</span> T[size];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Vector</span>(){</span><br><span class="line">        <span class="keyword">delete</span>[] content;</span><br><span class="line">    }</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> p){</span><br><span class="line">        <span class="keyword">return</span> content[p];</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* content;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h2 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h2><p><strong>异常的类型如何定义？</strong></p>
<blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异常对象的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivisionError</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string message;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DivisionError</span>(<span class="type">const</span> string&amp; msg) : <span class="built_in">message</span>(msg) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"创建DivisionError异常对象"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    ~<span class="built_in">DivisionError</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"销毁DivisionError异常对象"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function">string <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内层函数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">divide</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"进入divide函数"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="function">Resource <span class="title">r</span><span class="params">(<span class="string">"divide函数的局部资源"</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DivisionError</span>(<span class="string">"除数不能为零"</span>);</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    cout &lt;&lt; <span class="string">"divide函数正常返回"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></blockquote>
<p>执行流程：</p>
<ol>
<li>通过 <code>throw</code> 创建对应的<strong>异常对象</strong></li>
<li>将异常所在的内层函数的<strong>资源释放</strong>；</li>
<li>再被外层的 <code>catch</code> 所<strong>捕获</strong></li>
</ol>
<p>在 <code>catch</code>块中可以通过 <code>throw;</code>再次抛出当前的异常</p>
<p>自定义异常类时，通常应该继承自 <code>std::exception</code>或其派生类</p>
<h4 id="异常规范"><a href="#异常规范" class="headerlink" title="异常规范"></a>异常规范</h4><p>在函数原型中声明可能返回的异常类型：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(Document&amp; p)</span> <span class="title">throw</span><span class="params">(PrintOffLine, BadDocument)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodguy</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>;<span class="comment">// throw no exceptions, until C++11</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">alloc</span><span class="params">()</span> <span class="title">throw</span><span class="params">(...)</span></span>;<span class="comment">// can throw any exception</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">abc</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;<span class="comment">// throw no exceptions, since C++11</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果函数返回了规范之外的异常，将调用 <code>std::unexpected()</code>处理（默认调用 <code>std::terminate()</code>终止程序）</p>
</blockquote>
<p><code>noexcept</code>也可以作为运算符使用，检查表达式是否声明为不抛出异常：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> willNotThrow = <span class="built_in">noexcept</span>(<span class="built_in">func</span>());  <span class="comment">// 检查func()是否声明为noexcept</span></span><br></pre></td></tr></table></figure></div>

<h4 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">std::exception</span><br><span class="line">├── std::logic_error</span><br><span class="line">│   ├── std::invalid_argument</span><br><span class="line">│   ├── std::domain_error</span><br><span class="line">│   ├── std::length_error</span><br><span class="line">│   ├── std::out_of_range</span><br><span class="line">│   └── std::future_error</span><br><span class="line">├── std::runtime_error</span><br><span class="line">│   ├── std::range_error</span><br><span class="line">│   ├── std::overflow_error</span><br><span class="line">│   ├── std::underflow_error</span><br><span class="line">│   └── std::system_error</span><br><span class="line">├── std::bad_alloc</span><br><span class="line">├── std::bad_cast</span><br><span class="line">├── std::bad_typeid</span><br><span class="line">├── std::bad_exception</span><br><span class="line">└── std::bad_function_call</span><br></pre></td></tr></table></figure></div>

<ul>
<li>数组的 <code>.at</code>可以自动抛出数组访问异常的 <code>range_error</code>；</li>
<li>容器的 <code>resize</code>方法可以自动抛出长度异常 <code>length_error</code>；</li>
</ul>
<h4 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h4><p>析构函数应该避免抛出异常，否则会导致系统调用 <code>std::terminate()</code></p>
<p>由于在 <code>try-catch</code>中，如果发生了异常，本地变量将自动调用自己的析构函数，此时如果存在 <code>new</code>申请的空间资源，将导致其无法指向正确的地址</p>
<p>因此，我们采取两阶段的构造确保构造函数不会抛出异常：</p>
<ol>
<li>在构造函数内对基本变量赋值</li>
<li>在 <code>init()</code>函数中显式申请内存空间</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Widget</span>() : <span class="built_in">initialized</span>(<span class="literal">false</span>) {</span><br><span class="line">        <span class="comment">// 只做最小的初始化： 不存在抛出异常的可能</span></span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">initialize</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 执行可能失败的初始化操作</span></span><br><span class="line">            initialized = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        } <span class="built_in">catch</span> (...) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">use</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (!initialized) {</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">"对象未初始化"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 使用对象</span></span><br><span class="line">    }</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> initialized;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="知识蒸馏"><a href="#知识蒸馏" class="headerlink" title="知识蒸馏"></a>知识蒸馏</h1><blockquote>
<p>将个人印象比较浅的部分重新摘了一遍</p>
</blockquote>
<ul>
<li>字符指针与字符数组</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *sp = <span class="string">"Hello World!"</span>; <span class="comment">// 字符指针可以移动，不能修改</span></span><br><span class="line"><span class="type">char</span> array[] = <span class="string">"Hello World!"</span>; <span class="comment">// 字符数组不能移动，可以修改</span></span><br><span class="line"></span><br><span class="line">array[<span class="number">0</span>] = <span class="string">'h'</span> ; <span class="comment">// 合法</span></span><br><span class="line">array = <span class="string">'hello'</span>; <span class="comment">// 非法！</span></span><br><span class="line"></span><br><span class="line">sp = <span class="string">'world'</span>; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>实际上，<code>char *sp</code>就是 <code>const char *sp</code>，所以不能改变字符串的值，但是可以改变sp的指向</p>
<p>而字符串数组的数组名是栈中的固定地址，无法移动，但是可以修改</p>
</blockquote>
<ul>
<li><p>不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们<strong>之间没有初始化的依赖.</strong></p>
</li>
<li><p>返回类型的常量</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 只能将函数的返回值赋值给一个 const int*</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="vptr的大小"><a href="#vptr的大小" class="headerlink" title="vptr的大小"></a>vptr的大小</h4><p>如果父类具有 <code>virtual</code>也就是虚函数，子类继承之后也会得到一个虚函数表，对应有一个<strong>vptr</strong>指针指向自己的虚函数表：</p>
<ul>
<li>在64位的机器下，一个vptr指针的大小是<strong>8字节</strong></li>
<li>普通函数不占据类的大小，因为函数地址存放在全局空间</li>
<li>如果类内没有成员变量，也没有虚函数，那么大小就是<strong>1</strong>（告诉编译器这个类的存在）</li>
</ul>
<h4 id="编译器的对齐"><a href="#编译器的对齐" class="headerlink" title="编译器的对齐"></a>编译器的对齐</h4><ul>
<li>C++ 编译器会对类进行<strong>按最大对齐的成员</strong>进行对齐</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Nothing</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Nothing</span>() {}</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Nothing</span>() {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Nothing obj;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Sizeof Nothing: "</span> &lt;&lt; <span class="built_in">sizeof</span>(Nothing) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Address of obj: "</span> &lt;&lt; &amp;obj &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Address of a: "</span> &lt;&lt; &amp;(obj.a) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>对应的输出：</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sizeof Nothing: 16</span><br><span class="line">Address of obj: 0x16d57e830</span><br><span class="line">Address of a: 0x16d57e838</span><br></pre></td></tr></table></figure></div>

<p>我们可以观察到两个现象：</p>
<ol>
<li><code>size</code>=16说明了对齐现象；</li>
<li>Nothing对象的地址首先是其vptr，然后是其他的成员</li>
</ol>
<h1 id="期末题集"><a href="#期末题集" class="headerlink" title="期末题集"></a>期末题集</h1><blockquote>
<p>补天专用楼</p>
</blockquote>
<h2 id="程序填空"><a href="#程序填空" class="headerlink" title="程序填空"></a>程序填空</h2><h4 id="题目摘录"><a href="#题目摘录" class="headerlink" title="题目摘录"></a>题目摘录</h4><h5 id="类模板：Array"><a href="#类模板：Array" class="headerlink" title="类模板：Array"></a>类模板：Array</h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Array</span>() {</span><br><span class="line">        data = <span class="keyword">new</span> T[BLK_SIZE];</span><br><span class="line">        next = <span class="literal">nullptr</span> ;</span><br><span class="line">     }</span><br><span class="line">    ~<span class="built_in">Array</span>() {</span><br><span class="line">        <span class="keyword">delete</span> [] data;</span><br><span class="line">        <span class="keyword">delete</span> next;</span><br><span class="line">     }</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span> i);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">iterate</span><span class="params">(<span class="type">void</span> (*f)(T&amp;))</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T  *data; <span class="comment">// data of type T</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> BLK_SIZE=<span class="number">32</span>; <span class="comment">// fixed block size</span></span><br><span class="line">    Array *next;  <span class="comment">// the next array block</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> i) {</span><br><span class="line">    <span class="keyword">if</span> (i &lt; BLK_SIZE) {</span><br><span class="line">        <span class="keyword">return</span> data[i];</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) {</span><br><span class="line">            next = <span class="keyword">new</span> Array&lt;T&gt;;</span><br><span class="line">         }</span><br><span class="line">        <span class="keyword">return</span> (*next)[i-BLK_SIZE];</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Array&lt;T&gt;::<span class="built_in">iterate</span>(<span class="built_in">void</span> (*f)(T&amp;)) {</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; BLK_SIZE; i++) {</span><br><span class="line">        <span class="built_in">f</span>(data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (next != <span class="literal">NULL</span>) {</span><br><span class="line">        next-&gt; <span class="built_in">iterate</span>(f);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Array&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">100</span>;</span><br><span class="line">    cin &gt;&gt; size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        a[i] = i;</span><br><span class="line">    }</span><br><span class="line">    a.<span class="built_in">iterate</span>([](<span class="type">int</span> &amp;x) { cout &lt;&lt; x &lt;&lt; endl; });</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="函数模板：内积"><a href="#函数模板：内积" class="headerlink" title="函数模板：内积"></a>函数模板：内积</h5><p>此处的 <code>op</code>操作之前没有接触过，利用的是标准库提供的二元操作：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">InputIt1</span>, <span class="keyword">class</span> <span class="title class_">InputIt2</span>, <span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">BinaryOp1</span>, <span class="keyword">class</span> <span class="title class_">BinaryOp2</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">inner_product</span><span class="params">(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init, BinaryOp1 op1, BinaryOp2 op2)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  <span class="keyword">while</span> (first1 != last1)</span><br><span class="line">  {</span><br><span class="line">    init = <span class="built_in">op1</span> (init, <span class="built_in">op2</span>(*first1, *first2) );</span><br><span class="line">    ++first1;</span><br><span class="line">	++first2;</span><br><span class="line">  }</span><br><span class="line">  <span class="keyword">return</span> init;</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; a{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>};</span><br><span class="line">  std::vector&lt;<span class="type">int</span>&gt; b{<span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>};</span><br><span class="line">  <span class="type">int</span> r1 = <span class="built_in">inner_product</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), <span class="number">0</span>, std::plus&lt;&gt;(), std::multiplies&lt;&gt;());</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Inner product of a and b: "</span> &lt;&lt; r1 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> r2 = <span class="built_in">inner_product</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b.<span class="built_in">begin</span>(), <span class="number">0</span>, std::plus&lt;&gt;(), std::equal_to&lt;&gt;());</span><br><span class="line">  std::cout &lt;&lt; <span class="string">"Number of pairwise matches between a and b: "</span> &lt;&lt;  r2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="类模板的填写"><a href="#类模板的填写" class="headerlink" title="类模板的填写"></a>类模板的填写</h4><ul>
<li>非内联定义成员函数时，需要在类型与函数名之间加上 <code>&lt;class-name&gt;&lt;T&gt;::</code> ，不要忘记了其中的 <code>&lt;T&gt;</code></li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Array&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> i) {</span><br><span class="line">    <span class="keyword">if</span> (i &lt; BLK_SIZE) {</span><br><span class="line">        <span class="keyword">return</span> data[i];</span><br><span class="line">     } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) {</span><br><span class="line">            next = <span class="keyword">new</span> Array&lt;T&gt;;</span><br><span class="line">         }</span><br><span class="line">        <span class="keyword">return</span> (*next)[i-BLK_SIZE];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="长话短说"><a href="#长话短说" class="headerlink" title="长话短说"></a>长话短说</h2><p><strong>注意函数模板的返回类型：</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">func</span><span class="params">(T x, <span class="type">double</span> y)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">2.7</span>, <span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">3</span>, <span class="number">2.7</span>) &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>此时第二个输出从 5.7 向 int转换，得到的结果是 5</p>
<p>如果是数组空间的管理, 注意 <code>new</code> 和  <code>delete</code> 都需要对应的 <code>[]</code></p>
<p>如果没有显式定义任何的构造函数，那么编译器会自动创建一个默认构造函数</p>
<ul>
<li>但是如果程序员定义了任何的构造函数（无论是否带有默认参数），编译器就不用自动创建默认构造函数</li>
</ul>
<p><strong>upcast</strong>：将一个派生类的指针或者引用赋值给基类的指针或引用</p>
<ul>
<li><strong>动态绑定</strong>：发生upcast之后，通过基类指针或引用调用虚函数时，实际调用的是指针或引用锁指向的对象的虚函数的实现；而不是根据指针或引用的静态类型</li>
<li>如果此时发生了析构，如果基类的析构函数是虚函数，就会先后调用子类和父类的析构函数；如果父类的析构函数不是虚函数，就只会调用父类的析构函数<ul>
<li>为了确保子类的资源可以被释放，总是应当将类的析构函数作为虚析构函数</li>
</ul>
</li>
</ul>
<p><strong>析构函数不允许被重载</strong></p>
<ul>
<li>事实上，析构函数的名称固定，并且没有参数，因此无法通过参数列表来区分不同的韩苏版本，自然也就无法重载</li>
</ul>
<p>C++标准只规定了整数类型的相对顺序：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;= <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;= <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;= <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;= <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>也就是说, 可能存在 size上 <code>int = long</code>的情况</li>
</ul>
<p>A program is a bunch of objects telling each other how to do <strong>by sending messages</strong></p>
<ul>
<li>此处的消息在oop中指的就是通过调用对象内部的方法</li>
</ul>
<h2 id="一句话说不清楚的"><a href="#一句话说不清楚的" class="headerlink" title="一句话说不清楚的"></a>一句话说不清楚的</h2><h4 id="重载与友元函数"><a href="#重载与友元函数" class="headerlink" title="重载与友元函数"></a>重载与友元函数</h4><ul>
<li><p>完全无法重载的：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">. .* :: ?:</span><br><span class="line"><span class="keyword">sizeof</span> <span class="keyword">typeid</span></span><br><span class="line"><span class="keyword">static_cast</span> <span class="keyword">dynamic_cast</span> <span class="keyword">const_cast</span></span><br><span class="line"><span class="keyword">reinterpret_cast</span></span><br></pre></td></tr></table></figure></div></li>
<li><p>只能作为成员函数（无法作为友元函数）重载的：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=, (), [], -&gt;, -&gt;*</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>以及单目运算符</p>
</blockquote>
</li>
</ul>
<h4 id="父类的构造函数"><a href="#父类的构造函数" class="headerlink" title="父类的构造函数"></a>父类的构造函数</h4><img lazyload="" src="/images/loading.svg" data-src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250613213521969.png?imageSlim">

<p>构造函数与普通的成员函数不同：</p>
<ul>
<li>如果父类的构造函数被声明为 <code>private</code> 的，和普通的成员函数一样——只能被自己的成员和友元函数可以调用</li>
<li>如果父类的构造函数被声明为 <code>protected</code> 的，那么只有父类的成员、友元以及<strong>派生类的构造函数</strong>可以调用；<ul>
<li>这意味着此时无法直接在子类除了构造函数之外的地方来直接创建独立的父类对象</li>
</ul>
</li>
</ul>
<h4 id="C-对编程范式的支持"><a href="#C-对编程范式的支持" class="headerlink" title="C++对编程范式的支持"></a>C++对编程范式的支持</h4><img lazyload="" src="/images/loading.svg" data-src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250613214216540.png?imageSlim">

<ul>
<li>过程式编程的特性包括：函数、全局变量、顺序执行、选择（if/else, switch）、循环等<ul>
<li>C就是过程式编程的一种，C++继承了C的特性，因此对过程式变成支持良好</li>
</ul>
</li>
<li>声明式编程指的是“做什么”而非如何做，比如SQL、HTML、Swift等。C++和C是命令式语言，关注“如何做”</li>
</ul>
<blockquote>
<p>因此答案选C</p>
</blockquote>
<h4 id="对象切片"><a href="#对象切片" class="headerlink" title="对象切片"></a>对象切片</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C2* pC2 = <span class="keyword">new</span> <span class="built_in">C2</span>();</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">{</span><br><span class="line">    C1 a = *pC2; <span class="comment">// 发生了对象切片，只保留了基类对象的属性</span></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">C1* pC1 = pC2;</span><br><span class="line"><span class="keyword">delete</span> pC1; <span class="comment">// 基类的析构函数是virtual的，所以此处发生多态析构</span></span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>

<h4 id="拷贝初始化"><a href="#拷贝初始化" class="headerlink" title="拷贝初始化"></a>拷贝初始化</h4><p>用基本类型的值来隐式调用构造函数以创建对象:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ResId</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ResId</span>(<span class="type">int</span> Id);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">ResId res = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// ResId res(5);</span></span><br><span class="line"><span class="comment">// ResId res = ResId(5);</span></span><br></pre></td></tr></table></figure></div>

<p>这个过程分为两步:</p>
<ol>
<li>用 5 构造一个临时的ResId对象;</li>
<li>用这个临时对象初始化res</li>
</ol>
<p>因此我们整体上可以说:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">An object of <span class="keyword">class</span> <span class="title class_">ResId</span> will be created by <span class="number">5</span></span><br></pre></td></tr></table></figure></div>

<h4 id="禁止隐式的拷贝初始化"><a href="#禁止隐式的拷贝初始化" class="headerlink" title="禁止隐式的拷贝初始化"></a>禁止隐式的拷贝初始化</h4><p>通过声明 <code>explicit</code> 来禁止上述通过值隐式调用构造函数:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">C</span><span class="params">(<span class="type">int</span>)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"i"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">C</span>(<span class="type">double</span>) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"d"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">C <span class="title">c1</span><span class="params">(<span class="number">7</span>)</span></span>; <span class="comment">// 匹配了第一个构造函数</span></span><br><span class="line">    C c2 = <span class="number">7</span>; <span class="comment">// 隐式构造, 只能将7转换为double, 然后调用第二个构造函数</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>输出:</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i</span><br><span class="line">d</span><br></pre></td></tr></table></figure></div>

<h4 id="子类对父类函数的重载与重写"><a href="#子类对父类函数的重载与重写" class="headerlink" title="子类对父类函数的重载与重写"></a>子类对父类函数的重载与重写</h4><p>子类如果重载或者重写了父类的同名函数，将无法通过子类的对象访问父类中的这些函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">int</span>)</span> </span>{ cout &lt;&lt; <span class="string">"A::F(int)"</span> &lt;&lt; endl; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">double</span>)</span> </span>{ cout &lt;&lt; <span class="string">"A::F(double)"</span> &lt;&lt; endl; }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F2</span><span class="params">(<span class="type">int</span>)</span> </span>{ cout &lt;&lt; <span class="string">"A::F2(int)"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	  <span class="keyword">using</span> A::F;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">double</span>)</span> </span>{ cout &lt;&lt; <span class="string">"B::F(double)"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">F</span>(<span class="number">2.0</span>);</span><br><span class="line">    b.<span class="built_in">F</span>(<span class="number">2</span>);</span><br><span class="line">    b.<span class="built_in">F2</span>(<span class="number">2</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B::<span class="built_in">F</span>(<span class="type">double</span>)</span><br><span class="line">B::<span class="built_in">F</span>(<span class="type">double</span>)</span><br><span class="line">A::<span class="built_in">F2</span>(<span class="type">int</span>)</span><br></pre></td></tr></table></figure></div>

<p>但是我们可以通过在子类中声明 <code>using A::F</code>来重新获得访问权限：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::F;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">F</span><span class="params">(<span class="type">double</span>)</span> </span>{ cout &lt;&lt; <span class="string">"B::F(double)"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>此时的输出为：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B::<span class="built_in">F</span>(<span class="type">double</span>)</span><br><span class="line">A::<span class="built_in">F</span>(<span class="type">int</span>)</span><br><span class="line">A::<span class="built_in">F2</span>(<span class="type">int</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="默认参数的静态绑定"><a href="#默认参数的静态绑定" class="headerlink" title="默认参数的静态绑定"></a>默认参数的静态绑定</h4><ul>
<li>虚函数：运行时多态（动态绑定）</li>
<li>默认参数：编译时确定（静态绑定）</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a = <span class="number">1</span>)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; a;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> : A {</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> a = <span class="number">2</span>)</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; a;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    A *a = <span class="keyword">new</span> B;</span><br><span class="line">    a-&gt;<span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">delete</span> a;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><strong>为什么cpp要选择让静态参数实现静态绑定？</strong></p>
<p>为了保持语言的一致性与可预测性，设计者让静态参数作为编译时期自动替换的值，避免在运行过程中动态替换</p>
</blockquote>
<h4 id="函数模板与模板特化"><a href="#函数模板与模板特化" class="headerlink" title="函数模板与模板特化"></a>函数模板与模板特化</h4><p>模板特化：在函数模板的基础上，如果我们希望对某个类型实现不一样的逻辑，就可以使用～</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp; value)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"泛型模板: "</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对int类型采取模板特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">f</span>&lt;<span class="type">int</span>&gt;(<span class="type">const</span> <span class="type">int</span>&amp; value) {</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"特化版本: int 类型"</span> &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>因此，模板特化必须首先存在一个主模板</li>
</ul>
<p><strong>模板特化的结果无法被重载</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; <span class="type">void</span> <span class="title">f</span><span class="params">(T &amp;i)</span> </span>{ std::cout &lt;&lt; <span class="number">1</span>; }</span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp;i)</span> </span>{ std::cout &lt;&lt; <span class="number">2</span>; }</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> i = <span class="number">24</span>;</span><br><span class="line">    <span class="built_in">f</span>(i);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>将会输出： <code>1</code></p>
<ul>
<li>如果我们只保留 <code>void f(const int &amp;i) { std::cout &lt;&lt; 2; }</code>  函数，将会触发类型转换，可以调用</li>
<li>如果我们只去除模板特化中的 <code>const</code>， 就可以匹配（输出 <code>2</code>）</li>
</ul>
<p>再比如：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(T, T)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2.2</span>); <span class="comment">// ❌ 模板不能推导出统一的 T（int vs double）</span></span><br></pre></td></tr></table></figure></div>

<h4 id="常量对象"><a href="#常量对象" class="headerlink" title="常量对象"></a>常量对象</h4><ul>
<li>静态函数同样参与函数重载，但是优先匹配非静态函数</li>
<li>静态函数不受 <code>const</code>限制——即使没有被声明为 <code>const</code>也可以被常量对象调用</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"f(double)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"f(int)"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">const</span> A a;</span><br><span class="line">    a.<span class="built_in">f</span>(<span class="number">3</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="type">double</span>)</span><br></pre></td></tr></table></figure></div>

<p>如果存在完全匹配的普通函数，就会直接调用非静态函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> <span class="type">const</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"f(int) const"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span> </span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"f(int)"</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>此处的 <code>void f(int) const</code> 无法改为 <code>void f(double) const</code>, 否则与同名静态函数的参数完全一致</p>
</blockquote>
<h4 id="异常的-catch顺序"><a href="#异常的-catch顺序" class="headerlink" title="异常的 catch顺序"></a>异常的 <code>catch</code>顺序</h4><p><code>catch</code>块的匹配是从上到下的，因此只要遇到第一个匹配的，后续的匹配就会结束</p>
<ul>
<li>子类的对象可以被父类捕获</li>
<li>注意此时的动态绑定——如果父类层级（引用或者指针）在前，内部抛出的是子类的异常对象，捕捉之后调用的函数是子类的对象</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Base::what()"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {}  <span class="comment">// 虚析构保证多态安全</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Derived::what()"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Derived</span>();  <span class="comment">// 抛出子类对象</span></span><br><span class="line">    } <span class="built_in">catch</span> (<span class="type">const</span> Base&amp; e) {  <span class="comment">// 用父类引用接收</span></span><br><span class="line">        cout &lt;&lt; <span class="string">"由父类层级捕获到异常: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;  <span class="comment">// 动态绑定调用子类 what()</span></span><br><span class="line">    } <span class="built_in">catch</span> (<span class="type">const</span> Derived&amp; e) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"由子类层级捕获到异常: "</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">    } <span class="built_in">catch</span> (...) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"捕获到未知异常"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">由父类层级捕获到异常: Derived::<span class="built_in">what</span>()</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>如果将 <code>catch</code>内部改为普通的对象，将会输出 <code>由父类层级捕获到异常: Base::what()</code></p>
</blockquote>
<p>由此可见，我们应该遵循：将子类对象的捕捉放在其父类之前，最后是 <code>catch(...)</code></p>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> oop复习</li>
        <li><strong>作者:</strong> ffy</li>
        <li><strong>创建于
                :</strong> 2025-06-21 18:55:00</li>
        
            <li>
                <strong>更新于
                    :</strong> 2025-06-26 14:57:33
            </li>
        
        <li>
            <strong>链接:</strong> https://ffy6511.github.io/2025/06/21/课程笔记/oop复习笔记/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">#编程语言</a>&nbsp;
			</li>
			
			<li class="tag-item mx-0.5">
				<a href="/tags/CS%E8%AF%BE%E7%A8%8B/">#CS课程</a>&nbsp;
			</li>
			
			<li class="tag-item mx-0.5">
				<a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">#面向对象编程</a>&nbsp;
			</li>
			
		</ul>
		

		
  <div class="recommended-article px-2 sm:px-6 md:px-8">
   <div class="recommended-desktop">
    <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
    </div>
    <div class="recommended-article-group"><a class="recommended-article-item" href="/2025/01/09/编程语言/JavaScript/" title="JavaScript" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="JavaScript" class="!max-w-none">
  <span class="title">JavaScript</span>
</a><a class="recommended-article-item" href="/2025/06/25/课程笔记/密码学复习/" title="密码学复习" rel="bookmark">
  <img src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250625145854973.png?imageSlim" alt="密码学复习" class="!max-w-none">
  <span class="title">密码学复习</span>
</a><a class="recommended-article-item" href="/2025/04/17/编程语言/swift/" title="Swift学习摘记" rel="bookmark">
  <img src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094625386.png?imageSlim" alt="Swift学习摘记" class="!max-w-none">
  <span class="title">Swift学习摘记</span>
</a></div>
   </div>
   <div class="recommended-mobile">
   <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
   </div>
   <div class="recommended-article-group"><a class="recommended-article-item" href="/2025/01/09/编程语言/JavaScript/" title="JavaScript" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="JavaScript" class="!max-w-none">
  <span class="title">JavaScript</span>
</a><a class="recommended-article-item" href="/2025/06/25/课程笔记/密码学复习/" title="密码学复习" rel="bookmark">
  <img src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250625145854973.png?imageSlim" alt="密码学复习" class="!max-w-none">
  <span class="title">密码学复习</span>
</a></div>
   </div>
  </div>

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/06/21/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">数据库系统复习</span>
						<span class="post-nav-item">上一篇</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/05/17/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/MAIC/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">MAIC</span>
						<span class="post-nav-item">下一篇</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        评论
    </div>
    

        
            
    <div id="giscus-container"></div>
    <script data-swup-reload-script defer>
        async function loadGiscus() {
            const giscusConfig = {
                'src': 'https://giscus.app/client.js',
                'data-repo': 'ffy6511/ffy6511.github.io',
                'data-repo-id': 'R_kgD00mnQ1A&#34;',
                'data-category': 'Announcements',
                'data-category-id': 'DIC_kwD00mnQ1M4Cp8zM',
                'data-mapping': 'pathname',
                'data-strict': '0',
                'data-reactions-enabled': '1',
                'data-emit-metadata': '1',
                'data-theme': 'preferred_color_scheme',
                'data-lang': 'zh-CN',
                'data-input-position': 'top',
                'data-loading': 'lazy',
                'crossorigin': 'anonymous',
                'async': true
            }
            const giscusScript = document.createElement('script');
            for (const key in giscusConfig) {
                giscusScript.setAttribute(key, giscusConfig[key]);
            }
            document.getElementById('giscus-container').appendChild(giscusScript);
        }
        if ('true') {
            let loadGiscusTimeout = setTimeout(() => {
                loadGiscus();
                clearTimeout(loadGiscusTimeout);
            }, 1000);
        } else {
            document.addEventListener('DOMContentLoaded', loadGiscus);
        }
    </script>


        
        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">目录</div>
		<div class="page-title">oop复习</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9%E5%9B%9E%E9%A1%BE"><span class="nav-number">1.</span> <span class="nav-text">知识点回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E6%93%8D%E4%BD%9C"><span class="nav-number">1.1.</span> <span class="nav-text">实验操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">截取字符串</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream"><span class="nav-number">1.2.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">1.2.1.</span> <span class="nav-text">文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%8D%E6%88%96%E8%BF%90%E7%AE%97%E7%AC%A6%E6%8C%87%E5%AE%9A%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">位或运算符指定模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%B5%81"><span class="nav-number">1.2.2.</span> <span class="nav-text">字符串流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E8%AF%8D"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">字符串分词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8B%BC%E6%8E%A5"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">字符串的拼接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#STL"><span class="nav-number">1.3.</span> <span class="nav-text">STL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#for-each"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">for-each</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map"><span class="nav-number">1.3.1.</span> <span class="nav-text">map</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lower-bound"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">lower_bound</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#class"><span class="nav-number">1.4.</span> <span class="nav-text">class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#include%E6%9C%BA%E5%88%B6"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">include机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">静态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#delete"><span class="nav-number">1.4.0.5.</span> <span class="nav-text">delete</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inside-class"><span class="nav-number">1.5.</span> <span class="nav-text">Inside class</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%9E%84%E9%80%A0"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">代理构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">内联函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.</span> <span class="nav-text">组合与继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-number">1.6.1.</span> <span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">命名空间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#using"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">using</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.2.</span> <span class="nav-text">继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E5%85%AC%E5%BC%80%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">非公开的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">静态成员的继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#name-hiding"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">name hiding</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E4%BC%A0%E9%80%92"><span class="nav-number">1.6.2.4.</span> <span class="nav-text">默认参数的重载传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0"><span class="nav-number">1.6.2.5.</span> <span class="nav-text">子类重写父类函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">1.7.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E8%A7%84%E8%8C%83"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">虚函数的规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E4%B8%8E%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">1.7.0.3.</span> <span class="nav-text">菱形继承与虚继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Copy-Move"><span class="nav-number">1.8.</span> <span class="nav-text">Copy &amp; Move</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">拷贝构造函数的调用时机</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">右值引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">1.8.0.3.</span> <span class="nav-text">移动构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#move"><span class="nav-number">1.8.0.4.</span> <span class="nav-text">move</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">1.8.1.</span> <span class="nav-text">初始化的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.8.1.1.</span> <span class="nav-text">基本类型的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.8.1.2.</span> <span class="nav-text">对象的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%9F%E4%B8%80%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">1.8.1.3.</span> <span class="nav-text">统一初始化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">1.9.</span> <span class="nav-text">操作符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E4%B8%8E%E8%87%AA%E7%94%B1%E5%87%BD%E6%95%B0"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">成员函数与自由函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A0%E6%B3%95%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.9.0.2.</span> <span class="nav-text">无法重载的运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.0.3.</span> <span class="nav-text">参数传递与返回类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.9.0.4.</span> <span class="nav-text">比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E8%BF%90%E7%AE%97"><span class="nav-number">1.9.0.5.</span> <span class="nav-text">流运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.9.0.6.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.9.0.7.</span> <span class="nav-text">隐式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="nav-number">1.9.0.8.</span> <span class="nav-text">显式转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-number">1.9.0.9.</span> <span class="nav-text">转换优先级</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">1.9.0.10.</span> <span class="nav-text">转换运算符</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Template"><span class="nav-number">1.10.</span> <span class="nav-text">Template</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.10.1.</span> <span class="nav-text">函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8C%B9%E9%85%8D"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">参数匹配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">1.10.2.</span> <span class="nav-text">类模板</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exception"><span class="nav-number">1.11.</span> <span class="nav-text">Exception</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E8%A7%84%E8%8C%83"><span class="nav-number">1.11.0.1.</span> <span class="nav-text">异常规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.11.0.2.</span> <span class="nav-text">层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-number">1.11.0.3.</span> <span class="nav-text">构造与析构</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%9F%A5%E8%AF%86%E8%92%B8%E9%A6%8F"><span class="nav-number">2.</span> <span class="nav-text">知识蒸馏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#vptr%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-number">2.0.0.1.</span> <span class="nav-text">vptr的大小</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E5%AF%B9%E9%BD%90"><span class="nav-number">2.0.0.2.</span> <span class="nav-text">编译器的对齐</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%9F%E6%9C%AB%E9%A2%98%E9%9B%86"><span class="nav-number">3.</span> <span class="nav-text">期末题集</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E5%A1%AB%E7%A9%BA"><span class="nav-number">3.1.</span> <span class="nav-text">程序填空</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%91%98%E5%BD%95"><span class="nav-number">3.1.0.1.</span> <span class="nav-text">题目摘录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A1%AB%E5%86%99"><span class="nav-number">3.1.0.2.</span> <span class="nav-text">类模板的填写</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%95%BF%E8%AF%9D%E7%9F%AD%E8%AF%B4"><span class="nav-number">3.2.</span> <span class="nav-text">长话短说</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%AF%B4%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%9A%84"><span class="nav-number">3.3.</span> <span class="nav-text">一句话说不清楚的</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.0.1.</span> <span class="nav-text">重载与友元函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.0.2.</span> <span class="nav-text">父类的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%AF%B9%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E7%9A%84%E6%94%AF%E6%8C%81"><span class="nav-number">3.3.0.3.</span> <span class="nav-text">C++对编程范式的支持</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%88%87%E7%89%87"><span class="nav-number">3.3.0.4.</span> <span class="nav-text">对象切片</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.3.0.5.</span> <span class="nav-text">拷贝初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A6%81%E6%AD%A2%E9%9A%90%E5%BC%8F%E7%9A%84%E6%8B%B7%E8%B4%9D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.3.0.6.</span> <span class="nav-text">禁止隐式的拷贝初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%90%E7%B1%BB%E5%AF%B9%E7%88%B6%E7%B1%BB%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99"><span class="nav-number">3.3.0.7.</span> <span class="nav-text">子类对父类函数的重载与重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A"><span class="nav-number">3.3.0.8.</span> <span class="nav-text">默认参数的静态绑定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96"><span class="nav-number">3.3.0.9.</span> <span class="nav-text">函数模板与模板特化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.3.0.10.</span> <span class="nav-text">常量对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84-catch%E9%A1%BA%E5%BA%8F"><span class="nav-number">3.3.0.11.</span> <span class="nav-text">异常的 catch顺序</span></a></li></ol></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2025</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 1s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">ffy</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 24 篇文章
                    </span>
                    
                        <span>
                            共 72.9k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/Swup.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/utils.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/main.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/runtime.js" ></script>
    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/assets/odometer-theme-minimal.css">



  <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/typed.js" ></script>



    
        <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/mermaid.min.js" ></script>
    
    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/mermaid.js" ></script>





    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>