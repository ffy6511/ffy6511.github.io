<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="ffy">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
        
        
        
            <link rel="preconnect" href="https://evan.beee.top" crossorigin>
        
    
    <!--- Seo Part-->
    
    <link rel="canonical" href="http://example.com/2025/02/14/编程语言/cpp学习记录/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="cpp学习记录">
<meta property="og:url" content="http://example.com/2025/02/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/redefine-og.webp">
<meta property="article:published_time" content="2025-02-14T12:21:21.000Z">
<meta property="article:modified_time" content="2025-05-09T01:48:28.191Z">
<meta property="article:author" content="ffy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/img/avatar.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/img/avatar.svg">
    <meta name="theme-color" content="#f0ad7c">
    <link rel="shortcut icon" href="/img/avatar.svg">
    <!--- Page Info-->
    
    <title>
        
            cpp学习记录 | ffyの备忘录
        
    </title>

    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/Chillax/chillax.css">

    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/css/build/tailwind.css">
    

    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/GeistMono/geist-mono.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fonts/Geist/geist.css">
    <!--- Font Part-->
    
    
        <link href="/fonts/custom-fonts.css" rel="stylesheet">
    
    
        <link href="/fonts/custom-fonts.css" rel="stylesheet">
    
    
        <link href="/fonts/custom-fonts.css" rel="stylesheet">
    
    
        <link href="/fonts/custom-fonts.css" rel="stylesheet">
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"example.com","root":"/","language":"zh-CN","path":"search.json"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":true,"family":"mono, monospace","url":"/fonts/custom-fonts.css"}},"toc":{"enable":true,"max_depth":3,"number":true,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":true,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#f0ad7c","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":true,"family":"WenKai, sans-serif","url":"/fonts/custom-fonts.css"},"english":{"enable":true,"family":"mono, sans-serif","url":"/fonts/custom-fonts.css"},"title":{"enable":true,"family":"WenKai, sans-serif","url":"/fonts/custom-fonts.css"}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedsun.png?imageSlim","dark":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefineddark.png?imageSlim"},"title":"不时掉落ffy的生活碎片和灵感","subtitle":{"text":["This is the first message"],"hitokoto":{"enable":true,"show_author":false,"api":"https://v1.hitokoto.cn?c=a&c=d&c=k"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":true,"style":"default","links":{"github":"https://github.com/ffy6511","instagram":null,"zhihu":null,"twitter":null,"email":"1253876012z@gmail.com"},"qrs":{"weixin":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedvx.JPG?imageSlim"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":true,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":true,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"},"Friends":{"path":"/links","icon":"fa-regular fa-heart"},"导航":{"icon":"fa-regular fa-compass","submenus":{"chatSQL":"https://chat-sql-hazel.vercel.app/"}}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"info","announcement":"听说您要来, 波奇酱在ta的柜子里翻出了这些有趣的笔记~","show_on_mobile":true,"links":{"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"Categories":{"path":"/categories","icon":"fa-regular fa-folder"}}},"article_date_format":"auto","excerpt_length":130,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2025/5/8 19:11:00"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/fontawesome.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/brands.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/solid.min.css">
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/fontawesome/regular.min.css">
    
    
    
    
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                ffyの备忘录
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags"
                                        >
                                    <i class="fa-regular fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/categories"
                                        >
                                    <i class="fa-regular fa-folder fa-fw"></i>
                                    分类
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/links"
                                        >
                                    <i class="fa-regular fa-heart fa-fw"></i>
                                    友情链接
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class="has-dropdown"
                                   href="#"
                                        onClick=&#34;return false;&#34;>
                                    <i class="fa-regular fa-compass fa-fw"></i>
                                    导航
                                    <i class="fa-solid fa-chevron-down fa-fw"></i>
                                </a>

                                <!-- Submenu -->
                                
                                    <ul class="sub-menu">
                                        
                                            <li>
                                                <a target="_blank" rel="noopener" href="https://chat-sql-hazel.vercel.app/">
                                                    CHATSQL
                                                </a>
                                            </li>
                                        
                                    </ul>
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/categories"
                        >
                            <span>
                                分类
                            </span>
                            
                                <i class="fa-regular fa-folder fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/links"
                        >
                            <span>
                                友情链接
                            </span>
                            
                                <i class="fa-regular fa-heart fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item-sub text-base my-1.5 flex flex-col w-full">
                        
                        <div class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary cursor-pointer text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                             navbar-data-toggle="submenu-导航"
                        >
                            <span>
                                导航
                            </span>
                            
                                <i class="fa-solid fa-chevron-right fa-sm fa-fw transition-all"></i>
                            
                        </div>
                        

                        
                            <div class="flex-col items-start px-2 py-2 hidden" data-target="submenu-导航">
                                
                                    <div class="drawer-navbar-item text-base flex flex-col justify-center items-start hover:underline active:underline hover:underline-offset-1 rounded-3xl">
                                        <a class=" text-third-text-color text-xl"
                                           target="_blank" rel="noopener" href="https://chat-sql-hazel.vercel.app/">CHATSQL</a>
                                    </div>
                                
                            </div>
                        
                    </li>
            

            
            
                
                    
                    
                    
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">5</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">11</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			
			
			<img src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094812819.png?imageSlim" alt="cpp学习记录" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75" />
			
			<div class="w-full flex items-center absolute bottom-0 justify-start">
				<h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-semibold backdrop-blur-lg rounded-xl border border-border-color ">cpp学习记录</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/img/avatar.svg">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">ffy</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2025-02-14 20:21:21</span>
        <span class="mobile">2025-02-14 20:21:21</span>
        <span class="hover-info">创建</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-05-09 09:48:28</span>
            <span class="mobile">2025-05-09 09:48:28</span>
            <span class="hover-info">更新</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a>&nbsp;
                        </li>
                    
                    
                
                    
                        
                            <li>></li>
                        
                        <li>
                            <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>35.4k 字</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>147 分钟</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<h4 id="导论"><a href="#导论" class="headerlink" title="导论"></a>导论</h4><p>编译时, 从<code>c</code>的<code>gcc</code>转变为了<code>g++</code>.</p>
<p>OOP的三大特点:</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>在C语言中,我们主要使用<code>malloc()</code>和<code>free()</code>来进行动态内存管理。但这种方式存在一些问题:</p>
<ul>
<li>它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;</li>
<li>容易发生内存泄漏.</li>
</ul>
<p>为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了<code>new</code>和<code>delete</code>.</p>
<p>new的基本语法十分直观:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Type* pointer = <span class="keyword">new</span> Type;           <span class="comment">// 分配单个对象</span></span><br><span class="line">Type* pointer = <span class="keyword">new</span> Type[size];     <span class="comment">// 分配对象数组</span></span><br></pre></td></tr></table></figure></div>

<p>可以在创建时进行初始化:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);              <span class="comment">// 初始化为5</span></span><br><span class="line">string* p2 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"hello"</span>);   <span class="comment">// 初始化为"hello"</span></span><br></pre></td></tr></table></figure></div>

<p>也可以根据变量进行动态的内存分配:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size;</span><br><span class="line">cin &gt;&gt; size;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[size];  <span class="comment">// 根据输入分配内存</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>[!NOTE]</p>
<p>Use <code>delete ［］</code> if <code>new ［］</code> was used to allocate an array.</p>
</blockquote>
<h1 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h1><p>通过包含头文件 – <code>#include &lt;iostream&gt;</code> 来使用输入输出流 <code>cin</code> 和 <code>cout</code>.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="type">int</span> age; </span><br><span class="line">    cin &gt;&gt; age;</span><br><span class="line">    cout &lt;&lt; <span class="string">"You are "</span> &lt;&lt; age &lt;&lt; <span class="string">" years old"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// endl 是换行符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>cin</code>读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">string str=<span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"out.txt"</span>)</span></span>;</span><br><span class="line">fout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"out.txt"</span>)</span></span>;</span><br><span class="line">string str1,str2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件中的两个字符串</span></span><br><span class="line">fin&gt;&gt;str1&gt;&gt;str2; </span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出:</span></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// world!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>


<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><h3 id="输入输出流基础"><a href="#输入输出流基础" class="headerlink" title="输入输出流基础"></a>输入输出流基础</h3><ul>
<li>头文件: <code>#include &lt;fstream&gt;</code></li>
<li>类: <code>ifstream</code>(输入流), <code>ofstream</code>(输出流)</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span>  <span class="comment">// 需要包含这个头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件输出（写入文件）</span></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"output.txt"</span>)</span></span>;</span><br><span class="line">outFile &lt;&lt; <span class="string">"Hello World"</span> &lt;&lt; endl;</span><br><span class="line">outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件输入（读取文件）</span></span><br><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">"input.txt"</span>)</span></span>; </span><br><span class="line">string line;</span><br><span class="line"><span class="built_in">getline</span>(inFile, line);</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></div>
<ul>
<li>写入文件时, 如果没有文件, 会自动创建.</li>
</ul>
<h3 id="常用操作示例"><a href="#常用操作示例" class="headerlink" title="常用操作示例"></a>常用操作示例</h3><ol>
<li><strong>写入文件</strong></li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ofstream outFile;</span><br><span class="line">outFile.<span class="built_in">open</span>(<span class="string">"test.txt"</span>);  <span class="comment">// 打开文件</span></span><br><span class="line"><span class="keyword">if</span> (outFile.<span class="built_in">is_open</span>()) {   <span class="comment">// 检查是否成功打开</span></span><br><span class="line">    outFile &lt;&lt; <span class="string">"第一行"</span> &lt;&lt; endl;</span><br><span class="line">    outFile &lt;&lt; <span class="string">"第二行"</span> &lt;&lt; endl;</span><br><span class="line">    outFile.<span class="built_in">close</span>();       <span class="comment">// 完成后关闭文件</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ol start="2">
<li>**读取文件 **</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">"test.txt"</span>)</span></span>;</span><br><span class="line">string line;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">getline</span>(inFile, line)) {  <span class="comment">// 逐行读取</span></span><br><span class="line">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></div>

<ol start="3">
<li><strong>以追加模式打开文件</strong></li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"test.txt"</span>, ios::app)</span></span>;  <span class="comment">// app 表示追加模式</span></span><br><span class="line">outFile &lt;&lt; <span class="string">"这行会被添加到文件末尾"</span> &lt;&lt; endl;</span><br><span class="line">outFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure></div>


<h3 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h3><ul>
<li><code>ios::in</code> - 读取模式</li>
<li><code>ios::out</code> - 写入模式</li>
<li><code>ios::app</code> - 追加模式</li>
<li><code>ios::ate</code> - 打开文件后立即定位到文件末尾</li>
<li><code>ios::binary</code> - 二进制模式</li>
<li><code>ios::trunc</code> - 如果文件存在则<strong>截断</strong>文件<ul>
<li>如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 test.txt 原本内容是:</span></span><br><span class="line"><span class="comment">// Hello World</span></span><br><span class="line"><span class="comment">// This is a test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 trunc 模式打开</span></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"test.txt"</span>, ios::out | ios::trunc)</span></span>;  </span><br><span class="line">outFile &lt;&lt; <span class="string">"新的内容"</span> &lt;&lt; endl;</span><br><span class="line">outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在 test.txt 的内容只有:</span></span><br><span class="line"><span class="comment">// 新的内容</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p> 或直接用 <code>ios::out</code>，因为out默认包含trunc</p>
</blockquote>
<ul>
<li>使用位或运算符<code>|</code>来同时指定多个模式:</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 组合使用打开模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">"test.txt"</span>, ios::out | ios::app)</span></span>;</span><br></pre></td></tr></table></figure></div>

<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">"nonexistent.txt"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (!inFile) {</span><br><span class="line">    cerr &lt;&lt; <span class="string">"无法打开文件！"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用is_open()</span></span><br><span class="line"><span class="keyword">if</span> (!inFile.<span class="built_in">is_open</span>()) {</span><br><span class="line">    cerr &lt;&lt; <span class="string">"无法打开文件！"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>需要先引入指定的头文件:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure></div>

<ul>
<li>定义时可以使用等号或者用括号包裹字符串:</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string name = <span class="string">"John"</span>; </span><br><span class="line"><span class="comment">// string name("John");</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="stringstream"><a href="#stringstream" class="headerlink" title="stringstream"></a>stringstream</h3><p><code>stringstream</code> 表示<strong>双向</strong>字符串流:</p>
<ul>
<li>需要导入头文件<code>#include &lt;sstream&gt;</code>;</li>
<li><code>istringstream</code> 表示<strong>输入</strong>字符串流<ul>
<li>作用: 将字符串转换成一个类似于输入流的对象;</li>
<li>内部维护了一个字符串和一个位置指针;</li>
<li>每次读取时, 位置指针向后移动, 且自动跳过空白字符.</li>
</ul>
</li>
<li><code>ostringstream</code> 表示<strong>输出</strong>字符串流.</li>
</ul>
<h4 id="字符串分词"><a href="#字符串分词" class="headerlink" title="字符串分词"></a>字符串分词</h4><p>自动以<strong>空白字符</strong>(空格、制表符\t、换行符\n等)分割字符串;</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function">string <span class="title">name</span> <span class="params">( <span class="string">"Xiao Ming"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用括号包字符串</span></span><br><span class="line">    <span class="function">istringstream <span class="title">is</span> <span class="params">(name)</span></span>; </span><br><span class="line">    string s;</span><br><span class="line">    <span class="keyword">while</span> (is&gt;&gt;s){</span><br><span class="line">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><code>&gt;&gt;</code> 表示从输入流中读取数据;</p>
<p>注意字符串流也是一种类型, 作用的对象是字符串.</p>
</blockquote>
<p>Output:</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Xiao Ming</span><br><span class="line">Xiao</span><br><span class="line">Ming</span><br></pre></td></tr></table></figure></div>

<p>包含更多分词的字符串:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    string words = <span class="string">"hello \n world! \t I am \n here!"</span>;</span><br><span class="line">    <span class="function">stringstream <span class="title">is</span> <span class="params">(words)</span></span>;</span><br><span class="line">    </span><br><span class="line">    string word;</span><br><span class="line">    <span class="type">int</span> count  = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(is &gt;&gt; word){</span><br><span class="line">        cout &lt;&lt; <span class="string">"Word "</span> &lt;&lt; count &lt;&lt; <span class="string">": "</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">        count++;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>Output:</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Word 1: hello</span><br><span class="line">Word 2: world!</span><br><span class="line">Word 3: I</span><br><span class="line">Word 4: am</span><br><span class="line">Word 5: here!</span><br></pre></td></tr></table></figure></div>

<h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ostringstream oss;</span><br><span class="line">    string name = <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">25</span>;</span><br><span class="line">    </span><br><span class="line">    oss &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; name &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; age;</span><br><span class="line">    string result = oss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>Output:</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name: Alice, Age: 25</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>通过<code>.str()</code>方法可以对象转换为字符串类型, 从而<strong>格式化输出</strong>.</p>
</blockquote>
<br>

<p><code>.str("")</code>方法可以<strong>清空</strong>字符串流:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ostringstream oss;</span><br><span class="line">    string name = <span class="string">"Alice"</span>;</span><br><span class="line">    <span class="type">int</span> age = <span class="number">25</span>;</span><br><span class="line">    </span><br><span class="line">    oss &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; name &lt;&lt; <span class="string">", Age: "</span> &lt;&lt; age;</span><br><span class="line">    oss.<span class="built_in">str</span>(<span class="string">""</span>);</span><br><span class="line">    string result = oss.<span class="built_in">str</span>();</span><br><span class="line">    cout &lt;&lt; result &lt;&lt; <span class="string">"Nothing"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>Output:</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Nothing</span><br></pre></td></tr></table></figure></div>

<h3 id="Getline"><a href="#Getline" class="headerlink" title="Getline"></a>Getline</h3><p><strong>基本语法:</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getline</span>(istream&amp; is, string&amp; str, <span class="type">char</span> delim = <span class="string">'\n'</span>);</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>is</code>: 输入流（通常是cin;</li>
<li><code>str</code>: 存储结果的字符串;</li>
<li><code>delim</code>: 分隔符, 默认为换行符<code>\n</code>.</li>
</ul>
<p><strong>Example</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    string line;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"请输入一行文本："</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);  <span class="comment">// 读取整行，包括空格</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"你输入的是："</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用自定义分隔符</span></span><br><span class="line">    string data;</span><br><span class="line">    cout &lt;&lt; <span class="string">"请输入内容（用,分隔）："</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, data, <span class="string">','</span>);  <span class="comment">// 读取直到遇到逗号</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"读取到逗号前的内容："</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="cin"><a href="#cin" class="headerlink" title="cin"></a>cin</h3><p><strong>特点</strong>:</p>
<ul>
<li>以空白字符（空格、制表符、换行符）为分隔符;</li>
<li><strong>忽略</strong>前导空白字符;</li>
<li>遇到空白字符就停止读取.</li>
</ul>
<p>通常需要与<code>getchar()</code>方法配合来清除缓冲区当中的<code>\n</code>字符:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    string line;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"输入一个数字："</span>;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清除输入缓冲区中的换行符</span></span><br><span class="line">    <span class="built_in">getchar</span>(); <span class="comment">// or cin.ignore(); </span></span><br><span class="line">   </span><br><span class="line">    cout &lt;&lt; <span class="string">"输入一行文本："</span>;</span><br><span class="line">    <span class="built_in">getline</span>(cin, line);  <span class="comment">// 现在可以正确读取整行</span></span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">"数字："</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">"文本："</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>如果输入<code>8 \n</code>, 则<code>getchar()</code>读取空格, 文本为空.</p>
</blockquote>
<h3 id="Alter-String"><a href="#Alter-String" class="headerlink" title="Alter String"></a>Alter String</h3><p><strong>outline</strong> : 常用的字符串方法(成员函数):</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">insert</span>(<span class="type">size_t</span> pos, <span class="type">const</span> string&amp; s);</span><br><span class="line"><span class="built_in">erase</span> (<span class="type">size_t</span> pos = <span class="number">0</span>, size_tlen = npos);</span><br><span class="line"><span class="built_in">append</span> (<span class="type">const</span> string&amp; str);</span><br><span class="line"><span class="built_in">replace</span> (<span class="type">size_t</span> pos,<span class="type">size_t</span> len,<span class="type">const</span> string&amp; str);</span><br></pre></td></tr></table></figure></div>

<hr>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul>
<li><code>insert(int pos, string str)</code> 在指定位置插入字符串</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="comment">// 在位置5处插入字符串</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">5</span>, <span class="string">" Beautiful"</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// 结果: "Hello Beautiful World"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在字符串末尾插入内容</span></span><br><span class="line">str.<span class="built_in">insert</span>(str.<span class="built_in">length</span>(), <span class="string">"!"</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// 结果: "Hello Beautiful World!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入单个字符（使用string构造）</span></span><br><span class="line">str.<span class="built_in">insert</span>(<span class="number">0</span>, <span class="string">"&gt;"</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// 结果: "&gt;Hello Beautiful World!"</span></span><br></pre></td></tr></table></figure></div>

<hr>
<ul>
<li><code>erase(int pos, int length)</code> 删除从指定位置开始的若干个字符</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">"Hello Beautiful World!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除从下标6开始的9个字符</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">6</span>, <span class="number">9</span>); </span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// 结果: "Hello World!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除从某个位置开始到末尾的所有字符</span></span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// 结果: "Hello"</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><code>length</code>参数省略, 则删除从<code>pos</code>位置开始到字符串末尾的所有字符.</p>
</blockquote>
<hr>
<ul>
<li><code>replace (int pos, int length, string)</code> 替换指定位置的字符串</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从位置6开始，替换5个字符为"C++"</span></span><br><span class="line">string str = <span class="string">"Hello World!"</span>;</span><br><span class="line">str.<span class="built_in">replace</span>(<span class="number">6</span>, <span class="number">5</span>, <span class="string">"C++"</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// 结果: "Hello C++!"</span></span><br></pre></td></tr></table></figure></div>


<hr>
<ul>
<li><code>append (const string&amp; str);</code></li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加整个字符串</span></span><br><span class="line">string<span class="number">1.</span><span class="built_in">append</span>(string2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加指定位置的字符(索引从开始)</span></span><br><span class="line">string<span class="number">1.</span><span class="built_in">append</span>(string2, start, length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复字符的添加</span></span><br><span class="line">string<span class="number">1.</span><span class="built_in">append</span>(count, <span class="type">char</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>除此之外, 还存在着使用<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.17ex;" xmlns="http://www.w3.org/2000/svg" width="6.787ex" height="2.867ex" role="img" focusable="false" viewBox="0 -750 3000 1267"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="munder"><g data-mml-node="mrow"><g data-mml-node="mi"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">迭</text></g><g data-mml-node="mi" transform="translate(1000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">代</text></g><g data-mml-node="mi" transform="translate(2000,0)"><text data-variant="normal" transform="scale(1,-1)" font-size="884px" font-family="serif">器</text></g></g><g data-mml-node="mo" transform="translate(0,-665)"><svg width="3000" height="237" x="0" y="148" viewBox="750 148 3000 237"><path data-c="2013" d="M0 248V285H499V248H0Z" transform="scale(9,1)"></path></svg></g></g></g></g></svg></mjx-container>的用法: </p>
<blockquote>
<p>类似于指针, 指向容器(如字符串、数组等)的特定位置.</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    string source = <span class="string">"World!"</span>;</span><br><span class="line">    string target = <span class="string">"Hello "</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加source中的部分字符（从开始到结束）</span></span><br><span class="line">    target.<span class="built_in">append</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>());</span><br><span class="line">    cout &lt;&lt; target &lt;&lt; endl;  <span class="comment">// 输出: Hello World!</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只添加部分字符</span></span><br><span class="line">    string target2 = <span class="string">"Hello "</span>;</span><br><span class="line">    target<span class="number">2.</span><span class="built_in">append</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">begin</span>() + <span class="number">5</span>);  <span class="comment">// 只添加"World"，不包含"!"</span></span><br><span class="line">    cout &lt;&lt; target2 &lt;&lt; endl;  <span class="comment">// 输出: Hello World</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<ol>
<li><code>begin()</code>方法返回字符串的第一个字符的迭代器, <code>end()</code>方法返回字符串最后一个字符的<strong>下一个</strong>位置的迭代器;</li>
<li>迭代器的范围是<strong>左闭右开</strong>.</li>
</ol>
<hr>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul>
<li><code>find(string, int pos)</code> 从指定的位置开始寻找字符串位置</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">"Hello World Hello"</span>;</span><br><span class="line"><span class="comment">// 从位置0开始查找"Hello"</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(<span class="string">"Hello"</span>, <span class="number">0</span>) &lt;&lt; endl;     <span class="comment">// 结果: 0</span></span><br><span class="line"><span class="comment">// 从位置1开始查找"Hello"</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(<span class="string">"Hello"</span>, <span class="number">1</span>) &lt;&lt; endl;     <span class="comment">// 结果: 12</span></span><br><span class="line"><span class="comment">// 查找不存在的字符串</span></span><br><span class="line">cout &lt;&lt; str.<span class="built_in">find</span>(<span class="string">"Python"</span>) &lt;&lt; endl;       <span class="comment">// 结果: string::npos</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>string::npos</code>是<code>size_t</code>类型的最大值;</li>
<li>可以使用<code>str.find("Python") == string::npos</code>作为判断条件, 检查是否找到字符串.</li>
</ul>
<hr>
<ul>
<li><code>compare(string)</code> 字符串比较</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">"Hello"</span>;</span><br><span class="line">string str2 = <span class="string">"Hello"</span>;</span><br><span class="line">string str3 = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; str<span class="number">1.</span><span class="built_in">compare</span>(str2) &lt;&lt; endl;  <span class="comment">// 结果: 0  (相等)</span></span><br><span class="line">cout &lt;&lt; str<span class="number">1.</span><span class="built_in">compare</span>(str3) &lt;&lt; endl;  <span class="comment">// 结果: -15 (str1 &lt; str3) </span></span><br><span class="line">cout &lt;&lt; str<span class="number">3.</span><span class="built_in">compare</span>(str1) &lt;&lt; endl;  <span class="comment">// 结果: 15  (str3 &gt; str1)</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>按照字典序比较得到结果</li>
</ul>
<hr>
<ul>
<li><code>to_string(int)</code> 将数字转换成字符串</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">123</span>;</span><br><span class="line">string str = <span class="built_in">to_string</span>(num);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;          <span class="comment">// 结果: "123"</span></span><br><span class="line">cout &lt;&lt; str + <span class="string">"456"</span> &lt;&lt; endl;  <span class="comment">// 结果: "123456"</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>字符串之间可以通过<code>+</code>直接拼接.</li>
</ul>
<hr>
<ul>
<li><code>stoi(string)</code> 将字符串转换成整数</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">"123"</span>;</span><br><span class="line"><span class="type">int</span> num = <span class="built_in">stoi</span>(str);</span><br><span class="line">cout &lt;&lt; num + <span class="number">456</span> &lt;&lt; endl;    <span class="comment">// 结果: 579</span></span><br><span class="line"><span class="comment">// 注意：字符串必须是合法的数字格式</span></span><br><span class="line"><span class="comment">// string str = "abc"; </span></span><br><span class="line"><span class="comment">// int num = stoi(str);  // 这会抛出异常</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li>字符串必须是合法的数字格式;</li>
<li><code> int num = stoi("abc");</code>  将会抛出异常</li>
</ul>
<hr>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p><strong>Outline:</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>(<span class="type">const</span> <span class="type">char</span> *cp, <span class="type">int</span> len);</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s2, <span class="type">int</span> pos);</span><br><span class="line"><span class="built_in">string</span>(<span class="type">const</span> string&amp; s2, <span class="type">int</span> pos, <span class="type">int</span> len);</span><br></pre></td></tr></table></figure></div>

<hr>
<ul>
<li><code>string(const char *cp, int len)</code> 字符数组创建字符串</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="string">"Hello World"</span>, <span class="number">5</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出: Hello</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>string(const string&amp; s2, int pos)</code> 从现有字符串创建新字符串，从指定位置到末尾</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s2 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="function">string <span class="title">str2</span><span class="params">(s2, <span class="number">6</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出: World</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>string(const string&amp; s2, int pos, int len)</code> 从现有字符串创建新字符串，指定起始位置和长度</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s3 = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="function">string <span class="title">str3</span><span class="params">(s3, <span class="number">6</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出: Wor</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>string(int length, char c)</code> 用指定长度的字符c初始化字符串</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str4</span><span class="params">(<span class="number">5</span>, <span class="string">'*'</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出: *****</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际应用示例</span></span><br><span class="line"><span class="type">int</span> num = <span class="number">432</span>;</span><br><span class="line">string str = <span class="built_in">to_string</span>(num);</span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(<span class="number">5</span> - str.<span class="built_in">length</span>(), <span class="string">'0'</span>) + str &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 输出: 00432</span></span><br></pre></td></tr></table></figure></div>


<h3 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取子字符串</span></span><br><span class="line"><span class="built_in">substr</span>(<span class="type">int</span> pos, <span class="type">int</span> len);</span><br><span class="line">string str = <span class="string">"Hello World"</span>;</span><br><span class="line">string sub = str.<span class="built_in">substr</span>(<span class="number">6</span>, <span class="number">3</span>);  <span class="comment">// 结果: "Wor"</span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串赋值</span></span><br><span class="line"><span class="built_in">assign</span>();</span><br><span class="line">string str1 = <span class="string">"Hello"</span>;</span><br><span class="line">string str2;</span><br><span class="line">str<span class="number">2.</span><span class="built_in">assign</span>(str1);  <span class="comment">// str2现在是 "Hello"</span></span><br></pre></td></tr></table></figure></div>


<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在指定位置插入字符串</span></span><br><span class="line">    string str1 = <span class="string">"hello"</span>;</span><br><span class="line">    string str2 = <span class="string">"world"</span>;</span><br><span class="line">    str<span class="number">1.</span><span class="built_in">insert</span>(<span class="number">3</span>, str2);</span><br><span class="line">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 结果: helworldlo </span></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的指定长度的字符</span></span><br><span class="line"><span class="built_in">erase</span>(<span class="type">int</span> pos, <span class="type">int</span> len);</span><br><span class="line">string str = <span class="string">"Hello World"</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">5</span>, <span class="number">6</span>);  <span class="comment">// 结果: "Hello"</span></span><br></pre></td></tr></table></figure></div>

<p><strong>Notice：</strong></p>
<ol>
<li>所有位置索引都是从0开始计数</li>
<li>如果指定的长度超过字符串实际长度，会自动调整到实际可用长度</li>
<li>使用这些函数时要注意检查参数的有效性，避免越界访问</li>
<li><code>.assign(str, pos, len)</code>: 相比于直接赋值, <code>assign</code>还提供了精确控制赋值的方法, 也就是指定内容字符串的起始位置和长度.</li>
</ol>
<hr>
<h3 id="Substr"><a href="#Substr" class="headerlink" title="Substr"></a>Substr</h3><p>在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. <code>substr()</code>方法可以精确地获取字符串片段.</p>
<p><code>substr</code>即substring的缩写, 表示子字符串.</p>
<p><strong>基本语法</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">substr</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> len)</span> </span>;</span><br></pre></td></tr></table></figure></div>
<p>参数分别表示截取的起始下标以及要截取的长度(如果省略<code>len</code>将截取到字符串的末尾).</p>
<p><strong>e.g.</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string email = <span class="string">"user.name@example.com"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户名的部分</span></span><br><span class="line"><span class="type">int</span> atPos = email.<span class="built_in">find</span>(<span class="string">'@'</span>);</span><br><span class="line">string username = email.<span class="built_in">substr</span>(<span class="number">0</span>, atPos); <span class="comment">// result: "user.name"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取域名部分</span></span><br><span class="line">string domain =  email.<span class="built_in">substr</span>(atPos + <span class="number">1</span>); <span class="comment">// result: "example.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顶级域名(最后一个.之后的部分)</span></span><br><span class="line"><span class="type">int</span> lastDotPos = email.<span class="built_in">rfind</span>(<span class="string">'.'</span>);</span><br><span class="line">string topLevelDomain = email.<span class="built_in">substr</span>(lastDotPos + <span class="number">1</span>); <span class="comment">// result: "com"</span></span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>rfind()</code>方法: 会从字符串的<strong>末尾向前</strong>搜索，从而返回要查找的字符或子字符串此时第一次出现的位置。如果没有找到，则返回 string::npos.</li>
</ul>
<hr>
<h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><h2 id="Default-arguments"><a href="#Default-arguments" class="headerlink" title="Default arguments"></a>Default arguments</h2><p>要点:</p>
<ul>
<li><p>默认值必须在函数原型中从右到左地给出, 否则在调用的时候无法分辨;</p>
</li>
<li><p>默认值只能出现在函数原型 或者 将声明和定义放在一起, 下面的情况会报错:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j = <span class="number">10</span>)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h1 id="Group"><a href="#Group" class="headerlink" title="Group"></a>Group</h1><p><strong>选择的标准:</strong></p>
<ul>
<li>一般情况 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container> <code>vector</code>;</li>
<li>程序需要对元素进行<strong>随机访问</strong> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container> <code>vector</code> or <code>deque</code>;</li>
<li>程序需要在容器<strong>中间插入</strong>元素 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container> <code>list</code> or <code>forward_list</code>;</li>
<li>程序需要在容器的<strong>首尾插入</strong>元素 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.054ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.242ex" role="img" focusable="false" viewBox="0 -525 1000 549"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21D2" d="M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z"></path></g></g></g></svg></mjx-container> <code>deque</code>;</li>
<li>容器中的元素<strong>相对较小</strong>但是数量较多 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.079ex;" xmlns="http://www.w3.org/2000/svg" width="2.262ex" height="1.287ex" role="img" focusable="false" viewBox="0 -534 1000 569"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mo"><path data-c="21CF" d="M346 174Q348 176 378 249T411 325Q411 327 239 327H68Q55 342 55 347Q55 354 68 367H428L459 445Q487 509 494 521T510 534Q517 534 524 527T531 516Q531 515 502 438L471 367H677L666 381Q631 421 605 463T578 516Q578 522 582 523T599 525H615L619 512Q659 437 714 383T812 309T896 272T942 254Q943 246 938 243T911 232Q718 172 619 -13L615 -24L599 -26Q578 -26 578 -17Q578 -11 587 6T617 53T666 118L677 132H373L339 54Q323 12 313 -8T298 -32T288 -35Q280 -35 275 -29T269 -17Q269 -14 298 57T328 132H68Q55 145 55 152Q55 156 56 158T62 165T68 172H206Q346 172 346 174ZM848 249Q763 297 735 318L722 327H455L422 252L391 174Q391 172 557 172H722L735 181Q773 210 819 234L848 249Z"></path></g></g></g></svg></mjx-container> <code>list</code> nor <code>forward_list</code>.<ul>
<li>否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.</li>
</ul>
</li>
</ul>
<h2 id="Pair"><a href="#Pair" class="headerlink" title="Pair"></a>Pair</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h4><p>pair 是 C++ 标准库提供的模板类，用于<u>将两个不同类型的值组合成一个对象</u>。它定义在 <code>&lt;utility&gt;</code> 头文件中。</p>
<h4 id="2-创建与初始化"><a href="#2-创建与初始化" class="headerlink" title="2. 创建与初始化"></a>2. 创建与初始化</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造</span></span><br><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; p1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function">std::pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="string">"tag"</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用make_pair</span></span><br><span class="line"><span class="keyword">auto</span> p3 = std::<span class="built_in">make_pair</span>(<span class="string">"data"</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一初始化</span></span><br><span class="line">std::pair&lt;std::string, <span class="type">int</span>&gt; p4{<span class="string">"value"</span>, <span class="number">8</span>};</span><br></pre></td></tr></table></figure></div>

<h4 id="3-访问元素"><a href="#3-访问元素" class="headerlink" title="3. 访问元素"></a>3. 访问元素</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统访问方式</span></span><br><span class="line">std::cout &lt;&lt; p<span class="number">2.f</span>irst &lt;&lt; <span class="string">": "</span> &lt;&lt; p<span class="number">2.</span>second &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构化绑定(C++17)</span></span><br><span class="line"><span class="keyword">auto</span> [key, val] = p3;</span><br><span class="line">std::cout &lt;&lt; key &lt;&lt; <span class="string">": "</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>

<h4 id="4-常用操作"><a href="#4-常用操作" class="headerlink" title="4. 常用操作"></a>4. 常用操作</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较操作</span></span><br><span class="line"><span class="keyword">if</span> (p1 == p2) {...}</span><br><span class="line"><span class="keyword">if</span> (p1 &lt; p2) {...}  <span class="comment">// 先比较first，再比较second</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换内容</span></span><br><span class="line">p<span class="number">1.</span><span class="built_in">swap</span>(p2);</span><br><span class="line">std::<span class="built_in">swap</span>(p1, p2);</span><br></pre></td></tr></table></figure></div>

<h4 id="5-实际应用示例"><a href="#5-实际应用示例" class="headerlink" title="5. 实际应用示例"></a>5. 实际应用示例</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作为函数返回值</span></span><br><span class="line"><span class="function">std::pair&lt;<span class="type">bool</span>, string&gt; <span class="title">checkInput</span><span class="params">(<span class="type">const</span> string&amp; input)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (input.<span class="built_in">empty</span>()) {</span><br><span class="line">        <span class="keyword">return</span> {<span class="literal">false</span>, <span class="string">"输入不能为空"</span>};</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> {<span class="literal">true</span>, <span class="string">""</span>};</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在容器中使用</span></span><br><span class="line">vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; dataList = {</span><br><span class="line">    {<span class="string">"item1"</span>, <span class="number">10</span>},</span><br><span class="line">    {<span class="string">"item2"</span>, <span class="number">20</span>},</span><br><span class="line">    {<span class="string">"item3"</span>, <span class="number">30</span>}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与map配合使用</span></span><br><span class="line">map&lt;string, pair&lt;<span class="type">int</span>, <span class="type">double</span>&gt;&gt; complexData;</span><br></pre></td></tr></table></figure></div>

<h4 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h4><ol>
<li>pair 的元素可以是任意类型，包括自定义类型</li>
<li>使用结构化绑定需要C++17或更高标准</li>
<li>pair 常用于需要返回多个值的函数</li>
<li>在性能敏感场景要注意构造和拷贝开销</li>
</ol>
<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><p><strong>集合</strong>: 用于存储一组不允许重复的元素, 且会自动排序.</p>
<p>可以使用的方法包括:</p>
<ol>
<li><p><code>.insert( )</code>: 插入元素;</p>
</li>
<li><p><code>.erase()</code>: 删除元素. 如果输入是元素值, 那么返回1/0表示是否成功删除; 如果输入是迭代器, 那么返回的是<strong>下一个元素的迭代器</strong>.</p>
</li>
<li><p><code>.find( )</code>: 寻找元素, 如果找到 返回对应的 <strong>迭代器</strong>. 否则返回 <code>.end( )</code>;</p>
</li>
</ol>
<h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><p>存储元素在<strong>连续的内存空间</strong>中, 支持<strong>随机访问</strong>.</p>
<ul>
<li>可以动态增长, 适合存储<strong>未知数量</strong>的元素;</li>
<li>通过下标访问元素的时间复杂度为 O(1);</li>
<li>在末尾插入和删除元素的时间复杂度为 O(1);</li>
<li>在中间插入和删除元素的时间复杂度为 O(n);</li>
<li><strong>使用场景</strong>: 需要随机访问、排序、内存连续存储的场景.</li>
</ul>
<p><strong>语法</strong>:</p>
<ul>
<li><p>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), value);  <span class="comment">// 查找 value</span></span><br><span class="line">  <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {         <span class="comment">// 如果找到了（即没有返回 end()）</span></span><br><span class="line">      vec.<span class="built_in">erase</span>(it);             <span class="comment">// 则删除找到的元素</span></span><br><span class="line">  }</span><br></pre></td></tr></table></figure></div></li>
<li><p>使用 <code>.push_back()</code>在末尾插入元素, 或者使用<code>.emplace_back()</code>在末尾原位构造元素(更加高效);</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">vec.<span class="built_in">emplace_back</span>(<span class="number">20</span>); <span class="comment">//更加高效</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><code>emplace_back</code>方法<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象, 相比于<code>push_back</code>而言更加<strong>高效</strong>.</p>
</blockquote>
</li>
<li><p><code>.erase()</code>方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;</p>
  <div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>);       <span class="comment">// 删除第二个元素</span></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">begin</span>() + <span class="number">3</span>); <span class="comment">// 删除前三个元素</span></span><br><span class="line">vec.<span class="built_in">clear</span>();                      <span class="comment">// 清空整个 vector</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><code>vec.clear();</code> 将会清空整个vector.</p>
<p>和<code>insert</code>需要的参数一样, 都需要<strong>迭代器</strong>而非索引来定位.</p>
</blockquote>
</li>
<li><p><code>vec[i]</code>的形式访问, 使用<code>vec.at(i)</code>的方式可以在越界时抛出异常;</p>
</li>
<li><p><code>.begin()</code>和<code>.end()</code>获取迭代器, 使用范围for循环遍历元素;</p>
  <div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> cout &lt;&lt; <span class="string">"Vector elements:"</span> &lt;&lt; endl;</span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> num : vec) {</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"> }</span><br><span class="line"> cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用迭代器遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = vec.<span class="built_in">begin</span>(); it != vec.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">    cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div></li>
<li><p><code>.size()</code>获取<code>vector</code>的大小, <code>.empty()</code>判断<code>vector</code>是否为空;</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"Vector size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">if</span> (vec.<span class="built_in">empty</span>()) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"Vector is empty."</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p>使用<code>sort()</code>对<code>vector</code>进行排序, 使用<code>find()</code>查找元素;</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());   <span class="comment">// 排序</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">5</span>); <span class="comment">// 查找 5</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>insert</code> 插入的位置是指定的迭代器位置之前一个;</p>
</li>
</ul>
<h3 id="Reserve"><a href="#Reserve" class="headerlink" title="Reserve"></a>Reserve</h3><p>为了避免频繁地扩展内存, 可以通过<code>reserve</code>预先分配合适的空间, 同时通过<code>.reszie()</code>调整大小;</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v2;</span><br><span class="line">v<span class="number">2.</span><span class="built_in">reserve</span>(<span class="number">1000</span>);  <span class="comment">// 一次性分配 1000 个元素的空间</span></span><br><span class="line"></span><br><span class="line">v<span class="number">2.</span><span class="built_in">resize</span>(v<span class="number">2.</span><span class="built_in">size</span>() + v<span class="number">2.</span><span class="built_in">size</span>()/<span class="number">2</span>); <span class="comment">// 调整大小为原来的 1.5 倍</span></span><br></pre></td></tr></table></figure></div>

<p><code>reserve</code>只分配空间而不创建元素,<code>resize</code>将同时分配元素(默认值):</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; vec;</span><br><span class="line"><span class="comment">// reserve: 只分配空间，不创建元素</span></span><br><span class="line">vec.<span class="built_in">reserve</span>(<span class="number">10</span>);  </span><br><span class="line">cout &lt;&lt; <span class="string">"The capacity with reserve: "</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"The size with reserve: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// resize: 分配空间并创建元素</span></span><br><span class="line">vec.<span class="built_in">resize</span>(<span class="number">10</span>);   </span><br><span class="line">cout &lt;&lt; <span class="string">"The capacity with resize: "</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"The size with resize: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;   </span><br></pre></td></tr></table></figure></div>

<p><strong>Output</strong>:</p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The capacity with reserve: 10</span><br><span class="line">The size with reserve: 0</span><br><span class="line">The capacity with resize: 10</span><br><span class="line">The size with resize: 10</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>[!important]</p>
<p><code>.push_back()</code>的实际作用是在容器索引的<code>size</code>处插入元素.</p>
<p> 而<code>reserve</code>不会影响容器的<code>size</code>,  初始化和<code>resize</code>会影响并且填充默认值:</p>
</blockquote>
<p><strong>e.g.  验证:</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印初始状态</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"初始状态：\n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">", capacity: "</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 预留5个空间</span></span><br><span class="line">    vec.<span class="built_in">reserve</span>(<span class="number">15</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"reserve(15) 后：\n"</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; <span class="string">", capacity: "</span> &lt;&lt; vec.<span class="built_in">capacity</span>() &lt;&lt; <span class="string">"\n\n"</span>;</span><br><span class="line">    </span><br><span class="line">    vec[<span class="number">20</span>] =<span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素并观察</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"添加元素过程：\n"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) {</span><br><span class="line">        vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">        cout &lt;&lt; <span class="string">"添加 "</span> &lt;&lt; i &lt;&lt; <span class="string">" 后 - "</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"size: "</span> &lt;&lt; vec.<span class="built_in">size</span>() </span><br><span class="line">             &lt;&lt; <span class="string">", capacity: "</span> &lt;&lt; vec.<span class="built_in">capacity</span>()</span><br><span class="line">             &lt;&lt; <span class="string">", 元素: "</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : vec) cout &lt;&lt; x &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>Output:</strong></p>
<div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">初始状态：</span><br><span class="line">size: 10, capacity: 10</span><br><span class="line"></span><br><span class="line">reserve(15) 后：</span><br><span class="line">size: 10, capacity: 15</span><br><span class="line"></span><br><span class="line">添加元素过程：</span><br><span class="line">添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 </span><br><span class="line">添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 </span><br><span class="line">添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 </span><br><span class="line">添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 </span><br><span class="line">添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 </span><br><span class="line">添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 </span><br></pre></td></tr></table></figure></div>

<ol>
<li>此处的 <code>vector&lt;int&gt; vec(10);</code>初始化了10个默认值的<code>int</code>类型的元素;</li>
<li><code>vec[20] = 20;</code>没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;<ol>
<li>如果换成<code>vec.at(20) = 20</code>将会在编译时报错;</li>
</ol>
</li>
<li>可以发现, <code>reserve</code>的作用就是避免了多次自动扩容.</li>
</ol>
<blockquote>
<p><code>reserve</code>的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素<strong>copy</strong>到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.</p>
</blockquote>
<h3 id="Resize"><a href="#Resize" class="headerlink" title="Resize"></a>Resize</h3><p>用法的枚举:</p>
<ol>
<li><p><code>resize(n)</code>: 将vector的大小调整为n, 如果大于当前值, 则在末尾添加具有默认值的新元素;</p>
</li>
<li><p><code>resize(n, val)</code>: 同样调整大小, 但是指定了默认值为新的 <code>val</code>;</p>
</li>
<li><p>对于二维向量的内存分配也是类似的:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m;  <span class="comment">//二维码向量;</span></span><br><span class="line"> ...</span><br><span class="line"> m.<span class="built_in">resize</span>(r,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c,<span class="number">0</span>)); <span class="comment">//初始化为一个r行c列且初始值为0的矩阵.</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><ul>
<li>在<code>list</code>容器当中, 迭代器是双向迭代器;<ul>
<li>双向迭代器不支持大小的比较, 只支持 <code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>;<br>因此, 注意实际的使用:</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst1;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator iter1 = lst<span class="number">1.</span><span class="built_in">begin</span>();</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator iter2 = lst<span class="number">1.</span><span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="keyword">while</span> (iter1 != iter2) {</span><br><span class="line">    <span class="comment">// 处理当前元素</span></span><br><span class="line">    ++iter1;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误的比较</span></span><br><span class="line"><span class="comment">// while(iter1 &lt; iter2) </span></span><br><span class="line">    </span><br></pre></td></tr></table></figure></div>

<h3 id="有序链表"><a href="#有序链表" class="headerlink" title="有序链表"></a>有序链表</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    list&lt;string&gt; s;</span><br><span class="line">    string str;</span><br><span class="line">    list&lt;string&gt; :: iterator p;</span><br><span class="line">    <span class="type">int</span> count ;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"enter the number of the strings:"</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cin &gt;&gt; count; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++){</span><br><span class="line">        cout &lt;&lt; <span class="string">"enter a string:"</span> ;</span><br><span class="line">        cin &gt;&gt;str;</span><br><span class="line">        </span><br><span class="line">        p = s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span>(p != s.<span class="built_in">end</span>() &amp;&amp; *p &lt;str)</span><br><span class="line">            p++;</span><br><span class="line">        s.<span class="built_in">insert</span>(p,str);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(p = s.<span class="built_in">begin</span>(); p!=s.<span class="built_in">end</span>(); p++)</span><br><span class="line">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>分析:</strong></p>
<ul>
<li><code>while(p != s.end() &amp;&amp; *p &lt;str)</code> 每次输入<code>str</code>时, 令迭代器从<code>list</code>的开头开始, 进行字典序的比较;</li>
</ul>
<blockquote>
<p>[!important]</p>
<p>找到插入的位置, 利用<code>insert()</code>方法插入到给出迭代器的<strong>前面</strong>!.</p>
</blockquote>
<h2 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h2><p><code>deque</code>即 double-ended queue, <strong>双端队列</strong>.</p>
<p>支持:</p>
<ul>
<li>在两端快速的插入或删除;</li>
<li>随机访问;</li>
</ul>
<p><strong>语法</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 插入操作</span></span><br><span class="line">dq.<span class="built_in">push_back</span>(<span class="number">1</span>);    <span class="comment">// 在末尾插入</span></span><br><span class="line">dq.<span class="built_in">push_front</span>(<span class="number">2</span>);   <span class="comment">// 在开头插入</span></span><br><span class="line">dq.<span class="built_in">insert</span>(pos, val);<span class="comment">// 在指定位置插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 删除操作</span></span><br><span class="line">dq.<span class="built_in">pop_back</span>();      <span class="comment">// 删除末尾元素</span></span><br><span class="line">dq.<span class="built_in">pop_front</span>();     <span class="comment">// 删除首部元素</span></span><br><span class="line">dq.<span class="built_in">erase</span>(pos);      <span class="comment">// 删除指定位置元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 访问操作</span></span><br><span class="line">dq[<span class="number">0</span>];              <span class="comment">// 随机访问</span></span><br><span class="line">dq.<span class="built_in">at</span>(<span class="number">1</span>);           <span class="comment">// 带边界检查的访问</span></span><br><span class="line">dq.<span class="built_in">front</span>();         <span class="comment">// 访问第一个元素</span></span><br><span class="line">dq.<span class="built_in">back</span>();          <span class="comment">// 访问最后一个元素</span></span><br></pre></td></tr></table></figure></div>

<p><strong>示例:</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在两端插入元素</span></span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    dq.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">    dq.<span class="built_in">push_front</span>(<span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dq ：{8, 1, 3, 4}</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用随机访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; dq.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">        cout &lt;&lt; dq[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="Forward-list"><a href="#Forward-list" class="headerlink" title="Forward_list"></a>Forward_list</h3><p><code>forward_list</code>即 单项链表.</p>
<ul>
<li>只能向前遍历, 即对应的迭代器不支持<code>--</code>而支持<code>++</code>.</li>
<li>同时不支持下标访问以及随机访问.</li>
<li>单项链表的设计, 使得内部的每个节点只需要<strong>一个</strong>指针来指向下一个节点, 从而比<code>list</code>双向链表更加<strong>节省内存.</strong></li>
</ul>
<p><strong>语法</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line">forward_list&lt;<span class="type">int</span>&gt; fl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 插入操作</span></span><br><span class="line">fl.<span class="built_in">push_front</span>(<span class="number">1</span>);           <span class="comment">// 在开头插入</span></span><br><span class="line">fl.<span class="built_in">insert_after</span>(pos, val);  <span class="comment">// 在指定位置之后插入</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 删除操作</span></span><br><span class="line">fl.<span class="built_in">pop_front</span>();            <span class="comment">// 删除第一个元素</span></span><br><span class="line">fl.<span class="built_in">erase_after</span>(pos);       <span class="comment">// 删除指定位置之后的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 访问操作</span></span><br><span class="line">fl.<span class="built_in">front</span>();               <span class="comment">// 访问第一个元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 特殊操作</span></span><br><span class="line">fl.<span class="built_in">before_begin</span>();        <span class="comment">// 返回第一个元素之前的迭代器</span></span><br><span class="line">fl.<span class="built_in">begin</span>();               <span class="comment">// 返回第一个元素的迭代器</span></span><br></pre></td></tr></table></figure></div>

<p><strong>示例</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    forward_list&lt;<span class="type">int</span>&gt; fl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 插入元素</span></span><br><span class="line">    fl.<span class="built_in">push_front</span>(<span class="number">3</span>);</span><br><span class="line">    fl.<span class="built_in">push_front</span>(<span class="number">2</span>);</span><br><span class="line">    fl.<span class="built_in">push_front</span>(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在特定位置后插入</span></span><br><span class="line">    <span class="keyword">auto</span> it = fl.<span class="built_in">begin</span>(); <span class="comment">// 指向第一个元素</span></span><br><span class="line">    fl.<span class="built_in">insert_after</span>(it, <span class="number">4</span>); <span class="comment">// 在第一个元素后插入4</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历打印</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; val : fl) {</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 输出：1 4 2 3</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="访问前一个元素"><a href="#访问前一个元素" class="headerlink" title="访问前一个元素"></a>访问前一个元素</h4><p>由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合<code>before_begin()</code>方法.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果需要访问某个元素的前一个元素，必须从头开始遍历</span></span><br><span class="line"><span class="keyword">auto</span> prev = fl.<span class="built_in">before_begin</span>();</span><br><span class="line"><span class="keyword">auto</span> curr = fl.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(curr != fl.<span class="built_in">end</span>() &amp;&amp; *curr != target) {</span><br><span class="line">    ++prev;</span><br><span class="line">    ++curr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键<strong>自动排序</strong></p>
<ul>
<li>如果插入重复的key, 将会覆盖原有的value;</li>
<li>通过键查找元素、插入和删除的时间复杂度均为O(log n);</li>
<li><strong>使用场景</strong>: 字典、索引、统计等.</li>
</ul>
<p><strong>语法</strong>:</p>
<ul>
<li><p>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于<code>map</code>当中;</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = ages.<span class="built_in">find</span>(<span class="string">"Charlie"</span>);  <span class="comment">// 查找 "Charlie"</span></span><br><span class="line">  <span class="keyword">if</span> (it != ages.<span class="built_in">end</span>()) {         <span class="comment">// 如果找到了（即没有返回 end()）</span></span><br><span class="line">      ages.<span class="built_in">erase</span>(it);             <span class="comment">// 则删除找到的元素</span></span><br><span class="line">  }</span><br></pre></td></tr></table></figure></div></li>
<li><p>使用下标(键)直接插入,或者通过键值对插入</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ages[<span class="string">"Alice"</span>] = <span class="number">25</span>;</span><br><span class="line">ages.<span class="built_in">insert</span>({<span class="string">"Bob"</span>, <span class="number">30</span>});</span><br><span class="line">ages.<span class="built_in">emplace</span>(<span class="string">"Charlie"</span>, <span class="number">28</span>); <span class="comment">// 使用 emplace 插入 (更高效)</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><code>emplace</code>方法指<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于<code>insert</code>而言更加<strong>高效</strong>.</p>
</blockquote>
</li>
<li><p><code>.erase()</code>方法删除指定key的元素, 也可以通过<code>.find()</code>找到key对应的迭代器<code>it</code>, 然后<code>erase(it)</code>.</p>
  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ages.<span class="built_in">erase</span>(<span class="string">"Bob"</span>);           <span class="comment">// 删除键为 "Bob" 的元素</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> it = ages.<span class="built_in">find</span>(<span class="string">"Charlie"</span>);</span><br><span class="line"><span class="keyword">if</span> (it != ages.<span class="built_in">end</span>()) {</span><br><span class="line">    ages.<span class="built_in">erase</span>(it);         <span class="comment">// 删除迭代器指向的元素</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><code>ages.clear();</code> 将会清空整个map.</p>
</blockquote>
</li>
<li><p><code>map[key]</code>的形式访问, 使用<code>map.at(key)</code>的方式可以在key不存在时抛出异常;</p>
</li>
<li><p><code>.find(key)</code>查找对应键的元素( 返回<strong>迭代器</strong> ), <code>.count(key)</code>返回对应键的元素个数(0 or 1)</p>
</li>
<li><p><code>.size()</code>获取map的大小.</p>
</li>
<li><p>迭代器的<code>-&gt;first</code>和<code>-&gt;second</code>可以分别访问键和值.</p>
  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"Map elements:"</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> mapIt = ages.<span class="built_in">begin</span>(); mapIt != ages.<span class="built_in">end</span>(); ++mapIt) {</span><br><span class="line">   cout &lt;&lt; mapIt-&gt;first &lt;&lt; <span class="string">": "</span> &lt;&lt; mapIt-&gt;second &lt;&lt; endl; <span class="comment">// 访问键和值</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h2><p>迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.</p>
<ul>
<li><strong>标记位置</strong>: <code>.begin()</code>和<code>.end()</code> 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;</li>
</ul>
<p>迭代器的分类:</p>
<ul>
<li>输入迭代器: 支持读取和递增操作;<ul>
<li><code>istream_iterator</code>: 用于从输入流读取数据;</li>
</ul>
</li>
<li>输出迭代器: 支持写入和递增操作;<ul>
<li><code>ostream_iterator</code>: 用于向输出流写入数据;</li>
</ul>
</li>
<li>前向迭代器: 具有输入、输出迭代器的<strong>所有</strong>功能, 并且可以多次遍历同一个序列;<ul>
<li>比如<code>forwarf_list</code>的迭代器:<code>auto it = flist.begin()</code> or <code>forward_list&lt;int&gt;::iterator it = flist.begin()</code>;</li>
</ul>
</li>
<li>双向迭代器: 在前向迭代器的原有功能上, 同时支持<strong>递减</strong>操作;<ul>
<li>比如双向链表<code>list</code>的迭代器.<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; myList = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双向迭代器正向遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Forward traversal: "</span>;</span><br><span class="line">    <span class="keyword">for</span> ( list&lt;<span class="type">int</span>&gt;::iterator it = myList.<span class="built_in">begin</span>(); it != myList.<span class="built_in">end</span>(); ++it) {</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt;  endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用双向迭代器逆向遍历</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"Reverse traversal: "</span>;</span><br><span class="line">    <span class="keyword">for</span> ( list&lt;<span class="type">int</span>&gt;::reverse_iterator rit = myList.<span class="built_in">rbegin</span>(); rit != myList.<span class="built_in">rend</span>(); ++rit) {</span><br><span class="line">        cout &lt;&lt; *rit &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    cout &lt;&lt;  endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Forward traversal: 10 20 30 40 50 </span></span><br><span class="line">    <span class="comment">// Reverse traversal: 50 40 30 20 10 </span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<blockquote>
<ol>
<li><code>reverse_iterator</code>用于声明逆向遍历的迭代器, 也可以使用<code>auto</code>直接声明.</li>
<li><code>rbegin()</code>和<code>rend()</code>分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的<code>++</code>相当于正向遍历时的<code>--</code>操作.</li>
</ol>
</blockquote>
</li>
</ul>
</li>
<li>随机访问迭代器: 具有双向迭代器的所有功能, 同时支持<strong>随机访问</strong>, 如<code>it+n</code>,<code>it[n]</code>.<ul>
<li>比如<code>vector</code>的迭代器.</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>};</span><br><span class="line">cout &lt;&lt; <span class="string">"Vector elements (random access): "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) {</span><br><span class="line">    cout &lt;&lt; vec[i] &lt;&lt; <span class="string">" "</span>; <span class="comment">// 使用下标随机访问</span></span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>另外, 还有一种迭代器称为<strong>插入迭代器</strong>, 比如<code>back_inserter</code></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>};</span><br><span class="line"></span><br><span class="line"><span class="comment">//结合copy将容器的元素直接插入到另一个容器中</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; dest = {<span class="number">60</span>,<span class="number">70</span>};</span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(dest)); <span class="comment">// 在 dest 末尾插入元素</span></span><br><span class="line">cout &lt;&lt; <span class="string">"Copied vector: "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : dest) {</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// Copied vector: 60 70 10 20 30 40 50 </span></span><br></pre></td></tr></table></figure></div>

<h2 id="for-each"><a href="#for-each" class="headerlink" title="for-each"></a>for-each</h2><p>for-each 循环的语法：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (range_declaration : range_expression) {</span><br><span class="line">    loop_statement;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<ul>
<li>range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 <code>auto </code>关键字让编译器自动推导类型;</li>
<li>range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或<strong>字符串</strong>;</li>
<li>loop_statement： 循环体，包含要对每个元素执行的语句.</li>
</ul>
<p>e.g:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 for-each 循环遍历 vector</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) {</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出每个元素</span></span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 auto 关键字自动推导类型</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : numbers) {</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改容器中的元素（需要使用引用）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> &amp;num : numbers) {</span><br><span class="line">        num *= <span class="number">2</span>; <span class="comment">// 将每个元素乘以 2</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出修改后的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : numbers) {</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>for (int &amp;num : numbers)</code>：使用引用 &amp;，可以直接修改容器中的元素.</li>
</ul>
<h3 id="Map的循环"><a href="#Map的循环" class="headerlink" title="Map的循环"></a>Map的循环</h3><p>当range_expression是<code>map</code>时, 可以使用<code>auto</code>自动推导range_declaration的类型.需要注意是:</p>
<ul>
<li>用迭代器的方式访问<code>map</code>中的键值对的形式是 <code>it-&gt;first</code>与<code>it-&gt;second</code>;</li>
<li>在<code>for-each</code>循环当中, range_declaration是一个值, 因此使用<code>.first</code>与<code>.second</code>来访问键和值.  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    map&lt;string, string&gt; m = {{<span class="string">"one"</span>, <span class="string">"1"</span>}, {<span class="string">"two"</span>, <span class="string">"2"</span>}, {<span class="string">"three"</span>, <span class="string">"3"</span>}};</span><br><span class="line">    vector&lt;string&gt; vec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; entry : m){</span><br><span class="line">        vec.<span class="built_in">push_back</span>(entry.first + <span class="string">":"</span> + entry.second );</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;string&gt;(cout, <span class="string">" "</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
  <strong>Output:</strong>  <div class="code-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">one:1 three:3 two:2</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>此处由于<code>map</code>自动按照键的字典序进行排序, 因此输出时<code>three</code>的元素在<code>two</code>前;</p>
</blockquote>
</li>
</ul>
<p>在上述的示例中, 也可以使用下面的方式进行<code>vec</code>的输出:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; s : vec) {</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<p>此时<code>auto</code>会自动推导为<code>string</code>类型, 且<code>&amp;</code>对数组的元素进行了引用, 使得输出更加高效.</p>
<h3 id="Pro-Con"><a href="#Pro-Con" class="headerlink" title="Pro&Con"></a>Pro&amp;Con</h3><p><code>for-each</code>循环的优点:</p>
<ul>
<li>消除了访问数组等越界的风险;</li>
<li>不需要事先初始化迭代器;</li>
</ul>
<p><code>for-each</code>循环的缺点:</p>
<ul>
<li>无法获取元素的索引;</li>
<li>只能顺序地遍历.</li>
</ul>
<h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h2><p>我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.</p>
<p>而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> old_type new_type;</span><br></pre></td></tr></table></figure></div>

<h2 id="Notices"><a href="#Notices" class="headerlink" title="Notices"></a>Notices</h2><ol>
<li><p>直接对数组、字符串和<code>vector</code>进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;</p>
</li>
<li><p>对于<code>vector</code>, 可以通过<code>.at() = </code>的方式进行安全访问, 编译器会进行边界检查. 或者通过<code>.push_back()</code> or <code>.emplace_back</code>的方式在末尾赋值. 同时注意用<code>.reserve()</code>预先分配充分的内存空间.</p>
</li>
<li><p>避免不经意地向<code>map</code>当中插入元素:</p>
<ol>
<li>错误的示范:</li>
</ol>
 <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(foo[<span class="string">"bob"</span>] == <span class="number">1</span>){...}</span><br><span class="line"><span class="comment">// 设置默认的零值</span></span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>使用<code>.count()</code>方法正确检查元素是否存在:</li>
</ol>
 <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( foo.<span class="built_in">count</span>(<span class="string">"bob"</span>) ){...}</span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li>也可以使用<code>find()</code>方法检查元素是否存在:</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = m.<span class="built_in">find</span>(<span class="string">"four"</span>);</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(it  != m.<span class="built_in">end</span>()){</span><br><span class="line">    cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Not found"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
<li><p>使用<code>.empty()</code>方法来检查容器<strong>整体是否为空</strong>, 而非<code>.count() == 0</code>的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.</p>
</li>
<li><p><code>erase()</code> 方法会返回<strong>指向</strong>被删除元素的<strong>下一个</strong>元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:</p>
 <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initialize a list</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator li = L.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wrong:</span></span><br><span class="line">L.<span class="built_in">erase</span>(li);    <span class="comment">// 删除元素后，li 变成了无效迭代器</span></span><br><span class="line">++li;           <span class="comment">// 错误, 不能对无效迭代器进行操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Correct:</span></span><br><span class="line">li = L.<span class="built_in">erase</span>(li);  <span class="comment">// 删除元素后，li 被更新为指向被删除元素的下一个元素</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><ul>
<li>Pointers to Objects</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">"hello"</span>;</span><br><span class="line">string *p = &amp;str;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>Oprators with Pointers<ul>
<li><code>&amp;</code>: 取地址;</li>
<li><code>*</code>: 解引用;</li>
<li><code>-&gt;</code>: 用于访问对象的成员.</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*p).<span class="built_in">length</span>();</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line">p-&gt;<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure></div>
<blockquote>
<p><code>length()</code>即为<code>string</code>类的成员函数, 因此可以用<code>-&gt;</code>来访问.</p>
</blockquote>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="指针-1"><a href="#指针-1" class="headerlink" title="指针"></a>指针</h2><blockquote>
<p>以<code>char</code>为例.</p>
</blockquote>
<ul>
<li>指向常量的指针 <code>const char *p</code><ul>
<li>可以改变指针的地址.</li>
<li>无法通过指针改变对象的值</li>
</ul>
</li>
<li>常量指针 <code>char * const p</code><ul>
<li>指针指向的地址无法改变;</li>
<li>但是可以通过指针改变对象的值<br>如果需要同时保证地址和值都无法改变, 则需要使用<code>const char * const p</code>.</li>
</ul>
</li>
</ul>
<p>如果<code>sp</code>是指向字符串的指针, 那么这两种的写法是等价的, 注意<code>.</code>的优先级高于<code>*</code>, 因此括号不可忽略.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sp-&gt;<span class="built_in">length</span>();</span><br><span class="line">(*sp).<span class="built_in">length</span>();</span><br></pre></td></tr></table></figure></div>



<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><h3 id=""><a href="#" class="headerlink" title="::"></a><code>::</code></h3><p><code>::</code> resolver: 作用域解析运算符</p>
<ul>
<li><p>作用: </p>
<ul>
<li><p>访问全局的作用域<br>当局部变量和全局变量同名时, 可以使用 <code>::</code> 来访问全局变量</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> value = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    cout &lt;&lt; value;    <span class="comment">// 输出 20（局部变量）</span></span><br><span class="line">    cout &lt;&lt; ::value;  <span class="comment">// 输出 10（全局变量）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>访问命名空间中的成员</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Math {</span><br><span class="line">    <span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> circumference = <span class="number">2</span> * Math::PI * radius; <span class="comment">// 使用命名空间中的常量</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p>语法:</p>
<ul>
<li><code>&lt;class_name&gt; :: &lt;function_name&gt;</code></li>
<li><code>::&lt;function_name&gt;</code>  全局作用域</li>
</ul>
</li>
</ul>
<p>e.g. </p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">S::f</span><span class="params">()</span> </span>{</span><br><span class="line">    ::<span class="built_in">f</span>();  <span class="comment">// Would be recursive otherwise!</span></span><br><span class="line">    ::a++;  <span class="comment">// Select the global a</span></span><br><span class="line">    a--;    <span class="comment">// The a at class scope</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>S::f()</code>: 定义了属于类S的成员函数f;</p>
<p><code>::f()</code>:表示调用全局作用域中的函数 <code>f()</code>, 默认为递归调用当前的成员函数;</p>
<p><code>::a++</code>表示将全局作用域的 <code>a</code> 自增, <code>a--</code>则访问并递减类作用域中的成员变量 <code>a</code>.</p>
</blockquote>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a><code>this</code></h3><p><code>this</code>指针是成员函数的隐藏参数. 指向<strong>当前对象的实例</strong>.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::move</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span></span>;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Point::move</span><span class="params">(Point *<span class="keyword">this</span>, <span class="type">int</span> dx, <span class="type">int</span> dy)</span></span>;</span><br></pre></td></tr></table></figure></div>

<p>当调用成员函数时, 对象的地址会自动作为 <code>this</code>参数传递.</p>
<p>在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 <code>this</code>:</p>
<p>e.g</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 移动点的位置</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> </span>{</span><br><span class="line">        x += dx;</span><br><span class="line">        y += dy;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印点的坐标</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Point at ("</span> &lt;&lt; x &lt;&lt; <span class="string">", "</span> &lt;&lt; y &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 组合以上两个功能的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">move_and_print</span><span class="params">(<span class="type">int</span> dx, <span class="type">int</span> dy)</span> </span>{</span><br><span class="line">        <span class="built_in">move</span>(dx, dy);  <span class="comment">// 等同于 this-&gt;move(dx, dy)</span></span><br><span class="line">        <span class="built_in">print</span>();       <span class="comment">// 等同于 this-&gt;print()</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>但是也可以显式指定 <code>this-&gt;move</code>, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.</p>
</blockquote>
<h3 id="封装特性"><a href="#封装特性" class="headerlink" title="封装特性"></a>封装特性</h3><p>在OOP中, Object = Attributes + Services, 即数据和操作被<strong>封装</strong>在一起, 构成一个完整的对象.</p>
<h3 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h3><p>我们应当在头文件中声明对象的成员及其 <code>public</code>,<code>private</code>和 <code>protected</code>等属性, 并且在 <code>cpp</code>文件中给出具体的定义:</p>
<blockquote>
<p>最好为每个类都建立如此对应的头文件和源文件 <code>cpp</code>.</p>
</blockquote>
<p>e.g. </p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.h - 类的声明</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> STUDENT_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STUDENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">// 在头文件中使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 数据成员</span></span><br><span class="line">    string name;     </span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">float</span> gpa;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数原型</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> string&amp; name, <span class="type">int</span> id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 成员函数原型</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(<span class="type">const</span> string&amp; newName)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">calculateGPA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isEligibleForScholarship</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// STUDENT_H</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.cpp - 成员函数的定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"Student.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  <span class="comment">// 在源文件中使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数实现</span></span><br><span class="line">Student::<span class="built_in">Student</span>(<span class="type">const</span> string&amp; name, <span class="type">int</span> id) {</span><br><span class="line">    <span class="keyword">this</span>-&gt;name = name;</span><br><span class="line">    <span class="keyword">this</span>-&gt;id = id;</span><br><span class="line">    <span class="keyword">this</span>-&gt;gpa = <span class="number">0.0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::setName</span><span class="params">(<span class="type">const</span> string&amp; newName)</span> </span>{</span><br><span class="line">    name = newName;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">Student::getName</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Student::calculateGPA</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 实现GPA计算逻辑</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Student::isEligibleForScholarship</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> gpa &gt;= <span class="number">3.5</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>Student::getName()</code>指的就是类 <code>Student</code>中的成员函数 <code>getName()</code>.</p>
</blockquote>
<p>具体来说, <code>.h</code>头文件当中应该有:</p>
<ul>
<li><p>外部变量的声明<br>e.g. <code>extern int globalCounter;  // 仅声明，不定义</code></p>
</li>
<li><p>函数原型<br>e.g. <code>int calculateSum(int a, int b);  // 函数声明，不包含实现</code></p>
</li>
<li><p>类/结构体的声明<br>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>;  <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 或完整类声明（不含成员函数定义）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> width;</span><br><span class="line">    <span class="type">double</span> height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> w, <span class="type">double</span> h);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>回顾 <code>#include</code>: 将被引用的文件插入 <code>.cpp</code> 文件当中</p>
<ul>
<li><p><code>#include "xx.h"</code>: 首先在当前目录下寻找;</p>
</li>
<li><p><code>#include &lt;xx.h&gt;</code>: 直接在指定的目录中寻找</p>
<blockquote>
<p>等价于 <code>#include &lt;xx&gt;</code>.</p>
</blockquote>
</li>
</ul>
<p>为了避免在多个 <code>.cpp</code> 文件中重复引用相同的头文件, 可以通过 <code>#ifndef</code>等标记来判断是否需要引用当前的头文件:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEADER_FLAG</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HEADER_FLAG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<p><code>HEADER_FLAG</code>一般使用完全大写来方便标识, 但是也可以大小写混合.</p>
</blockquote>
<p>e.g. </p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: vector.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> VECTOR_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VECTOR_H</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// VECTOR_H</span></span></span><br></pre></td></tr></table></figure></div>

<h2 id="生命周期管理"><a href="#生命周期管理" class="headerlink" title="生命周期管理"></a>生命周期管理</h2><p>当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.</p>
<p>为了确保这些工作不被遗忘, <code>cpp</code>的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.</p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.</p>
<ul>
<li>语法:</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">ClassName</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">ClassName</span>(参数列表);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">ClassName</span>(<span class="type">const</span> ClassName&amp; other);</span><br><span class="line">    </span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ol>
<li><strong>默认构造函数</strong>：不带参数或所有参数都有默认值;</li>
<li><strong>带参数的构造函数</strong>：接受一个或多个参数;</li>
<li><strong>拷贝构造函数</strong>：从同类型的另一个对象创建新对象.</li>
</ol>
</blockquote>
<ul>
<li><p>构造函数初始化列表</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Point::<span class="built_in">Point</span>(<span class="type">int</span> xx, <span class="type">int</span> yy) :<span class="built_in">x</span>(xx), <span class="built_in">y</span>(yy) {</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>构造函数时, 传递参数并直接赋值给内部的成员变量 <code>x</code> , <code>y</code>.</p>
</blockquote>
</li>
<li><p>结构体中的构造函数:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Y</span> { </span><br><span class="line">    <span class="type">float</span> f;     <span class="comment">// 浮点型成员变量</span></span><br><span class="line">    <span class="type">int</span> i;       <span class="comment">// 整型成员变量</span></span><br><span class="line">    <span class="built_in">Y</span>(<span class="type">int</span> a);    <span class="comment">// 声明了一个接受int参数的构造函数</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ol>
<li>此处只是声明了构造函数需要 <code>int a</code>作为参数, 但是没有给出具体的实现;</li>
<li>声明结构体对象(数组)  e.g. <code>Y y1[] = { Y(1), Y(2), Y(3) };</code></li>
</ol>
</blockquote>
</li>
</ul>
<h3 id="默认构造"><a href="#默认构造" class="headerlink" title="默认构造"></a>默认构造</h3><p><code>auto</code> default constructor: (自动) 默认构造函数. <strong>当且仅当</strong>不存在任何构造函数时, 程序会自动生成默认构造函数, 不作任何的操作.</p>
<p><code>默认构造函数</code>： 在没有参数的情况下可以调用的构造函数， 称为默认构造函数. 其来源除了上述的程序构造以外, 还包括:</p>
<ol>
<li>显示定义的无参构造函数;</li>
<li>定义的所有参数都具有默认值的构造函数.</li>
</ol>
<ul>
<li>对于成员变量: 不进行初始化;</li>
</ul>
<h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 <code>~</code>. 当对象超出作用域或被显式删除时，析构函数会自动被调用.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassName</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">ClassName</span>();</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<ul>
<li>类似于栈, 优先创建的后析构.</li>
</ul>
<p>运用的示例:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>() : <span class="built_in">data</span>(<span class="literal">nullptr</span>) {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"默认构造函数调用"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str) {</span><br><span class="line">        <span class="keyword">if</span> (str) {</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"参数构造函数调用"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) {</span><br><span class="line">        <span class="keyword">if</span> (other.data) {</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">        }</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"拷贝构造函数调用"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() {</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"析构函数调用"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印字符串</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; (data ? data : <span class="string">"空字符串"</span>) &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 测试各种构造函数</span></span><br><span class="line">    MyString s1;                  <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;         <span class="comment">// 带参数的构造函数</span></span><br><span class="line">    MyString s3 = s2;             <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    </span><br><span class="line">    s<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line">    s<span class="number">2.</span><span class="built_in">print</span>();</span><br><span class="line">    s<span class="number">3.</span><span class="built_in">print</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 所有对象在这里被销毁，调用析构函数</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<p>本地对象: </p>
<p><code>Field</code>(字段)指的是在类中定义的变量(成员变量):</p>
<ul>
<li>可以直接被类中的所有方法访问;</li>
<li>生命周期<strong>和类的对象保持一致;</strong></li>
</ul>
<p>其他类型数据的生命周期:</p>
<ul>
<li><strong>参数</strong>: 函数执行期间;</li>
<li><strong>局部变量</strong>: 声明的代码块内部.</li>
</ul>
<hr>
<p>全局对象:</p>
<blockquote>
<p>[!NOTE]</p>
<p>如果在类或对象的方法内部定义了一个和成员变量同名的变量, 那么将默认访问这个变量, 只有用 <code>this-&gt;xxx</code>才能显式访问成员变量. e.g. <code>int MyClass::count </code>.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>; <span class="comment">// 字段</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="type">int</span> value = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Local value: "</span> &lt;&lt; value &lt;&lt; std::endl; <span class="comment">// 输出局部变量</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Field value: "</span> &lt;&lt; <span class="keyword">this</span>-&gt;value &lt;&lt; std::endl;<span class="comment">//使用this指针访问字段</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></blockquote>
<h2 id="Access-Control"><a href="#Access-Control" class="headerlink" title="Access Control"></a>Access Control</h2><p><code>class</code>的默认为 <code>private</code>, 而 <code>struct</code>的默认权限是 <code>public</code>.</p>
<p>访问限制符:</p>
<h3 id="friend"><a href="#friend" class="headerlink" title="friend"></a><code>friend</code></h3><p>在 <code>class</code>内部声明友元, 可以使得对应的函数访问自身的成员变量(包括私有和受保护, 也即是所有的变量).</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">X</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">g</span><span class="params">(X*, <span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">Y::y</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>[!NOTE]</p>
<p><strong>友元关系不具有传递性 !</strong></p>
</blockquote>
<h3 id="protected"><a href="#protected" class="headerlink" title="protected"></a><code>protected</code></h3><p>该声明内的成员可以被以下的范围访问:</p>
<ol>
<li>该类自身的成员函数;</li>
<li><strong>该类的派生类的成员函数;</strong></li>
</ol>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> val) : <span class="built_in">protectedVar</span>(val) {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> val) : <span class="built_in">Base</span>(val) {}</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessProtectedVar</span><span class="params">()</span> </span>{</span><br><span class="line">        protectedVar = <span class="number">10</span>; <span class="comment">// 派生类可以访问 protectedVar</span></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getProtectedVar</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> protectedVar;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>此处的 <code>base</code>就是一个基类, <code>class Derived : public Base</code>表明 Derived 是 base的一个派生类.</p>
<p>因此,  派生类可以通过自己的成员函数, 访问基类的 <code>protected</code>内的成员变量.</p>
</blockquote>
<h2 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h2><p>对于本地变量和全局变量的作用不同, 前者是生命周期, 后者是访问空间.</p>
<p>静态的对象的生命周期是全局, 但是不会跟全局变量一样(一开始就创建), 而是在第一次调用的时候才构造, 且只构造一次.</p>
<ul>
<li><p><code>静态成员变量</code>由所有的实例<strong>共享</strong>, 初始化的时候不能再添加 <code>static</code>标签(否则无法被外文件访问), 必须在类的外部进行初始化, 且需要声明所属于的类;</p>
<blockquote>
<p>但是也可以被普通的成员函数所访问.</p>
</blockquote>
</li>
<li><p><code>静态成员函数</code>属于类本身, 因此可以通过类名直接调用, 但是只能访问类的静态成员变量, 因为不存在属于实例的<code>this</code>指针. 静态成员函数可以在<strong>类的内部</strong>就定义, 如果在类的外部定义, 也不需要额外的<code>static</code>标签;</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态成员变量</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> i) : <span class="built_in">id</span>(i) {</span><br><span class="line">        count++; <span class="comment">// 每次创建对象，count加1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() {</span><br><span class="line">        count--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getCount</span><span class="params">()</span> </span>{ <span class="comment">// 静态成员函数</span></span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::count = <span class="number">0</span>; <span class="comment">// 静态成员变量的初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Count: "</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; std::endl; <span class="comment">// 通过类名调用静态成员函数</span></span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Count: "</span> &lt;&lt; MyClass::<span class="built_in">getCount</span>() &lt;&lt; std::endl; <span class="comment">// 通过类名调用静态成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>Output:</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Count: <span class="number">0</span></span><br><span class="line">Count: <span class="number">2</span></span><br></pre></td></tr></table></figure></div>


</li>
<li><p>函数内部的静态变量只会在调用的时候<strong>初始化一次</strong>, 直到程序结束.<br>e.g. 计数函数的调用次数:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>{</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span> num_calls = <span class="number">0</span>;</span><br><span class="line">  ...</span><br><span class="line">  num_calls += <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>extern</code>关键字用于声明变量或函数在其他文件中定义. 告诉编译器从而允许跨文件的访问.</p>
<blockquote>
<p>但是这种跨文件访问只能作用于<strong>非静态</strong>的全局变量, i.e. 全局变量加上<code>static</code>声明之后, 将其作用域限制在了当前文件的内部.</p>
</blockquote>
</li>
<li><p>函数内部的静态对象, 其构造函数只会在定义的时候调用一次. 并且析构函数当退出程序时调用. 即使采取条件构造, 也只会在第一次条件满足的时候构造.</p>
</li>
<li><p>静态成员的使用:</p>
<ul>
<li><p>通过类名: <code>&lt;class_name&gt;::&lt;static member</code></p>
</li>
<li><p>通过实例名: <code>&lt;ob variable&gt;.&lt;static member&gt;</code></p>
<blockquote>
<p>让人误以为是类的对象变量, 不建议这样使用.</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>引用（Reference）是一个非常重要的特性。它的引入是为了解决一些特定场景下的问题：</p>
<ul>
<li><strong><u>避免不必要的拷贝</u></strong>：在某些情况下，传递大型对象或结构体给函数时，如果直接传递拷贝会导致性能下降。引用允许我们传递对象的别名，而不需要拷贝整个对象。</li>
<li><strong><u>简化代码</u></strong>：引用可以使代码更简洁，特别是在函数返回值和参数传递时。例如，通过引用返回一个对象可以避免构造临时对象。</li>
<li><strong><u>指针的安全替代</u></strong>：引用提供了指针的功能，但避免了指针容易导致的错误，如空指针解引用或野指针。</li>
</ul>
<p><strong>基本语法</strong>: </p>
<p>引用是一个变量的别名，它在<strong>声明时必须被初始化</strong>，并且一旦初始化后就**<u>不能再指向其他</u>**对象.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; ref = a;  <span class="comment">// ref 是 a 的引用</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>int&amp;</code> 表示引用类型，<code>ref</code> 是 <code>a</code> 的引用。</li>
<li>引用必须在声明时初始化，并且不能重新引用到另一个对象。</li>
<li>无法对引用进行引用;</li>
<li><strong>不允许</strong>存在 <strong>以引用为元素的数组</strong></li>
</ul>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; ref = a;  <span class="comment">// ref 是 a 的引用</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Original value of a: "</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value of ref: "</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    ref = <span class="number">20</span>;  <span class="comment">// 修改引用会影响原变量</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"After modifying ref, value of a: "</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Value of ref: "</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中：</p>
<ul>
<li><code>ref</code> 是 <code>a</code> 的引用，修改 <code>ref</code> 的值会影响 <code>a</code> 的值。</li>
<li>通过引用，我们可以访问和修改原始变量 <code>a</code> 的值，而不需要直接操作 <code>a</code>。</li>
</ul>
<p>引用可以作为函数的形参, 此时<strong>函数内部的形参作为实参的引用可以改变实参的值</strong>.</p>
<p>引用的绑定必须是一个具有明确地址的左值 ,而不能是临时产生的右值:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="built_in">func</span> (i * <span class="number">3</span>); <span class="comment">// Warning or error!</span></span><br></pre></td></tr></table></figure></div>



<h4 id="指针与引用"><a href="#指针与引用" class="headerlink" title="指针与引用"></a>指针与引用</h4><ul>
<li><p>限制:</p>
<ul>
<li><p>无法获得指针的引用;</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> &amp;*p;<span class="comment">// illegal</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p>但是可以获得<strong>指向引用的指针</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> *&amp;p)</span></span>;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<p> 可以如此理解, 引用实际上是对象的别名. 用于修改对象的值. 但是为了修改指针, 可以直接使用指针的指针 <code>**</code>.</p>
<p>此外, 引用并非独立的对象, 而是直接 <strong>绑定</strong>. 因此 <code>int&amp; ref = a;</code>  <code>&amp;ref</code>就是 a的地址.</p>
<h4 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h4><p>左值是指具有明确地址的变量或者引用, 右值是计算过程中的中间结果或者字面量 (e.g.<code>10</code>).等不可寻址的值;</p>
<blockquote>
<p>涉及到计算的基本都是右值, 但是这四种的计算结果依旧是左值: <code>*</code>,<code>.</code>,<code>[]</code>和 <code>-&gt;</code>.</p>
</blockquote>
<p>右值一般在计算结束后就消失了, 如果我们希望延长其生命周期, 就可以使用 <strong>右值引用</strong>.</p>
<ul>
<li><p><strong>格式</strong>: <code>&lt;tyep&gt; &amp;&amp; &lt;ref_name&gt; = &lt;right_value&gt;</code></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">20</span>; <span class="comment">// left-value </span></span><br><span class="line"><span class="type">int</span>&amp;&amp; rx = x * <span class="number">2</span>:</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>TIps:</p>
<ul>
<li>右值引用在初始化之后就可以正常赋值;</li>
<li>右值引用无法使用左值进行赋值.</li>
</ul>
</li>
</ul>
<h4 id="引用参数与函数重载"><a href="#引用参数与函数重载" class="headerlink" title="引用参数与函数重载"></a>引用参数与函数重载</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp; lref)</span></span>{</span><br><span class="line">   cout &lt;&lt; <span class="string">"lref = "</span> &lt;&lt; lref &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span>&amp;&amp; rref)</span></span>{</span><br><span class="line">   cout &lt;&lt; <span class="string">"rref = "</span> &lt;&lt; rref &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">   <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">   <span class="built_in">fun</span>(x);</span><br><span class="line">   <span class="built_in">fun</span>(<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>Output</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lref = <span class="number">10</span></span><br><span class="line">rref = <span class="number">10</span></span><br></pre></td></tr></table></figure></div>

<blockquote>
<ol>
<li>字面量<code>10</code>作为右值, 可以通过右值引用作为函数的参数;</li>
<li>具有明确地址的变量 <code>x</code>是左值;</li>
<li>C++ 允许在同一个作用域内声明多个具有相同名称但参数列表不同的函数。这被称为<strong>函数重载</strong>。编译器通过检查函数调用时提供的参数类型和数量来决定调用哪个重载函数。</li>
</ol>
</blockquote>
<p>另外, 加上<code>const</code>之后, <code>&amp; </code>的形参也可以接受右值作为实参, 比如: <code>void fun (const int&amp; clref) {...}</code></p>
<blockquote>
<p>但是如果已经存在右值实参作为形参的同名函数, 将会优先选择后者进行重载.</p>
</blockquote>
<p>这是因为普通引用对于右值的修改 make no sense, 而 <code>const</code> 引用<u>保证不会修改引用的对象</u>，因此即使是临时对象（右值）也可以安全地绑定到 <code>const</code> 引用.</p>
<h2 id="Constants"><a href="#Constants" class="headerlink" title="Constants"></a>Constants</h2><p>使用 <code>const</code>声明常量, 常量的值不可修改.</p>
<p><code>const</code>声明集合的时候, 其中的值在<strong>编译期间不可知</strong>, 因此<u>无法在代码中, 使用常量集合内部的值进行操作.</u></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i[] = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="type">float</span> f[i[<span class="number">2</span>]]; <span class="comment">// Illegal!</span></span><br></pre></td></tr></table></figure></div>



<p>使用<code>const</code>对指针类型进行操作的时候:</p>
<ol>
<li>忽略类似于 <code>char</code>之类的类型, 只关注 <code>const</code>与 <code>*</code>之间的位置关系;</li>
<li>如果是 <code>const *p</code> 意思是指针指向的内容不可通过这个指针进行更改;</li>
<li>如果是 <code>* const p</code>意思是指针指向的对象不可更改, 但是可以通过 <code>*p</code> 的方式改写对象的值</li>
</ol>
<hr>
<p>关于字符指针与字符数组:</p>
<ul>
<li><code>char  *p = "hello";</code> 实际上是 <code>const char *p</code>, 也就是说不允许修改 <code>*p</code>;</li>
<li>而 <code>char p[] = 'hello';</code> 则可以通过<code>*p</code> 修改.</li>
</ul>
<hr>
<p>如果<strong>成员函数</strong>的<u>名称后</u>加了 <code>const</code>标记, 意味着:</p>
<ol>
<li>无法通过该成员函数改变成员变量的值.</li>
<li>同时无法调用其他 <strong>非const</strong>的成员函数</li>
<li>实际上, 将其的 <code>this</code>指针转换为 <code>const A* this</code>, 也就是指向常量的指针</li>
</ol>
<blockquote>
<p>因此 <code>const</code>修饰的成员函数具有 <code>this</code>指针(可访问), 不要与 <code>static</code>修饰的静态成员函数混淆! 后者不具有 <code>this</code>指针.</p>
<p>注意不要与 <code>const  type f()</code>混淆, 这是限制返回的结果无法修改; 而 <code>type f() const</code>限制成员函数本身的操作.</p>
</blockquote>
<p><strong>重载</strong>: 允许根据成员函数是否被 <code>const</code>限制, 以及对象本身是否为 <code>const</code>来重载成员函数.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> <span class="type">const</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"const version"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"non-const version"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    A a;</span><br><span class="line">    <span class="type">const</span> A ca;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">f</span>();    <span class="comment">// 输出: non-const version</span></span><br><span class="line">    ca.<span class="built_in">f</span>();   <span class="comment">// 输出: const version</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<p>如果成员变量是 <code>const</code>, 那么:</p>
<ul>
<li><p><strong>必须在对象构造时进行初始化</strong> (无法在构造函数中进行直接赋值):</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> value) : <span class="built_in">i</span>(value) {} <span class="comment">// 在初始化列表中初始化</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>如果在实例化对象的时候,  声明了这个实例是 <code>const</code>, 那么就无法调用成员函数中没有在后面声明 <code>const</code>的部分.( 即使实际上并没有修改的函数, 也不能通过编译).  —— 只能调用那些被标记为<code>const</code>的成员函数。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>{</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">get_value</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">int</span> get_const_value <span class="title">const</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> A <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">a.get_value; <span class="comment">// ERROR, const对象无法调用非const声明的成员函数</span></span><br><span class="line">a.get_const_value; <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></div>



<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250318120332036.png?imageSlim" alt="image-20250318120332036"></p>
<blockquote>
<p>无法用普通的指针来指向 <code>const</code>常量.</p>
<p>但是可以用指向常量的指针 来指向非常量的对象.</p>
</blockquote>
<hr>
<p>全局变量的构造在 <code>main()</code>之前. 静态本地变量在第一次执行到的时候才发生构造, 且只构造一次.</p>
<hr>
<h2 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h2><p>在 C++ 中，使用 <code>new</code> 关键字分配的空间位于 <strong>堆</strong> 上，与栈上的自动变量不同，堆上的内存不会自动释放，需要手动使用 <code>delete</code> 来析构以避免内存泄漏。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// 使用 new 在堆上分配一个整数</span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"值: "</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 delete 释放内存</span></span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针置空，避免野指针</span></span><br><span class="line">    ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>每次 <code>new</code> 分配的内存都需要对应的 <code>delete</code>。</li>
<li>对于数组，使用 <code>new[]</code> 分配，释放时用 <code>delete[]</code>：</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>];  <span class="comment">// 分配数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;           <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure></div>

<hr>
<h2 id="Inline-Class"><a href="#Inline-Class" class="headerlink" title="Inline Class"></a>Inline Class</h2><h3 id="Delegating-Constructor"><a href="#Delegating-Constructor" class="headerlink" title="Delegating Constructor"></a>Delegating Constructor</h3><p>委托构造函数（Delegating Constructor）是通过一个构造函数调用另一个构造函数来完成初始化的机制, 也就是在初始化列表中调用其他.</p>
<p>相对于委托构造的构造函数, 被称为 <em>target constructor</em> 目标构造函数.</p>
<p>目标构造函数的执行先于委托构造函数.</p>
<hr>
<h4 id="什么是委托构造函数？"><a href="#什么是委托构造函数？" class="headerlink" title="什么是委托构造函数？"></a>什么是委托构造函数？</h4><ul>
<li><strong>定义</strong>: 一个构造函数可以在其初始化列表中调用同一个类的另一个构造函数来完成部分或全部初始化工作。</li>
<li><strong>目的</strong>: 避免在多个构造函数中重复编写相同的初始化逻辑，解决代码重复的问题。</li>
<li><strong>限制</strong>: 委托构造函数<u>本身不能在初始化列表中再初始化其他成员变量</u>，只能依赖被调用的构造函数。</li>
</ul>
<h4 id="代码示例与分析"><a href="#代码示例与分析" class="headerlink" title="代码示例与分析"></a>代码示例与分析</h4><p>考虑将下面的冗余代码通过委托构造函数简化:</p>
<p><img lazyload="" src="/images/loading.svg" data-src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250325120013059.png?imageSlim"></p>
<p>实现: </p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ClassC</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> max;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> middle;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基础构造函数</span></span><br><span class="line">    <span class="built_in">ClassC</span>(<span class="type">int</span> my_max) {</span><br><span class="line">        max = (my_max &gt; <span class="number">0</span>) ? my_max : <span class="number">10</span>;  <span class="comment">// 默认值10</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托给基础构造函数</span></span><br><span class="line">    <span class="built_in">ClassC</span>(<span class="type">int</span> my_max, <span class="type">int</span> my_min) : <span class="built_in">ClassC</span>(my_max) {</span><br><span class="line">        min = (my_min &gt; <span class="number">0</span> &amp;&amp; my_min &lt; max) ? my_min : <span class="number">1</span>;  <span class="comment">// 默认值1</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托给第二个构造函数</span></span><br><span class="line">    <span class="built_in">ClassC</span>(<span class="type">int</span> my_max, <span class="type">int</span> my_min, <span class="type">int</span> my_middle) : <span class="built_in">ClassC</span>(my_max, my_min) {</span><br><span class="line">        middle = (my_middle &lt; max &amp;&amp; my_middle &gt; min) ? my_middle : <span class="number">5</span>;  <span class="comment">// 默认值5</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    ClassC c1{<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>};</span><br><span class="line">    cout &lt;&lt; <span class="string">"max: "</span> &lt;&lt; c<span class="number">1.</span>max &lt;&lt; <span class="string">", min: "</span> &lt;&lt; c<span class="number">1.</span>min &lt;&lt; <span class="string">", middle: "</span> &lt;&lt; c<span class="number">1.</span>middle &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="运行结果分析"><a href="#运行结果分析" class="headerlink" title="运行结果分析"></a>运行结果分析</h4><ul>
<li><code>ClassC c1{1, 3, 2}</code>:<ol>
<li>调用 <code>ClassC(int, int, int)</code> 构造函数。</li>
<li>它委托给 <code>ClassC(int, int)</code>，后者再委托给 <code>ClassC(int)</code>。</li>
<li>初始化顺序：<ul>
<li><code>max = 1</code>（因为 1 &gt; 0）。</li>
<li><code>min = 1</code>（因为 3 &gt; max，不满足条件，使用默认值 1）。</li>
<li><code>middle = 2</code>（因为 2 &lt; max 且 2 &gt; min 不成立，但逻辑上仍赋值 2，需检查代码逻辑）。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ol>
<li><p><strong>初始化位置</strong>:</p>
<ul>
<li>成员变量不能在委托构造函数的初始化列表中直接使用参数初始化，必须通过被委托的构造函数完成。</li>
<li>如 <code>ClassC(int my_max, int my_min) : ClassC(my_max)</code> 中，不能再初始化 <code>min</code>，只能在函数体内赋值。</li>
</ul>
</li>
<li><p><strong>代码重复问题</strong>:</p>
<ul>
<li>如果每个构造函数都独立初始化 <code>max</code>、<code>min</code> 等，会导致重复代码。</li>
<li>委托构造函数将公共逻辑集中到基础构造函数中。</li>
</ul>
</li>
<li><p><strong>委托链</strong>:</p>
<ul>
<li>可以形成构造函数调用链，如 <code>ClassC(int, int, int)</code> → <code>ClassC(int, int)</code> → <code>ClassC(int)</code>。</li>
</ul>
</li>
<li><p><strong>限制与解决方法</strong>:</p>
<ul>
<li>委托构造函数不能再有其他初始化列表项。</li>
<li>如果需要更灵活的初始化，可以引入一个私有的辅助构造函数：</li>
</ul>
</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassC</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> max;  </span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> my_max)</span> </span>{ max = my_max &gt; <span class="number">0</span> ? my_max : <span class="number">10</span>; }</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ClassC</span>(<span class="type">int</span> my_max) { <span class="built_in">init</span>(my_max); }</span><br><span class="line">    <span class="built_in">ClassC</span>(<span class="type">int</span> my_max, <span class="type">int</span> my_min) : <span class="built_in">min</span>(my_min) { <span class="built_in">init</span>(my_max); } <span class="comment">// 直接在初始化列表中初始成员变量	</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>





<hr>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul>
<li>默认参数是在函数声明中为参数指定的默认值，调用时未提供参数则使用默认值。</li>
<li>规则：默认参数必须<u>从右到左设置</u>。</li>
</ul>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">harpo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m = <span class="number">4</span>, <span class="type">int</span> j = <span class="number">5</span>)</span></span>;  <span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">chico</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m = <span class="number">6</span>, <span class="type">int</span> j)</span></span>;       <span class="comment">// 非法：j 无默认值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">groucho</span><span class="params">(<span class="type">int</span> k = <span class="number">1</span>, <span class="type">int</span> m = <span class="number">2</span>, <span class="type">int</span> n = <span class="number">3</span>)</span></span>;  <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> beeps;</span><br><span class="line">    beeps = <span class="built_in">harpo</span>(<span class="number">2</span>);      <span class="comment">// harpo(2, 4, 5) -&gt; 11</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"beeps = "</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class="line">    beeps = <span class="built_in">harpo</span>(<span class="number">1</span>, <span class="number">8</span>);   <span class="comment">// harpo(1, 8, 5) -&gt; 14</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"beeps = "</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class="line">    beeps = <span class="built_in">harpo</span>(<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>);  <span class="comment">// harpo(8, 7, 6) -&gt; 21</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"beeps = "</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">harpo</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> j)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> n + m + j;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h4><ol>
<li><strong>规则</strong>:<ul>
<li>默认参数从右到左设置。</li>
<li><code>int harpo(int n, int m = 4, int j = 5)</code> 合法。</li>
<li><code>int chico(int n, int m = 6, int j)</code> 非法。</li>
</ul>
</li>
<li><strong>作用</strong>:<ul>
<li>省略参数时自动填充默认值。</li>
<li>减少函数重载需求。</li>
</ul>
</li>
<li><strong>注意</strong>:<ul>
<li>默认值在声明中指定，<u>不在定义中</u>。</li>
<li>不能“跳跃”使用参数，如 <code>harpo(1, , 6)</code> 非法。</li>
</ul>
</li>
</ol>
<h4 id="改进建议"><a href="#改进建议" class="headerlink" title="改进建议"></a>改进建议</h4><ul>
<li>复杂逻辑可考虑函数重载或委托构造函数。</li>
<li>避免过度使用默认参数以保持代码清晰。</li>
</ul>
<hr>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><blockquote>
<p>Inline Functions</p>
</blockquote>
<h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul>
<li><p>内联函数是用 <code>inline</code> 关键字修饰的函数，编译器会尝试将函数调用替换为函数体代码，减少函数调用的开销。</p>
<blockquote>
<p>普通函数的调用需要经历: 压栈、传递参数、跳转到函数地址、返回值处理、出栈等步骤, 由此可见内联函数可以有效提升性能.</p>
</blockquote>
</li>
<li><p>适用于小型、频繁调用的函数。</p>
</li>
</ul>
<h4 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Square of "</span> &lt;&lt; num &lt;&lt; <span class="string">" is "</span> &lt;&lt; <span class="built_in">square</span>(num) &lt;&lt; endl;  <span class="comment">// 输出 25</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h4><ol>
<li><strong>作用</strong>:<ul>
<li>减少函数调用开销（如参数传递、栈帧创建）。</li>
<li>提高执行效率，适合小型函数。</li>
</ul>
</li>
<li><strong>使用场景</strong>:<ul>
<li>函数体短小、调用频繁。</li>
<li>不适合复杂函数（可能导致代码膨胀）。</li>
</ul>
</li>
<li><strong>注意</strong>:<ul>
<li><code>inline</code> 是建议，编译器可能忽略（例如函数过大或包含循环）。</li>
<li>内联函数定义通常放在头文件中，避免链接错误 (在多个源文件被调用的时候, <code>inline</code>的声明可以告诉编译器, 重复的定义是被允许的)</li>
</ul>
</li>
</ol>
<blockquote>
<p>[!NOTE]</p>
<ol>
<li><p><strong>Any function you define inside a class declaration is automatically an inline.</strong></p>
<blockquote>
<p><code>class</code>内部**<u>定义</u>**的函数自动为 <code>inline</code>类型. 如果是类外定义(相同的<code>.h</code>文件), 那么需要显式声明为内联函数.</p>
</blockquote>
</li>
<li><p>内联函数必须在**<u>头文件</u>**中定义，或者在调用它的同一翻译单元中.</p>
<blockquote>
<p>如果定义在 .cpp 文件中，调用点无法看到定义，编译器无法内联，链接器会报错.</p>
</blockquote>
</li>
<li><p>如果决定将类的函数定义写在头文件中, 有以下的两种选择使其成为内联函数;</p>
<ol>
<li>直接在声明的地方给出完全的定义;</li>
<li>在类外声明 <code>inline</code>然后定义.</li>
</ol>
</li>
<li><p><code>inline</code>确实比C语言的 <code>macro</code>更好, 因为内联函数实现了对参数的类型检查.</p>
</li>
<li><p>编译器会对声明为 <code>inline</code> 的函数进行检查: 如果包含了递归 或者 代码量较大, 编译器依旧不会将其视为 <code>inline</code> .</p>
</li>
</ol>
</blockquote>
<h3 id="inline-变量"><a href="#inline-变量" class="headerlink" title="inline 变量"></a>inline 变量</h3><blockquote>
<p>[!NOTE]</p>
<ul>
<li><p>为静态成员变量声明 <code>inline</code>, 不必在 <code>.cpp</code>中再次声明.</p>
</li>
<li><p>用于<strong>在头文件中定义具有外部链接的变量</strong>，避免了重复定义的问题.</p>
</li>
</ul>
</blockquote>
<p>在 C++ 传统规则中，<strong>全局变量</strong>（或者 namespace 作用域的变量）在头文件中定义会导致多个翻译单元（编译文件）出现<strong>重复定义错误</strong>。在 C++17 之前，通常的做法是：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> myVar; <span class="comment">// 声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mysource.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"myheader.h"</span></span></span><br><span class="line"><span class="type">int</span> myVar = <span class="number">42</span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure></div>

<p>但在 C++17 之后，可以使用 inline 变量，直接在头文件中定义，而不会导致重复定义错误：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myheader.h</span></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> myVar = <span class="number">42</span>;  <span class="comment">// C++17 及以上</span></span><br></pre></td></tr></table></figure></div>

<p>在任何 <code>#include "myheader.h</code>“ 的地方，myVar 仍然是<u><strong>同一个变量</strong></u>。</p>
<blockquote>
<p>如果希望不同的文件不是一个实例, 需要声明为 静态全局变量.</p>
</blockquote>
<p><strong>inline 变量的特点</strong></p>
<p>​	1.	<strong>允许在头文件中定义</strong>，避免 extern 的使用。</p>
<p>​	2.	<strong>所有包含它的翻译单元共享同一个变量</strong>（编译时不会创建多个实例）。</p>
<p>​	3.	<strong>必须初始化</strong>，否则编译器无法确定变量的值。</p>
<p><strong>示例：多个文件使用 inline 变量</strong></p>
<p>假设有以下两个源文件，同时包含 myheader.h，但不会引发重复定义错误：</p>
<p><strong>头文件 myheader.h</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MYHEADER_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MYHEADER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> globalVar = <span class="number">100</span>; <span class="comment">// inline 变量</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p><strong>源文件 file1.cpp</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"myheader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"file1.cpp: "</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>源文件 file2.cpp</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"myheader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"file2.cpp: "</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>主程序 main.cpp</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"myheader.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">    globalVar += <span class="number">10</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"main.cpp: "</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>编译 &amp; 运行</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ file1.cpp file2.cpp main.cpp -o output &amp;&amp; ./output</span><br></pre></td></tr></table></figure></div>

<p><strong>输出示例：</strong></p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file1.cpp: 100</span><br><span class="line">file2.cpp: 100</span><br><span class="line">main.cpp: 110</span><br></pre></td></tr></table></figure></div>

<p>说明：</p>
<p>​	•	globalVar 是<strong>同一个变量</strong>，而不是多个副本。</p>
<p>​	•	main.cpp 修改 globalVar 之后，globalVar 在所有翻译单元中都被更新。</p>
<hr>
<p><strong>inline 变量 vs constexpr 变量</strong></p>
<p>​	•	inline 变量可以是<strong>可变的</strong>，可以修改其值。</p>
<p>​	•	constexpr 变量必须是<strong>编译时常量</strong>，不能修改。</p>
<p>​	•	inline constexpr 变量既有 inline 特性，又是编译时常量。</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inline constexpr int constantVar = 50; // 不能修改</span><br></pre></td></tr></table></figure></div>



<h3 id="weak"><a href="#weak" class="headerlink" title="weak"></a>weak</h3><p><code>weak</code>允许不同的编译单元存在同名的函数, 并且在实际调用的时候, 优先调用不是 <code>weak</code>的函数. 从而提供了一种默认的实现.</p>
<p><code>weak</code>关键字可以用于函数、变量与对象等, 与主要使用于函数的 <code>inline</code>不同.</p>
<p>如果没有 <code>weak</code>标记, 就是强变量.</p>
<ul>
<li>一般的编译器需要使用 <code>__attribute__((weak)) </code> 来声明:</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明 weak 变量，提供默认值</span></span><br><span class="line">__attribute__((weak)) <span class="type">int</span> globalValue = <span class="number">42</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"globalValue = "</span> &lt;&lt; globalValue &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h1 id="Composition"><a href="#Composition" class="headerlink" title="Composition"></a>Composition</h1><p>用已有的对象构造新的对象. 称为组合.</p>
<p>可以用 <code>has-a</code>的关系来描述.</p>
<h2 id="类内对象的初始化"><a href="#类内对象的初始化" class="headerlink" title="类内对象的初始化"></a>类内对象的初始化</h2><p>假设我们有一个 <code>Person</code> 类，该类内部包含一个 <code>std::vector&lt;std::string&gt;</code> 类型的成员变量，用于存储人的爱好。我们将展示如何在类的构造函数中使用完全初始化和引用初始化来初始化这个成员变量。</p>
<h3 id="1-Fully"><a href="#1-Fully" class="headerlink" title="1. Fully"></a>1. Fully</h3><p>完全初始化是指在类的构造函数中直接为成员变量赋予初始值。这通常通过成员初始化列表（member initializer list）来完成。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; hobbies;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完全初始化：使用成员初始化列表</span></span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::vector&lt;std::string&gt;&amp; initialHobbies)</span><br><span class="line">        : <span class="built_in">hobbies</span>(initialHobbies) { }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>解释</strong></p>
<ul>
<li><strong>成员变量初始化</strong>：在 <code>Person</code> 类的构造函数中，我们使用成员初始化列表 <code>: hobbies(initialHobbies)</code> 来完全初始化 <code>hobbies</code> 成员变量。这意味着 <code>person1.hobbies</code> 将拥有 <code>initialHobbies</code> 的一个拷贝。</li>
<li><strong>独立性</strong>：<code>person1.hobbies</code> 是 <code>initialHobbies</code> 的一个独立拷贝，修改 <code>person1.hobbies</code> 不会影响 <code>initialHobbies</code>，反之亦然。</li>
</ul>
<h3 id="2-Reference"><a href="#2-Reference" class="headerlink" title="2. Reference"></a>2. Reference</h3><p>引用初始化是指将类内部的成员变量声明为引用类型，并在构造函数中将其绑定到另一个对象。这意味着类内的引用将直接指向外部对象，而不是持有其拷贝。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;std::string&gt;&amp; hobbiesRef;  <span class="comment">// 引用类型的成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用初始化：使用成员初始化列表绑定到外部对象</span></span><br><span class="line">    <span class="built_in">Person</span>(std::vector&lt;std::string&gt;&amp; externalHobbies)</span><br><span class="line">        : <span class="built_in">hobbiesRef</span>(externalHobbies) { }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>解释</strong></p>
<ul>
<li><strong>成员变量声明</strong>：<code>std::vector&lt;std::string&gt;&amp; hobbiesRef;</code> 声明了一个引用类型的成员变量 <code>hobbiesRef</code>，它将引用外部的 <code>std::vector&lt;std::string&gt;</code> 对象。</li>
<li><strong>引用绑定</strong>：在构造函数中，通过 <code>: hobbiesRef(externalHobbies)</code> 将 <code>hobbiesRef</code> 绑定到传入的 <code>externalHobbies</code> 对象。这意味着 <code>person2.hobbiesRef</code> 和 <code>sharedHobbies</code> 指向同一个内存位置。</li>
<li><strong>共享数据</strong>：对 <code>person2.hobbiesRef</code> 的修改（如添加新爱好）会直接影响到 <code>sharedHobbies</code>，因为它们共享相同的数据。</li>
</ul>
<h3 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比"></a>3. 对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>完全初始化</th>
<th>引用初始化</th>
</tr>
</thead>
<tbody><tr>
<td><strong>存储方式</strong></td>
<td>存储外部对象的拷贝</td>
<td>存储对外部对象的引用</td>
</tr>
<tr>
<td><strong>内存使用</strong></td>
<td>额外占用内存用于拷贝</td>
<td>不占用额外内存，直接引用外部对象</td>
</tr>
<tr>
<td><strong>数据独立性</strong></td>
<td>修改类内成员不会影响外部对象</td>
<td>修改类内成员会影响外部对象</td>
</tr>
<tr>
<td><strong>生命周期依赖</strong></td>
<td>类内成员独立于外部对象的生命周期</td>
<td>类内引用的生命周期必须至少与外部对象相同</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需要独立副本时使用</td>
<td>需要与外部对象共享数据时使用, 初始情况下不知道容量</td>
</tr>
</tbody></table>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p><strong>引用必须在构造时初始化</strong>：引用类型的成员变量必须在构造函数的初始化列表中绑定到一个对象，不能在构造函数体内赋值。</p>
<blockquote>
<p>[!NOTE]</p>
<p>因为引用类型的对象必须在初始化的时候绑定, 并且只能绑定一次.</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误示例：试图在构造函数体内赋值给引用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;std::string&gt;&amp; hobbiesRef;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Person</span>(std::vector&lt;std::string&gt;&amp; externalHobbies) {</span><br><span class="line">        hobbiesRef = externalHobbies; <span class="comment">// 错误：引用必须在初始化时绑定</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>生命周期管理</strong>：使用引用初始化时，必须确保被引用的对象在使用期间是有效的。如果引用的对象被销毁，引用将变为悬空引用，导致未定义行为。</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 危险示例：悬空引用</span></span><br><span class="line"><span class="function">std::vector&lt;std::string&gt; <span class="title">createHobbies</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;std::string&gt; temp = {<span class="string">"Temporary"</span>};</span><br><span class="line">    <span class="function">Person <span class="title">person</span><span class="params">(temp)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> temp; <span class="comment">// temp 被销毁，person.hobbiesRef 悬空</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>为了避免这种情况，通常可以使用智能指针（如 <code>std::shared_ptr</code> 或 <code>std::unique_ptr</code>）来管理对象的生命周期，或者确保引用的对象在使用期间一直有效。</p>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<p>[!NOTE]</p>
<ol>
<li><p>如果使用 完全初始化 的方式, 类内必须包含另一个类的完整定义(引用头文件);</p>
</li>
<li><p>如果是引用初始化, 可以直接在这个类的内部预先声明另一个类的存在即可.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>; <span class="comment">// 前向声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>{</span><br><span class="line">  A* ptr;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ol>
</blockquote>
<hr>
<h2 id="Embedded-objects"><a href="#Embedded-objects" class="headerlink" title="Embedded objects"></a>Embedded objects</h2><blockquote>
<p>[!NOTE]</p>
<ul>
<li>对于嵌入对象，如果不用初始化列表，就必须有默认构造函数。</li>
</ul>
</blockquote>
<h2 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h2><h3 id="命名空间的别名"><a href="#命名空间的别名" class="headerlink" title="命名空间的别名"></a>命名空间的别名</h3><p>如果 <code>namespace</code>过长, 可以将其重新赋值并使用:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> supercalifragilistic {</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">namespace</span> <span class="type">short</span> = supercalifragilistic;</span><br><span class="line"><span class="type">short</span>::<span class="built_in">f</span>();</span><br></pre></td></tr></table></figure></div>



<h3 id="selection"><a href="#selection" class="headerlink" title="selection"></a>selection</h3><p>除了直接在一个命名空间内部嵌套其他, 我们也可以在一个命名空间里选择性地使用其他空间的部分函数:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> mine｛</span><br><span class="line">	<span class="keyword">using</span> orig::Cat;	 <span class="comment">// use Cat class from origvoid ×O）；</span></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">x</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">y</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>[!NOTE]</p>
<ol>
<li><strong>Multiple namespace declarations add to the same namespace.</strong><br>也即是说, 多个 <code>.h</code>文件内相同的命名空间会自动的视作一个.</li>
</ol>
</blockquote>
<h1 id="Inheritance"><a href="#Inheritance" class="headerlink" title="Inheritance"></a>Inheritance</h1><blockquote>
<p>[!NOTE]</p>
<ol>
<li>继承的对象都具有基类的属性, 但是不一定具有访问的权限.<br>也就是 <strong>Think of inherited traits as an embedded object</strong></li>
<li>派生类的构造函数中的初始化列表应当包含基类的构造函数.</li>
<li>由于基类的私有成员无法被子类直接访问, 需要让子类调用基类的public的函数, 从而间接访问.</li>
<li>如果子类和父类含有同名的变量, 将会同时存在, 并且可以在子类中声明 <code>parent_class:A</code>来访问父类中的属性A.</li>
<li>子类中一定有部分是父类的对象, 并且处于子类的开头(父类必须首先完成初始化).</li>
</ol>
</blockquote>
<h4 id="初始化列表的常用场景"><a href="#初始化列表的常用场景" class="headerlink" title="初始化列表的常用场景"></a>初始化列表的常用场景</h4><ol>
<li><p>调用基类的构造函数 (否则调用默认构造函数)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> data) { <span class="comment">/* ... */</span> }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> baseVal) : <span class="built_in">Base</span>(baseVal) { }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>初始化嵌入类</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Member</span>(<span class="type">const</span> std::string&amp; str) { <span class="comment">/* ... */</span> }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span> {</span><br><span class="line">    Member memberObj;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Container</span>(<span class="type">const</span> std::string&amp; s) : <span class="built_in">memberObj</span>(s) { }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>需要注意的是, 此处的初始化列表中的嵌入类的构造, 变量名不是类名.</p>
<p>如果嵌入类不存在默认的构造函数, 那么初始化列表中的显式构造是必要的.</p>
</blockquote>
</li>
<li><p>初始化常量成员:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> constMember;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">constMember</span>(val) { }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>const 成员一旦定义，必须立即初始化，且<strong>只能</strong>在初始化列表中完成，不能在构造函数体内赋值。</p>
</blockquote>
</li>
<li><p>初始化引用成员</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line">    <span class="type">int</span>&amp; refMember;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span>&amp; ref) : <span class="built_in">refMember</span>(ref) { }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>引用成员（如 int&amp; ref）必须在初始化时绑定对象，<strong>不能在构造函数体内赋值</strong>，因此也必须使用初始化列表。</p>
</blockquote>
</li>
</ol>
<p>继承: 基于已有的类来设计新的类，新的类的对象可以被当作已有类的对象.</p>
<p>相比于 <em>composition</em>  的 <code>has-a</code>关系, 继承是 <code>is-a</code>的关系.</p>
<p>同义词:</p>
<ul>
<li>父类、超类、基类</li>
<li>派生类、子类</li>
</ul>
<p>控制基类成员在派生类中的可见性：</p>
<ul>
<li><code>public</code>：基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>，<code>protected</code> 成员仍然是 <code>protected</code>。</li>
<li><code>protected</code>：基类的 <code>public</code> 和 <code>protected</code>成员在派生类中都变为 <code>protected</code>。</li>
<li><code>private</code>：基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p>此时, 仍旧可以通过子类的方法来访问基类的属性或者方法, 但是无法通过子类直接访问基类~!</p>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base function called."</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedFunction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="built_in">baseFunction</span>(); <span class="comment">// 在子类内部可以访问基类的成员函数</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">baseFunction</span>();    <span class="comment">// 错误：无法从子类外部访问基类的成员函数</span></span><br><span class="line">    d.<span class="built_in">derivedFunction</span>(); <span class="comment">// 可以调用子类的函数，该函数内部调用了基类的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></blockquote>
<p>clint class 表示这个类要使用另一个类(中的public).</p>
<p>子类的对象也可以认为是父类的对象。子类不能访问父类的私有变量，但私有变量存在于这个类中</p>
<p>当调用构造函数时，我们不能调用父类的私有变量，只能用初始化列表的方式调用父类的构造函数。</p>
<p>赋值的运算符不会被继承:</p>
<h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>赋值运算符是这样形式的方法:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Point &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Point &amp;other)</span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt; <span class="string">"Point::operator= 被调用"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">    {</span><br><span class="line">        x = other.x;</span><br><span class="line">        y = other.y;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>当我们如此赋值的时候就会发生上述的调用:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Point <span class="title">p1</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">Point <span class="title">p2</span><span class="params">(<span class="number">3</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">p1 = p2;</span><br></pre></td></tr></table></figure></div>

<p>可见, 赋值运算符通过引用快速地将右值中的属性赋值给左侧的目标.</p>
<p>但是父类的赋值运算符只会确保自身的属性能够被赋值, 无法确保子类自身的属性可以被正确设置. 因此, 为了安全性, CPP不允许子类自动继承父类的赋值运算符.</p>
<blockquote>
<p>[!NOTE]</p>
<p>然而, 编译器可能为子类自动生成一个赋值运算符.</p>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>) : <span class="built_in">x</span>(x), <span class="built_in">y</span>(y) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义赋值运算符</span></span><br><span class="line">    Point &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Point &amp;other)</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Point::operator= 被调用"</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">        {</span><br><span class="line">            x = other.x;</span><br><span class="line">            y = other.y;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ColoredPoint</span> : <span class="keyword">public</span> Point</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string color;</span><br><span class="line">    <span class="built_in">ColoredPoint</span>(<span class="type">int</span> x = <span class="number">0</span>, <span class="type">int</span> y = <span class="number">0</span>, string color = <span class="string">"white"</span>) : <span class="built_in">Point</span>(x, y), <span class="built_in">color</span>(color) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"x:"</span> &lt;&lt; x &lt;&lt; <span class="string">", y:"</span> &lt;&lt; y &lt;&lt; <span class="string">", color:"</span> &lt;&lt; color &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function">ColoredPoint <span class="title">cp1</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"red"</span>)</span></span>;</span><br><span class="line">    cp<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line">    <span class="function">ColoredPoint <span class="title">cp2</span><span class="params">(<span class="number">3</span>, <span class="number">4</span>, <span class="string">"blue"</span>)</span></span>;</span><br><span class="line">    cp<span class="number">2.</span><span class="built_in">print</span>();</span><br><span class="line">    cp1 = cp2;</span><br><span class="line">    cp<span class="number">1.</span><span class="built_in">print</span>();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p><strong>输出结果</strong>:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x:<span class="number">1</span>, y:<span class="number">2</span>, color:red</span><br><span class="line">x:<span class="number">3</span>, y:<span class="number">4</span>, color:blue</span><br><span class="line">Point::<span class="keyword">operator</span>= 被调用</span><br><span class="line">x:<span class="number">3</span>, y:<span class="number">4</span>, color:blue</span><br></pre></td></tr></table></figure></div>

<p>可见, 父类的赋值运算符也被自动地调用了, 这是因为编译器为子类自动生成了一份.</p>
</blockquote>
<hr>
<p>父类的构造是在子类的构造之前。</p>
<h3 id="using声明"><a href="#using声明" class="headerlink" title="using声明"></a><code>using</code>声明</h3><h4 id="将基类的函数派生使用"><a href="#将基类的函数派生使用" class="headerlink" title="将基类的函数派生使用"></a>将基类的函数派生使用</h4><p>必须使用 <code>using &lt;parentClass&gt;:: func</code>的方式, 无法忽略 <code>using</code>.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>{</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">double</span>)</span></span>{</span><br><span class="line">      cout &lt;&lt; <span class="string">"double\n"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : Base{</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  	<span class="keyword">using</span> Base::f; <span class="comment">// 将基类中的私有函数本地使用</span></span><br><span class="line">  	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>{</span><br><span class="line">      cout &lt;&lt; <span class="string">"int\n"</span>&lt;&lt;endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">f</span>(<span class="number">4</span>);</span><br><span class="line">    d.<span class="built_in">f</span>(<span class="number">4.5</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p><strong>Output:</strong></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> </span><br><span class="line"></span><br><span class="line"><span class="type">double</span></span><br></pre></td></tr></table></figure></div>



<h4 id="默认参数值无法通过重载传递"><a href="#默认参数值无法通过重载传递" class="headerlink" title="默认参数值无法通过重载传递"></a>默认参数值无法通过重载传递</h4><p>在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免<strong>多重继承时参数值产生冲突或二义性</strong>。默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.</p>
<blockquote>
<p>如果你在派生类中<strong>重新声明或重载了基类的函数</strong>，那么你不能获得默认参数值，必须通过多个重载模拟默认参数功能.</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>, <span class="type">double</span> b = <span class="number">2.0</span>)</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::f;         <span class="comment">// ✅ 此时默认参数仍可见</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a)</span></span>;      <span class="comment">// ❌ 重载后，这个版本没有默认参数</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>



<blockquote>
<p>但是使用 <code>using</code>声明的父类函数可以获得默认参数值.</p>
</blockquote>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a = <span class="number">3</span>, <span class="type">double</span> b = <span class="number">2.0</span>)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"A::f("</span> &lt;&lt; a &lt;&lt; <span class="string">", "</span> &lt;&lt; b &lt;&lt; <span class="string">")"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> A::f; <span class="comment">// 继承 A::f 到 B 中</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    B b;</span><br><span class="line">    b.<span class="built_in">f</span>();        <span class="comment">// ✅ 是否等价于 f(3, 2.0)？</span></span><br><span class="line">    b.<span class="built_in">f</span>(<span class="number">10</span>);      <span class="comment">// ✅ 是否等价于 f(10, 2.0)？</span></span><br><span class="line">    b.<span class="built_in">f</span>(<span class="number">10</span>, <span class="number">5.5</span>); <span class="comment">// ✅ 正常调用</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>输出:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A::<span class="built_in">f</span>(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line">A::<span class="built_in">f</span>(<span class="number">10</span>, <span class="number">2</span>)</span><br><span class="line">A::<span class="built_in">f</span>(<span class="number">10</span>, <span class="number">5.5</span>)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="解决重写函数的重载问题"><a href="#解决重写函数的重载问题" class="headerlink" title="解决重写函数的重载问题"></a>解决重写函数的重载问题</h4><p>子类重新定义 (<code>override</code>重写) 了父类的某个函数，就会把父类中对应 <code>overloaded</code> 的函数覆盖:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 基类中的重载函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base display(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Base display(double): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子类重新定义了基类的 display(int)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Derived display(int): "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">using</span> Base::display;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">display</span>(<span class="number">5</span>); <span class="comment">// 调用 Derived 的 display(int)</span></span><br><span class="line"></span><br><span class="line">    d.Base::<span class="built_in">display</span>(<span class="number">5.5</span>); <span class="comment">// 或者d.display(5.5);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li><p>注意, CPP中的浮点数可以隐式转换为整型.</p>
<ul>
<li>当将一个浮点数赋值给一个整型变量时，编译器会执行<strong>隐式转换</strong>，将浮点数的值转换为整型。这种转换通常涉及<strong>截断</strong>（truncation），即去掉小数部分，只保留整数部分.</li>
</ul>
</li>
<li><p>可以通过 <code>using </code>声明重新引入基类中的重载函数: </p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Base::display;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</blockquote>
<hr>
<h1 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h1><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ol>
<li><p>成员函数（无论是虚函数还是非虚函数）本身不占用类对象的内存空间，因为它们的代码存储在程序的代码段中。只有<strong>成员变量和虚表指针</strong>（如果有虚函数）会占用对象的内存空间:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>此时的 <code>sizeof(A)</code>为4字节.</p>
</li>
<li><p>虚函数指针的大小一般是 <u>8字节</u>. 如果结构体内部存在虚函数指针, 就需要对齐为8字节的倍数.</p>
</li>
<li><p>因为子类的构造在父类的构造之后, 也就是每一个子类对象的前部分都是父类对象. 因此, 我们可以将一个子类对象的指针赋值给父类对象, 只要忽视后续数据结构即可.</p>
</li>
<li><p><u>多态变量</u>: 指向子类对象的基类指针/引用.</p>
</li>
<li><p>如果类内不存在任何成员变量, 它的对象依旧占用 <code>1</code> 个字节的空间.</p>
</li>
<li><p>如果一个类将来可能具有子类, 就让其析构函数设置为 <code>virtual</code>. —— 任何的类都应该设置它的析构为 <code>virtual</code>.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A{};</span><br><span class="line"></span><br><span class="line">A* p = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure></div>

<p>如果 A 的析构函数不是virtual的, 那么编译器只会调用A的析构函数.</p>
</li>
<li><p>如果父类的构造函数中调用了 <code>virtual</code> 的函数, 那么实际上还是调用自己的函数(静态绑定)</p>
<ol>
<li>这是因为, 创建一个派生类的对象时, 首先调用父类的构造函数, 然后执行派生类的构造函数;</li>
<li>此时, 子类的成员还没有初始化, 父类无法调用其重写版本, 也就无法实现多态.</li>
</ol>
</li>
<li><blockquote>
<p>[!NOTE]</p>
<p>深刻理解什么叫做多态! 也就是子类对象的引用或者指针赋值给了父类! 此后调用这个对象时, 虚函数是动态绑定到子类的!</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A &amp;ra = b;    <span class="comment">// ra是A类型的引用，但指向B类型的对象</span></span><br><span class="line">ra.<span class="built_in">f</span>();       <span class="comment">// 虽然ra是A类型的引用，但f()会调用B::f()</span></span><br></pre></td></tr></table></figure></div></blockquote>
</li>
<li><p>如果B是A的子类:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A *p1 = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">3</span>);    <span class="comment">// p1是A类型的指针，但指向B类型的对象</span></span><br></pre></td></tr></table></figure></div>

<p>实际上,  p1指向的对象是B类的对象</p>
</li>
</ol>
<p>当一个被重写的函数在 Derived::func() 中通过 Base::func() 调用其基类版本时，会发生什么？</p>
<ul>
<li><p>可以正常调用, 这也正是重写存在的意义——扩充原来的功能, 同时保留.</p>
</li>
<li><p>多态与返回对象类型:</p>
<ul>
<li><p>允许重载返回自身的 <u>指针</u> 与 <u>引用</u>, 但是不支持直接返回自身的类型:</p>
</li>
<li><p>i.e. </p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Class Expr｛</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> Expr* newExpr （）；</span><br><span class="line">  <span class="keyword">virtual</span> Expr&amp; clone （）；</span><br><span class="line">  <span class="keyword">virtual</span> Expr Expr self（）；</span><br><span class="line">｝；</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryExpr</span> ： <span class="keyword">public</span> Expr ｛</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">  <span class="keyword">virtual</span> BinaryExpr* newExpr （）； <span class="comment">//Ok</span></span><br><span class="line">  <span class="keyword">virtual</span> BinaryExpr&amp; clone （）； <span class="comment">// Ok</span></span><br><span class="line">  <span class="keyword">virtual</span> BinaryExpr self（）；<span class="comment">// Error！</span></span><br><span class="line">  ｝；</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>原因: 指针和引用的大小固定, 编译时刻可以确定调用时候所需的空间, 如果按照类型返回, 由于多态的动态绑定是运行时决定调用对应的方法, 所以编译的时候caller不知道要在栈上预留多少的空间.</p>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>Polymorphism<ul>
<li>virtual functions and override</li>
<li>abstract functions and classes</li>
</ul>
</li>
<li>Multiple Inheritance</li>
</ul>
<p>由于子类具有父类的所有属性, 因此我们可以将一个子类对象看作父类的对象, 并进行对应的操作.</p>
<p>将子类对象看作父类对象的操作, 叫做 <u>upcast</u>. 具体是说, 将子类的指针或者引用赋值给基类的对象.</p>
<p>现在的问题是, 如果采取传统的继承+重写的方式, 我们在子类内部采取重写父类方法, 可能导致 <code>静态绑定</code> static binding:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Animal speaks"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Dog barks"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Animal *animal = <span class="keyword">new</span> <span class="built_in">Dog</span>(); <span class="comment">// 注意：父类指针指向子类对象</span></span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();            <span class="comment">// 会调用哪个？</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>输出:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Animal speaks</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p>为了解决上述的问题, 我们引入 <u>虚函数</u> 的概念.</p>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><p>虚函数可以实现 <strong>运行时多态</strong>. 所谓多态, 就是静态+ 动态的绑定.</p>
<p>通过在父类的函数前加上 <code>virtual</code>的声明, 我们将其定义为虚函数</p>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Animal speaks"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Dog barks"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>(); </span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>(); <span class="comment">// 这次会调用哪个？</span></span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>输出:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dog barks</span><br></pre></td></tr></table></figure></div></li>
</ul>
<blockquote>
<ul>
<li><code>override</code>声明明确这个函数是重写父类的虚函数, 可以让编译器检查是否存在错误.</li>
<li>但是上述的关键字也不是必须的.</li>
</ul>
</blockquote>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>~指的是需要强制派生类去实现的函数:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> 返回类型 函数名(...) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>



<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><ul>
<li>定义: 虚函数表（virtual table）是 C++ 为了实现<strong>运行时多态</strong>而采用的一种底层技术手段;</li>
<li>本质:<ul>
<li><code>vtable</code>是一个函数指针数组;</li>
<li>每个类都有自己的vtable</li>
<li>对象中存在一个隐藏的指针 <code>vptr</code>, 指向该类的vtable</li>
</ul>
</li>
</ul>
<h4 id="内存示意图"><a href="#内存示意图" class="headerlink" title="内存示意图"></a>内存示意图</h4><p>假设有如下结构:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>内存布局的伪结构如下:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+-------------------------+</span><br><span class="line">| vptr  → 指向vtable     |  ←隐藏成员</span><br><span class="line">+-------------------------+</span><br><span class="line">| a : <span class="type">int</span>                |  ←显式成员</span><br><span class="line">+-------------------------+</span><br><span class="line"></span><br><span class="line"><span class="built_in">vtable</span> (Base):</span><br><span class="line">[ func 的地址 ]</span><br><span class="line"></span><br><span class="line"><span class="built_in">vtable</span> (Derived):</span><br><span class="line">[ 重写的 func 的地址 ]</span><br></pre></td></tr></table></figure></div>



<h4 id="拓展说明"><a href="#拓展说明" class="headerlink" title="拓展说明"></a>拓展说明</h4><ul>
<li>vtable是类级别的, 所有该类的对象共享一个vtable;</li>
<li>vptr是对象级别的, 隐含于各个对象当中.</li>
<li>如果类没有虚函数, 就不存在上述的~</li>
</ul>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>如果一个类中包含至少一个纯虚函数, 那么这个类就是一个抽象类.</p>
<p>抽象类无法被实例化, <strong>只能用来作为基类.</strong></p>
<h3 id="使用抽象类定义接口"><a href="#使用抽象类定义接口" class="headerlink" title="使用抽象类定义接口"></a>使用抽象类定义接口</h3><p>用图形绘制的例子来说明抽象类和纯虚函数的使用:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数，子类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：Circle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Drawing Circle"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：Rectangle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Drawing Rectangle"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染函数：面向抽象类编程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">render</span><span class="params">(Shape* shape)</span> </span>{</span><br><span class="line">    shape-&gt;<span class="built_in">draw</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    Circle c;</span><br><span class="line">    Rectangle r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">render</span>(&amp;c); <span class="comment">// Drawing Circle</span></span><br><span class="line">    <span class="built_in">render</span>(&amp;r); <span class="comment">// Drawing Rectangle</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h3 id="继承链"><a href="#继承链" class="headerlink" title="继承链"></a>继承链</h3><p>一个抽象类可以有多个纯虚函数, 此时继承的子类可能没有完全实现. </p>
<p>子类的子类, 也就是在继承链上完成了所有纯虚函数的定义的 最末一级的派生类, 才可以被实例化.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">run</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Breathing..."</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>



<h2 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h2><p><strong>virtual destructor</strong>: 虚析构函数</p>
<p>同样的, 虚析构函数的作用体现在 <code>upcast</code>, 也就是将子类的指针或引用转换为父类的指针或引用的过程. 此时, 如果父类的析构函数不是虚函数, 就会让向上转型之后的对象在析构时调用父类的析构函数.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Base</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base Destructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived Destructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Base *obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    <span class="keyword">delete</span> obj; <span class="comment">// 注意这里！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>此时会输出 :  <code>Base Destructor</code> , 也就是调用了父类的析构函数.</p>
<p>这是十分危险的, 特别是我们需要确保子类的所有资源都被安全地释放.</p>
<p>因此, 我们可以将父类的析构函数也设置为虚函数:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base Destructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~<span class="built_in">Derived</span>() {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived Destructor"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>此时的输出:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Derived Destructor  </span><br><span class="line">Base Destructor</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>先后调用子类和父类的析构函数.</p>
</blockquote>
<h2 id="接口类"><a href="#接口类" class="headerlink" title="接口类"></a>接口类</h2><blockquote>
<p>也被称为 <u>协议类</u>. 其实就像 <code>swift</code>的协议一样, 强制要求继承的子类定义某些函数实现.</p>
</blockquote>
<ul>
<li>含义:<ul>
<li>只定义接口, 不提供实现的抽象类</li>
<li>所有的成员函数都是纯虚函数;</li>
<li>一般不包含任何数据成员.</li>
</ul>
</li>
</ul>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Printable</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Printable</span>() = <span class="keyword">default</span>; <span class="comment">// 记得虚析构函数</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> : <span class="keyword">public</span> Printable {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Printing Document"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>



<h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2><p>多重继承 <em>multiple inheritance</em> 指的是一个类继承自多个基类.</p>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayA</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"I am A"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayB</span><span class="params">()</span> </span>{ cout &lt;&lt; <span class="string">"I am B"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B {</span><br><span class="line">    <span class="comment">// 继承了 A 和 B 的成员</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>可以将多个类的功能整合到一个类中:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C c;</span><br><span class="line">c.<span class="built_in">sayA</span>(); <span class="comment">// OK</span></span><br><span class="line">c.<span class="built_in">sayB</span>(); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></div>



<h3 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h3><p>多重继承中的特例:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C {};</span><br></pre></td></tr></table></figure></div>

<p>继承结构看上去就像菱形:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   A</span><br><span class="line"> /   \</span><br><span class="line">B     C</span><br><span class="line"> \   /</span><br><span class="line">   D</span><br></pre></td></tr></table></figure></div>

<p>如果我们直接使用D类:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D d;</span><br><span class="line">d.value = <span class="number">10</span>; <span class="comment">// ❌ 编译错误：'value' is ambiguous</span></span><br></pre></td></tr></table></figure></div>

<p>这是因为D继承自B和C, 而后者又各自具有自己的A子对象. 导致了二义性的问题.</p>
<blockquote>
<p>[!NOTE]</p>
<p>注意此处的二义性的问题, 来自于在D类对象中直接访问A类对象的成员变量!  什么时候产生二义性? 就是判断此时是否存在多个相同名称的变量.</p>
</blockquote>
<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><p>C++ 提供了一个机制：<strong>虚继承（virtual inheritance）</strong>，来解决上述问题:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> B{};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> :  <span class="keyword">public</span> B, <span class="keyword">public</span> C{}</span><br></pre></td></tr></table></figure></div>

<p>此时, D中只有一个共享的A子对象.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ptr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"value: "</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A {};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C {};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    D d;</span><br><span class="line">    d.value = <span class="number">10</span>; <span class="comment">// ✅ OK，只有一个 A，二义性消除</span></span><br><span class="line">    d.<span class="built_in">ptr</span>();</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>此时, B,C不再具有自己的A.</p>
<blockquote>
<p>[!NOTE]</p>
<p>由于虚继承带来的是“共享”的基类对象，所以：</p>
<ul>
<li>虚基类的构造 <strong>必须由最底层派生类负责</strong></li>
<li>派生类的构造函数中要<strong>显式初始化</strong>虚基类</li>
</ul>
</blockquote>
<h1 id="Copy-and-Move"><a href="#Copy-and-Move" class="headerlink" title="Copy and Move"></a>Copy and Move</h1><h4 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h4><ul>
<li><p><code>vptr</code>只会初始化一次, 然后保持不变. 发生在构造函数的第一步.</p>
</li>
<li><p>循环内部执行构造和析构时, 作用的地址是同一块. 此时将对象的地址传入到vector of <code>*</code> 时, 得到的是相同的地址;</p>
<ul>
<li>为了避免上述的情况, 我们在循环内部的构造, 需要为对象直接 <code>new</code> 一个新的空间.</li>
</ul>
</li>
<li><p><code>std::move</code>的作用就是告诉编译器: 这个类型是右值引用, 需要使用移动语义.</p>
</li>
</ul>
<h2 id="C-中的拷贝构造与移动语义"><a href="#C-中的拷贝构造与移动语义" class="headerlink" title="C++中的拷贝构造与移动语义"></a>C++中的拷贝构造与移动语义</h2><h3 id="拷贝构造函数基础"><a href="#拷贝构造函数基础" class="headerlink" title="拷贝构造函数基础"></a>拷贝构造函数基础</h3><p>拷贝构造函数是创建新对象的一种方式，它从现有对象复制数据来初始化新对象。</p>
<ul>
<li>拷贝构造函数的签名：<code>T::T(const T&amp;)</code></li>
<li>如果不提供拷贝构造函数，C++会自动生成一个默认的拷贝构造函数</li>
<li>默认拷贝构造函数执行的是成员级别的拷贝（memberwise copy），而非位级别的拷贝（bitwise copy）<ul>
<li>对于基本类型成员，直接复制值</li>
<li>对于对象类型成员，调用其拷贝构造函数</li>
<li><strong><u>对于指针类型成员</u></strong>，只复制指针值（浅拷贝），导致两个对象共享同一块内存</li>
</ul>
</li>
</ul>
<h3 id="拷贝构造函数的调用时机"><a href="#拷贝构造函数的调用时机" class="headerlink" title="拷贝构造函数的调用时机"></a>拷贝构造函数的调用时机</h3><p>拷贝构造函数在以下情况下会被调用：</p>
<ol>
<li><p><strong>按值传递参数时</strong>：当对象作为参数按值传递给函数时</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span></span>; <span class="comment">// 调用时会触发拷贝构造</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>对象初始化时</strong>：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyClass a;</span><br><span class="line">MyClass b = a;    <span class="comment">// 初始化，调用拷贝构造函数</span></span><br><span class="line"><span class="function">MyClass <span class="title">c</span><span class="params">(a)</span></span>;     <span class="comment">// 初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>函数返回对象时</strong>：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="keyword">return</span> obj;   <span class="comment">// 可能触发拷贝构造（取决于编译器优化）</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="拷贝构造函数的最佳实践"><a href="#拷贝构造函数的最佳实践" class="headerlink" title="拷贝构造函数的最佳实践"></a>拷贝构造函数的最佳实践</h3><ul>
<li>显式定义拷贝构造函数，不要依赖默认版本</li>
<li>如果类不需要被复制，可以声明私有的拷贝构造函数（不需要定义）</li>
<li>如果类包含指针成员，必须实现<u>深拷贝</u>的拷贝构造函数</li>
</ul>
<h4 id="深拷贝构造函数"><a href="#深拷贝构造函数" class="headerlink" title="深拷贝构造函数"></a>深拷贝构造函数</h4><p>将拷贝的值另外寻找新的内存空间, 而不是指向同一处地址.</p>
<ul>
<li>如果没有显式定义深拷贝构造函数, 观察下面的代码:</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringHolder <span class="title">original</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">    StringHolder copy = original; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"copy包含: "</span> &lt;&lt; copy.<span class="built_in">getString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改copy，如果是浅拷贝，也会影响original</span></span><br><span class="line">    copy.<span class="built_in">setString</span>(<span class="string">"Modified"</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"修改后，copy包含: "</span> &lt;&lt; copy.<span class="built_in">getString</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"修改后，original包含: "</span> &lt;&lt; original.<span class="built_in">getString</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy在此作用域结束时被销毁</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<blockquote>
<ul>
<li><p><code>original</code>的层级在  <code>copy</code> 的外面;</p>
</li>
<li><p>在代码块的内部, 通过浅拷贝构造, 两者的数据共享一个内存空间;</p>
</li>
<li><p>二者先后析构, 导致 <code>double free</code>的问题!</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: Double free of object 0x11f6060c0</span><br><span class="line">02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: *** <span class="built_in">set</span> a breakpoint <span class="keyword">in</span> malloc_error_break to debug</span><br></pre></td></tr></table></figure></div></li>
</ul>
</blockquote>
<p>由此, 我们需要如此定义:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringHolder</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">StringHolder</span>(<span class="type">const</span> <span class="type">char</span> *str)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (str)</span><br><span class="line">        {</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"构造函数: 为\""</span> &lt;&lt; data &lt;&lt; <span class="string">"\"分配内存"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"构造函数: 创建空字符串"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义拷贝构造函数（深拷贝）</span></span><br><span class="line">    <span class="comment">// 如果复制掉这部分的自定义, 将会调用默认的浅拷贝构造函数, 导致问题:浅拷贝的指针两次释放内存</span></span><br><span class="line">    <span class="built_in">StringHolder</span>(<span class="type">const</span> StringHolder &amp;other)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (other.data)</span><br><span class="line">        {</span><br><span class="line">            data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.data) + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(data, other.data);</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"深拷贝构造函数: 为\""</span> &lt;&lt; data &lt;&lt; <span class="string">"\"分配新内存"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            data = <span class="literal">nullptr</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">"深拷贝构造函数: 复制空字符串"</span> &lt;&lt; std::endl;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">StringHolder</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"析构函数: 释放\""</span> &lt;&lt; (data ? data : <span class="string">"nullptr"</span>) &lt;&lt; <span class="string">"\"的内存"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这样就可以避免上面的问题.</p>
<h3 id="函数参数和返回值的选择"><a href="#函数参数和返回值的选择" class="headerlink" title="函数参数和返回值的选择"></a>函数参数和返回值的选择</h3><ul>
<li><p><strong>传入参数</strong>：</p>
<ul>
<li>按值传递：<code>void func(Student s)</code> - 创建新对象，适用于需要存储对象的情况<ul>
<li>如果对象内部的属性存在指针类型的属性, 为了避免浅拷贝, 就需要自定义一个深拷贝构造函数.</li>
</ul>
</li>
<li>常量引用：<code>void func(const Student&amp; s)</code> - 不创建新对象，适用于<u>只读取值</u>的情况</li>
<li>指针/引用：<code>void func(Student* s)</code> 或 <code>void func(Student&amp; s)</code> - 适用于需要<u>修改对象</u>的情况</li>
</ul>
</li>
<li><p><strong>返回值</strong>：</p>
<ul>
<li>按值返回：<code>Student func()</code> - 返回新创建的对象</li>
<li>返回指针：<code>Student* func()</code> - 注意内存管理问题</li>
<li>返回引用：<code>Student&amp; func()</code> - 注意生命周期问题</li>
</ul>
</li>
</ul>
<h2 id="右值引用与移动语义"><a href="#右值引用与移动语义" class="headerlink" title="右值引用与移动语义"></a>右值引用与移动语义</h2><h4 id="左值与右值"><a href="#左值与右值" class="headerlink" title="左值与右值"></a>左值与右值</h4><ul>
<li><strong>左值</strong>：可以出现在赋值号左边的表达式<ul>
<li>变量名、引用</li>
<li>解引用操作符（*）和下标操作符（[]）的结果</li>
</ul>
</li>
<li><strong>右值</strong>：只能出现在赋值号右边的表达式<ul>
<li>字面量</li>
<li>表达式结果</li>
<li>函数返回的临时对象</li>
</ul>
</li>
</ul>
<h4 id="右值引用-1"><a href="#右值引用-1" class="headerlink" title="右值引用"></a>右值引用</h4><ul>
<li>使用 <code>&amp;&amp;</code> 声明</li>
<li>可以绑定到右值，延长其生命周期</li>
<li>右值引用变量本身是左值</li>
<li>可以使用 <code>std::move()</code> 将左值转换为右值引用</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp;&amp; rx = x * <span class="number">2</span>;  <span class="comment">// 绑定右值</span></span><br><span class="line">rx = <span class="number">100</span>;          <span class="comment">// rx本身是左值，可以被赋值</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><p>两种可以同时输入左值和右值引用作为参数的方法:</p>
<ul>
<li><p>重载</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重载函数，分别处理左值和右值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"重载函数 - 处理左值: "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"重载函数 - 处理右值: "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><code>const int&amp; x </code></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受const左值引用的函数（可以接受左值和右值）</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processAny</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span> </span>{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"处理任意值: "</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ul>
<h4 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h4><ul>
<li>签名：<code>T::T(T&amp;&amp; other)</code>, 也就是<strong>将右值引用作为参数的构造函数</strong></li>
<li>用于”窃取”即将销毁的对象的资源，避免不必要的深拷贝</li>
<li>通常将源对象的指针成员置为<code>nullptr</code>，防止资源被错误释放</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(MyClass&amp;&amp; other) : </span><br><span class="line">    ptr{other.ptr} {</span><br><span class="line">      other.data = <span class="number">0</span></span><br><span class="line">      other.ptr = <span class="literal">nullptr</span>;  <span class="comment">// 防止源对象析构时释放内存</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li>与浅拷贝类似, 但是需要在内部将源对象的指针成员 设置为 <code>nullptr</code> , 其他成员设置为有效但是为空的状态</li>
</ul>
<p> 标准库容器（如 std::vector）在进行元素移动时会优先选择不会抛异常的移动构造函数，否则会退而求其次选择拷贝构造函数（更慢）。</p>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;DynamicArray&gt; vec;</span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="built_in">DynamicArray</span>(<span class="number">5</span>));</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在这个 push_back 中，如果 DynamicArray 的移动构造函数被标记为 <code>noexcept</code>，那么 vector 会使用移动构造（高效）。</p>
</blockquote>
<h2 id="初始化方式"><a href="#初始化方式" class="headerlink" title="初始化方式"></a>初始化方式</h2><p>C++11提供了多种初始化对象的方式：</p>
<ul>
<li><p><strong>小括号初始化</strong>：<code>MyClass obj(arg1, arg2);</code></p>
</li>
<li><p><strong>等号初始化</strong>：<code>MyClass obj = value;</code></p>
</li>
<li><p><strong>大括号初始化</strong>（统一初始化）：<code>MyClass obj{arg1, arg2};</code></p>
</li>
<li><p><strong>列表初始化</strong>：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>};</span><br><span class="line">MyClass* ptr = <span class="keyword">new</span> MyClass{arg1, arg2};</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="基本类型的初始化"><a href="#基本类型的初始化" class="headerlink" title="基本类型的初始化"></a>基本类型的初始化</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本类型的初始化方式</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;             <span class="comment">// 等号初始化</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">b</span><span class="params">(<span class="number">20</span>)</span></span>;              <span class="comment">// 小括号初始化</span></span><br><span class="line"><span class="type">int</span> c{<span class="number">30</span>};              <span class="comment">// 大括号初始化（C++11）</span></span><br><span class="line"><span class="type">int</span> d = {<span class="number">40</span>};           <span class="comment">// 等号+大括号初始化（C++11）</span></span><br><span class="line"><span class="type">int</span> arr1[] = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}; <span class="comment">// 数组初始化</span></span><br><span class="line"><span class="type">int</span> arr2[]{<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};    <span class="comment">// 数组大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div>



<h4 id="对象的初始化"><a href="#对象的初始化" class="headerlink" title="对象的初始化"></a>对象的初始化</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象的初始化方式</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">"张三"</span>, <span class="number">25</span>)</span></span>;          <span class="comment">// 小括号初始化</span></span><br><span class="line">Person p2 = <span class="built_in">Person</span>(<span class="string">"李四"</span>, <span class="number">30</span>); <span class="comment">// 等号+临时对象初始化</span></span><br><span class="line">Person p3{<span class="string">"王五"</span>, <span class="number">35</span>};          <span class="comment">// 大括号初始化（C++11）</span></span><br><span class="line">Person p4 = {<span class="string">"赵六"</span>, <span class="number">40</span>};       <span class="comment">// 等号+大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div>



<ul>
<li><p>动态分配对象的初始化</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态分配对象的初始化方式</span></span><br><span class="line">Person *pp1 = <span class="keyword">new</span> <span class="built_in">Person</span>(<span class="string">"动态张三"</span>, <span class="number">25</span>); <span class="comment">// 传统new</span></span><br><span class="line">Person *pp2 = <span class="keyword">new</span> Person{<span class="string">"动态李四"</span>, <span class="number">30</span>}; <span class="comment">// 大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><ul>
<li><strong>浅拷贝</strong>：默认拷贝构造函数执行的是浅拷贝，只复制指针值，不复制指针指向的内容</li>
<li><strong>深拷贝</strong>：自定义拷贝构造函数可以实现深拷贝，为指针成员分配新内存并复制内容</li>
</ul>
<h3 id="何时使用移动语义"><a href="#何时使用移动语义" class="headerlink" title="何时使用移动语义"></a>何时使用移动语义</h3><ul>
<li>类包含动态分配的资源（如指针成员）</li>
<li>对象需要在函数间传递</li>
<li>需要避免不必要的深拷贝操作</li>
<li>使用容器时（如<code>std::vector</code>、<code>std::string</code>等）<ul>
<li><code>move</code>会将一个左值变成右值引用, 从而允许调用移动构造函数!</li>
<li>使用 <code>move</code> 时, 如果存在对应的移动构造函数, 就会优先调用;</li>
<li>数组的 <code>push_back</code>也是如此, 优先调用移动构造函数<ul>
<li>但是我们可以使用 <code>emplace</code>来继续优化上述的效率问题——直接将对象存储到数组的末端.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li>拷贝构造函数用于创建对象的副本，深拷贝需要自定义实现</li>
<li>移动语义通过右值引用实现<strong>资源的高效转移</strong>，避免不必要的拷贝, 同时<strong>规避了浅拷贝导致的 double free</strong> 的问题.</li>
<li>根据需要选择合适的参数传递和返回值方式</li>
<li>使用<code>std::move()</code>可以将左值转换为右值引用，触发移动语义</li>
</ul>
<hr>
<h1 id="Overloaded-Operators"><a href="#Overloaded-Operators" class="headerlink" title="Overloaded Operators"></a>Overloaded Operators</h1><h4 id="补充-2"><a href="#补充-2" class="headerlink" title="补充"></a>补充</h4><p>自定义类型的方向转换:  <em>T</em> ==&gt; <em>C</em></p>
<ul>
<li><p>当下面情况存在一种时, 可以发生上述的转换:</p>
<ol>
<li><p>C存在以 <em>T</em> 作为输入参数的构造函数;</p>
</li>
<li><p><em>T</em> 存在 <code>operator C(){ }</code>的成员函数.<br>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>{  <span class="comment">// Rational到double的转换</span></span><br><span class="line">        <span class="keyword">return</span> numerator_ / (<span class="type">double</span>)denominator_;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d = r;  <span class="comment">// 隐式转换：r =&gt; double</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
</li>
<li><p>不同同时存在两者的转换(编译器无法知道采取什么方式)</p>
</li>
</ul>
<p>题目:</p>
<ul>
<li><p>并非所有运算符都可以用三种方式重载。例如赋值运算符 =、下标运算符 []、函数调用运算符 ()、成员访问运算符 -&gt; <strong>只能</strong>作为成员函数重载;</p>
</li>
<li><p>流提取符 &gt;&gt; 和插入符 &lt;&lt; 可以被重载</p>
</li>
<li><p>运算符 <code>+</code> 返回的类型 <strong>不一定</strong> 要与参数类型一致;</p>
</li>
<li><p>对于友元函数, 在声明处加上 <code>friend</code>标识, 但是在定义处是没有这个标识的. </p>
</li>
<li><blockquote>
<p>[!NOTE]</p>
<p>无法被重载的运算符:</p>
<ul>
<li>条件运算符: <code>?:</code></li>
<li>成员指针访问运算符: <code>.*</code></li>
</ul>
</blockquote>
<p><code>new</code>是可以重载的!</p>
</li>
<li><p>运算符的分类:</p>
<ul>
<li><p>成员运算符: 在类内部以成员函数形式重载的运算符 ==&gt; 具有隐式的 <code>this</code>;</p>
</li>
<li><p>友元运算符: 定义在类外部（在类内部用 <code>friend</code> 声明），没有 <code>this</code> 指针.</p>
<p>因此, 一个重载函数只有一个参数时 ==&gt; 二员成员运算符 / 一元友元运算符.</p>
</li>
</ul>
</li>
<li><p>隐式转换的尝试是从左到右的:</p>
<ul>
<li><code>1+a</code>会尝试将类的对象 <code>a</code> 尝试转换为int类型.</li>
</ul>
</li>
<li><p>注意类型:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀++</span></span><br><span class="line"><span class="type">const</span> Integer&amp; Integer::<span class="keyword">operator</span>++() {</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;  <span class="comment">// 先增加</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 再返回</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀++（参数int未使用，仅用于区分）</span></span><br><span class="line"><span class="type">const</span> Integer Integer::<span class="keyword">operator</span>++(<span class="type">int</span>) {</span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">// 先保存</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);  <span class="comment">// 再增加</span></span><br><span class="line">    <span class="keyword">return</span> old;  <span class="comment">// 返回旧值</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>前缀++的返回是 <code>&amp;</code> 类型, 因为比较节省空间和时间. 后缀++的返回是值.</p>
<ul>
<li><code>[]</code> 的返回必须是 <code>&amp;</code> 类型, 这样可以作为左值赋值.</li>
</ul>
</li>
</ul>
<p>返回类型设计的<strong>总体原则</strong>：</p>
<ol>
<li><p>如果运算符需要作为左值（可以出现在赋值左侧），返回非常量引用。</p>
<ol>
<li>否则, 声明为<code>const</code>类型, 避免成为左值.</li>
</ol>
</li>
<li><p>如果运算符创建新对象，返回值（通常是常量值）。</p>
</li>
<li><p>如果运算符返回布尔结果，直接返回 <code>bool</code> 类型。</p>
</li>
<li><p>如果需要支持链式操作，返回引用。</p>
</li>
</ol>
<p>全局和成员函数的设计思路:</p>
<ol>
<li>一元运算符（如 <code>-a</code>）应该用<strong>成员函数</strong>，因为只操作一个对象</li>
<li>赋值相关运算符（<code>=</code>, <code>+=</code>, <code>[]</code>, <code>-&gt;()</code>与 <code>-&gt;*</code> 等）必须是成员函数，因为它们需要修改对象状态</li>
<li>对于二元运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)建议使用<strong>全局函数</strong>，因为：<ul>
<li>支持操作数的对称转换</li>
<li>更好地支持与其他类型的互操作</li>
<li>保持了运算符的自然语义（如 <code>3 * x</code> 和 <code>x * 3</code> 应该都能工作）</li>
</ul>
</li>
</ol>
<h2 id="C-运算符重载基础"><a href="#C-运算符重载基础" class="headerlink" title="C++运算符重载基础"></a>C++运算符重载基础</h2><p>运算符重载是C++的一项强大特性，它允许用户定义的类型像内置类型一样使用各种运算符。本质上，运算符重载是函数调用的另一种形式。</p>
<h3 id="可重载与不可重载的运算符"><a href="#可重载与不可重载的运算符" class="headerlink" title="可重载与不可重载的运算符"></a>可重载与不可重载的运算符</h3><p>C++允许重载大多数运算符，但以下<strong>运算符不能被重载</strong>：</p>
<ul>
<li><code>.</code> (成员访问运算符)</li>
<li><code>.*</code> (成员指针访问运算符)</li>
<li><code>::</code> (作用域解析运算符)</li>
<li><code>?:</code> (条件运算符)</li>
<li><code>sizeof</code> (获取类型大小)</li>
<li><code>typeid</code> (获取类型信息)</li>
<li>类型转换运算符 (<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code>)</li>
</ul>
<h3 id="运算符重载的限制"><a href="#运算符重载的限制" class="headerlink" title="运算符重载的限制"></a>运算符重载的限制</h3><ol>
<li><p><strong>只能重载已存在的运算符</strong></p>
<ul>
<li>不能创建新的运算符（如Python中的<code>**</code>）</li>
<li>可以改变运算符的语义（如重载<code>+</code>实现减法），但不推荐</li>
</ul>
</li>
<li><p><strong>运算符必须在类或枚举类型上重载</strong></p>
<ul>
<li>至少有一个操作数必须是用户定义类型</li>
</ul>
</li>
<li><p><strong>必须保持操作数数量</strong></p>
<ul>
<li>如二元运算符<code>/</code>重载后仍必须是二元的</li>
</ul>
</li>
<li><p><strong>必须保持优先级和结合律</strong></p>
<ul>
<li>运算符的优先级和结合律是固定的，不能被改变</li>
</ul>
</li>
</ol>
<h2 id="运算符重载的实现方式"><a href="#运算符重载的实现方式" class="headerlink" title="运算符重载的实现方式"></a>运算符重载的实现方式</h2><p>运算符重载本质上是一个以<code>operator</code>关键字为前缀，后跟运算符的特殊函数。</p>
<h3 id="成员函数方式"><a href="#成员函数方式" class="headerlink" title="成员函数方式"></a>成员函数方式</h3><p>作为类的成员函数实现运算符重载时：</p>
<ul>
<li>第一个操作数（左操作数）隐式为<code>this</code>指针</li>
<li>不对接收者（左操作数）执行类型转换</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> ii) : <span class="built_in">i</span>(ii) {}</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>{ <span class="keyword">return</span> i; }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载+运算符，返回新对象</span></span><br><span class="line">    <span class="type">const</span> A <span class="keyword">operator</span>+(<span class="type">const</span> A&amp; that) <span class="type">const</span> {</span><br><span class="line">        <span class="function">A <span class="title">c</span><span class="params">(<span class="keyword">this</span>-&gt;i + that.i)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    }</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>使用成员函数重载时，左操作数必须是该类的对象：</p>
<ul>
<li><code>a + b</code> 可行（a是A类对象）</li>
<li><code>a + 9</code> 可行（9会被隐式转换为A类对象）</li>
<li><code>9 + a</code> 不可行（9不是A类对象）</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p>隐式转换: 编译器查找是否存在从给出参数作为构造函数的输入, 从而创建一个指定对象的方式:</p>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer h = a + <span class="number">7</span>; <span class="comment">// 7被隐式转换为Integer</span></span><br></pre></td></tr></table></figure></div>

<p>上述发生的前提条件是 类 <code>Integer</code> 存在对应的构造函数:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Integer</span>(<span class="type">int</span> val = <span class="number">0</span>) : <span class="built_in">value</span>(val)</span><br></pre></td></tr></table></figure></div></blockquote>
<h3 id="全局函数方式"><a href="#全局函数方式" class="headerlink" title="全局函数方式"></a>全局函数方式</h3><p>作为全局函数实现运算符重载时：</p>
<ul>
<li>所有操作数都是显式参数</li>
<li>开发者不需要特殊访问类的权限</li>
<li>可能需要声明为友元函数以访问私有成员</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="type">const</span> Integer <span class="keyword">operator</span>*(<span class="type">const</span> Integer &amp;left, <span class="type">const</span> Integer&amp; right);</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以直接在全局函数中访问私有成员</span></span><br><span class="line"><span class="type">const</span> Integer <span class="keyword">operator</span>*(<span class="type">const</span> Integer &amp;left, <span class="type">const</span> Integer &amp;right)</span><br><span class="line">{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"调用全局函数*运算符: "</span> &lt;&lt; left.value &lt;&lt; <span class="string">" * "</span> &lt;&lt; right.value &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Integer</span>(left.value * right.value);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<p>当然, 全局函数实现的运算符重载, 可以通过调用类的public中的函数接口, 来间接访问内部的私有成员变量:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span>{</span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过public接口访问内部的私有成员变量.</span></span><br><span class="line"><span class="type">const</span> Integer <span class="keyword">operator</span>/(<span class="type">const</span> Integer &amp;left, <span class="type">const</span> Integer &amp;right)</span><br><span class="line">{</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"调用全局函数/运算符: "</span> &lt;&lt; left.<span class="built_in">getValue</span>() &lt;&lt; <span class="string">" / "</span> &lt;&lt; right.<span class="built_in">getValue</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (right.<span class="built_in">getValue</span>() == <span class="number">0</span>)</span><br><span class="line">    {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"错误: 除数不能为零"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Integer</span>(<span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Integer</span>(left.<span class="built_in">getValue</span>() / right.<span class="built_in">getValue</span>());</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<p>使用全局函数重载时，可以处理左操作数不是该类对象的情况：</p>
<ul>
<li><code>9 - b</code> 可行（9会被隐式转换为A类对象）</li>
<li>因为两个操作数都是普通参数，地位平等, 体现了运算符的对称性</li>
</ul>
<h3 id="成员函数vs全局函数的选择"><a href="#成员函数vs全局函数的选择" class="headerlink" title="成员函数vs全局函数的选择"></a>成员函数vs全局函数的选择</h3><ul>
<li><strong>一元运算符</strong>应该作为成员函数</li>
<li><strong>赋值运算符</strong>（<code>=</code>, <code>()</code>, <code>[]</code>, <code>-&gt;</code>, <code>-&gt;</code>）必须是成员函数</li>
<li>其他<strong>二元运算符</strong>最好作为非成员函数（全局函数）</li>
</ul>
<h2 id="参数传递与返回类型"><a href="#参数传递与返回类型" class="headerlink" title="参数传递与返回类型"></a>参数传递与返回类型</h2><h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><ol>
<li>对于只读参数，使用<code>const</code>引用传递（除了内置类型）</li>
<li>对于不修改对象的成员函数，声明为<code>const</code></li>
<li>对于全局函数，如果左操作数会被修改，使用引用传递</li>
</ol>
<h3 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h3><p>根据运算符的预期含义选择返回类型：</p>
<ol>
<li><p><strong>算术运算符</strong>（<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code>, <code>&amp;</code>, <code>|</code>, <code>~</code>）</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> T <span class="keyword">operator</span> <span class="title">X</span><span class="params">(<span class="type">const</span> T&amp; l, <span class="type">const</span> T&amp; r)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>返回新对象，不应返回引用（除非返回成员引用）</li>
<li>返回<code>const</code>对象防止<code>(a+b) = c</code>这样的操作</li>
</ul>
</li>
<li><p><strong>逻辑运算符</strong>（<code>!</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>&gt;=</code>, <code>&gt;</code>）</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="keyword">operator</span> <span class="title">X</span><span class="params">(<span class="type">const</span> T&amp; l, <span class="type">const</span> T&amp; r)</span></span>;</span><br></pre></td></tr></table></figure></div>

<ul>
<li>返回布尔值</li>
</ul>
</li>
<li><p><strong>下标运算符</strong>（<code>[]</code>）</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E&amp; T::<span class="keyword">operator</span>[](<span class="type">int</span> index);</span><br></pre></td></tr></table></figure></div>

<ul>
<li>返回左值（非<code>const</code>引用），允许<code>a[i] = value</code>操作</li>
<li>不能返回新对象，否则赋值操作无效</li>
</ul>
</li>
</ol>
<h2 id="特殊运算符重载"><a href="#特殊运算符重载" class="headerlink" title="特殊运算符重载"></a>特殊运算符重载</h2><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>C++区分前缀和后缀自增自减运算符：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前缀++</span></span><br><span class="line"><span class="type">const</span> Integer&amp; Integer::<span class="keyword">operator</span>++() {</span><br><span class="line">    *<span class="keyword">this</span> += <span class="number">1</span>;  <span class="comment">// 先增加</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 再返回</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后缀++（参数int未使用，仅用于区分）</span></span><br><span class="line"><span class="type">const</span> Integer Integer::<span class="keyword">operator</span>++(<span class="type">int</span>) {</span><br><span class="line">    <span class="function">Integer <span class="title">old</span><span class="params">(*<span class="keyword">this</span>)</span></span>;  <span class="comment">// 先保存</span></span><br><span class="line">    ++(*<span class="keyword">this</span>);  <span class="comment">// 再增加</span></span><br><span class="line">    <span class="keyword">return</span> old;  <span class="comment">// 返回旧值</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>调用方式：</p>
<ul>
<li><p><code>++x</code> 调用 <code>x.operator++()</code></p>
<ul>
<li><p>返回的是引用, 从而支持链式操作 如:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Counter g = ++(++f); <span class="comment">// 可以，因为前缀返回引用</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><code>x++</code> 调用 <code>x.operator++(0)</code></p>
<ul>
<li><p>返回的是临时的对象, 也就是旧值的副本. 声明<code>const</code>避免了后缀的链式调用</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Counter h = (f++)++; <span class="comment">// 不可以，因为后缀返回const值</span></span><br></pre></td></tr></table></figure></div>

<p>之所以要防止上述的后缀链式调用, 是因为 对<code>f++</code>继续自增将会导致语义的混乱.</p>
</li>
</ul>
</li>
</ul>
<h3 id="下标运算符"><a href="#下标运算符" class="headerlink" title="下标运算符"></a>下标运算符</h3><p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下标运算符（返回左值引用，允许修改）</span></span><br><span class="line"><span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">int</span> index) {</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"错误: 下标越界 ["</span> &lt;&lt; index &lt;&lt; <span class="string">"]"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 返回第一个元素作为应急措施（实际应用中应抛出异常）</span></span><br><span class="line">        <span class="keyword">return</span> data[<span class="number">0</span>];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下标运算符的const版本（返回值，不允许修改）</span></span><br><span class="line"><span class="type">int</span> <span class="keyword">operator</span>[](<span class="type">int</span> index) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= size) {</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">"错误: 下标越界 ["</span> &lt;&lt; index &lt;&lt; <span class="string">"]"</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 返回0作为应急措施（实际应用中应抛出异常）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> data[index];</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>





<h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符通常成对实现，可以相互利用：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>==(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> i == rhs.i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>!=(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);  <span class="comment">// 利用==运算符</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>&lt;(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> i &lt; rhs.i;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>&gt;(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> rhs &lt; *<span class="keyword">this</span>;  <span class="comment">// 利用&lt;运算符</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>&lt;=(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> !(rhs &lt; *<span class="keyword">this</span>);  <span class="comment">// 利用&lt;运算符</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> Integer::<span class="keyword">operator</span>&gt;=(<span class="type">const</span> Integer&amp; rhs) <span class="type">const</span> {</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; rhs);  <span class="comment">// 利用&lt;运算符</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="流运算符"><a href="#流运算符" class="headerlink" title="流运算符"></a>流运算符</h3><p>输入输出流运算符通常实现为全局函数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出流运算符</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="type">const</span> A&amp; a) {</span><br><span class="line">    os &lt;&lt; a.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">return</span> os;  <span class="comment">// 返回流对象以支持链式操作</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入流运算符</span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; is, A&amp; a) {</span><br><span class="line">    string line;</span><br><span class="line">    cin &gt;&gt; line;</span><br><span class="line">    <span class="comment">// 读取a的数据</span></span><br><span class="line">    <span class="keyword">return</span> is;  <span class="comment">// 返回流对象以支持链式操作</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<ul>
<li>输出流运算符的第一个参数不能是<code>const</code>，因为输出会修改流</li>
<li>输入流运算符的第二个参数不能是<code>const</code>，因为需要修改对象</li>
<li>通常需要声明为友元以访问私有成员</li>
</ul>
<h3 id="自定义流操纵符"><a href="#自定义流操纵符" class="headerlink" title="自定义流操纵符"></a>自定义流操纵符</h3><p>可以定义自己的流操纵符：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream&amp; <span class="title">tab</span><span class="params">(ostream&amp; out)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> out &lt;&lt; <span class="string">'\t'</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：cout &lt;&lt; "Hello" &lt;&lt; tab &lt;&lt; "World!" &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure></div>





<h2 id="赋值运算符与类型转换"><a href="#赋值运算符与类型转换" class="headerlink" title="赋值运算符与类型转换"></a>赋值运算符与类型转换</h2><h3 id="赋值运算符-1"><a href="#赋值运算符-1" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符有几个重要特点：</p>
<ul>
<li>必须是成员函数</li>
<li>如果不提供，编译器会自动生成（行为类似默认拷贝构造函数）</li>
<li>需要检查自赋值情况</li>
<li>确保为所有数据成员赋值</li>
<li>返回<code>*this</code>的引用</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">A&amp; A::<span class="keyword">operator</span>=(<span class="type">const</span> A&amp; rhs) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) {  <span class="comment">// 检查自赋值</span></span><br><span class="line">        <span class="comment">// 释放当前资源</span></span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 分配新资源</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[rhs.size];</span><br><span class="line">        size = rhs.size;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 复制数据</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">            data[i] = rhs.data[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回对象引用</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h4><p>C++支持两种用户定义的类型转换：</p>
<ol>
<li><p><strong>构造函数转换</strong>：从其他类型到当前类型</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PathName</span> {</span><br><span class="line">    string name;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PathName</span>(<span class="type">const</span> string&amp; s) : <span class="built_in">name</span>(s) {}  <span class="comment">// string到PathName的转换</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">abc</span><span class="params">(<span class="string">"abc"</span>)</span></span>;</span><br><span class="line">PathName xyz = abc;  <span class="comment">// 隐式转换：abc =&gt; PathName</span></span><br></pre></td></tr></table></figure></div>

<p>可以使用<code>explicit</code>关键字禁止隐式转换：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">PathName</span><span class="params">(<span class="type">const</span> string&amp; s)</span></span>;  <span class="comment">// 只能用于显式构造</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>转换运算符</strong>：从当前类型到其他类型</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rational</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span> </span>{  <span class="comment">// Rational到double的转换</span></span><br><span class="line">        <span class="keyword">return</span> numerator_ / (<span class="type">double</span>)denominator_;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">Rational <span class="title">r</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d = r;  <span class="comment">// 隐式转换：r =&gt; double</span></span><br></pre></td></tr></table></figure></div>

<p>同样可以使用<code>explicit</code>关键字要求显式转换：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="type">double</span> d = (<span class="type">double</span>)r;  <span class="comment">// 必须显式转换</span></span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>注意：如果同时提供了从T到C的构造函数和从C到T的转换运算符，编译器可能会产生歧义。</p>
<h4 id="显式转换"><a href="#显式转换" class="headerlink" title="显式转换"></a>显式转换</h4><p>显式转换的外在特点:</p>
<ul>
<li>使用直接初始化语法</li>
<li>明确指出要用构造函数创建对象</li>
<li>转换过程更加清晰可见</li>
</ul>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造函数转换：double到Rational</span></span><br><span class="line">Rational r1 = <span class="number">3.14</span>;  <span class="comment">// 隐式转换</span></span><br><span class="line"><span class="function">Rational <span class="title">r2</span><span class="params">(<span class="number">2.5</span>)</span></span>;    <span class="comment">// 显式转换</span></span><br></pre></td></tr></table></figure></div>



<p>如果声明 <code>explict</code>, 就必须使用强制的显式转换:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果想要强制显式转换，应该这样声明：</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Rational</span><span class="params">(<span class="type">double</span> value)</span> </span>{</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> PRECISION = <span class="number">10000</span>;</span><br><span class="line">    numerator = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(value * PRECISION);</span><br><span class="line">    denominator = PRECISION;</span><br><span class="line">    <span class="built_in">simplify</span>();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Rational r1 = <span class="number">3.14</span>;        <span class="comment">// 错误：不允许隐式转换</span></span><br><span class="line"><span class="function">Rational <span class="title">r2</span><span class="params">(<span class="number">2.5</span>)</span></span>;          <span class="comment">// 正确：显式构造</span></span><br><span class="line">Rational r3 = <span class="built_in">Rational</span>(<span class="number">3.14</span>); <span class="comment">// 正确：显式转换</span></span><br></pre></td></tr></table></figure></div>



<p>类型的显式转换:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d2 = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(r2);  <span class="comment">// 显式转换</span></span><br></pre></td></tr></table></figure></div>



<h4 id="混合类型的转换"><a href="#混合类型的转换" class="headerlink" title="混合类型的转换"></a>混合类型的转换</h4><p>根据运算结果, 自动地将运算的操作数进行类型转换:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 混合类型运算</span></span><br><span class="line"><span class="function">Rational <span class="title">r3</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="type">double</span> d3 = <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里会将r3转换为double，然后进行double加法</span></span><br><span class="line"><span class="type">double</span> result = r3 + d3;</span><br></pre></td></tr></table></figure></div>



<h1 id="Template"><a href="#Template" class="headerlink" title="Template"></a>Template</h1><h2 id="模板概述"><a href="#模板概述" class="headerlink" title="模板概述"></a>模板概述</h2><p>模板是C++中实现**<u>泛型编程</u>**的核心机制，允许我们编写可以处理不同数据类型的代码，而不必为每种类型重复编写相同的逻辑。</p>
<ul>
<li><p>首先尝试匹配普通的函数, 否则尝试匹配模板函数</p>
</li>
<li><p>函数模板是声明, 而非定义. 是在实际调用时候去 <strong><u>实例化</u></strong> 对应类型的函数.</p>
</li>
<li><p>必须都放在头文件的实现包含:</p>
<ul>
<li><p>函数模板;</p>
</li>
<li><p>inline函数</p>
</li>
<li><p>带有default参数的声明.</p>
</li>
<li><p>类模板的成员函数</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;T&gt;</span><br><span class="line"><span class="type">int</span> Vector&lt;T&gt;::<span class="built_in">getSize</span>()<span class="type">const</span>{</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>注意, 都需要声明模板类, 并且需要在 <code>&lt; &gt;</code>内部声明类.</p>
</li>
</ul>
</li>
<li><p><code>template&lt;class T&gt;</code> 和 <code>template&lt;typename T&gt;</code> 是等价的, 后者是后来引入的更明确的语法.</p>
</li>
<li><p>类模板的每个成员函数在类外定义时，都必须以<code>template&lt;class T&gt;</code>（或<code>template&lt;typename T&gt;</code>）开头，即使该成员函数没有直接使用模板参数T.</p>
</li>
<li><p><code>Vector&lt; int (*)&gt;</code></p>
</li>
</ul>
<h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><h3 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; x, T&amp; y)</span> </span>{</span><br><span class="line">    T temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>template</code> 关键字引入模板声明</li>
<li><code>class T</code> 指定参数化类型名称（<code>class</code>在这里表示任何内置类型或用户定义类型）</li>
<li>在模板内部，<code>T</code> 被用作类型名称</li>
</ul>
<h3 id="模板实例化"><a href="#模板实例化" class="headerlink" title="模板实例化"></a>模板实例化</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">3</span>, j = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">swap</span>(i, j);  <span class="comment">// 使用int类型的swap</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> k = <span class="number">4.5</span>, m = <span class="number">3.7</span>;</span><br><span class="line"><span class="built_in">swap</span>(k, m);  <span class="comment">// 实例化float类型的swap</span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">s</span><span class="params">(<span class="string">"Hello"</span>)</span>, <span class="title">t</span><span class="params">(<span class="string">"World"</span>)</span></span>;</span><br><span class="line"><span class="built_in">swap</span>(s, t);  <span class="comment">// 实例化std::string类型的swap</span></span><br></pre></td></tr></table></figure></div>

<p>编译器会根据传入的参数类型自动生成相应的函数实例。</p>
<h3 id="模板匹配规则"><a href="#模板匹配规则" class="headerlink" title="模板匹配规则"></a>模板匹配规则</h3><ul>
<li>只使用类型的精确匹配</li>
<li>不应用类型转换操作</li>
<li>即使是隐式转换也会被忽略</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>(<span class="type">int</span>, <span class="type">int</span>);     <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">swap</span>(<span class="type">double</span>, <span class="type">double</span>); <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">swap</span>(<span class="type">int</span>, <span class="type">double</span>);  <span class="comment">// 错误！类型不匹配</span></span><br></pre></td></tr></table></figure></div>

<h3 id="模板函数与普通函数共存"><a href="#模板函数与普通函数共存" class="headerlink" title="模板函数与普通函数共存"></a>模板函数与普通函数共存</h3><p>如果同时存在模板函数和普通函数，编译器会优先选择**<u>普通函数</u>**.</p>
<h4 id="显式指定"><a href="#显式指定" class="headerlink" title="显式指定"></a>显式指定</h4><p>可以显式地指定模板参数类型:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有返回值的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">myMax</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"调用模板版本的myMax"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  cout &lt;&lt; <span class="string">"myMax&lt;double&gt;(10, 20.5) = "</span> &lt;&lt; <span class="built_in">myMax</span>&lt;<span class="type">double</span>&gt;(<span class="number">10</span>, <span class="number">20.5</span>) &lt;&lt; endl; </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// myMax(10, 20.5);  // 错误：参数类型不一致</span></span><br></pre></td></tr></table></figure></div>



<h4 id="多参数的函数模板"><a href="#多参数的函数模板" class="headerlink" title="多参数的函数模板"></a>多参数的函数模板</h4><p>同理的, 我们可以设置多个参数类型, 根据输入的类型来推断:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="function">T1 <span class="title">myMax</span><span class="params">(T1 a, T2 b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    cout &lt;&lt; <span class="string">"调用模板版本的myMax2"</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">  cout &lt;&lt;  <span class="built_in">myMax</span>(<span class="number">10</span>, <span class="number">20.5</span>) &lt;&lt; endl; </span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p> 此时, 上述的函数不需要显式的声明参数类型, 因为存在匹配的模板函数.</p>
<p>同时, 此时根据类型推断, 返回的类型是 <code>int</code>, 然后舍弃 20.5的小数部分, 最终的结果是 <code>20</code>.</p>
<h2 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h2><h3 id="基本语法-2"><a href="#基本语法-2" class="headerlink" title="基本语法"></a>基本语法</h3><p>此处的 <code>Vector</code>是自己定义的.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">int</span>);</span><br><span class="line">    ~<span class="built_in">Vector</span>();</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">const</span> Vector&amp;);</span><br><span class="line">    Vector&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Vector&amp;);</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="type">int</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_elements;</span><br><span class="line">    <span class="type">int</span> m_size;</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h3 id="类模板的使用"><a href="#类模板的使用" class="headerlink" title="类模板的使用"></a>类模板的使用</h3><p>类模板必须显式指定类型参数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">Vector&lt;Complex&gt; <span class="title">v2</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">v1[<span class="number">20</span>] = <span class="number">10</span>;</span><br><span class="line">v2[<span class="number">20</span>] = v1[<span class="number">20</span>];  <span class="comment">// 如果定义了int到Complex的转换，则正确</span></span><br></pre></td></tr></table></figure></div>

<h3 id="类模板成员函数的定义"><a href="#类模板成员函数的定义" class="headerlink" title="类模板成员函数的定义"></a>类模板成员函数的定义</h3><p>所有成员函数定义都需要包含模板声明：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">Vector&lt;T&gt;::<span class="built_in">Vector</span>(<span class="type">int</span> size) : <span class="built_in">m_size</span>(size) {</span><br><span class="line">    m_elements = <span class="keyword">new</span> T[m_size];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T&amp; Vector&lt;T&gt;::<span class="keyword">operator</span>[](<span class="type">int</span> indx) {</span><br><span class="line">    <span class="keyword">if</span> (indx &lt; m_size &amp;&amp; indx &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> m_elements[indx];</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 错误处理</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>注意：</p>
<ul>
<li>每个成员函数定义前都要加上 <code>template &lt;class T&gt;</code></li>
<li>类名必须写为 <code>Vector&lt;T&gt;</code></li>
<li>类模板的函数通常在头文件中实现，不需要分离的.cpp文件</li>
</ul>
<h2 id="多参数模板"><a href="#多参数模板" class="headerlink" title="多参数模板"></a>多参数模板</h2><p>模板可以使用多个类型参数：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> {</span><br><span class="line">    <span class="function"><span class="type">const</span> Value&amp; <span class="title">lookup</span><span class="params">(<span class="type">const</span> Key&amp;)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">install</span><span class="params">(<span class="type">const</span> Key&amp;, <span class="type">const</span> Value&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<h2 id="嵌套模板"><a href="#嵌套模板" class="headerlink" title="嵌套模板"></a>嵌套模板</h2><p>模板可以嵌套使用，因为它们只是新的类型：</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vector&lt;Vector&lt;<span class="type">double</span>&gt;&gt; matrix;  <span class="comment">// 注意C++11之前需要空格：Vector&lt;Vector&lt;double&gt; &gt;</span></span><br><span class="line">Vector&lt;<span class="built_in">int</span> (*)(Vector&lt;<span class="type">double</span>&gt;&amp;, <span class="type">int</span>)&gt; functionPointers;  <span class="comment">// 函数指针的向量</span></span><br></pre></td></tr></table></figure></div>



<h4 id="非类型模板参数"><a href="#非类型模板参数" class="headerlink" title="非类型模板参数"></a>非类型模板参数</h4><p>~也就是没有使用模板类型的普通参数.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Key</span>, <span class="keyword">class</span> <span class="title class_">Value</span>, <span class="type">int</span> TableSize = <span class="number">10</span>&gt;</span><br><span class="line"><span class="keyword">class</span> HashTable {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<p>其中的 <code>TableSize</code> 就是普通的参数. 在编译时就确定了类型.</p>
<h2 id="模板的局限性与注意事项"><a href="#模板的局限性与注意事项" class="headerlink" title="模板的局限性与注意事项"></a>模板的局限性与注意事项</h2><ol>
<li>模板代码通常放在头文件中，因为编译器需要在编译时看到完整的模板定义</li>
<li>模板错误通常在实例化时才会被发现，错误信息可能很复杂</li>
<li>模板可能导致代码膨胀，因为每种类型都会生成一份代码</li>
<li>模板参数必须支持模板中使用的所有操作</li>
</ol>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><ul>
<li>使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.<ul>
<li>另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.</li>
</ul>
</li>
</ul>
<h2 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h2><h3 id="继承关系中的访问控制"><a href="#继承关系中的访问控制" class="headerlink" title="继承关系中的访问控制"></a>继承关系中的访问控制</h3><p>控制基类成员在派生类中的可见性：</p>
<ul>
<li><code>public</code>：基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>，<code>protected</code> 成员仍然是 <code>protected</code>。</li>
<li><code>protected</code>：基类的 <code>public</code> 和 <code>protected</code>成员在派生类中都变为 <code>protected</code>。</li>
<li><code>private</code>：基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>
</ul>
<h2 id="作用域与生存期"><a href="#作用域与生存期" class="headerlink" title="作用域与生存期"></a>作用域与生存期</h2><p>本地: 均为本地</p>
<p>全局: 均为全局</p>
<p>静态本地: 作用域是本地, 生存期是全局</p>
<p>静态全局: ~</p>
<h2 id="Includes"><a href="#Includes" class="headerlink" title="Includes"></a>Includes</h2><h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p><code>copy(first, last, result)</code>:</p>
<ul>
<li><code>fisrt</code>和<code>last</code>是输入迭代器, 表示要复制的范围, 左闭右开即<code>last</code>应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;</li>
<li><code>result</code>是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作<ul>
<li>e.g.<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; source = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">destination</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 确保目标容器有足够的空间</span></span><br><span class="line"></span><br><span class="line">std::<span class="built_in">copy</span>(source.<span class="built_in">begin</span>(), source.<span class="built_in">end</span>(), destination.<span class="built_in">begin</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> num : destination) {</span><br><span class="line">    std::cout &lt;&lt; num &lt;&lt; <span class="string">" "</span>; <span class="comment">// 输出：1 2 3 4 5</span></span><br><span class="line">}</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><code>result</code>可以直接输出到<code>cout</code>中.  <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++){</span><br><span class="line">    vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>()<span class="number">+2</span>); <span class="comment">//删除第三个元素</span></span><br><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">","</span>));</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 0,1,3,4,</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<hr>
<ul>
<li>数组之间<strong>不可以</strong>直接赋值, 但是字符串可以直接赋值</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">"World"</span>;</span><br><span class="line">str1 = str2;  <span class="comment">// 错误，数组之间不可以直接赋值</span></span><br><span class="line"></span><br><span class="line">string s1 = <span class="string">"Hello"</span>;</span><br><span class="line">string s2 = <span class="string">"World"</span>;</span><br><span class="line">s1 = s2;  <span class="comment">// 正确，字符串可以直接赋值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">"Hello"</span>;</span><br><span class="line">string s2 = <span class="string">"World"</span>;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"初始状态："</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"s1: "</span> &lt;&lt; s1 &lt;&lt; endl;  <span class="comment">// 输出：Hello</span></span><br><span class="line">cout &lt;&lt; <span class="string">"s2: "</span> &lt;&lt; s2 &lt;&lt; endl;  <span class="comment">// 输出：World</span></span><br><span class="line"></span><br><span class="line">s1 = s2;  <span class="comment">// 赋值操作</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">"赋值后："</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"s1: "</span> &lt;&lt; s1 &lt;&lt; endl;  <span class="comment">// 输出：World</span></span><br><span class="line">cout &lt;&lt; <span class="string">"s2: "</span> &lt;&lt; s2 &lt;&lt; endl;  <span class="comment">// 输出：World</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 s2 不会影响 s1，因为是深拷贝</span></span><br><span class="line">s2 = <span class="string">"Changed"</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">"修改 s2 后："</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">"s1: "</span> &lt;&lt; s1 &lt;&lt; endl;  <span class="comment">// 输出：World</span></span><br><span class="line">cout &lt;&lt; <span class="string">"s2: "</span> &lt;&lt; s2 &lt;&lt; endl;  <span class="comment">// 输出：Changed</span></span><br></pre></td></tr></table></figure></div>

<h2 id="Temp"><a href="#Temp" class="headerlink" title="Temp"></a>Temp</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代器</span></span><br><span class="line">I.<span class="built_in">begin</span>();</span><br><span class="line">I.<span class="built_in">end</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Item Access</span></span><br><span class="line">V.<span class="built_in">front</span>();;</span><br><span class="line">V.<span class="built_in">back</span>();</span><br></pre></td></tr></table></figure></div>

<h2 id="区分"><a href="#区分" class="headerlink" title="区分"></a>区分</h2><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p><code>find</code>是字符串类的一种方法, 同时也是标准库<code>algorithm</code>中的一个函数.</p>
<ul>
<li><code>find</code>方法: 用于在字符串中查找子字符串的位置。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="type">size_t</span> pos = str.<span class="built_in">find</span>(<span class="string">"World"</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != string::npos) {</span><br><span class="line">    cout &lt;&lt; <span class="string">"Found 'World' at position "</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<ul>
<li><code>algorithm</code>中的<code>find</code>函数: 用于在容器（如数组、向量等）中查找元素。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>};</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;::iterator it = <span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) {</span><br><span class="line">        cout &lt;&lt; <span class="string">"Found 3 at position "</span> &lt;&lt; <span class="built_in">distance</span>(vec.<span class="built_in">begin</span>(), it) &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Found 3 at position 2</span></span><br></pre></td></tr></table></figure></div>
<blockquote>
<p>编译: <code>g++ -std=c++11 test.cpp -o test</code></p>
</blockquote>
<h3 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h3><ul>
<li>对于字符串的方法: <code>str.erase(pos, len)</code><ul>
<li>删除从指定位置开始的指定个数字符</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">"Hello World"</span>;</span><br><span class="line">str.<span class="built_in">erase</span>(<span class="number">6</span>, <span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;  <span class="comment">// 输出: Hello</span></span><br></pre></td></tr></table></figure></div>

<hr>
<ul>
<li>对于容器的方法: <code>erase(pos1, pos2)</code><ul>
<li>左闭右开式删除容器当中的元素.</li>
</ul>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = {<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>};</span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Original vector: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : vec) {</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素</span></span><br><span class="line">    vec.<span class="built_in">erase</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, vec.<span class="built_in">begin</span>() + <span class="number">4</span>); <span class="comment">// 删除 vec[1], vec[2], vec[3]</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">"Modified vector: "</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : vec) {</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 输出 "1 5 6"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h2 id="不知道放在哪里的代码块"><a href="#不知道放在哪里的代码块" class="headerlink" title="不知道放在哪里的代码块"></a>不知道放在哪里的代码块</h2><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 1. 创建并填充链表</span></span><br><span class="line">list&lt;<span class="type">int</span>&gt; L;                      <span class="comment">// 创建一个空的整数链表</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; ++i)          <span class="comment">// 循环5次</span></span><br><span class="line">    L.<span class="built_in">push_back</span>(i);              <span class="comment">// 依次在链表尾部添加数字1,2,3,4,5</span></span><br><span class="line">                                 <span class="comment">// 此时链表内容为：1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 删除第二个元素</span></span><br><span class="line">L.<span class="built_in">erase</span>( ++L.<span class="built_in">begin</span>() );          <span class="comment">// L.begin()指向第一个元素</span></span><br><span class="line">                                 <span class="comment">// ++L.begin()指向第二个元素</span></span><br><span class="line">                                 <span class="comment">// erase删除迭代器指向的元素</span></span><br><span class="line">                                 <span class="comment">// 此时链表内容为：1,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 打印链表内容</span></span><br><span class="line"><span class="built_in">copy</span>(                            <span class="comment">// 标准库算法，用于复制序列</span></span><br><span class="line">    L.<span class="built_in">begin</span>(),                   <span class="comment">// 源序列的起始位置</span></span><br><span class="line">    L.<span class="built_in">end</span>(),                     <span class="comment">// 源序列的结束位置</span></span><br><span class="line">    <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(       <span class="comment">// 输出流迭代器</span></span><br><span class="line">        cout,                    <span class="comment">// 指定输出到标准输出</span></span><br><span class="line">        <span class="string">","</span>                      <span class="comment">// 每个元素后面追加的分隔符</span></span><br><span class="line">    )</span><br><span class="line">);</span><br><span class="line">cout &lt;&lt; endl;                    <span class="comment">// 换行</span></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h1 id="课堂缓冲区"><a href="#课堂缓冲区" class="headerlink" title="课堂缓冲区"></a>课堂缓冲区</h1><ul>
<li><p>私有的边界是 <code>class</code>而非对象. 也就是说, <strong>相同类的对象可以直接访问对方的私有属性</strong>.</p>
</li>
<li><p>不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们之间没有初始化的依赖.</p>
</li>
<li><p>需要尽可能地避免使用全局变量.</p>
</li>
<li><p>一个良好的习惯: 当成员函数不需要改变成员变量的值时, 在后面加上 <code>const</code>的关键字, 确保不会改变;</p>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* s = <span class="string">"Hello,world！"</span>；</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>此时的右侧字符串位于 段 <code>text</code>, 不可写. <code>s</code>本身是一个固定内存的指针.</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s［］ = <span class="string">"Hello,world！"</span>；</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>此时的 <code>s</code>是一个大小等于数组内容的对象.</p>
</blockquote>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 只能将函数的返回值赋值给一个 const int*</span></span><br></pre></td></tr></table></figure></div>



<h4 id="函数内部的对象的空间分配"><a href="#函数内部的对象的空间分配" class="headerlink" title="函数内部的对象的空间分配"></a>函数内部的对象的空间分配</h4><p>编译器在编译的时候计算得到函数内部所有的对象的空间, 在实际进入函数的时候**, 立即分配所有对象的空间;**</p>
<ul>
<li>实际执行到的时候发生构造.</li>
</ul>
<h4 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h4><p>静态全局、本地和成员变量都存储于全局数据区.</p>
<ul>
<li>静态成员变量的构造也在 <code>main()</code>之前.</li>
</ul>
<h1 id="题目梳理"><a href="#题目梳理" class="headerlink" title="题目梳理"></a>题目梳理</h1><h2 id="HW2"><a href="#HW2" class="headerlink" title="HW2"></a>HW2</h2><p><img lazyload="" src="/images/loading.svg" data-src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedundefinedundefinedimage-20250225160042809.png?imageSlim"></p>
<ul>
<li>ANS:  B</li>
<li>由于此处的<code>map</code>以<code>char *</code>作为key, 同时初始化<code>str</code>的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.</li>
</ul>
<hr>
<p><img lazyload="" src="/images/loading.svg" data-src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250225160652522.png?imageSlim"></p>
<ul>
<li>逗号表达式, 从左到右分别计算,最后返回的结果是最右侧的值, 此处为1.</li>
</ul>
<blockquote>
<ul>
<li><p><code>vector&lt;int&gt; v(10);</code> 创建包含10个元素的容器, 每个元素初始化为 <code>0</code>;</p>
</li>
<li><p><code>vector &lt;int&gt; v(10, 1);</code>: 创建包含10个元素的容器, 但是都初始化为 <code>1</code>;</p>
</li>
<li><p><code>vector &lt;int&gt; v{10, 1};</code>: 创建包含10,1 这2个元素的容器;</p>
</li>
<li><p>此外, 还可以使用 <code>vector &lt;int&gt; v</code>;创建一个空的容器; </p>
</li>
<li><p>同时也还可以用 <strong>迭代器</strong>进行初始化: <code>vector &lt;int&gt; v(arr, arr + 5);</code></p>
</li>
</ul>
</blockquote>
<h2 id="HW3"><a href="#HW3" class="headerlink" title="HW3"></a>HW3</h2><ul>
<li>类成员的默认访问权限是 <strong><u>私有的</u></strong>, 即不显式声明访问修饰符, 默认为 <code>private</code>;</li>
</ul>
<h2 id="HW4"><a href="#HW4" class="headerlink" title="HW4"></a>HW4</h2><h3 id="可变大小矩阵"><a href="#可变大小矩阵" class="headerlink" title="可变大小矩阵:"></a>可变大小矩阵:</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span>{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> r,c;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; m; <span class="comment">// 二维向量, 每个向量元素是一个一维向量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="type">int</span> r, <span class="type">int</span> c) : <span class="built_in">r</span>(r),<span class="built_in">c</span>(c){</span><br><span class="line">        m.<span class="built_in">resize</span>(r, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(c)); <span class="comment">// 分配r个一维向量, 每个一维向量的大小为c</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">transform</span><span class="params">()</span></span>{</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">new_m</span>(c, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r,<span class="number">0</span>)); <span class="comment">//	声明一个临时的二维向量</span></span><br><span class="line">        </span><br><span class="line">    	<span class="comment">// 将矩阵转置, 放入临时的向量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c; i++){</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span> ; j&lt; r; j++){</span><br><span class="line">                new_m[i][j] = m[j][i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="built_in">swap</span>(r,c); <span class="comment">//改变矩阵的行与列</span></span><br><span class="line">        m = <span class="built_in">move</span>(new_m); <span class="comment">//使用 move 直接将临时变量的所有权交给m, 避免拷贝</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>此处值得注意的是 <code>resize</code>在二维向量中的使用, 以及 <code>move</code>直接给予“所有权”的特性.</p>
</blockquote>
<h2 id="HW5"><a href="#HW5" class="headerlink" title="HW5"></a>HW5</h2><p><strong>判断题</strong>: const成员函数不能作用于非const对象</p>
<blockquote>
<p>答案是 <strong>False</strong>. </p>
<p>题目的意思大致是: 非const对象无法调用 const对象, 实际上是事实是相反的描述. 只需要理解题目的表述即可做出判断.</p>
</blockquote>
<h2 id="HW6"><a href="#HW6" class="headerlink" title="HW6"></a>HW6</h2><p>右值引用本身是一个左值, 可以取地址.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>&amp;&amp; r = <span class="number">5</span>;</span><br><span class="line">std::cout &lt;&lt; r; <span class="comment">// r 在这里是左值，因为它有名字</span></span><br></pre></td></tr></table></figure></div>



<h2 id="HW7"><a href="#HW7" class="headerlink" title="HW7"></a>HW7</h2><h2 id="HW9"><a href="#HW9" class="headerlink" title="HW9"></a>HW9</h2><ol>
<li><p>因为静态成员函数不能是虚函数，所以它们不能实现多态</p>
<ul>
<li>静态成员函数不与类的任何具体实例（对象）相关联;</li>
</ul>
</li>
<li><p>在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类A</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"A的构造函数被调用"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>()</span><br><span class="line">    {</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"B的构造函数被调用"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类C，继承自A和B</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A, <span class="keyword">public</span> B</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数中显式调用基类构造函数</span></span><br><span class="line">    <span class="built_in">C</span>() : <span class="built_in">B</span>(), <span class="built_in">A</span>()</span><br><span class="line">    { <span class="comment">// 注意：这里虽然B在A之前，但实际调用顺序由类定义决定</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">"C的构造函数被调用"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    C c; <span class="comment">// 创建C的实例</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>输出:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A的构造函数被调用</span><br><span class="line">B的构造函数被调用</span><br><span class="line">C的构造函数被调用</span><br></pre></td></tr></table></figure></div>

<p>由此可见, 虽然在C的初始化列表中声明了B前A后, 但是实际上A优先调用.</p>
</li>
<li><p><del>如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针）</del></p>
<ul>
<li><p>这句话的括号内部是错误的.</p>
</li>
<li><p>因为我们依旧可以将其的子类 <code>upcast</code></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">ptr</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">ptr</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"B"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    A *a = <span class="keyword">new</span> <span class="built_in">B</span>();</span><br><span class="line">    a-&gt;<span class="built_in">ptr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
</ol>
<ul>
<li><p>类内的纯虚函数被认为是 <code>inline</code>的函数;</p>
</li>
<li><p>在创建派生类的对象时, 构造函数的执行顺序为—— 基类对象-&gt;对象成员-&gt;派生类自身:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() { cout &lt;&lt; <span class="string">"Base 构造函数"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Member</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Member</span>() { cout &lt;&lt; <span class="string">"Member 构造函数"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base</span><br><span class="line">{</span><br><span class="line">    Member m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>() { cout &lt;&lt; <span class="string">"Derived 构造函数"</span> &lt;&lt; endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>输出:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Base 构造函数</span><br><span class="line">Member 构造函数</span><br><span class="line">Derived 构造函数</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>私有继承问题: 可以通过方法访问私有继承的public, protected的基类成员(不包括私有成员), 但是无法直接访问.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>; <span class="comment">// 私有</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>; <span class="comment">// 保护</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>; <span class="comment">// 公有</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">private</span> Base</span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> d = <span class="number">4</span>; <span class="comment">// 派生类自己的私有成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="comment">// cout &lt;&lt; a;  // ❌ 错误！Base 的私有成员 a，派生类根本不能访问</span></span><br><span class="line">        cout &lt;&lt; b &lt;&lt; endl; <span class="comment">// ✅ OK：Base 的 protected 成员，在 Derived 中变成了 private</span></span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl; <span class="comment">// ✅ OK：Base 的 public 成员，在 Derived 中变成了 private</span></span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl; <span class="comment">// ✅ OK：Derived 的私有成员当然能访问</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Derived d;</span><br><span class="line">    d.<span class="built_in">show</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; d.b; // ❌ 错误！Base 的 protected 成员，在 Derived 中变成了 private</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>虚函数也具有 <code>this</code> 指针.</p>
</li>
<li><p>在构造函数中调用虚函数，不是动态联编</p>
<ul>
<li>原因是：<strong>对象还未完全构造完成（或已经开始析构）时，虚函数表（vtable）可能尚未指向最终派生类</strong>.</li>
<li>所以，在构造函数中调用虚函数时，<strong>只会调用当前类中该函数的版本</strong>，不会发生多态。</li>
</ul>
</li>
</ul>
<h4 id="虚析构函数-1"><a href="#虚析构函数-1" class="headerlink" title="虚析构函数"></a>虚析构函数</h4><ul>
<li>为了在多重继承的时候, 可以正确的调用各个阶段的析构函数, 我们需要声明基类的析构为虚函数, 然后在子类中重写:</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">CRAFT</span>()</span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt; <span class="string">"销毁航行器(速度: "</span> &lt;&lt; speed &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">~<span class="built_in">PLANE</span>() <span class="keyword">override</span></span><br><span class="line">{</span><br><span class="line">    cout &lt;&lt; <span class="string">"销毁飞机(翼展: "</span> &lt;&lt; width &lt;&lt; <span class="string">")"</span> &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<ul>
<li><p>菱形继承的时候, 注意 <code>virtual public</code>的声明 以及 在底层的子类中的初始化列表的顺序!</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SEAPLANE</span>(<span class="type">float</span> speed, <span class="type">float</span> width, <span class="type">float</span> depth) : <span class="built_in">CRAFT</span>(speed), <span class="built_in">PLANE</span>(speed, width), <span class="built_in">SHIP</span>(speed, depth)</span><br><span class="line">{</span><br><span class="line">  ...</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h2 id="HW10"><a href="#HW10" class="headerlink" title="HW10"></a>HW10</h2><ul>
<li>判断: 对象间赋值将调用拷贝构造函数。  <ul>
<li>错误. 对象间的赋值调用的是 <u>拷贝复赋值运算符</u>.</li>
</ul>
</li>
</ul>
<h4 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h4><p><img lazyload="" src="/images/loading.svg" data-src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250423094724267.png?imageSlim" alt="image-20250423094724267"></p>
<ul>
<li><strong>A</strong>是错误的。C++允许自定义异常类，可以继承标准异常类如std::exception。</li>
<li><strong>B</strong>是正确的，C++异常机制会在异常抛出前自动销毁局部对象。</li>
<li><strong>C</strong>是正确的，抛出异常时对象会被拷贝（或移动）到catch块中。</li>
<li><strong>D</strong>是正确的，在catch块中可以使用对象引用来接收异常对象。</li>
</ul>
<h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><ul>
<li><p>语法:</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名&amp; <span class="keyword">operator</span>=(<span class="type">const</span> 类名&amp; 对象名)</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>特点:</p>
<ul>
<li>返回类型是类的引用（为了支持连续赋值 a=b=c）</li>
<li>参数是const引用（防止修改原对象）</li>
<li>通常需要先释放自己的资源，再复制数据</li>
</ul>
</li>
</ul>
<p>e.g.</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; a) {</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;a) {  <span class="comment">// 防止自赋值</span></span><br><span class="line">        <span class="keyword">delete</span>[] data;  <span class="comment">// 释放原有内存</span></span><br><span class="line">        size = a.size;  <span class="comment">// 复制大小</span></span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">int</span>[size];  <span class="comment">// 分配新内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {  <span class="comment">// 复制数据</span></span><br><span class="line">            data[i] = a.data[i];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回对象自身的引用</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h2 id="W12"><a href="#W12" class="headerlink" title="W12"></a>W12</h2><ul>
<li>建立类模板对象的实例化过程为: <code>模板类-对象</code>.<ul>
<li>编译器根据提供的模板参数将类模板实例化为一个具体的模板类（也称为实例化类或特化类），然后才能创建该模板类的对象。</li>
<li>类模板的使用实际上是将类模板实例化成一个 <code>类</code></li>
</ul>
</li>
<li>类模板与模板类<ul>
<li>类模板是类的蓝图或规范，它本身不是一个类</li>
<li>模板类（或实例化类、特化类）是使用具体的类型参数实例化类模板后得到的具体的类。</li>
</ul>
</li>
<li>类模板和函数模板的实例化的时期 – 均为<code>编译时期</code><ul>
<li>函数模板在编译时期检查定义中的基本语法;</li>
<li>尝试调用某一个函数模板时, 编译器根据实际的参数类型来推导模板参数类型/或者由显式指定类型得到, 如果合法就生成函数实例(i.e. <em><strong>模板函数</strong></em>), 这个过程就是模板实例化(生成代码).</li>
</ul>
</li>
<li>除了使用构造函数, 还可以直接调用 <code>make_pair</code> 让编译器自动推导类型来创建pair对象;</li>
<li></li>
</ul>
<h2 id="L3"><a href="#L3" class="headerlink" title="L3"></a>L3</h2><blockquote>
<p>[!NOTE]</p>
<ol>
<li>内联函数在 <strong><u>编译时展开</u></strong>, 而不是运行时.</li>
<li>内联函数的声明以及最终的生效与否, 是由 <strong><u>编译器</u></strong> 决定的. 也就是说, 无论是否存在 inline 的声明, 编译器最终决定函数的类型.</li>
</ol>
</blockquote>
<h3 id="C-初始化列表与成员变量初始化"><a href="#C-初始化列表与成员变量初始化" class="headerlink" title="C++ 初始化列表与成员变量初始化"></a>C++ 初始化列表与成员变量初始化</h3><blockquote>
<p>[!NOTE]</p>
<ul>
<li><code>int</code>和自己定义的类都是cpp的类, 所以可以直接在初始化列表中用 <code>:class_instance{input},...{}</code>来初始化类内的类对象.</li>
<li>推荐使用 <code>{}</code>来初始化, 不会产生是函数的歧义.</li>
</ul>
</blockquote>
<h4 id="1-构造顺序"><a href="#1-构造顺序" class="headerlink" title="1. 构造顺序"></a>1. 构造顺序</h4><ul>
<li>在 C++ 中，<strong>成员变量的初始化顺序由它们在类中声明的顺序决定</strong>，而不是在初始化列表中的顺序。</li>
<li>初始化列表用于 <strong>直接初始化</strong> 成员变量，而不是在构造函数体内先创建未初始化的对象再赋值。</li>
</ul>
<h4 id="2-为什么必须使用初始化列表？"><a href="#2-为什么必须使用初始化列表？" class="headerlink" title="2. 为什么必须使用初始化列表？"></a>2. 为什么必须使用初始化列表？</h4><ul>
<li><strong>成员变量在进入构造函数体之前就已经完成了初始化</strong>，不能在构造函数体内赋值来替代初始化。</li>
<li><strong>如果成员变量是一个没有默认构造函数的对象</strong>，必须在初始化列表中显式调用其构造函数，否则编译会报错。</li>
<li>在构造函数体内赋值，意味着：<ol>
<li>先调用默认构造函数创建对象（如果 <code>NumberDisplay</code> 没有默认构造函数，这一步会失败）。</li>
<li>然后使用赋值运算符进行赋值，而赋值运算与初始化是不同的过程。</li>
</ol>
</li>
</ul>
<h4 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. 示例代码</h4><h4 id="❌-错误示例（可能会编译失败）"><a href="#❌-错误示例（可能会编译失败）" class="headerlink" title="❌ 错误示例（可能会编译失败）"></a>❌ 错误示例（可能会编译失败）</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberDisplay</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumberDisplay</span>(<span class="type">int</span> max) { <span class="comment">/* 初始化代码 */</span> }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NumberDisplay hour_display;</span><br><span class="line">    NumberDisplay minute_display;</span><br><span class="line">    NumberDisplay second_display;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Clock</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second) { <span class="comment">// ❌ 错误：NumberDisplay 没有默认构造函数</span></span><br><span class="line">        hour_display = <span class="built_in">NumberDisplay</span>(<span class="number">24</span>);     <span class="comment">// 不能这样赋值</span></span><br><span class="line">        minute_display = <span class="built_in">NumberDisplay</span>(<span class="number">60</span>);</span><br><span class="line">        second_display = <span class="built_in">NumberDisplay</span>(<span class="number">60</span>);</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="✅-正确示例"><a href="#✅-正确示例" class="headerlink" title="✅ 正确示例"></a><strong>✅ 正确示例</strong></h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Clock</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NumberDisplay hour_display;</span><br><span class="line">    NumberDisplay minute_display;</span><br><span class="line">    NumberDisplay second_display;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 使用初始化列表</span></span><br><span class="line">    <span class="built_in">Clock</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span><br><span class="line">        : <span class="built_in">hour_display</span>(<span class="number">24</span>), <span class="built_in">minute_display</span>(<span class="number">60</span>), <span class="built_in">second_display</span>(<span class="number">60</span>) {</span><br><span class="line">        <span class="comment">// 构造函数体内的代码可以进行额外的赋值操作</span></span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure></div>



<p><strong>4. 结论</strong></p>
<p>​	•	<strong>所有成员变量都会在构造函数体执行前被初始化</strong>，不能依赖在构造函数体内赋值。</p>
<p>​	•	<strong>如果成员变量是没有默认构造函数的对象</strong>，必须使用初始化列表进行初始化，否则会导致编译错误。</p>
<p>​	•	<strong>初始化列表的顺序应与成员变量的声明顺序一致</strong>，否则可能会导致未定义行为。</p>
<h2 id="Project"><a href="#Project" class="headerlink" title="Project"></a>Project</h2><h3 id="P1"><a href="#P1" class="headerlink" title="P1"></a>P1</h3><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="string">"\""</span> &lt;&lt; value &lt;&lt; <span class="string">"\""</span>;</span><br></pre></td></tr></table></figure></div>

<p>如果要输出引号, 需要加入 <code>\</code>来进行转义!</p>
<h4 id="使用匿名函数来排序"><a href="#使用匿名函数来排序" class="headerlink" title="使用匿名函数来排序"></a>使用匿名函数来排序</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(sortedRecords.<span class="built_in">begin</span>(), sortedRecords.<span class="built_in">end</span>(),</span><br><span class="line">     [](<span class="type">const</span> Record&amp; a, <span class="type">const</span> Record&amp; b) {</span><br><span class="line">         <span class="keyword">if</span> (a.qso_date != b.qso_date) <span class="keyword">return</span> a.qso_date &lt; b.qso_date;</span><br><span class="line">         <span class="keyword">return</span> a.time_on &lt; b.time_on;</span><br><span class="line">     });</span><br></pre></td></tr></table></figure></div>

<p><code>sort</code>是 <code>algorithm</code>头文件中的库函数, 支持原地排序.</p>
<p>第三个参数是一个函数, 返回 <code>true</code>表示这个函数的第一个参数应该排在第二个参数的前面.</p>
<p>比如此处, 使用了匿名函数 <code>[]</code>, 同时比较 <code>date</code>, 当 </p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> a.qso_date &lt; b.qso_date;</span><br></pre></td></tr></table></figure></div>

<p>指的是当前者的时间较小, 应该排在前面, 因此是升序.</p>
<blockquote>
<p>不要因为语句太长而忘记末尾的 <code>;</code>.</p>
</blockquote>
<h3 id="P2"><a href="#P2" class="headerlink" title="P2"></a>P2</h3><h4 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h4><ul>
<li>整体设计:<ul>
<li>程序随机生成一组设置, 然后用户开始输入</li>
<li>大概率, 用户不可避免地会失败, 此时应当让用户选择是否继续参与这场游戏, 否则程序生成下一组的设置;</li>
</ul>
</li>
<li>房间:<ul>
<li>monster所在;</li>
<li>princess所在</li>
<li>lobby;</li>
<li>普通的room</li>
<li>具有毒药的房间(接触后限制之后行动的次数)</li>
<li>解药房间(可以解除中毒的状态)</li>
<li>地图房间(接触后可以通过输入 <code>map</code>来显示当前的位置)</li>
</ul>
</li>
<li>房间个数: <ul>
<li>每次都将上述的因素都加入, 不太合适, 因此需要用户输入游戏的类型/难度;</li>
<li>经典模式: 只会产生monster, princess,lobby和普通房间. 房间的个数较少;</li>
<li>挑战模式:  加入毒药, 解药和地图因素; 房间个数较多.</li>
</ul>
</li>
</ul>
<h2 id="刷题"><a href="#刷题" class="headerlink" title="刷题"></a>刷题</h2><ul>
<li><p>Destructors can not be overloaded.</p>
<ul>
<li>因为析构函数没有任何的参数和返回类型, 无法重载.</li>
</ul>
</li>
<li><p><strong>类的成员函数可以访问同类的私有成员，即使是其他对象的成员。</strong> 回顾类的私有边界不是相对于对象的, 而是类. </p>
</li>
<li><p>cpp中, 构造函数一定不能是 <code>virtual</code> 的! </p>
</li>
<li><p>静态变量需要再类的外部定义, 但是静态函数不一定.</p>
</li>
<li><p>“In C++， struct is actually the same thing as class， except for minor differences in usage.”</p>
<ul>
<li>这句话是正确的, 注意结构体也是支持继承的. 只是默认的继承方式也是 <code>public</code>.</li>
</ul>
</li>
<li><p>In C++, inheritance allows a derived class to directly access all of the functions and data of its base class.（T/F）</p>
<ul>
<li>错误的. 对于 <code>public</code> 类型的继承, 依旧无法直接访问父类的私有成员, 只能通过子类的方法来间接访问.</li>
</ul>
</li>
<li><p>下面的代码段, 能够能够通过编译, 但是存在运行时的错误(越界访问):</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{ vector&lt;<span class="type">float</span>&gt; v; v[<span class="number">0</span>] = <span class="number">2.5</span>; }</span><br></pre></td></tr></table></figure></div>

<ul>
<li>编译器在编译时候, 检查的主要是程序的语法和类型;</li>
<li>越界访问的问题存在于运行时检测.</li>
</ul>
</li>
<li><p>64位系统系统环境, 按照8个字节进行对齐:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参考的类定义方式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A1</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>{}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他的类型定义</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>Output:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Size of <span class="title">A1</span> <span class="params">(non - <span class="keyword">virtual</span> function with <span class="type">int</span> member)</span>: <span class="number">4</span> bytes</span></span><br><span class="line"><span class="function">Size of A2 (virtual function with int member): <span class="number">16</span> bytes</span></span><br><span class="line"><span class="function">Size of A3 (non - virtual function without int member): <span class="number">1</span> bytes</span></span><br><span class="line"><span class="function">Size of A4 (virtual function without int member): <span class="number">8</span> bytes</span></span><br><span class="line"><span class="function">Size of B (derived from A1): <span class="number">8</span> bytes</span></span><br></pre></td></tr></table></figure></div>

<p>主要注意2点:</p>
<ol>
<li><p>没有任何成员的类, 也占用1个字节的大小;</p>
</li>
<li><p>4+8 将会对齐得到16个字节的空间大小.</p>
<blockquote>
<p>[!NOTE]</p>
<p><code>void*</code> 和 <code>int*</code> 的大小相同! (题目通常给出 <code>int*</code>的大小, 然后给出虚函数)</p>
</blockquote>
</li>
</ol>
</li>
<li><p><code>malloc</code> 不会调用对象的构造函数, 仅仅分配内存, 并不涉及对象的初始化;</p>
<ul>
<li><p><code>new</code>会调用构造函数</p>
</li>
<li><p><code>malloc</code> 需要显式地类型转换:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() { std::cout &lt;&lt; <span class="string">"Constructor called!"</span> &lt;&lt; std::endl; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">MyClass* p1 = <span class="keyword">new</span> <span class="built_in">MyClass</span>();  <span class="comment">// 输出 "Constructor called!"</span></span><br><span class="line">MyClass* p2 = (MyClass*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(MyClass));  <span class="comment">// 无输出，构造函数未调用</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
</li>
<li><p><code>new</code> 是CPP的运算符, 可以重载; <code>malloc</code>是标准库的函数, 无法重载.</p>
</li>
<li><p>每个类最多具有一个析构函数</p>
</li>
</ul>
<h4 id="重载问题"><a href="#重载问题" class="headerlink" title="重载问题"></a>重载问题</h4><p>在 <code>::</code>, <code>()</code> 和 <code>-&gt;</code>中, 只有 <code>-&gt;</code>可以被重载:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>{</span><br><span class="line">        std::cout &lt;&lt; <span class="string">"Hello from MyClass!"</span> &lt;&lt; std::endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPtr</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MyClass* ptr;  <span class="comment">// 内部存储一个原生指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">MyPtr</span>(MyClass* p) : <span class="built_in">ptr</span>(p) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载 -&gt; 运算符</span></span><br><span class="line">    MyClass* <span class="keyword">operator</span>-&gt;() {</span><br><span class="line">        <span class="keyword">return</span> ptr;  <span class="comment">// 返回原生指针，使得可以继续用 -&gt; 访问成员</span></span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    MyClass obj;</span><br><span class="line">    <span class="function">MyPtr <span class="title">myPtr</span><span class="params">(&amp;obj)</span></span>;  <span class="comment">// 用 MyPtr 包装 MyClass 对象</span></span><br><span class="line"></span><br><span class="line">    myPtr-&gt;<span class="built_in">sayHello</span>();  <span class="comment">// 调用 MyClass 的成员函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="new与对象转换"><a href="#new与对象转换" class="headerlink" title="new与对象转换"></a>new与对象转换</h4><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">x</span>(x) {}</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getx</span><span class="params">()</span> </span>{ <span class="keyword">return</span> x; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">int</span> x = <span class="number">0</span>) : <span class="built_in">A</span>(x) { <span class="keyword">this</span>-&gt;x++; }</span><br><span class="line">    <span class="built_in">B</span>(<span class="type">const</span> B &amp;b) : <span class="built_in">A</span>(b.x) { <span class="keyword">this</span>-&gt;x++; }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">A::<span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span> </span>{ <span class="keyword">return</span> *<span class="keyword">new</span> <span class="built_in">B</span>(x + <span class="number">1</span>); } <span class="comment">// 特别注意此处</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    A *p1 = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">3</span>); <span class="comment">// new的时候触发B的构造函数, 自增</span></span><br><span class="line">    A *p2 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">9</span>);</span><br><span class="line">    B b0 = *p1; <span class="comment">// 发生了A类对象向B类对象的转化, 详见下面两行:</span></span><br><span class="line">    <span class="comment">// *p1 将要转化的时候,  先传入x+1作为B的初始化参数输入,</span></span><br><span class="line">    <span class="comment">// 然后new将触发B的构造函数, 最后返回, 返回结果用于初始化b0, 继续触发拷贝构造函数</span></span><br><span class="line">    B &amp;r = b0;</span><br><span class="line">    B b1 = b0;  <span class="comment">// 发生了 B类对象的拷贝构造, b1的x为8, 但是不会改变b0的x=7</span></span><br><span class="line">    B b2 = *p2; <span class="comment">// 这一步的转换与上面的同理. 也是+3</span></span><br><span class="line">    cout &lt;&lt; p1-&gt;<span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; p2-&gt;<span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b<span class="number">0.</span><span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; r.<span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b<span class="number">1.</span><span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b<span class="number">2.</span><span class="built_in">getx</span>() &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>解题过程中的关键步骤已经写在注释当中, 最后的输出是:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure></div>

<p>梳理考察的重要知识点:</p>
<ol>
<li><p>upcast的时候, 是子类的属性赋值给父类, 包括虚函数表. 因此, 此时看作是父类的对象, 但是虚函数能够动态绑定.</p>
</li>
<li><p><code>new</code>和<code>delete</code>分别自动调用类的构造函数和析构函数;</p>
</li>
<li><p><code>A::operator B()</code> 形式表示A类对象如何转换成B类型对象的, 在发生转换的时候自动调用这部分的函数.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A *p1 = <span class="keyword">new</span> <span class="built_in">B</span>(<span class="number">3</span>); <span class="comment">// 拷贝构造的时候直接自增为4</span></span><br><span class="line">A *p2 = <span class="keyword">new</span> <span class="built_in">A</span>(<span class="number">9</span>);</span><br></pre></td></tr></table></figure></div>

<p>注意上面的指针都指向A类的对象.</p>
</li>
</ol>
<h4 id="链式的析构顺序"><a href="#链式的析构顺序" class="headerlink" title="链式的析构顺序"></a>链式的析构顺序</h4><ul>
<li>构造顺序: 父类-&gt;成员对象-&gt; 自身</li>
<li>析构顺序: 自身-&gt; 成员对象-&gt; 父类</li>
</ul>
<p>下面的这道题目涉及的类的关系如下:</p>
<ol>
<li>P是父类, S是子类;</li>
<li>P内部有两个P类型的指针成员.</li>
</ol>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 先声明基类 P</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">P</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> flag; <span class="comment">// 静态成员声明</span></span><br><span class="line">    <span class="type">int</span> x;            <span class="comment">// 数据成员</span></span><br><span class="line">    P *left, *right;  <span class="comment">// 指针成员</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">P</span>(P *left = <span class="literal">nullptr</span>, P *right = <span class="literal">nullptr</span>)</span><br><span class="line">        : <span class="built_in">x</span>(<span class="number">0</span>), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 虚析构函数（因为有继承关系，应该是虚函数）</span></span><br><span class="line">    ~<span class="built_in">P</span>()</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (flag)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">delete</span> left;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">delete</span> right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">delete</span> right;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (left != <span class="literal">nullptr</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="keyword">delete</span> left;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        cout &lt;&lt; <span class="string">"P"</span> &lt;&lt; x;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 静态成员的定义（必须在类外定义）</span></span><br><span class="line"><span class="type">bool</span> P::flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 派生类 S</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> : <span class="keyword">public</span> P</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，调用基类构造函数</span></span><br><span class="line">    <span class="built_in">S</span>(P *left = <span class="literal">nullptr</span>, P *right = <span class="literal">nullptr</span>) : <span class="built_in">P</span>(left, right) {}</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">S</span>()</span><br><span class="line">    {</span><br><span class="line">        cout &lt;&lt; <span class="string">"S"</span> &lt;&lt; x;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    S *p1 = <span class="keyword">new</span> S;</span><br><span class="line">    p1-&gt;x = <span class="number">1</span>; <span class="comment">// 设置第一个节点的值</span></span><br><span class="line">    S *p2 = <span class="keyword">new</span> S;</span><br><span class="line">    p2-&gt;x = <span class="number">2</span>;   <span class="comment">// 设置第二个节点的值</span></span><br><span class="line">    <span class="function">S <span class="title">s</span><span class="params">(p1, p2)</span></span>; <span class="comment">// 创建根节点，连接p1和p2</span></span><br><span class="line">    s.x = <span class="number">3</span>;     <span class="comment">// 设置根节点的值/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    <span class="comment">// 程序结束时析构对象</span></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>最终的输出:</p>
<ol>
<li>析构s, 首先析构子类自身, 调用s的析构函数, 输出s;</li>
<li>然后析构父类, 父类是P, 析构的时候直接调用自身的析构函数, 一词析构右指针和左指针;</li>
<li>执行到末尾, 输出自身的P3.</li>
</ol>
<p>Output:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">S3P2P1P3</span><br></pre></td></tr></table></figure></div>







<h4 id="操作符的重载"><a href="#操作符的重载" class="headerlink" title="操作符的重载"></a>操作符的重载</h4><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 110</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Your answer will be inserted here. Feel free to add anything needed here.*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vec</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> first, second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vec</span>(<span class="type">int</span> a, <span class="type">int</span> b) : <span class="built_in">first</span>(a), <span class="built_in">second</span>(b) {}</span><br><span class="line">    <span class="comment">//  &lt; 的重载</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> vec &amp;other) <span class="type">const</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> second &lt; other.second;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型转换的重载</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(first);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出的重载</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> vec &amp;v)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; <span class="string">"("</span> &lt;&lt; v.first &lt;&lt; <span class="string">","</span> &lt;&lt; v.second &lt;&lt; <span class="string">")"</span>;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printArrayInfo</span><span class="params">(vec **arr, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vec *maxv = arr[<span class="number">0</span>], *minv = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="type">double</span> avg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    {</span><br><span class="line">        vec *val = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (*val &lt; *minv)</span><br><span class="line">            minv = val;</span><br><span class="line">        <span class="keyword">if</span> (*maxv &lt; *val)</span><br><span class="line">            maxv = val;</span><br><span class="line">        avg = avg + <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(*val);</span><br><span class="line">    }</span><br><span class="line">    avg /= n;</span><br><span class="line">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="string">"min = "</span> &lt;&lt; *minv &lt;&lt; <span class="string">", max = "</span> &lt;&lt; *maxv &lt;&lt; <span class="string">", avg = "</span> &lt;&lt; avg &lt;&lt; std::endl;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    vec *pool[MAXN];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    {</span><br><span class="line">        std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        pool[i] = <span class="keyword">new</span> <span class="built_in">vec</span>(a, b);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printArrayInfo</span>(pool, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="菱形继承与二义性问题"><a href="#菱形继承与二义性问题" class="headerlink" title="菱形继承与二义性问题"></a>菱形继承与二义性问题</h4><p>并不是菱形继承的操作都会导致二义性, 要从本质–访问的操作是否导致无法区分正确的单独对象?</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">A</span>() : <span class="built_in">x</span>(<span class="number">6</span>) {}</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> A::<span class="built_in">fun</span>() + x;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> A::<span class="built_in">fun</span>() + x;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C</span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">return</span> B::<span class="built_in">fun</span>() + C::<span class="built_in">fun</span>();</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    D d;</span><br><span class="line">    cout &lt;&lt; d.<span class="built_in">fun</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; d.A::fun(); 存在二义性的问题, 因为在D当中分别存在来自于B和C的这个函数!</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>在上面代码中, D是菱形继承, 但是可以直接访问d的fun, 因为在d的fun中涉及的是B和C自己的fun. 而后者又能够直接调用自己的继承自A的fun</p>
<ul>
<li>无法直接调用 <code>d.A::fun()</code>, 参见注释.</li>
</ul>
<h1 id="最后的枚举"><a href="#最后的枚举" class="headerlink" title="最后的枚举"></a>最后的枚举</h1><h4 id="转换运算符"><a href="#转换运算符" class="headerlink" title="转换运算符"></a>转换运算符</h4><p><code>A::operator B()</code>的含义： 定义了如何将 <code>A</code> 类型的对象转换为 <code>B</code> 类型的对象。</p>
<ul>
<li><code>A::</code> 表示这是 <code>A</code> 类的成员函数</li>
<li><code>operator B</code> 表示这是一个到 <code>B</code> 类型的转换运算符</li>
<li><code>()</code> 表示这是一个函数</li>
</ul>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A 具有一个成员变量且在构造函数中可以赋值</span></span><br><span class="line"></span><br><span class="line"><span class="function">A::<span class="keyword">operator</span> <span class="title">B</span><span class="params">()</span> </span>{ <span class="keyword">return</span> *<span class="keyword">new</span> <span class="built_in">B</span>(x + <span class="number">1</span>); }</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>new B(x + 1)</code> 创建一个新的 <code>B</code> 对象，其中 <code>x</code> 是 <code>A</code> 类的成员变量</li>
<li><code>*</code> 解引用这个新创建的对象</li>
<li>返回这个 <code>B</code> 类型的对象</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p>注意, 这只是决定了B类对象的如何构造, 并不会影响A类对象本身.</p>
</blockquote>
<p>调用的场景: 需要将A类型的对象转换为B类型的对象 e.g.——</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A <span class="title">a</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">B b = a;  <span class="comment">// 这里会自动调用 A::operator B()</span></span><br></pre></td></tr></table></figure></div>



<h2 id="const相关"><a href="#const相关" class="headerlink" title="const相关"></a>const相关</h2><h3 id="对象与方法的对应"><a href="#对象与方法的对应" class="headerlink" title="对象与方法的对应"></a>对象与方法的对应</h3><p>C++在选择成员函数时会考虑对象的const属性：</p>
<ul>
<li><p>const对象只能调用const成员函数 </p>
</li>
<li><p>非const对象优先调用非const版本，如果没有非const版本才会调用const版本</p>
</li>
<li><blockquote>
<p>[!NOTE]</p>
<p>函数定义的顺序并不会影响调用的选择!</p>
</blockquote>
</li>
</ul>
<p>e.g.</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span></span><br><span class="line">{</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x) {}</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl</span><br><span class="line">             &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Print</span><span class="params">()</span> <span class="type">const</span> </span>{ cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl</span><br><span class="line">                              &lt;&lt; val &lt;&lt; endl; }</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="function"><span class="type">const</span> MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    obj<span class="number">1.</span><span class="built_in">Print</span>();</span><br><span class="line">    obj<span class="number">2.</span><span class="built_in">Print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<p>output:</p>
<div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure></div>





<h2 id="初始化先后的问题"><a href="#初始化先后的问题" class="headerlink" title="初始化先后的问题"></a>初始化先后的问题</h2><p>C++中对象的初始化和销毁顺序遵循特定的规则，这对于理解程序行为和避免内存问题至关重要</p>
<h3 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h3><h3 id="类的构造与析构顺序"><a href="#类的构造与析构顺序" class="headerlink" title="类的构造与析构顺序"></a>类的构造与析构顺序</h3><p>在C++中，对象的构造和析构顺序遵循以下规则：</p>
<ol>
<li><p><strong>构造顺序</strong>：</p>
<ul>
<li>基类先于派生类构造</li>
<li>成员变量按声明顺序构造</li>
<li>基类构造完成后，才执行派生类构造函数体</li>
<li><blockquote>
<p>[!NOTE]</p>
<p>对象在调用构造函数之前, 首先完成内部成员对象的构造</p>
</blockquote>
</li>
</ul>
</li>
<li><p><strong>析构顺序</strong>：</p>
<ul>
<li>与构造顺序相反</li>
<li>先执行派生类析构函数体</li>
<li>然后按声明顺序的逆序析构成员变量</li>
<li>最后析构基类</li>
</ul>
</li>
</ol>
<h4 id="示例分析"><a href="#示例分析" class="headerlink" title="示例分析"></a>示例分析</h4><div class="code-container" data-rel="C++"><figure class="iseeu highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Child c;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="类层次结构"><a href="#类层次结构" class="headerlink" title="类层次结构"></a>类层次结构</h5><div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X (基础类)</span><br><span class="line">↑</span><br><span class="line">Y (继承自X)</span><br><span class="line"></span><br><span class="line">Parent (包含X成员)</span><br><span class="line">↑</span><br><span class="line">Child (继承自Parent，包含Y成员)</span><br></pre></td></tr></table></figure></div>

<h5 id="构造过程分析"><a href="#构造过程分析" class="headerlink" title="构造过程分析"></a>构造过程分析</h5><p>当创建<code>Child</code>对象时，构造顺序为：</p>
<ol>
<li>首先构造基类<code>Parent</code><ul>
<li>在<code>Parent</code>构造前，先构造其成员<code>x</code>（调用<code>X::X()</code>）</li>
<li>然后执行<code>Parent</code>构造函数体（输出”Parent::Parent()”）</li>
</ul>
</li>
<li>基类构造完成后，构造<code>Child</code>的成员<code>y</code><ul>
<li>在构造<code>y</code>前，先构造其基类部分（调用<code>X::X()</code>）</li>
<li>然后执行<code>Y</code>构造函数体（输出”Y::Y()”）</li>
</ul>
</li>
<li>最后执行<code>Child</code>构造函数体（输出”Child::Child()”）</li>
</ol>
<h5 id="析构过程分析"><a href="#析构过程分析" class="headerlink" title="析构过程分析"></a>析构过程分析</h5><p>当<code>Child</code>对象离开作用域时，析构顺序为：</p>
<ol>
<li>首先执行<code>Child</code>析构函数体（输出”Child::~Child()”）</li>
<li>然后析构成员<code>y</code><ul>
<li>先执行<code>Y</code>析构函数体（输出”Y::~Y()”）</li>
<li>然后析构其基类部分（调用<code>X::~X()</code>）</li>
</ul>
</li>
<li>最后析构基类<code>Parent</code><ul>
<li>先执行<code>Parent</code>析构函数体（输出”Parent::~Parent()”）</li>
<li>然后析构其成员<code>x</code>（调用<code>X::~X()</code>）</li>
</ul>
</li>
</ol>
<h4 id="预期输出"><a href="#预期输出" class="headerlink" title="预期输出"></a>预期输出</h4><p>执行<code>test.cpp</code>程序时，预期输出为：</p>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">X::X()              // Parent的成员x构造</span><br><span class="line">Parent::Parent()    // Parent构造函数体</span><br><span class="line">X::X()              // Y的基类部分构造</span><br><span class="line">Y::Y()              // Y构造函数体</span><br><span class="line">Child::Child()      // Child构造函数体</span><br><span class="line">Child::~Child()     // Child析构函数体</span><br><span class="line">Y::~Y()             // Y析构函数体</span><br><span class="line">X::~X()             // Y的基类部分析构</span><br><span class="line">Parent::~Parent()   // Parent析构函数体</span><br><span class="line">X::~X()             // Parent的成员x析构</span><br></pre></td></tr></table></figure></div>

<h4 id="重要注意事项"><a href="#重要注意事项" class="headerlink" title="重要注意事项"></a>重要注意事项</h4><ol>
<li><p><strong>虚析构函数</strong>：当使用多态时，基类应该有虚析构函数，确保正确调用派生类析构函数。</p>
</li>
<li><p><strong>成员初始化列表</strong>：推荐使用成员初始化列表而非在构造函数体内赋值，这样可以直接初始化而非先默认构造再赋值。</p>
</li>
<li><p><strong>异常安全</strong>：构造过程中如果抛出异常，已构造的成员会被正确析构，但未完全构造的对象不会调用析构函数。</p>
</li>
<li><p><strong>RAII原则</strong>：资源获取即初始化，在构造函数中获取资源，在析构函数中释放资源，确保资源管理安全。</p>
</li>
</ol>
<h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><p>理解对象生命周期对以下场景尤为重要：</p>
<ol>
<li><strong>资源管理</strong>：确保资源在不再需要时被释放</li>
<li><strong>依赖关系处理</strong>：确保依赖对象在被依赖对象之前构造，之后析构</li>
<li><strong>继承层次设计</strong>：合理设计基类和派生类的构造和析构行为</li>
</ol>

		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>标题:</strong> cpp学习记录</li>
        <li><strong>作者:</strong> ffy</li>
        <li><strong>创建于
                :</strong> 2025-02-14 20:21:21</li>
        
            <li>
                <strong>更新于
                    :</strong> 2025-05-09 09:48:28
            </li>
        
        <li>
            <strong>链接:</strong> https://ffy6511.github.io/2025/02/14/编程语言/cpp学习记录/
        </li>
        <li>
            <strong>
                版权声明:
            </strong>
            

            
                本文章采用 <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a> 进行许可。
            
        </li>
    </ul>
</div>

		</div>
		

		

		
  <div class="recommended-article px-2 sm:px-6 md:px-8">
   <div class="recommended-desktop">
    <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
    </div>
    <div class="recommended-article-group"><a class="recommended-article-item" href="/2025/01/09/编程语言/JavaScript/" title="JavaScript" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="JavaScript" class="!max-w-none">
  <span class="title">JavaScript</span>
</a><a class="recommended-article-item" href="/2025/04/17/swift/" title="Swift学习摘记" rel="bookmark">
  <img src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094625386.png?imageSlim" alt="Swift学习摘记" class="!max-w-none">
  <span class="title">Swift学习摘记</span>
</a><a class="recommended-article-item" href="/2025/01/20/前后端/响应式设计/" title="响应式设计" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="响应式设计" class="!max-w-none">
  <span class="title">响应式设计</span>
</a></div>
   </div>
   <div class="recommended-mobile">
   <div class="recommended-article-header text-xl md:text-3xl font-bold mt-10">
     <i aria-hidden="true"></i><span>推荐阅读</span>
   </div>
   <div class="recommended-article-group"><a class="recommended-article-item" href="/2025/01/09/编程语言/JavaScript/" title="JavaScript" rel="bookmark">
  <img src="/images/wallhaven-wqery6-light.webp" alt="JavaScript" class="!max-w-none">
  <span class="title">JavaScript</span>
</a><a class="recommended-article-item" href="/2025/04/17/swift/" title="Swift学习摘记" rel="bookmark">
  <img src="https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094625386.png?imageSlim" alt="Swift学习摘记" class="!max-w-none">
  <span class="title">Swift学习摘记</span>
</a></div>
   </div>
  </div>

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/02/16/%E5%89%8D%E5%90%8E%E7%AB%AF/%E8%B7%A8%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">跨组件渲染</span>
						<span class="post-nav-item">上一篇</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2025/01/20/%E5%89%8D%E5%90%8E%E7%AB%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">响应式设计</span>
						<span class="post-nav-item">下一篇</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">目录</div>
		<div class="page-title">cpp学习记录</div>
		<ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">2.</span> <span class="nav-text">输入输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81"><span class="nav-number">2.1.</span> <span class="nav-text">文件流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81%E5%9F%BA%E7%A1%80"><span class="nav-number">2.1.1.</span> <span class="nav-text">输入输出流基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">常用操作示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%89%93%E5%BC%80%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.1.3.</span> <span class="nav-text">文件打开模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="nav-number">2.1.4.</span> <span class="nav-text">错误处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">3.</span> <span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#String"><span class="nav-number">3.1.</span> <span class="nav-text">String</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#stringstream"><span class="nav-number">3.1.1.</span> <span class="nav-text">stringstream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Getline"><span class="nav-number">3.1.2.</span> <span class="nav-text">Getline</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cin"><span class="nav-number">3.1.3.</span> <span class="nav-text">cin</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Alter-String"><span class="nav-number">3.1.4.</span> <span class="nav-text">Alter String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.5.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.6.</span> <span class="nav-text">成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Substr"><span class="nav-number">3.1.7.</span> <span class="nav-text">Substr</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Function"><span class="nav-number">4.</span> <span class="nav-text">Function</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Default-arguments"><span class="nav-number">4.1.</span> <span class="nav-text">Default arguments</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Group"><span class="nav-number">5.</span> <span class="nav-text">Group</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pair"><span class="nav-number">5.1.</span> <span class="nav-text">Pair</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">5.1.1.</span> <span class="nav-text">基本介绍</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set"><span class="nav-number">5.2.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Vector"><span class="nav-number">5.3.</span> <span class="nav-text">Vector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Reserve"><span class="nav-number">5.3.1.</span> <span class="nav-text">Reserve</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Resize"><span class="nav-number">5.3.2.</span> <span class="nav-text">Resize</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List"><span class="nav-number">5.4.</span> <span class="nav-text">List</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8"><span class="nav-number">5.4.1.</span> <span class="nav-text">有序链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deque"><span class="nav-number">5.5.</span> <span class="nav-text">Deque</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Forward-list"><span class="nav-number">5.5.1.</span> <span class="nav-text">Forward_list</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map"><span class="nav-number">5.6.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Iterator"><span class="nav-number">5.7.</span> <span class="nav-text">Iterator</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#for-each"><span class="nav-number">5.8.</span> <span class="nav-text">for-each</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map%E7%9A%84%E5%BE%AA%E7%8E%AF"><span class="nav-number">5.8.1.</span> <span class="nav-text">Map的循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Pro-Con"><span class="nav-number">5.8.2.</span> <span class="nav-text">Pro&amp;Con</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedef"><span class="nav-number">5.9.</span> <span class="nav-text">typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Notices"><span class="nav-number">5.10.</span> <span class="nav-text">Notices</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%8C%87%E9%92%88"><span class="nav-number">6.</span> <span class="nav-text">指针</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">7.</span> <span class="nav-text">常量</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88-1"><span class="nav-number">7.1.</span> <span class="nav-text">指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Class"><span class="nav-number">8.</span> <span class="nav-text">Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">8.0.1.</span> <span class="nav-text">::</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#this"><span class="nav-number">8.0.2.</span> <span class="nav-text">this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E7%89%B9%E6%80%A7"><span class="nav-number">8.0.3.</span> <span class="nav-text">封装特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="nav-number">8.0.4.</span> <span class="nav-text">声明与定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86"><span class="nav-number">8.1.</span> <span class="nav-text">生命周期管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-1"><span class="nav-number">8.1.1.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0"><span class="nav-number">8.1.2.</span> <span class="nav-text">默认构造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.3.</span> <span class="nav-text">析构函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Access-Control"><span class="nav-number">8.2.</span> <span class="nav-text">Access Control</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#friend"><span class="nav-number">8.2.1.</span> <span class="nav-text">friend</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#protected"><span class="nav-number">8.2.2.</span> <span class="nav-text">protected</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Static"><span class="nav-number">8.3.</span> <span class="nav-text">Static</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reference"><span class="nav-number">8.4.</span> <span class="nav-text">Reference</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Constants"><span class="nav-number">8.5.</span> <span class="nav-text">Constants</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="nav-number">8.6.</span> <span class="nav-text">动态内存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Inline-Class"><span class="nav-number">8.7.</span> <span class="nav-text">Inline Class</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Delegating-Constructor"><span class="nav-number">8.7.1.</span> <span class="nav-text">Delegating Constructor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">8.7.2.</span> <span class="nav-text">默认参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">8.7.3.</span> <span class="nav-text">内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inline-%E5%8F%98%E9%87%8F"><span class="nav-number">8.7.4.</span> <span class="nav-text">inline 变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#weak"><span class="nav-number">8.7.5.</span> <span class="nav-text">weak</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Composition"><span class="nav-number">9.</span> <span class="nav-text">Composition</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%86%85%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">9.1.</span> <span class="nav-text">类内对象的初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-Fully"><span class="nav-number">9.1.1.</span> <span class="nav-text">1. Fully</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Reference"><span class="nav-number">9.1.2.</span> <span class="nav-text">2. Reference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%AF%B9%E6%AF%94"><span class="nav-number">9.1.3.</span> <span class="nav-text">3. 对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Embedded-objects"><span class="nav-number">9.2.</span> <span class="nav-text">Embedded objects</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#namespace"><span class="nav-number">9.3.</span> <span class="nav-text">namespace</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%88%AB%E5%90%8D"><span class="nav-number">9.3.1.</span> <span class="nav-text">命名空间的别名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#selection"><span class="nav-number">9.3.2.</span> <span class="nav-text">selection</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Inheritance"><span class="nav-number">10.</span> <span class="nav-text">Inheritance</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#using%E5%A3%B0%E6%98%8E"><span class="nav-number">10.0.1.</span> <span class="nav-text">using声明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Polymorphism"><span class="nav-number">11.</span> <span class="nav-text">Polymorphism</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">11.1.</span> <span class="nav-text">虚函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-number">11.1.1.</span> <span class="nav-text">纯虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="nav-number">11.1.2.</span> <span class="nav-text">虚函数表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">11.2.</span> <span class="nav-text">抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%AE%9A%E4%B9%89%E6%8E%A5%E5%8F%A3"><span class="nav-number">11.2.1.</span> <span class="nav-text">使用抽象类定义接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E9%93%BE"><span class="nav-number">11.2.2.</span> <span class="nav-text">继承链</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">11.3.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%A3%E7%B1%BB"><span class="nav-number">11.4.</span> <span class="nav-text">接口类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="nav-number">11.5.</span> <span class="nav-text">多重继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF"><span class="nav-number">11.5.1.</span> <span class="nav-text">菱形继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">11.5.2.</span> <span class="nav-text">虚继承</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Copy-and-Move"><span class="nav-number">12.</span> <span class="nav-text">Copy and Move</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%B8%AD%E7%9A%84%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">12.1.</span> <span class="nav-text">C++中的拷贝构造与移动语义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="nav-number">12.1.1.</span> <span class="nav-text">拷贝构造函数基础</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">12.1.2.</span> <span class="nav-text">拷贝构造函数的调用时机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">12.1.3.</span> <span class="nav-text">拷贝构造函数的最佳实践</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">12.1.4.</span> <span class="nav-text">函数参数和返回值的选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%8E%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">12.2.</span> <span class="nav-text">右值引用与移动语义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">12.3.</span> <span class="nav-text">初始化方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="nav-number">12.3.1.</span> <span class="nav-text">深拷贝与浅拷贝</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><span class="nav-number">12.3.2.</span> <span class="nav-text">何时使用移动语义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93-1"><span class="nav-number">12.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Overloaded-Operators"><span class="nav-number">13.</span> <span class="nav-text">Overloaded Operators</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%9F%BA%E7%A1%80"><span class="nav-number">13.1.</span> <span class="nav-text">C++运算符重载基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E8%BD%BD%E4%B8%8E%E4%B8%8D%E5%8F%AF%E9%87%8D%E8%BD%BD%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">13.1.1.</span> <span class="nav-text">可重载与不可重载的运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E9%99%90%E5%88%B6"><span class="nav-number">13.1.2.</span> <span class="nav-text">运算符重载的限制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">13.2.</span> <span class="nav-text">运算符重载的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">13.2.1.</span> <span class="nav-text">成员函数方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E6%96%B9%E5%BC%8F"><span class="nav-number">13.2.2.</span> <span class="nav-text">全局函数方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0vs%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">13.2.3.</span> <span class="nav-text">成员函数vs全局函数的选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E4%B8%8E%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.3.</span> <span class="nav-text">参数传递与返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="nav-number">13.3.1.</span> <span class="nav-text">参数传递</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">13.3.2.</span> <span class="nav-text">返回类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%89%B9%E6%AE%8A%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">13.4.</span> <span class="nav-text">特殊运算符重载</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%A2%9E%E8%87%AA%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">13.4.1.</span> <span class="nav-text">自增自减运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E6%A0%87%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">13.4.2.</span> <span class="nav-text">下标运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">13.4.3.</span> <span class="nav-text">关系运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%81%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">13.4.4.</span> <span class="nav-text">流运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%81%E6%93%8D%E7%BA%B5%E7%AC%A6"><span class="nav-number">13.4.5.</span> <span class="nav-text">自定义流操纵符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">13.5.</span> <span class="nav-text">赋值运算符与类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="nav-number">13.5.1.</span> <span class="nav-text">赋值运算符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">13.5.2.</span> <span class="nav-text">类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Template"><span class="nav-number">14.</span> <span class="nav-text">Template</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E6%A6%82%E8%BF%B0"><span class="nav-number">14.1.</span> <span class="nav-text">模板概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">14.2.</span> <span class="nav-text">函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-1"><span class="nav-number">14.2.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="nav-number">14.2.2.</span> <span class="nav-text">模板实例化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="nav-number">14.2.3.</span> <span class="nav-text">模板匹配规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%85%B1%E5%AD%98"><span class="nav-number">14.2.4.</span> <span class="nav-text">模板函数与普通函数共存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">14.3.</span> <span class="nav-text">类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95-2"><span class="nav-number">14.3.1.</span> <span class="nav-text">基本语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">14.3.2.</span> <span class="nav-text">类模板的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">14.3.3.</span> <span class="nav-text">类模板成员函数的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">14.4.</span> <span class="nav-text">多参数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B5%8C%E5%A5%97%E6%A8%A1%E6%9D%BF"><span class="nav-number">14.5.</span> <span class="nav-text">嵌套模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="nav-number">14.6.</span> <span class="nav-text">模板的局限性与注意事项</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%B6%E4%BB%96"><span class="nav-number">15.</span> <span class="nav-text">其他</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">15.1.</span> <span class="nav-text">访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E4%B8%AD%E7%9A%84%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">15.1.1.</span> <span class="nav-text">继承关系中的访问控制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="nav-number">15.2.</span> <span class="nav-text">作用域与生存期</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Includes"><span class="nav-number">15.3.</span> <span class="nav-text">Includes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Algorithm"><span class="nav-number">15.3.1.</span> <span class="nav-text">Algorithm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">15.4.</span> <span class="nav-text">深拷贝</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Temp"><span class="nav-number">15.5.</span> <span class="nav-text">Temp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%BA%E5%88%86"><span class="nav-number">15.6.</span> <span class="nav-text">区分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#find"><span class="nav-number">15.6.1.</span> <span class="nav-text">find</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#erase"><span class="nav-number">15.6.2.</span> <span class="nav-text">erase</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E7%9F%A5%E9%81%93%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%E7%9A%84%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-number">15.7.</span> <span class="nav-text">不知道放在哪里的代码块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%AF%BE%E5%A0%82%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-number">16.</span> <span class="nav-text">课堂缓冲区</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%A2%98%E7%9B%AE%E6%A2%B3%E7%90%86"><span class="nav-number">17.</span> <span class="nav-text">题目梳理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#HW2"><span class="nav-number">17.1.</span> <span class="nav-text">HW2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HW3"><span class="nav-number">17.2.</span> <span class="nav-text">HW3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HW4"><span class="nav-number">17.3.</span> <span class="nav-text">HW4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%A4%A7%E5%B0%8F%E7%9F%A9%E9%98%B5"><span class="nav-number">17.3.1.</span> <span class="nav-text">可变大小矩阵:</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HW5"><span class="nav-number">17.4.</span> <span class="nav-text">HW5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HW6"><span class="nav-number">17.5.</span> <span class="nav-text">HW6</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HW7"><span class="nav-number">17.6.</span> <span class="nav-text">HW7</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HW9"><span class="nav-number">17.7.</span> <span class="nav-text">HW9</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HW10"><span class="nav-number">17.8.</span> <span class="nav-text">HW10</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#W12"><span class="nav-number">17.9.</span> <span class="nav-text">W12</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#L3"><span class="nav-number">17.10.</span> <span class="nav-text">L3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E4%B8%8E%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">17.10.1.</span> <span class="nav-text">C++ 初始化列表与成员变量初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Project"><span class="nav-number">17.11.</span> <span class="nav-text">Project</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#P1"><span class="nav-number">17.11.1.</span> <span class="nav-text">P1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#P2"><span class="nav-number">17.11.2.</span> <span class="nav-text">P2</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%B7%E9%A2%98"><span class="nav-number">17.12.</span> <span class="nav-text">刷题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%80%E5%90%8E%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">18.</span> <span class="nav-text">最后的枚举</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#const%E7%9B%B8%E5%85%B3"><span class="nav-number">18.1.</span> <span class="nav-text">const相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E5%BA%94"><span class="nav-number">18.1.1.</span> <span class="nav-text">对象与方法的对应</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%85%88%E5%90%8E%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">18.2.</span> <span class="nav-text">初始化先后的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">18.2.1.</span> <span class="nav-text">初始化列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84%E9%A1%BA%E5%BA%8F"><span class="nav-number">18.2.2.</span> <span class="nav-text">类的构造与析构顺序</span></a></li></ol></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2025</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 1s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">ffy</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 11 篇文章
                    </span>
                    
                        <span>
                            共 60.4k 字
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="站内搜索您需要的内容..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>


<script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/Swup.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupSlideTheme.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupScriptsPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupProgressPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupScrollPlugin.min.js" ></script><script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/SwupPreloadPlugin.min.js" ></script>
<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	<script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/imageViewer.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/utils.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/main.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/navbarShrink.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/scrollTopBottom.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/lightDarkSwitch.js" ></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/categoryList.js" ></script>


    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/localSearch.js" ></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/codeBlock.js" ></script>



    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/lazyload.js" ></script>



    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/runtime.js" ></script>
    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/odometer.min.js" ></script>
    <link rel="stylesheet" href="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/assets/odometer-theme-minimal.css">



  <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/Typed.min.js" ></script>
  <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/typed.js" ></script>



    
        <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/mermaid.min.js" ></script>
    
    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/mermaid.js" ></script>





    <script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/anime.min.js" ></script>




    <script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/tools/tocToggle.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/toc.js" data-swup-reload-script></script><script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/plugins/tabs.js" data-swup-reload-script></script>


<script  src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/libs/moment-with-locales.min.js" data-swup-reload-script></script>
<script type="module" src="https://evan.beee.top/projects/hexo-theme-redefine@2.8.2/source/js/build/layouts/essays.js" data-swup-reload-script></script>




	
</body>

</html>