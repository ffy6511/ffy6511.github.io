[{"title":"倦鸟","url":"/2025/01/08/poets/bird/","content":"\n\n我盘旋的目光是漂泊不息的倦鸟\n\n越过人海 坠入你乌黑瞳仁中的夜\n\n\n\n> 下附最初的三节诗, 以及灵感来源.\n\n\n\n 完整三节诗\n\n我盘旋的目光是漂泊不息的倦鸟 \n越过人海终于落入你乌黑瞳仁中的夜\n\n你澄澈的眼眸映照着闪烁明灭的晨星\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记\n\n我们的目光还是悄然相遇了\n你温和的凝视又让我想起黎明的微光\n我漆黑的羽翼微微颤动 随后灼灼燃烧\n于是 我的目光载着余烬 再度飞远了\n\n\n\n\n 「灵感」Tagore's\n\n\nMy heart, the bird of the wilderness, \nhas found its sky in your eyes.\n\n(出自泰戈尔的园丁集)\n\n\n\n","categories":["随机掉落的文字碎片"],"tags":["短诗","她"]},{"title":"晚霞","url":"/2025/01/09/poets/%E6%99%9A%E9%9C%9E/","content":"\n\n白昼飞红了她的脸颊 \n以隐匿于远山之后的凝望  \n默默期待着  \n默默期待着  \n\n\n","categories":["随机掉落的文字碎片"],"tags":["短诗","自然"]},{"title":"css笔记","url":"/2025/01/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/css%E7%AC%94%E8%AE%B0/","content":"\n在线编辑平台\n\n伪元素使用伪元素before和after可以为元素添加内容.\n&lt;div class=&quot;author&quot;&gt;待抉&lt;/div&gt;&lt;style&gt;.author:before &#123;  content: &quot;Author: &quot;;  font-weight: bold; /* 加粗字体 */  color: blue; /* 文本颜色为蓝色 */&#125;.author:after &#123;  content: &quot; ✍️&quot;;  font-size: 1.2em; /* 调整图标大小 */  margin-left: 5px; /* 添加左边距 */&#125;&lt;/style&gt;\n\n\n:nth-child可用于对序列中不同的元素进行有序的样式设计:\n&lt;div class=&quot;index-card&quot;&gt;内容1&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容2&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容3&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容4&lt;/div&gt;&lt;style&gt;.index-card:nth-child(odd) &#123;  flex-direction: row-reverse;&#125;&lt;/style&gt;\n\n选择所有类名为 “index-card” 的元素;\nrow-reverse 会让 flex 容器中的项目从右到左排列;\n同理, even选择偶数位置的元素; 3n+1等函数表达式也可以起作用.\n\n\n\n基本的元素属性布局属性\nmargin: 控制元素的外边距;\npadding: 控制元素的内边距;\n\n文本属性\nfont-size: 控制字体大小;\nfont-weight: 控制字体粗细;\ntext-align: 控制文本的对齐方式;\ntext-decoration: 控制文本的装饰;\nline-height: 控制行高;\nletter-spacing: 控制字符间距;\ntext-transform: 控制文本的大小写;\n\n边框属性\nborder: e.g. border: 1px solid red; 简写属性;\nborder-radius: 控制元素的圆角;\nborder-style: solid, dashed, dotted…\n\n其他\noverflow: visible, hidden, scroll, auto;\nopacity: 控制元素的透明度;\ncursor: pointer, default, move, not-allowed…\n\n动感魔法hover效果通过为class设置:hover伪类，可以为元素添加鼠标悬停时的效果。\n.my-element:hover &#123;  background-color: green;  color: red;  transform: scale(1.1);  font-size:20px;&#125;\n\n空格将不会被忽略, 需要确保类名与:hover之间不存在空格;\n\n其他的一些常用的伪类:\na:hover &#123;      color: red;    &#125;    button:active &#123;      background-color: green;    &#125;    input:focus &#123;      border-color: blue;    &#125;    a:visited &#123;      color: purple;    &#125;    p:first-child &#123;      font-weight: bold;    &#125;    p:last-child &#123;      font-style: italic;    &#125;    li:nth-child(2) &#123;      color: red;    &#125;    p:only-child &#123;      color: green;    &#125;    div:empty &#123;      background-color: yellow;    &#125;\n\nFlex&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;style&gt;    /* 定义Flex容器 */    .container &#123;      display: flex; /* 将容器设置为Flexbox容器 */            /* flex-direction: 定义主轴方向 */      /* row: 水平从左到右（默认） */      /* row-reverse: 水平从右到左 */      /* column: 垂直从上到下 */      /* column-reverse: 垂直从下到上 */      flex-direction: row; /* 可以改为row-reverse, column, column-reverse */      /* flex-wrap: 定义是否换行 */      /* nowrap: 不换行（默认） */      /* wrap: 换行 */      /* wrap-reverse: 反向换行 */      flex-wrap: wrap; /* 可以改为nowrap, wrap-reverse */      /* flex-flow: flex-direction 和 flex-wrap 的简写 */      /* flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; */      flex-flow: row wrap; /* 可以改为column nowrap等组合 */      /* justify-content: 定义在主轴上的对齐方式 */      /* flex-start: 起始对齐（默认） */      /* flex-end: 末端对齐 */      /* center: 居中对齐 */      /* space-between: 两端对齐，项目之间间隔相等 */      /* space-around: 项目之间间隔相等，项目两边有半个间隔 */      /* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */      justify-content: space-between; /* 可以改为flex-start, flex-end, center, space-around, space-evenly */      /* align-items: 定义在交叉轴上的对齐方式 */      /* stretch: 拉伸适应容器（默认） */      /* flex-start: 交叉轴起始对齐 */      /* flex-end: 交叉轴末端对齐 */      /* center: 交叉轴居中对齐 */      /* baseline: 项目基线对齐 */      align-items: center; /* 可以改为flex-start, flex-end, stretch, baseline */      /* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */      /* stretch: 拉伸适应容器（默认） */      /* flex-start: 交叉轴起始对齐 */      /* flex-end: 交叉轴末端对齐 */      /* center: 交叉轴居中对齐 */      /* space-between: 多行两端对齐，行之间间隔相等 */      /* space-around: 多行之间间隔相等，行两边有半个间隔 */      align-content: space-between; /* 可以改为flex-start, flex-end, center, space-around */            height: 100vh; /* 设置容器高度 */      background-color: #f0f0f0; /* 设置容器背景颜色 */    &#125;        /* 定义Flex项目 */    .item &#123;      flex: 1; /* 设置项目的flex属性，项目平分空间 */      padding: 20px; /* 设置项目内边距 */      background-color: lightblue; /* 设置项目背景颜色 */      margin: 10px; /* 设置项目外边距 */      text-align: center; /* 设置项目文本居中 */      flex-grow: 1;/*尝试向flex容器扩展空间*/    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;item&quot;&gt;Item 1&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;Item 2&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;Item 3&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["学习笔记"],"tags":["前端","CSS"]},{"title":"JavaScript","url":"/2025/01/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/","content":"\nJavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「料理的加护」下, 尽可能将JS处理得更加可口一些)\n\n创建JS代码块变量var or let?var先于let的产生, 后者是现代版本的JS中新的关键字.\n使用var, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是let并不适用.\nmyName = \"Chris\";function logName() {  console.log(myName);}logName(); //输出\"Chris\"var myName = \"Aniya\";logName(); //输出\"Aniya\"\n\n除此之外, 可以使用var前后声明相同的变量, 这并不会报错:\nvar myName = \"Chris\";var myName = \"Bob\";\n\n而let只能声明一次:\nlet myName = \"Chris\";myName = \"Bob\";\n\n因此, 在代码编写中应尽量多使用let而非var, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.\n变量命名的规则与C语言类似, 建议以 字母、数字、下划线 组成的标识符来命名变量.\n\n不可用_开头, 因为可能被JS设计为特殊的含义;\n不可用数字开头, 否则引发错误;\n大小写敏感;\n建议采用 小写驼峰命名法 ,即小写整个命名的第一个字母然后大写剩下单词的首字符;\n避免使用保留字, 比如var,let,for等.\n\n变量类型let myAge = 20 ;// 数字let dolphinGoodbye = \"So long and thanks for all the fish\"; // 字符串let test = 6 &lt; 3; //boolean//数组类型let myNameArray = [\"Chris\", \"Bob\", \"Jim\"];let myNumberArray = [10, 15, 40];//对象类型let dog = { name: \"Spot\", breed: \"Dalmatian\" };\n\n对象类型的访问与结构体相似, dog.name;\n\n在上面的几种变量类型中, 我们都采用let关键字声明变量, 这体现了JS是一种 动态类型语言 ,即无需指定变量包含的数据类型.\n同时, 这也意味着我们可以像python一样对同一个变量先后赋值不同类型的值:\nlet myNumber = \"500\";typeof myNumber;// 输出 'string'myNumber = 500; typeof myNumber;//输出'number'\n\n\n函数\n提升 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.\n\nexampleFunction();function exampleFunction() {  console.log(\"函数内\");  console.log(x);}\n\n由于 提升 的存在, 上述的函数调用不会出错.\n\n默认参数在编写函数时, 可以通过在参数名称后添加=, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。\nfunction greeding(name = \"my friend\") {    console.log(`Hello, ${name}!`);}hello(); //Hello, my friend!hello(\"world\"); //Hello, world!\n\n\n\n事件处理函数的默认接受值是event:\n&lt;button&gt;onclick&lt;/button&gt;&lt;p&gt;nothing here&lt;/p&gt;&lt;script&gt;btn = document.querySelector(\"button\")para = document.querySelector(\"p\")btn.onclick = click;function click(string){  console.log(\"clicked!\")  para.textContent = string;}&lt;/script&gt;\n\n上述的btn在点击之后调用函数click, 该函数需要一个参数string, 由于btn.onclick = click;的绑定方式, 我们无法指定传参的值, 因此点击之后的para的内容显示为: [object PointerEvent];\ntextContent是属性而非方法, 因此采用赋值实现;\n\nbtn.onclick = function click(string) {  console.log(\"clicked!\")  para.textContent = \"You have clicked the button!\";}\n\n将上述的绑定方式如此改写, 可以在btn外对string进行赋值, 然后点击按钮可以传入指定参数供后续处理.\n\n箭头函数在了解箭头函数的作用之前, 需要先介绍 匿名函数:\nfunction myFunction() {  alert(\"你好\");}// 匿名函数(function () {  alert(\"你好\");});\n\n正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.\n\n如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:\nfunction logKey(event) {  console.log(`You pressed \"${event.key}\".`);}textBox.addEventListener(\"keydown\", logKey);\n这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:\ntextBox.addEventListener(\"keydown\", function (event) {  console.log(`You pressed \"${event.key}\".`);});\n\n只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.\n\n而箭头函数则是在此情况下更简洁的函数定义方式:\ntextBox.addEventListener(\"keydown\", (event) =&gt; {  console.log(`You pressed \"${event.key}\".`);});//如果函数只接受一个参数, 也可以省略参数周围的括号textBox.addEventListener(\"keydown\", event =&gt; {  console.log(`You pressed \"${event.key}\".`);});\n\n如果只包含一行的return,则可以忽略{}和return关键字:\nconst originals = [1, 2, 3];const doubled = originals.map(item =&gt; item * 2);console.log(doubled); // [2, 4, 6]\n\nitem =&gt; item * 2等价于:\n\nfunction doubleItem(item) {  return item * 2;}\n\n一个实例&lt;input id=\"textBox\" type=\"text\" /&gt;&lt;div id=\"output\"&gt;&lt;/div&gt;\nconst textBox = document.querySelector(\"#textBox\");const output = document.querySelector(\"#output\");textBox.addEventListener(\"keydown\", (event) =&gt; {  output.textContent = `You pressed \"${event.key}\".`;});\n通过监听输入框的keydown事件, 输出按下的键盘按键.\n函数作用域和冲突作用域 指当前的执行上下文, 在其中的值和表达式可以被访问. \n\n全局作用域: 脚本模式运行所有代码的默认作用域;\n模块作用域: 模块模式中运行代码的作用域;\n函数作用域: 由函数创建的作用域\n\n和C语言相似, 在函数外部let定义的变量, 以及const定义的常量可以在函数内部访问.\n如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:\n&lt;!-- Excerpt from my HTML --&gt;&lt;script src=\"first.js\"&gt;&lt;/script&gt;&lt;script src=\"second.js\"&gt;&lt;/script&gt;&lt;script&gt;  greeting();&lt;/script&gt;\n\n如果两个JS文件都定义了greeting函数, 则只有第一个文件中的函数才会被调用.\n\n数据类型数字和操作符大部分与C语言相同, 概括需要注意的差异:\n\nJS当中只有一种数字类型 – number, 对于整型或者浮点数的初始化得到的量, 由typeof均得到number;\n算术运算符: 求幂为**;\n常量无法使用自增或自减,好像也是C语言的 忘了\n===表示严格等于, !==表示不等于;\n同时存在==和!=来判断是否相等, 但是它们只是测试 值 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用===和!==来避免类型不一致的错误.\n\n\n\n字符串创建字符串\nlet myString = \"A string\";const constString = myString;console.log(constString);//A string\n可以使用单引号,双引号和反引号来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:\nconst single = '单引号';const double = \"双引号\";const backtick = `反引号`;\n\n反引号包裹的字符串称为模板字符串, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:\n\n可以嵌入 JavaScript;\n可以声明多行的模板字面量.\n\n字符串的拼接字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 串联法:\nconst name = \"克里斯\";const greeting = `你好，${name}`;console.log(greeting); // \"你好，克里斯\"\n\n在模板字面量中用${}包装JS的变量或者表达式.\n\nconst one = \"你好，\";const two = \"请问最近如何？\";const joined = `${one}${two}`;console.log(joined); // \"你好，请问最近如何？\"\n\n连接2个变量.\n\nconst song = \"青花瓷\";const score = 9;const highestScore = 10;const output = `我喜欢歌曲《${song}》。我给它打了 ${  (score / highestScore) * 100} 分。`;console.log(output); // \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"\n\n在模板字面量的${}内部包含表达式.\n\n\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\nconst greeting = \"你好\";const name = \"克里斯\";console.log(greeting + \"，\" + name); // \"你好，克里斯\"\n\n多行字符串模板字符串会保留源代码中的换行符，因此可以编写跨越多行的字符串:\nconst newline = `终于有一天，你知道了必须做的事情，而且开始……`;console.log(newline);/*终于有一天，你知道了必须做的事情，而且开始……*/\n\n如果希望用普通的字符串得到等效的输出, 必须在字符串中包含\\n,而非直接跨行:\nconst newline = \"终于有一天，\\n你知道了必须做的事情，而且开始……\";console.log(newline);/*终于有一天，你知道了必须做的事情，而且开始……*/\n\n显示引号\n转义  通过在符号前加上反斜杠\\, 可以转义字符串中的特殊字符,包括字符串中的引号:\n\nconst bigmouth = 'I\\'ve got no right to take my place…';\n\n换用其他字符: 在字面量内用不同于包裹字符串的引号:\n\nconst goodQuotes1 = 'She said \"I think so!\"';const goodQuotes2 = `She said \"I'm not going in there!\"`;\n\n\n常用方法对于字符串对象实例,其常用的方法:\n\n.length: 获取字符串的长度;\n[]: 返回字符串中对应索引的字符, 索引同样从0开始;\n.indexOf(\"\"): 查找子字符串\ninput: 希望查找的子字符串;\noutput: 子字符串开始的下标(如果不存在则返回-1);\n\n\n.slice(indedxStart, indexEnd): 截取字符串\ninput: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;\noutput: 截取的子字符串;\n\n\n\n更多的slice知识:\n\n标准化负值 如果索引是个负数, 取index+str.length进行标准化;\n如果indexStart大于str.length, 返回空字符串;\n如果标准化负值之后, indexStart大于indexEnd, 也返回空字符串;\n\n\n.toLowerCase() &amp; .toUpperCase(): 转换字符串中的所有字符为小写或大写;\n.replace(original, new): 替换字符串中original子字符串为new;\n此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.\n\n\n\nCases利用 indexOf 和 slice 方法, 获取新字符串:\n\ninput: \"str3\"三位长字符串+\"...\"(无关字符串)+\";\"+strLast(剩余字符串);\noutput: \"str3\"+\";\"+strLast\n\nvar stations = ['MAN675847583748sjt567654;Manchester Piccadilly',                'GNF576746573fhdg4737dh4;Greenfield',                'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street',                'SYB4f65hf75f736463;Stalybridge',                'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'];for(var i = 0; i &lt; stations.length; i++){    var input = stations[i];    var str3 = input.slice(0,3);    var strLast = input.slice(input.indexOf(\";\")+1); //indexOf获取;位置    var output = str3 + \";\" + strLast;}\n\n\n通过 indexOf 根据子字符串筛选字符串数组:\n\ninput: 可能包含 Christmas 的字符串数组;\noutput: 包含 Christmas 的字符串数组;\n\nvar list = document.querySelector('.output ul');list.innerHTML = '';var greetings = ['Happy Birthday!',                 'Merry Christmas my love',                 'A happy Christmas to all the family',                 'You\\'re all I want for Christmas',                 'Get well soon'];for(var i = 0; i &lt; greetings.length; i++) {  var input = greetings[i];  if(greetings[i].indexOf('Christmas') !== -1) {    var result = input;    var listItem = document.createElement('li');    listItem.textContent = result;    list.appendChild(listItem);  }}\n\n数字与字符串相互转换非常神奇, 在JS当中, 数字和字符串可以直接通过函数Number()和String()进行转换, 与C语言不同.\nconst myString = \"123\";const myNum = Number(myString);console.log(typeof myNum);// numberconsole.log(myNum);// 123\n\nconst myNum2 = 123;const myString2 = String(myNum2);console.log(typeof myString2);// stringconsole.log(myString2);// \"123\"\n\n对于浮点数同样成立.\n\n前后拼接使用+将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:\nconst name = \"Front \";const number = 242;const combine = name + number;console.log(combine); //Front 242console.log(typeof(combine));  //string\n\n数组\n存储任意类型元素–字符串，数字，对象，变量，另一个数组;\n可以 混合 元素类型:\n\nlet random = [\"tree\", 795, [0, 1, 2]];\n\n像访问字符串一样, 利用索引访问数组元素;\n多维数组 包含数组的数组结构称为~\n\nsplit()\n作用: 将一个字符串根据给定的字符分隔为字符串数组;\n\nlet myData = \"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\";let myArray = myData.split(\",\");console.log(myArray); // [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]\n\njoin()split的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:\nlet myNewString = myArray.join(\",\");myNewString;\n\ntoString()与join方法相似, 但是无法自定义分隔符, 默认为,:\nlet dogNames = [\"Rocket\", \"Flash\", \"Bella\", \"Slugger\"];dogNames.toString(); //Rocket,Flash,Bella,Slugger\n\npush &amp; poppush()方法可以将1或多个元素添加到数组的 末尾:\n\n将会直接改写原来的数组,不需要重新赋值;\n该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);\n\nlet myArray = [1, 2, 3];let newLength = myArray.push(4, 5,\"string\");console.log(myArray); // [1, 2, 3, 4, 5, \"string\"]console.log(newLength); // 6\n\n使用.pop()从数组中删除最后一个元素:\nmyArray.pop(); //\"string\"console.log(myArray); // [1, 2, 3, 4, 5]\n\n方法调用返回值就是删除的元素本身;\n直接对原始数组操作并赋值, 不需要另外的赋值操作;\n\n\nshift &amp; unshift:在功能上分别与push和pop相同, 但是作用于数组的开始位置.\n\n条件语句JS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:\n天气预报&lt;label for=\"weather\"&gt;选择今天的天气：&lt;/label&gt;&lt;select id=\"weather\"&gt;  &lt;option value=\"\"&gt;--作出选择--&lt;/option&gt;  &lt;option value=\"sunny\"&gt;晴天&lt;/option&gt;  &lt;option value=\"rainy\"&gt;雨天&lt;/option&gt;  &lt;option value=\"snowing\"&gt;雪天&lt;/option&gt;  &lt;option value=\"overcast\"&gt;阴天&lt;/option&gt;&lt;/select&gt;&lt;p&gt;&lt;/p&gt;\n\nlable当中的for标签与select标签的id属性对应, 用于关联两个标签.\n\nconst select = document.querySelector(\"select\");const para = document.querySelector(\"p\");select.addEventListener(\"change\", setWeather);function setWeather() {  const choice = select.value;  switch (choice) {    case \"sunny\":      para.textContent = \"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\";      break;    case \"rainy\":      para.textContent = \"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\";      break;    case \"snowing\":      para.textContent =        \"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\";      break;    case \"overcast\":      para.textContent =        \"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\";      break;    default:      para.textContent = \"\";  }}\n\n\n通过querySelector方法获取select和p标签;\n然后为select标签添加事件监听器, 当内容改变时触发 change 事件, 同时调用setWeather函数;\n进而通过 switch 语句处理不同天气的情况, 并设置相应的文字内容;在线网页示例:simple-switch\n\n\n事件介绍什么是事件? \n\n用户选择、点击或者光标悬停在某一元素;\n用户在键盘中按下某个按键;\n网页结束加载;\n…\n\n事件处理器 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.\n处理点击事件以点击事件为例, 介绍html与js如何进行事件处理的交互:\n&lt;button&gt; 改变颜色 &lt;/button&gt;\nconst btn = document.querySelector(\"button\");function random(number){  return Math.floor(Math.random()*(number+1));  }btn.addEventListener(\"click\", ()=&gt;{  const rndCol = `rgb(${random(255)},${random(255)},${random(255)})`;  document.body.style.backgroundColor = rndCol;})\n\nMath.random()方法生成一个介于[0,1)之间的随机数;\n*(number+1)之后利用向下取整的方法Math.floor()将其转换为整数, 范围为[0,number];\n假如输入的number为4, 则random(4)的结果可能为0, 1, 2, 3, 4中的一个;假设输入的number为3.6, 则输出的结果还是0~4中的整数.\n\n\nrndCol = `rgb(${random(255)},${random(255)},${random(255)}) 采用的是在模板字符串内部使用${}调用函数变量的方法.\n\naddEventListener()adEventListener方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.\n通过EventTarget.adddEventListener()的方法, 将指定的监听器注册到对象上, 具体的语法如下:\naddEventListener(type, listener);addEventListener(type, listener, options);addEventListener(type, listener, useCapture);\n\ntype: 事件类型, 如click, mouseover, mouseout, keydown, keyup等;\nlistener: 事件处理函数, 该函数将在事件发生时被调用;\n包括 回调函数 以及 实现了 EventListener 接口的对象;\n\n\noptions: 可选参数, 用于配置事件监听器的行为;\n可以为单个事件添加多个事件监听器.\n\n\n\nlistener回调函数 简单来说, ~指的是当某个事件发生时被调用的一段代码.\n\n是一个函数, 但是只有等到特定的事件发生时才会执行.\n\n实现了 EventListener 接口的对象:\n\n特点: 以对象作为listener, 对象中具有名为handleEvent()的方法;\n作用: \n将事件处理封装到一个对象当中, 可以更好地组织代码;\n便于在对象中保存更多的状态信息;\n\n\n\nconst listenerObject = {    count: 0,    handleEvent(event) {        this.count++;        console.log(`事件类型是：${event.type}，已触发 ${this.count} 次`);    }};const button = document.querySelector('button');button.addEventListener('click', listenerObject);\n\noptions一个指定有关 listener 属性的可选参数对象.\nCapture\n含义:\n\n一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;\n默认为false, 表示只有在冒泡阶段才触发.\n\n\n区别:\n\ncapture和useCapture实际上指的都是 监听器是否在捕获阶段触发 的布尔值.\n捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.\n\n\n后来DOM的规范更新时引入了options参数, 此后capture取代了useCapture的作用.\n如果addEventListener的第三个参数不指定对象, 只有布尔值, 那么默认是在设置useCapture\n\n\n\n\n可以先查看事件传播的阶段来辅助理解不同的阶段.\n\nOnce\n含义:\n一个布尔值，表示 listener 在添加之后最多只调用一次;\n默认为false, 表示可以多次调用.\n\n\ne.g.\n\nchild.addEventListener('click', () =&gt; {    console.log('子元素 - 目标阶段');},{once: true});\n\nonce属性被设置为true, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.\n\nPassive\n含义:\n\n一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();\n\n\n作用:\n\n明确不会在listener中不会调用preventDefault()方法, 即不会阻止浏览器的默认行为;\n此时, 浏览器可以直接渲染默认行为的结果, 无需等待listener的执行与默认行为的检查, 从而提高了性能.\n\n\nNotice:\n\n如果设置passive为true, 则listener当中不可出现preventDefault()方法, 否则会报错.\n\n\n\ne.g.\ndocument.addEventListener('wheel',()=&gt;{\tevent.preventDefault();  console.log(\"scrolling\");},{passive: false});\n\nwheel事件的默认行为是滚动页面;\nevent.preventDefault();表示会阻止鼠标滚动带来的页面滚动;\n\ndocument.addEventListener('wheel',()=&gt;{  console.log(\"scrolling\");},{passive: true});\n\n明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.\n\ndocument.addEventListener('wheel',()=&gt;{  event.preventDefault();  console.log(\"scrolling\");},{passive: true});\n\npassive的设置与listener内部矛盾, 将会报错.\n\nSignal用于有条件地移除事件监听器, 具体使用参见可被移除的监听器.\n事件传播的阶段\n捕获阶段 : 事件从根节点开始向目标节点传播;\ne.g. 点击事件从document开始传播, 经过html,body直到目标元素.\n\n\n目标阶段阶段 : 事件到达目标元素;\n冒泡阶段 : 事件从目标元素开始沿着DOM树向上传播.\n\nCase&lt;div id=\"parent\"&gt;  parent  &lt;div id=\"child\"&gt;child&lt;/div&gt;&lt;/div&gt;\nconst parent = document.querySelector('#parent');const child = document.querySelector('#child');parent.addEventListener('click', () =&gt; {    console.log('父元素 - 冒泡阶段');});parent.addEventListener('click', () =&gt; {    console.log('父元素 - 捕获阶段');}, { capture: true });child.addEventListener('click', () =&gt; {    console.log('子元素 - 目标阶段');});\n上述的child被包裹在parent内部.\n\n当点击parent时将会显示:\n\n\"父元素 - 捕获阶段\"\"父元素 - 冒泡阶段\"\n\n由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;\n\n\n当点击child时将会显示:\n\n\"父元素 - 捕获阶段\"\"子元素 - 目标阶段\"\"父元素 - 冒泡阶段\"\n\nchild是整个事件流的目标元素, 所以触发时机介于二者之间.\n\nNotice\n如果将div换成button, 则点击child时可能只会显示 目标 阶段的输出.\n\n这是因为, 不同浏览器对于button元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段\n\n\nevent.stopPropagation();加入该咒语代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:\n\n\nparent.addEventListener('click', () =&gt; {    console.log('父元素 - 捕获阶段');    event.stopPropagation();}, { capture: true });\n\n此时, 点击parent时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.\n\n可被移除的监听器&lt;table id=\"outside\"&gt;  &lt;tr&gt;    &lt;td id=\"t1\"&gt;one&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td id=\"t2\"&gt;two&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;\n// 为 table 添加可被移除的事件监听器const controller = new AbortController();const el = document.getElementById(\"outside\");el.addEventListener(\"click\", modifyText, { signal: controller.signal });// 改变 t2 内容的函数function modifyText() {  const t2 = document.getElementById(\"t2\");  if (t2.firstChild.nodeValue === \"three\") {    t2.firstChild.nodeValue = \"two\";  } else {    t2.firstChild.nodeValue = \"three\";    controller.abort(); // 当值变为 \"three\" 后，移除监听器  }}\n\n\nAbortController是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;\nsignal属性是一个AbortSignal对象, 用于控制监听器的移除;\ncontroller.abort()方法用于移除监听器;\n当t2的内容变为”three”时, 移除监听器, 使得modifyText函数不再执行. 此后, 点击t2不会触发modifyText函数.\n\n\n具体的构造步骤:\n\n创建一个AbortController实例: const controller = new AbortController();\n在事件监听器内的参数中添加signal: controller.signal选项;\n在需要移除监听器的地方调用controller.abort()方法;\n\n\n我们也可以直接使用removeEventListener()方法来移除事件监听器:\nremoveEventListener(type, listener);removeEventListener(type, listener, options);removeEventListener(type, listener, useCapture);\n\n\n\nNotices:\n如果同一个对象上存在2个事件监听器, 且仅在useCapture参数存在差异, 那么需要先后2次调用removeEventListener()方法才能完全移除其事件监听器;\n如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;\ntype,listener参数必须完全匹配才能移除事件监听器;\n对于options参数:\n字段相同: 一定可以移除;\n字段不同: 需要与默认值false匹配才可以移除.\n\n\n\n\n\nelement.addEventListener(\"mousedown\", handleMouseDown, { passive: true });element.removeEventListener(\"mousedown\", handleMouseDown, { passive: true }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, { capture: false }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, { capture: true }); // 失败element.removeEventListener(\"mousedown\", handleMouseDown, { passive: false }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, false); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, true); // 失败\n\n\n添加与移除的结合使用:\nconst body = document.querySelector(\"body\");const clickTarget = document.getElementById(\"click-target\");const mouseOverTarget = document.getElementById(\"mouse-over-target\");let toggle = false;function makeBackgroundYellow() {  body.style.backgroundColor = toggle ? \"white\" : \"yellow\";  toggle = !toggle;}clickTarget.addEventListener(\"click\", makeBackgroundYellow, false);mouseOverTarget.addEventListener(\"mouseover\", () =&gt; {  clickTarget.removeEventListener(\"click\", makeBackgroundYellow, false);});\n\n\n使用匿名函数在上述html例子下:\n// 改变 t2 内容的函数function modifyText(new_text) {  const t2 = document.getElementById(\"t2\");  t2.firstChild.nodeValue = new_text;}// 用匿名函数为 table 添加事件监听器const el = document.getElementById(\"outside\");el.addEventListener(  \"click\",  function () {    modifyText(\"four\");  },  false,);\n通过匿名函数封装代码, 将参数传入函数modifyText, 使得函数可以被调用.\n使用箭头函数// 改变 t2 内容的函数function modifyText(new_text) {  var t2 = document.getElementById(\"t2\");  t2.firstChild.nodeValue = new_text;}// 用箭头函数为 table 添加事件监听器const el = document.getElementById(\"outside\");el.addEventListener(  \"click\",  () =&gt; {    modifyText(\"four\");  },  false,);\n通过=&gt;{}形式的箭头函数简化代码书写.\n\n比较匿名与箭头匿名函数与箭头函数在此处的应用基本相同, 但是在this的指向上有所不同:\n\n匿名函数与其他普通的JS函数:this指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为undefined);\n\nfunction sayHello() {  console.log(this); // 在非严格模式下，this 指向 window}sayHello();\n\n\n箭头函数的this继承自外部作用域, 即调用该方法的对象.\n\nconst obj = {  name: \"ZJU\",  greet: function () {    console.log(this.name); // this 指向 obj  },};obj.greet(); // 输出：ZJU\n\n\ne.g.\n\nconst obj = {  name: \"ZJU\",  getNameWithAnonymous: function () {    return function () {      console.log(this.name);    };  },  getNameWithArrow: function () {    return () =&gt; {      console.log(this.name);    };  },};const anonymousFn = obj.getNameWithAnonymous();anonymousFn(); // 输出：undefinedconst arrowFn = obj.getNameWithArrow();arrowFn(); // 输出：ZJU\n\n进一步完善.\n\n事件对象事件对象 在事件处理函数的内部, 以固定指定名称出现的参数, 例如event,e,evt. 它被自动传递给事件处理函数，以提供额外的功能和信息。\ne.target始终是对 事件刚刚发生的元素 的引用\n表达式和运算符new() 用来创建对象实例的一个关键字. \n\n作用: 调用 一个 构造函数, 并返回一个由该构造函数创建的对象实例.\n\n语法new constructornew constructor()new constructor(arg1)new constructor(arg1, arg2)new constructor(arg1, arg2, /* …, */ argN)\n\n如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即new foo 等价于 new foo();\n构造函数内部的this将被绑定到新建的对象实例上;\n\n\ne.g.\n\nfunction Car(color, brand) {  this.color = color;   // 将 color 赋值给新对象  this.brand = brand;   // 将 brand 赋值给新对象}const myCar = new Car(\"red\", \"Toyota\");console.log(myCar.color); // 输出 \"red\"console.log(myCar.brand); // 输出 \"Toyota\"\n\n使用new()的步骤:\n\n定义构造函数;\n使用new()并传入构造函数的参数;\n将返回的对象实例赋值给一个变量;\n\n新增属性\n为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:\n\ncar1.color = \"black\" //为car1新增color属性\n\n\n\n添加共享属性到构造函数中的prototype:\n\nfunction Car() {}car1 = new Car();car2 = new Car();console.log(car1.color); // undefinedCar.prototype.color = \"原色\";console.log(car1.color); // '原色'car1.color = \"黑色\";console.log(car1.color); // '黑色'console.log(Object.getPrototypeOf(car1).color); // '原色'console.log(Object.getPrototypeOf(car2).color); // '原色'console.log(car1.color); // '黑色'console.log(car2.color); // '原色'\n\n\n此处的构造函数名为Car, 因此通过Car.prototype可以访问到构造函数的原型对象;\ngetPrototypeOf 表示获取对象的原型对象, 因此此处均为最初定义的 原色.\n\n\nnew.target函数通过new.target属性可以判断是否通过new关键字调用, 即构造.\n\n如果函数是正常调用, 则返回undefined;\n\n如果函数是通过new调用, 返回被调用的构造函数.\n\ne.g.\n\n\nfunction Car(color) {  if (!new.target) {    // 以函数的形式被调用。    return `${color}车`;  }  // 通过 new 被调用。  this.color = color;}const a = Car(\"红\"); // a 是“红车”const b = new Car(\"红\"); // b 是 `Car { color: \"红\" }`\n\n对象类型与实例对象类型 通过构造函数可以创建一个对象类型:\nfunction Car(make, model, year) {  this.make = make;  this.model = model;  this.year = year;}\n\n对象实例 通过使用new()方法, 由对象类型构造一个对象实例:\nconst myCar = new Car(\"鹰牌\", \"Talon TSi\", 1993);\n\n类与new在JS当中, 类 必须 通过new调用.\n\n可以优先阅读类相关的知识\n\n\ne.g.\n\nclass Animal {  //构造函数  constructor(name) {    this.name = name;  }  //实例方法  greet() {    console.log(`你好，我的名字是${this.name}`);  }}\n对于上述的类, 必须使用如下的调用方式:\nconst animal = new Animal(\"Dog\"); // 正常\n而下面这样类似于普通函数的调用方式会抛出错误:\nAnimal(\"Cat\"); // TypeError:  Class constructor Animal cannot be invoked without 'new'\n\n\n在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:\nanimal.greet(); // 输出 \"你好，我的名字是Dog\"\n\n\n下面给出与普通函数的区别:\nfunction Car(model) {  this.model = model;}const car = new Car(\"Toyota\"); // 正常Car(\"Honda\"); // 不抛出错误，但 this 会指向全局对象.const anotherCar = Car(\"cat\"); //此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.\n总结:\n\n以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;\n如果以new方法构造得到对象实例, 依旧正常.\n\n\n补充默认行为默认行为 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.\n\n比如存在以下的默认行为:\n滚动事件：触摸屏上滑动手指，页面会滚动;\n拖拽文件到浏览器：浏览器会尝试加载文件;\n点击链接 (&lt;a href=\"...\"&gt;)：跳转到指定的 URL;\n\n\n\n阻止默认行为 使用 event.preventDefault() 方法可以阻止事件的默认行为.\n\ne.g: 阻止链接跳转\n\ndocument.querySelector('a').addEventListener('click', function(event) {    event.preventDefault(); // 阻止点击链接时的默认行为    console.log('链接被点击，但没有跳转');});\n\n\n作用:\n通过阻止默认行为, 可以实现自定义逻辑.\n\n\n\nthis\nthis可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;\nthis 指向的是当前函数的调用者，而不是函数内部定义的变量.\n\n\n\n\ne.g.\n\nconst obj = {    a: \"a in the obj\",    b: \"b in the obj\",    f: function() {        const b = \"b in the function\"; // 函数作用域        console.log(this.b); // 访问 this.b    }};const b = \"b outside of the func\";obj.f();\n\n此处的f\n\n函数上下文中的this\nthis参数的值取决于函数如何被调用, 而不是函数如何被定义.\n\n// 对象可以作为第一个参数传递给 'call' 或 'apply'，// 并且 'this' 将被绑定到它。const obj = { a: \"Custom\" };// 使用 var 声明的变量成为 'globalThis' 的属性。var a = \"Global\";function whatsThis() {  return this.a; // 'this' 取决于函数如何被调用}whatsThis(); // 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'obj.whatsThis = whatsThis;obj.whatsThis(); // 'Custom'; 'this' 参数被绑定到 obj\n\n同样是调用函数whatsThis(), 但是this参数被绑定到不同的对象上, 导致返回值不同;\n在非严格模式下, this参数默认指向globalThis, 即全局对象;\n对于典型函数, this指向函数访问的对象;\n\n\ne.g.\n\nconst obj = {    b: \"b in the obj\",    f: function() {        const b = \"b in the function\"; // 函数作用域        console.log(this.b); // 访问 this.b    }};const b = \"b outside of the func\";obj.f();\n\n此处f作为obj对象的方法被调用, 因此普通函数的this指向obj.\n\n\ne.g. 直接调用的普通函数this指向全局:\n\nconst obj = {    a: \"a in the obj\",    f: function() {        const funcA = function () { return this.a }; // 普通函数，this 由调用方式决定        console.log(funcA()); // 访问 this.a    }};var a = \"a in the global\";obj.f(); // \"a in the global\"\n\n\n此处的funcA并没有类似于作为对象的属性调用(obj.funcA()), 因此其this指向全局作用域(window), 输出undefined, 而是直接调用的形式, 因此其this指向全局作用域.\n\n\n对this传值使用call()以及apply()方法可以将this绑定到其他对象上.\ncall()\n形式: func.call(thisArg, arg1, arg2, ...)\ne.g:\n\nfunction add(c, d) {  return this.a + this.b + c + d;}const o = { a: 1, b: 3 };// 第一个参数被绑定到隐式的 'this' 参数；// 剩余的参数被绑定到命名参数。add.call(o, 5, 7); // 16\n\napply()\n形式: func.apply(thisArg, [argsArray])\ne.g:\n\nfunction add(c, d) {  return this.a + this.b + c + d;}const o = { a: 1, b: 3 };// 第一个参数被绑定到隐式的 'this' 参数；// 第二个参数是一个数组，其成员被绑定到命名参数。add.apply(o, [10, 20]); // 34\n\nbind()\n形式: f.bind(someObject);\n作用: \n创建一个新的函数(需要重新赋值), 具有与f相同的函数体和作用域;\n新函数的this被 永久地 绑定到someObject, 不随调用方式的变化而变化.\n\n\n限制: \nbind无法多次生效. 即对函数fbind得到的g, 无法继续用bind得到期望的h;\n\n\ne.g. 多次bind:\n\nfunction f() {  return this.a;}const g = f.bind({ b: \"azerty\" });console.log(g()); // undefinedconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！console.log(h()); // undefinedconst o = { a: 37, f, g, h };console.log(o.a, o.f(), o.g(), o.h()); // 37 37 undefined undefined\n\n\n由于bind只能对一个原始函数作用, 因此由f得到的g无法继续由bind绑定this得到期望的h, 此处h的this依旧是{b: \"azerty\"}, 因此在输出对象a时显示undefined;\no.f()的调用是普通函数的调用, 因此其this继承自对象o, 输出37;\n\n\n\ne.g. 对象\n\nfunction f() {  return this.a + \" \" + this.c;}const g = f.bind({ b: \"azerty\" , c:\"ccc\"});console.log(g()); // \"undefined ccc\"const h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！console.log(h()); // \"undefined ccc\"const o = { a: 37, f, g, h };console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty\n\n\nbind绑定的this是永久覆盖, 而非简单叠加;\n由于bind绑定的this不随者调用方式的变化而变化, 因此即使处于对象o当中, g,h依旧不会输出o中的a.\n\n\n箭头函数中的this使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。\n普通函数:\nconst a = \"a in the global\";const foo = function () {return this.a};const obj = { a: \"a in the obj\", f: foo};console.log(obj.f()); // \"a in the obj\"\n\ncall()、 apply()、 bind() 无法改变箭头函数的this(但是call与apply的其他参数可以正常传递:\nconst foo = ()=&gt; this.a;const obj = { a: \"a in the obj\", f: foo.bind({a:\"a in the bind\"}) // 显式绑定 this 到 obj, 但是无法生效};console.log(obj.f()); // undefined\n\n换成普通函数则输出a in the obj.\n\n\n全局作用域\n\nvar a = \"a in the global\";const foo1 = () =&gt; this.a;const obj = {\ta: \"a in the obj\",\tf: ()=&gt; a};console.log(obj.f());\n\n作用域作用域 指当前的执行上下文, 在其中的值和表达式可以被访问. \n\n全局作用域: 脚本模式运行所有代码的默认作用域;\n模块作用域: 模块模式中运行代码的作用域;\n函数作用域: 由函数创建的作用域\n块级作用域: 由let或const声明的变量的作用域.(对于var无效);\n\n{  var x = 1;}console.log(x); // 1{  const x = 1;}console.log(x); // undefined\n\nNotices:\n\n对象本身并不会创建作用域, 只是一个键值对的集合;\n箭头函数也不会创建自己的作用域, 而是 继承 外层作用域中的this;\n\n变量与作用域\nvar在全局作用域中声明时会成为 全局对象 (window或global)的属性;\nlet和const即使在全局作用域中声明, 也不会成为全局对象的属性;\n\nvar a = \"1\";let b = \"2\";window.a; // \"1\"window.b; // undefined\n\n因此, 建议在全局作用域中不要使用var声明变量, 而使用let或const声明变量. 从而避免导致意外的覆盖和冲突.\n\n函数与作用域普通函数普通函数和匿名函数的作用域继承自其定义时的作用域.\nconst obj = {    a: \"a in the obj\",    insideObj: {        g: function() {            return this.a; // 普通函数，this 动态绑定到 insideObj        }    },    f: function() {        return this.a; // 普通函数，this 动态绑定到 obj    }};console.log(obj.f());        // \"a in the obj\"console.log(obj.insideObj.g()); // undefined，因为 insideObj 中没有 a\n\n箭头函数e.g. 箭头函数继承外层作用域:\nvar a = \"a in the global\";const obj = {    a: \"a in the obj\",    insideObj: {        g: () =&gt; this.a    },    f: () =&gt; this.a};console.log(obj.f());        // \"a in the global\"console.log(obj.insideObj.g()); //\"a in the global\"\n由于对象不会创建作用域, 因此此处的箭头函数的this继承了外层作用域(window)的this, 且var创建的变量存在于全局作用域中.\n语法糖语法糖 一种让代码更简洁、更易读的语法形式.\n\n本质上没有增加语言的功能, 而是对已有功能的 包装 或者优化;\n可读性提升: 让代码更填 使得代码更加容易理解和书写;\n底层实现: 实质上依旧用基础的语法实现.\n\n类类 class 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承prototype的封装.\n使用class的写法:\nclass Person {  constructor(name) {    this.name = name;  }  greet() {    console.log(`Hello, my name is ${this.name}`);  }}const person = new Person(\"Alice\");person.greet(); // 输出：Hello, my name is Alice\n\n等价的原型写法:\nfunction Person(name) {  this.name = name;}Person.prototype.greet = function() {  console.log(`Hello, my name is ${this.name}`);};const person = new Person(\"Alice\");person.greet(); // 输出：Hello, my name is Alice\n\n箭头函数箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.\n\ne.g.\n\n// 使用箭头函数const add = (a, b) =&gt; a + b;// 等价的普通函数const add = function add(a, b) {  return a + b;}\n\n结构赋值结构赋值 手动提取对象属性的语法糖.\n\n使用结构赋值:\n\nconst person = {name:\"Zhuo\", gender:\"male\"};const {name, gender} = person;\n\n\n等价的原型写法:\n\nconst person = {name:\"Zhuo\", gender:\"male\"};const name = person.name;const gender = person.gender;\n\n赋值规则结构赋值时, 基于 属性名匹配 而非顺序.因此, 对象结构的{}内部属性必须和 对象的属性名 相对应.\n错误的示例:\nconst person = { name: \"Alice\", age: 25 };const { a, b } = person;console.log(a); // 输出：undefinedconsole.log(b); // 输出：undefined\n\n重命名属性的写法:\nconst person = { name: \"Alice\", age: 25 };const { name: a, age: b } = person;console.log(a); // 输出：Aliceconsole.log(b); // 输出：25\n\n手动赋值: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:\nconst person = { name: \"Alice\" };const { name, age = 30 } = person;console.log(name); // 输出：Aliceconsole.log(age);  // 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）\n数组的结构赋值上述讨论的结构赋值都是对 对象 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— 基于顺序赋值:\nconst arr = [\"Alice\", 25];const [a, b] = arr;console.log(a); // 输出：Aliceconsole.log(b); // 输出：25\n","categories":["学习笔记"],"tags":["前端","JS"]},{"title":"CORS","url":"/2025/01/16/%E5%89%8D%E5%90%8E%E7%AB%AF/CORS/","content":"跨域资源共享（CORS）技术指南目录\n概述\n技术背景\n配置方案\n最佳实践\n问题排查\n参考文献\n\n概述跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。\n技术背景同源策略基础同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：\n基准URL：http://example.com/page.html跨域场景：- http://api.example.com/data     // 子域名差异- https://example.com/data        // 协议差异- http://example.com:8080/data    // 端口差异\n\n配置方案环境变量驱动的CORS配置以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：\nimport osfrom flask import Flaskfrom flask_cors import CORSapp = Flask(__name__)# 从环境变量获取前端URL，如果没有设置则使用默认值FRONTEND_URL = os.environ.get(&#x27;FRONTEND_URL&#x27;, &#x27;http://localhost:3000&#x27;)# CORS配置实现CORS(app, resources=&#123;    r&quot;/api/*&quot;: &#123;        &quot;origins&quot;: FRONTEND_URL,        &quot;methods&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;, &quot;PUT&quot;, &quot;DELETE&quot;],        &quot;allow_headers&quot;: [&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Requested-With&quot;],        &quot;supports_credentials&quot;: True,        &quot;expose_headers&quot;: [&quot;Content-Disposition&quot;]    &#125;&#125;)\n\n配置详解让我们逐行分析这个配置：\n\n环境变量设置\n\nFRONTEND_URL = os.environ.get(&#x27;FRONTEND_URL&#x27;, &#x27;http://localhost:3000&#x27;)\n\n使用os.environ.get()获取环境变量\n提供默认值&#39;http://localhost:3000&#39;作为本地开发环境的配置\n可以通过环境变量轻松切换不同环境的配置\n\n\nCORS配置参数\n\n&quot;origins&quot;: FRONTEND_URL\n\n动态设置允许的源，基于环境变量\n避免了硬编码的问题\n支持不同部署环境的灵活配置\n\n\nHTTP方法配置\n\n&quot;methods&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;, &quot;PUT&quot;, &quot;DELETE&quot;]\n\n明确定义允许的HTTP方法\n包含了RESTful API所需的全部方法\nOPTIONS用于预检请求（preflight request）\n\n\n请求头配置\n\n&quot;allow_headers&quot;: [&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Requested-With&quot;]\n\nContent-Type：允许设置请求的内容类型\nAuthorization：支持身份验证令牌\nX-Requested-With：用于标识AJAX请求\n\n\n凭证支持\n\n&quot;supports_credentials&quot;: True\n\n允许跨域请求携带凭证（如Cookie）\n对需要身份验证的API至关重要\n\n\n响应头暴露\n\n&quot;expose_headers&quot;: [&quot;Content-Disposition&quot;]\n\n允许客户端访问Content-Disposition响应头\n通常用于文件下载功能\n\n环境变量配置示例# 开发环境export FRONTEND_URL=http://localhost:3000# 测试环境export FRONTEND_URL=http://test.example.com# 生产环境export FRONTEND_URL=https://www.example.com\n\n最佳实践环境变量管理建议\n开发环境\n\n\n使用.env文件管理本地开发环境变量\n将.env文件加入.gitignore\n\n\n生产环境\n\n\n使用容器化部署时通过环境变量注入\n使用配置管理系统统一管理环境变量\n\n安全性考虑\n避免过于宽松的配置\n\n# 不推荐&quot;origins&quot;: &quot;*&quot;  # 推荐&quot;origins&quot;: FRONTEND_URL\n\n\n合理设置凭证策略\n\n\n仅在必要时启用supports_credentials\n确保前端配置匹配（credentials: &#39;include&#39;）\n\n问题排查常见错误及解决方案\nCORS策略违规\n\nAccess to XMLHttpRequest at &#x27;http://api.example.com&#x27; from origin &#x27;http://example.com&#x27; has been blocked by CORS policy\n解决方案：\n\n检查环境变量是否正确设置\n验证前端请求URL与配置是否匹配\n确认所有必要的请求头都已配置\n\n参考文献\nW3C CORS Specification\nMDN Web Docs - Cross-Origin Resource Sharing\nFlask-CORS Official Documentation\n\n","categories":["学习笔记"],"tags":["前后端交互","网站开发"]},{"title":"响应式设计","url":"/2025/01/20/%E5%89%8D%E5%90%8E%E7%AB%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/","content":"所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:\n\n第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；\n另一个作用是当图片无法加载时，页面需要显示的替代文本。\n\n\n\n注意嵌套的形式.e.g\n&lt;p&gt;See more &lt;a href=&quot;https://freecatphotoapp.com&quot;&gt;cat photos&lt;/a&gt; in our gallery.&lt;/p&gt;\n\n\n\n\n要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。\n&lt;p&gt;See more &lt;a href=&quot;https://freecatphotoapp.com&quot; target = &quot;_blank&quot;&gt;cat photos&lt;/a&gt; in our gallery.&lt;/p&gt;\n\n\n\n锚元素除了能将文本转化为链接, 还可以将 图片 转换为链接:\n&lt;a hreg = &quot;https://freecatphotoapp.com&quot;&gt;    &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg&quot; alt=&quot;A cute orange cat lying on its back.&quot;&gt;&lt;/a&gt;\n\n\n\n\nsection 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。\n\n\n\n列表:\n\n无序列表: ul;\n有序列表:ol;\n列表项: li;\n\n\n\n\nfigure 元素代表自包含的内容，允许将图像与标题相关联;figcaption 元素用于添加标题以描述 figure 元素中包含的图像。\n&lt;figure&gt;  &lt;img src=&quot;image.jpg&quot; alt=&quot;A description of the image&quot;&gt;  &lt;figcaption&gt;A cute cat&lt;/figcaption&gt;&lt;/figure&gt;\n\n\n\n\n\n使用 em 使得文字为斜体;\nstrong 加深文字;\n\n\n\n\nform 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。\n\naction属性指定表单数据发送的位置;\n\n&lt;form action=&quot;/submit-url&quot;&gt;&lt;/form&gt;\n\n\ninput 允许通过多种方式从Web表单中收集数据:\n\n与img一样为空元素——不需要结束标签;\n使用 type 属性创建多种输入;\ntext : 文本;\nradio: 可以使用单选按钮;\ncheckbox: 表单使用 复选框;\n\n\n使用name属性使得区分提交的数据;\n令多个单选按钮具有 相同 的name, 使得在选中其中一个按钮时自动取消另外的单选按钮;\n形成name = value形式的属性对进行提交;\n\n\n\n&lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name = &quot;indoor-outdoor&quot;&gt; Indoor&lt;/label&gt;&lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name = &#x27;indoor-outdoor&#x27;&gt; Outdoor&lt;/label&gt;\n\nplaceholder 中为 占位符 文本, 用于提示输入框中输入的信息;\nrequired属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;\n\n&lt;input type=&quot;text&quot; name = &quot;catphotourl&quot;&gt;\n\n\n\n\nbutton 用于创建可点击的按钮:\n\n单击没有任何属性的表单按钮的默认行为会将表单提交到表单的 action 属性中指定的位置;\n由于input和button为 内联 元素, 即使相隔书写也会显示在同行:\ntype的submit明确了为 可提交按钮;\n\n&lt;button type = &quot;submit&quot;&gt;Submit&lt;/button&gt;\n\n\n\nlabel 元素用于帮助将 input 元素的文本与 input 元素本身关联起来\n&lt;label&gt;&lt;input type=&quot;radio&quot;&gt; cat&lt;/label&gt;&lt;!-- 点击单词 &quot;cat&quot; 也将选择 radio 按钮。 --&gt;\n\n\n\nid用于标识特定的HTML元素\n\n\nfieldset 元素用于在 Web 表单中将相关的输入和标签组合在一起:\n\n块级元素，这意味着它们出现在新的一行上。\nlegend 元素充当 fieldset 元素中内容的标题。\n\n&lt;fieldset&gt;        &lt;legend&gt; Is your cat an indoor or outdoor cat?&lt;/legend&gt;          &lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;indoor&quot;&gt; Indoor&lt;/label&gt;          &lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;outdoor&quot;&gt; Outdoor&lt;/label&gt;&lt;/fieldset&gt;\n\n\n\n还可以使用for属性将文本直接嵌套在label当中, 同时设置input的id与上述的for属性相同, 从而实现文本与元素相关联的效果:\n&lt;input id=&quot;loving&quot; type=&quot;checkbox&quot;&gt; &lt;label for = &quot;loving&quot;&gt; Loving &lt;/label&gt;\n\n\n\n默认选中的按钮: checked\n&lt;input checked type=&quot;radio&quot; name=&quot;meal&quot; value=&quot;breakfast&quot;&gt; Breakfast\n\nchecked属性无需额外赋值.\n\n\n\nfooter素用于定义文档或章节的页脚:\n\n脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.\n\n\n\nhead 相关\n\n存放 $\\underline{元数据}$ 不会实际显示在html中的数据;\ntitle 元素决定了浏览器在页面的标题栏或选项卡中显示的内容;\n&lt;link rel = &quot;stylesheet&quot; href = &quot;styles.css&quot;&gt; 将CSS文件链接到当前的HTML\n\nelse:\n\n&lt;!DOCTYPE html: 声明满足最新版本html相关设置的要求;\nmeta是空元素; &lt;meta charset = &quot;utf-8&quot;&gt;;\n\n\n\n选择器:\n\nid选择器\n\n#cat &#123;  width: 250px;&#125;\n\nclass选择器\n\n.class-name, .other-class &#123;  styles&#125;\n\nclass类中元素的选择\n\n.item p&#123;  /* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */  display: inline-block; &#125;\n\n伪元素\n\n/* 已访问链接后设置为灰色 */a:visited&#123;  color: grey;&#125;/* 悬浮时的变色 */a:hover &#123;  color: brown;&#125;/* 点击时的状态设置 */a:active&#123;  color: white;&#125;\n\n\nmargin-left : auto;margin-right: auto;\n\n使得普通元素在父级元素的空间内 水平居中\n\n\n\narticle是一个语义化标签:\n\n用于表示文档、页面或应用中的独立的、完整的内容单元;\n清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;\n内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.\n\n与其他类似标签的区别:\n\ndiv: 粹的容器，没有语义，常用于布局;\nsection: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;\narticle: 示一个可以独立存在的内容单元.\n\n\n\n/* 设置备用字体 */h1, h2 &#123;  font-family: Impact, serif;&#125;\n\n\n","categories":["学习笔记"],"tags":["杂记"]},{"title":"跨组件渲染","url":"/2025/02/16/%E5%89%8D%E5%90%8E%E7%AB%AF/%E8%B7%A8%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93/","content":"React Context 实现跨组件实时渲染的实践分析为什么需要跨组件实时渲染？在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：\n\n用户在一个组件中编辑内容，其他组件需要立即看到更新\n多个组件需要共享同一份数据\n需要避免通过层层组件传递 props（即所谓的 prop drilling）\n\n这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。\n最小实现示例以下是实现跨组件实时渲染的最简代码结构：\n// 1. 定义 Context 类型interface SharedContextType &#123;  data: any;  updateData: (newData: any) =&gt; void;&#125;// 2. 创建 Contextconst SharedContext = createContext&lt;SharedContextType | undefined&gt;(undefined);// 3. 创建 Provider 组件export function SharedProvider(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;  const [data, setData] = useState&lt;any&gt;(null);  const updateData = useCallback((newData: any) =&gt; &#123;    setData(newData);  &#125;, []);  return (    &lt;SharedContext.Provider value=&#123;&#123; data, updateData &#125;&#125;&gt;      &#123;children&#125;    &lt;/SharedContext.Provider&gt;  );&#125;// 4. 创建自定义 Hookexport function useShared() &#123;  const context = useContext(SharedContext);  if (!context) &#123;    throw new Error(&#x27;useShared must be used within SharedProvider&#x27;);  &#125;  return context;&#125;\n\n实际应用分析让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：\n// 1. 定义具体的数据结构interface HistoryItem &#123;  id: string;  content: string;  mermaidCode: string;  timestamp: number;&#125;// 2. 实现带有持久化的 Context Providerexport function HistoryProvider(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;  const [selectedHistory, setSelectedHistory] = useState&lt;HistoryItem | null&gt;(null);  const [historyList, setHistoryList] = useState&lt;HistoryItem[]&gt;([]);  // 数据持久化  useEffect(() =&gt; &#123;    if (selectedHistory) &#123;      localStorage.setItem(&#x27;selectedHistory&#x27;, JSON.stringify(selectedHistory));    &#125;  &#125;, [selectedHistory]);  // 实时更新方法  const addHistory = async (content: string, mermaidCode: string) =&gt; &#123;    const historyItem: HistoryItem = &#123;      id: Date.now().toString(),      content,      mermaidCode,      timestamp: Date.now()    &#125;;    setHistoryList(prev =&gt; [historyItem, ...prev]);  &#125;;  return (    &lt;HistoryContext.Provider      value=&#123;&#123;        selectedHistory,        setSelectedHistory,        addHistory,        historyList      &#125;&#125;    &gt;      &#123;children&#125;    &lt;/HistoryContext.Provider&gt;  );&#125;\n\n在这个实际例子中，我们可以看到几个关键点：\n\n状态定义：使用 TypeScript 接口明确定义了数据结构，确保类型安全\n状态持久化：通过 useEffect 监听状态变化并保存到 localStorage\n实时更新：通过 setHistoryList 确保状态更新后所有使用该 Context 的组件都能即时获得更新\n\n当组件需要使用这些共享状态时，只需：\nfunction HistoryViewer() &#123;  const &#123; selectedHistory &#125; = useHistory();    return (    &lt;div&gt;      &#123;selectedHistory &amp;&amp; (        &lt;div&gt;&#123;selectedHistory.content&#125;&lt;/div&gt;      )&#125;    &lt;/div&gt;  );&#125;\n\n这种模式的优势在于：\n\n避免了 props 的层层传递\n实现了组件间的解耦\n确保了状态更新的实时性\n提供了类型安全的数据访问\n\n参考资料\nReact Context Documentation\nTypeScript Handbook\nReact Hooks API Reference\n\n"},{"title":"cpp学习记录","url":"/2025/02/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"导论编译时, 从c的gcc转变为了g++.\nOOP的三大特点:\n\n封装\n继承\n多态\n\n基本语法在C语言中,我们主要使用malloc()和free()来进行动态内存管理。但这种方式存在一些问题:\n\n它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;\n容易发生内存泄漏.\n\n为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了new和delete.\nnew的基本语法十分直观:\nType* pointer = new Type;           // 分配单个对象Type* pointer = new Type[size];     // 分配对象数组\n\n可以在创建时进行初始化:\nint* p1 = new int(5);              // 初始化为5string* p2 = new string(\"hello\");   // 初始化为\"hello\"\n\n也可以根据变量进行动态的内存分配:\nint size;cin &gt;&gt; size;int* arr = new int[size];  // 根据输入分配内存\n\n\n[!NOTE]\nUse delete ［］ if new ［］ was used to allocate an array.\n\n输入输出流通过包含头文件 – #include &lt;iostream&gt; 来使用输入输出流 cin 和 cout.\n#include &lt;iostream&gt;using namespace std;int main(){    int age;     cin &gt;&gt; age;    cout &lt;&lt; \"You are \" &lt;&lt; age &lt;&lt; \" years old\" &lt;&lt; endl;    // endl 是换行符    return 0;}\n\n\ncin读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:\n\nstring str=\"Hello world!\";ofstream fout(\"out.txt\");fout&lt;&lt;str&lt;&lt;endl;ifstream fin(\"out.txt\");string str1,str2;// 读取文件中的两个字符串fin&gt;&gt;str1&gt;&gt;str2; cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2 &lt;&lt; endl;// 输出:// Hello// world!return 0;\n\n\n文件流输入输出流基础\n头文件: #include &lt;fstream&gt;\n类: ifstream(输入流), ofstream(输出流)\n\n#include &lt;fstream&gt;  // 需要包含这个头文件using namespace std;// 文件输出（写入文件）ofstream outFile(\"output.txt\");outFile &lt;&lt; \"Hello World\" &lt;&lt; endl;outFile.close();// 文件输入（读取文件）ifstream inFile(\"input.txt\"); string line;getline(inFile, line);inFile.close();\n\n写入文件时, 如果没有文件, 会自动创建.\n\n常用操作示例\n写入文件\n\nofstream outFile;outFile.open(\"test.txt\");  // 打开文件if (outFile.is_open()) {   // 检查是否成功打开    outFile &lt;&lt; \"第一行\" &lt;&lt; endl;    outFile &lt;&lt; \"第二行\" &lt;&lt; endl;    outFile.close();       // 完成后关闭文件}\n\n\n**读取文件 **\n\nifstream inFile(\"test.txt\");string line;while (getline(inFile, line)) {  // 逐行读取    cout &lt;&lt; line &lt;&lt; endl;}inFile.close();\n\n\n以追加模式打开文件\n\nofstream outFile(\"test.txt\", ios::app);  // app 表示追加模式outFile &lt;&lt; \"这行会被添加到文件末尾\" &lt;&lt; endl;outFile.close();\n\n\n文件打开模式\nios::in - 读取模式\nios::out - 写入模式\nios::app - 追加模式\nios::ate - 打开文件后立即定位到文件末尾\nios::binary - 二进制模式\nios::trunc - 如果文件存在则截断文件\n如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.\n\n\n\n// 假设 test.txt 原本内容是:// Hello World// This is a test// 使用 trunc 模式打开ofstream outFile(\"test.txt\", ios::out | ios::trunc);  outFile &lt;&lt; \"新的内容\" &lt;&lt; endl;outFile.close();// 现在 test.txt 的内容只有:// 新的内容\n\n 或直接用 ios::out，因为out默认包含trunc\n\n\n使用位或运算符|来同时指定多个模式:\n\n// 组合使用打开模式ofstream outFile(\"test.txt\", ios::out | ios::app);\n\n错误处理ifstream inFile(\"nonexistent.txt\");if (!inFile) {    cerr &lt;&lt; \"无法打开文件！\" &lt;&lt; endl;    return 1;}// 或者使用is_open()if (!inFile.is_open()) {    cerr &lt;&lt; \"无法打开文件！\" &lt;&lt; endl;    return 1;}\n\n变量String需要先引入指定的头文件:\n#include &lt;string&gt;\n\n\n定义时可以使用等号或者用括号包裹字符串:\n\nstring name = \"John\"; // string name(\"John\");\n\n\nstringstreamstringstream 表示双向字符串流:\n\n需要导入头文件#include &lt;sstream&gt;;\nistringstream 表示输入字符串流\n作用: 将字符串转换成一个类似于输入流的对象;\n内部维护了一个字符串和一个位置指针;\n每次读取时, 位置指针向后移动, 且自动跳过空白字符.\n\n\nostringstream 表示输出字符串流.\n\n字符串分词自动以空白字符(空格、制表符\\t、换行符\\n等)分割字符串;\n#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;int main(){    string name ( \"Xiao Ming\");    // 使用括号包字符串    istringstream is (name);     string s;    while (is&gt;&gt;s){        cout &lt;&lt; s &lt;&lt; endl;    }}\n\n&gt;&gt; 表示从输入流中读取数据;\n注意字符串流也是一种类型, 作用的对象是字符串.\n\nOutput:\nXiao MingXiaoMing\n\n包含更多分词的字符串:\n#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;int main(){    string words = \"hello \\n world! \\t I am \\n here!\";    stringstream is (words);        string word;    int count  = 1;    while(is &gt;&gt; word){        cout &lt;&lt; \"Word \" &lt;&lt; count &lt;&lt; \": \" &lt;&lt; word &lt;&lt; endl;        count++;    }}\nOutput:\nWord 1: helloWord 2: world!Word 3: IWord 4: amWord 5: here!\n\n字符串拼接#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() {    ostringstream oss;    string name = \"Alice\";    int age = 25;        oss &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age;    string result = oss.str();    cout &lt;&lt; result &lt;&lt; endl;}\nOutput:\nName: Alice, Age: 25\n\n通过.str()方法可以对象转换为字符串类型, 从而格式化输出.\n\n\n\n.str(\"\")方法可以清空字符串流:\n#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() {    ostringstream oss;    string name = \"Alice\";    int age = 25;        oss &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age;    oss.str(\"\");    string result = oss.str();    cout &lt;&lt; result &lt;&lt; \"Nothing\" &lt;&lt; endl;}\nOutput:\nNothing\n\nGetline基本语法:\ngetline(istream&amp; is, string&amp; str, char delim = '\\n');\n\nis: 输入流（通常是cin;\nstr: 存储结果的字符串;\ndelim: 分隔符, 默认为换行符\\n.\n\nExample:\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string line;        cout &lt;&lt; \"请输入一行文本：\";    getline(cin, line);  // 读取整行，包括空格    cout &lt;&lt; \"你输入的是：\" &lt;&lt; line &lt;&lt; endl;        // 使用自定义分隔符    string data;    cout &lt;&lt; \"请输入内容（用,分隔）：\";    getline(cin, data, ',');  // 读取直到遇到逗号    cout &lt;&lt; \"读取到逗号前的内容：\" &lt;&lt; data &lt;&lt; endl;}\n\ncin特点:\n\n以空白字符（空格、制表符、换行符）为分隔符;\n忽略前导空白字符;\n遇到空白字符就停止读取.\n\n通常需要与getchar()方法配合来清除缓冲区当中的\\n字符:\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    int number;    string line;        cout &lt;&lt; \"输入一个数字：\";    cin &gt;&gt; number;        //清除输入缓冲区中的换行符    getchar(); // or cin.ignore();        cout &lt;&lt; \"输入一行文本：\";    getline(cin, line);  // 现在可以正确读取整行        cout &lt;&lt; \"数字：\" &lt;&lt; number &lt;&lt; endl;    cout &lt;&lt; \"文本：\" &lt;&lt; line &lt;&lt; endl;}\n\n如果输入8 \\n, 则getchar()读取空格, 文本为空.\n\nAlter Stringoutline : 常用的字符串方法(成员函数):\ninsert(size_t pos, const string&amp; s);erase (size_t pos = 0, size_tlen = npos);append (const string&amp; str);replace (size_t pos,size_t len,const string&amp; str);\n\n\n常用方法\ninsert(int pos, string str) 在指定位置插入字符串\n\nstring str = \"Hello World\";// 在位置5处插入字符串str.insert(5, \" Beautiful\");cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello Beautiful World\"// 在字符串末尾插入内容str.insert(str.length(), \"!\");cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello Beautiful World!\"// 插入单个字符（使用string构造）str.insert(0, \"&gt;\");cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"&gt;Hello Beautiful World!\"\n\n\n\nerase(int pos, int length) 删除从指定位置开始的若干个字符\n\nstring str = \"Hello Beautiful World!\";// 删除从下标6开始的9个字符str.erase(6, 9); cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello World!\"// 删除从某个位置开始到末尾的所有字符str.erase(5);cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello\"\n\nlength参数省略, 则删除从pos位置开始到字符串末尾的所有字符.\n\n\n\nreplace (int pos, int length, string) 替换指定位置的字符串\n\n// 从位置6开始，替换5个字符为\"C++\"string str = \"Hello World!\";str.replace(6, 5, \"C++\");cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello C++!\"\n\n\n\n\nappend (const string&amp; str);\n\n// 添加整个字符串string1.append(string2);// 添加指定位置的字符(索引从开始)string1.append(string2, start, length);// 重复字符的添加string1.append(count, char);\n\n除此之外, 还存在着使用迭代器的用法: \n\n类似于指针, 指向容器(如字符串、数组等)的特定位置.\n\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string source = \"World!\";    string target = \"Hello \";        // 添加source中的部分字符（从开始到结束）    target.append(source.begin(), source.end());    cout &lt;&lt; target &lt;&lt; endl;  // 输出: Hello World!        // 只添加部分字符    string target2 = \"Hello \";    target2.append(source.begin(), source.begin() + 5);  // 只添加\"World\"，不包含\"!\"    cout &lt;&lt; target2 &lt;&lt; endl;  // 输出: Hello World        return 0;}\n\nbegin()方法返回字符串的第一个字符的迭代器, end()方法返回字符串最后一个字符的下一个位置的迭代器;\n迭代器的范围是左闭右开.\n\n\n其他方法\nfind(string, int pos) 从指定的位置开始寻找字符串位置\n\nstring str = \"Hello World Hello\";// 从位置0开始查找\"Hello\"cout &lt;&lt; str.find(\"Hello\", 0) &lt;&lt; endl;     // 结果: 0// 从位置1开始查找\"Hello\"cout &lt;&lt; str.find(\"Hello\", 1) &lt;&lt; endl;     // 结果: 12// 查找不存在的字符串cout &lt;&lt; str.find(\"Python\") &lt;&lt; endl;       // 结果: string::npos\n\nstring::npos是size_t类型的最大值;\n可以使用str.find(\"Python\") == string::npos作为判断条件, 检查是否找到字符串.\n\n\n\ncompare(string) 字符串比较\n\nstring str1 = \"Hello\";string str2 = \"Hello\";string str3 = \"World\";cout &lt;&lt; str1.compare(str2) &lt;&lt; endl;  // 结果: 0  (相等)cout &lt;&lt; str1.compare(str3) &lt;&lt; endl;  // 结果: -15 (str1 &lt; str3) cout &lt;&lt; str3.compare(str1) &lt;&lt; endl;  // 结果: 15  (str3 &gt; str1)\n\n按照字典序比较得到结果\n\n\n\nto_string(int) 将数字转换成字符串\n\nint num = 123;string str = to_string(num);cout &lt;&lt; str &lt;&lt; endl;          // 结果: \"123\"cout &lt;&lt; str + \"456\" &lt;&lt; endl;  // 结果: \"123456\"\n\n字符串之间可以通过+直接拼接.\n\n\n\nstoi(string) 将字符串转换成整数\n\nstring str = \"123\";int num = stoi(str);cout &lt;&lt; num + 456 &lt;&lt; endl;    // 结果: 579// 注意：字符串必须是合法的数字格式// string str = \"abc\"; // int num = stoi(str);  // 这会抛出异常\n\n字符串必须是合法的数字格式;\n int num = stoi(\"abc\");  将会抛出异常\n\n\n构造函数Outline:\nstring(const char *cp, int len);string(const string&amp; s2, int pos);string(const string&amp; s2, int pos, int len);\n\n\n\nstring(const char *cp, int len) 字符数组创建字符串\n\nstring str1(\"Hello World\", 5);cout &lt;&lt; str1 &lt;&lt; endl;// 输出: Hello\n\n\nstring(const string&amp; s2, int pos) 从现有字符串创建新字符串，从指定位置到末尾\n\nstring s2 = \"Hello World\";string str2(s2, 6);cout &lt;&lt; str2 &lt;&lt; endl;// 输出: World\n\n\nstring(const string&amp; s2, int pos, int len) 从现有字符串创建新字符串，指定起始位置和长度\n\nstring s3 = \"Hello World\";string str3(s3, 6, 3);cout &lt;&lt; str3 &lt;&lt; endl;// 输出: Wor\n\n\nstring(int length, char c) 用指定长度的字符c初始化字符串\n\nstring str4(5, '*');cout &lt;&lt; str4 &lt;&lt; endl;// 输出: *****// 实际应用示例int num = 432;string str = to_string(num);cout &lt;&lt; string(5 - str.length(), '0') + str &lt;&lt; endl;// 输出: 00432\n\n\n成员函数// 提取子字符串substr(int pos, int len);string str = \"Hello World\";string sub = str.substr(6, 3);  // 结果: \"Wor\"\n\n// 字符串赋值assign();string str1 = \"Hello\";string str2;str2.assign(str1);  // str2现在是 \"Hello\"\n\n\n// 在指定位置插入字符串    string str1 = \"hello\";    string str2 = \"world\";    str1.insert(3, str2);    cout &lt;&lt; str1 &lt;&lt; endl;// 结果: helworldlo \n\n// 删除指定位置的指定长度的字符erase(int pos, int len);string str = \"Hello World\";str.erase(5, 6);  // 结果: \"Hello\"\n\nNotice：\n\n所有位置索引都是从0开始计数\n如果指定的长度超过字符串实际长度，会自动调整到实际可用长度\n使用这些函数时要注意检查参数的有效性，避免越界访问\n.assign(str, pos, len): 相比于直接赋值, assign还提供了精确控制赋值的方法, 也就是指定内容字符串的起始位置和长度.\n\n\nSubstr在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. substr()方法可以精确地获取字符串片段.\nsubstr即substring的缩写, 表示子字符串.\n基本语法\nstring substr(int pos, int len) ;\n参数分别表示截取的起始下标以及要截取的长度(如果省略len将截取到字符串的末尾).\ne.g.:\nstring email = \"user.name@example.com\";// 获取用户名的部分int atPos = email.find('@');string username = email.substr(0, atPos); // result: \"user.name\"// 获取域名部分string domain =  email.substr(atPos + 1); // result: \"example.com\"// 获取顶级域名(最后一个.之后的部分)int lastDotPos = email.rfind('.');string topLevelDomain = email.substr(lastDotPos + 1); // result: \"com\"\n\nrfind()方法: 会从字符串的末尾向前搜索，从而返回要查找的字符或子字符串此时第一次出现的位置。如果没有找到，则返回 string::npos.\n\n\nFunctionDefault arguments要点:\n\n默认值必须在函数原型中从右到左地给出, 否则在调用的时候无法分辨;\n\n默认值只能出现在函数原型 或者 将声明和定义放在一起, 下面的情况会报错:\nvoid f(int i, int j = 10);int main(){    ...}void f(int i, int j = 10){    ...}\n\nGroup选择的标准:\n\n一般情况  vector;\n程序需要对元素进行随机访问  vector or deque;\n程序需要在容器中间插入元素  list or forward_list;\n程序需要在容器的首尾插入元素  deque;\n容器中的元素相对较小但是数量较多  list nor forward_list.\n否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.\n\n\n\nPair基本介绍1. 基本概念pair 是 C++ 标准库提供的模板类，用于将两个不同类型的值组合成一个对象。它定义在 &lt;utility&gt; 头文件中。\n2. 创建与初始化// 默认构造std::pair&lt;std::string, int&gt; p1;// 直接初始化std::pair&lt;std::string, int&gt; p2(\"tag\", 10);// 使用make_pairauto p3 = std::make_pair(\"data\", 5);// 统一初始化std::pair&lt;std::string, int&gt; p4{\"value\", 8};\n\n3. 访问元素// 传统访问方式std::cout &lt;&lt; p2.first &lt;&lt; \": \" &lt;&lt; p2.second &lt;&lt; endl;// 结构化绑定(C++17)auto [key, val] = p3;std::cout &lt;&lt; key &lt;&lt; \": \" &lt;&lt; val &lt;&lt; endl;\n\n4. 常用操作// 比较操作if (p1 == p2) {...}if (p1 &lt; p2) {...}  // 先比较first，再比较second// 交换内容p1.swap(p2);std::swap(p1, p2);\n\n5. 实际应用示例// 作为函数返回值std::pair&lt;bool, string&gt; checkInput(const string&amp; input) {    if (input.empty()) {        return {false, \"输入不能为空\"};    }    return {true, \"\"};}// 在容器中使用vector&lt;pair&lt;string, int&gt;&gt; dataList = {    {\"item1\", 10},    {\"item2\", 20},    {\"item3\", 30}};// 与map配合使用map&lt;string, pair&lt;int, double&gt;&gt; complexData;\n\n6. 注意事项\npair 的元素可以是任意类型，包括自定义类型\n使用结构化绑定需要C++17或更高标准\npair 常用于需要返回多个值的函数\n在性能敏感场景要注意构造和拷贝开销\n\nSet集合: 用于存储一组不允许重复的元素, 且会自动排序.\n可以使用的方法包括:\n\n.insert( ): 插入元素;\n\n.erase(): 删除元素. 如果输入是元素值, 那么返回1/0表示是否成功删除; 如果输入是迭代器, 那么返回的是下一个元素的迭代器.\n\n.find( ): 寻找元素, 如果找到 返回对应的 迭代器. 否则返回 .end( );\n\n\nVector存储元素在连续的内存空间中, 支持随机访问.\n\n可以动态增长, 适合存储未知数量的元素;\n通过下标访问元素的时间复杂度为 O(1);\n在末尾插入和删除元素的时间复杂度为 O(1);\n在中间插入和删除元素的时间复杂度为 O(n);\n使用场景: 需要随机访问、排序、内存连续存储的场景.\n\n语法:\n\n使用 .end()返回一个指向容器末尾后一个位置的迭代器:\nauto it = find(vec.begin(), vec.end(), value);  // 查找 value  if (it != vec.end()) {         // 如果找到了（即没有返回 end()）      vec.erase(it);             // 则删除找到的元素  }\n使用 .push_back()在末尾插入元素, 或者使用.emplace_back()在末尾原位构造元素(更加高效);\nvec.push_back(10);vec.emplace_back(20); //更加高效\n\nemplace_back方法直接在容器的内存空间中构造对象, 相比于push_back而言更加高效.\n\n\n.erase()方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;\n  vec.erase(vec.begin() + 1);       // 删除第二个元素vec.erase(vec.begin(), vec.begin() + 3); // 删除前三个元素vec.clear();                      // 清空整个 vector\n\nvec.clear(); 将会清空整个vector.\n和insert需要的参数一样, 都需要迭代器而非索引来定位.\n\n\nvec[i]的形式访问, 使用vec.at(i)的方式可以在越界时抛出异常;\n\n.begin()和.end()获取迭代器, 使用范围for循环遍历元素;\n   cout &lt;&lt; \"Vector elements:\" &lt;&lt; endl; for (int num : vec) {    cout &lt;&lt; num &lt;&lt; \" \"; } cout &lt;&lt; endl;//使用迭代器遍历for (auto it = vec.begin(); it != vec.end(); ++it) {    cout &lt;&lt; *it &lt;&lt; \" \";}cout &lt;&lt; endl;\n.size()获取vector的大小, .empty()判断vector是否为空;\ncout &lt;&lt; \"Vector size: \" &lt;&lt; vec.size() &lt;&lt; endl;if (vec.empty()) {    cout &lt;&lt; \"Vector is empty.\" &lt;&lt; endl;}\n使用sort()对vector进行排序, 使用find()查找元素;\nsort(vec.begin(), vec.end());   // 排序auto it = find(vec.begin(), vec.end(), 5); // 查找 5\n\ninsert 插入的位置是指定的迭代器位置之前一个;\n\n\nReserve为了避免频繁地扩展内存, 可以通过reserve预先分配合适的空间, 同时通过.reszie()调整大小;\nvector&lt;string&gt; v2;v2.reserve(1000);  // 一次性分配 1000 个元素的空间v2.resize(v2.size() + v2.size()/2); // 调整大小为原来的 1.5 倍\n\nreserve只分配空间而不创建元素,resize将同时分配元素(默认值):\nvector&lt;string&gt; vec;// reserve: 只分配空间，不创建元素vec.reserve(10);  cout &lt;&lt; \"The capacity with reserve: \" &lt;&lt; vec.capacity() &lt;&lt; endl;cout &lt;&lt; \"The size with reserve: \" &lt;&lt; vec.size() &lt;&lt; endl;    // resize: 分配空间并创建元素vec.resize(10);   cout &lt;&lt; \"The capacity with resize: \" &lt;&lt; vec.capacity() &lt;&lt; endl;cout &lt;&lt; \"The size with resize: \" &lt;&lt; vec.size() &lt;&lt; endl;   \n\nOutput:\nThe capacity with reserve: 10The size with reserve: 0The capacity with resize: 10The size with resize: 10\n\n[!important]\n.push_back()的实际作用是在容器索引的size处插入元素.\n 而reserve不会影响容器的size,  初始化和resize会影响并且填充默认值:\n\ne.g.  验证:\nint main() {    vector&lt;int&gt; vec(10);        // 打印初始状态    cout &lt;&lt; \"初始状态：\\n\";    cout &lt;&lt; \"size: \" &lt;&lt; vec.size() &lt;&lt; \", capacity: \" &lt;&lt; vec.capacity() &lt;&lt; \"\\n\\n\";        // 预留5个空间    vec.reserve(15);    cout &lt;&lt; \"reserve(15) 后：\\n\";    cout &lt;&lt; \"size: \" &lt;&lt; vec.size() &lt;&lt; \", capacity: \" &lt;&lt; vec.capacity() &lt;&lt; \"\\n\\n\";        vec[20] =20;    // 添加元素并观察    cout &lt;&lt; \"添加元素过程：\\n\";    for(int i = 1; i &lt;= 6; i++) {        vec.push_back(i);        cout &lt;&lt; \"添加 \" &lt;&lt; i &lt;&lt; \" 后 - \";        cout &lt;&lt; \"size: \" &lt;&lt; vec.size()              &lt;&lt; \", capacity: \" &lt;&lt; vec.capacity()             &lt;&lt; \", 元素: \";        for(int x : vec) cout &lt;&lt; x &lt;&lt; \" \";        cout &lt;&lt; \"\\n\";    }        return 0;}\n\nOutput:\n初始状态：size: 10, capacity: 10reserve(15) 后：size: 10, capacity: 15添加元素过程：添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 \n\n\n此处的 vector&lt;int&gt; vec(10);初始化了10个默认值的int类型的元素;\nvec[20] = 20;没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;\n如果换成vec.at(20) = 20将会在编译时报错;\n\n\n可以发现, reserve的作用就是避免了多次自动扩容.\n\n\nreserve的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素copy到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.\n\nResize用法的枚举:\n\nresize(n): 将vector的大小调整为n, 如果大于当前值, 则在末尾添加具有默认值的新元素;\n\nresize(n, val): 同样调整大小, 但是指定了默认值为新的 val;\n\n对于二维向量的内存分配也是类似的:\nvector&lt;vector&lt;int&gt;&gt; m;  //二维码向量; ... m.resize(r,vector&lt;int&gt;(c,0)); //初始化为一个r行c列且初始值为0的矩阵.\n\nList\n在list容器当中, 迭代器是双向迭代器;\n双向迭代器不支持大小的比较, 只支持 ==,!=,++,--;因此, 注意实际的使用:\n\n\n\nlist&lt;int&gt; lst1;list&lt;int&gt;::iterator iter1 = lst1.begin();list&lt;int&gt;::iterator iter2 = lst1.end();// 正确的写法while (iter1 != iter2) {    // 处理当前元素    ++iter1;}// 错误的比较// while(iter1 &lt; iter2)     \n\n有序链表#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;string&gt;using namespace std;int main() {    list&lt;string&gt; s;    string str;    list&lt;string&gt; :: iterator p;    int count ;    cout &lt;&lt; \"enter the number of the strings:\" &lt;&lt; endl;    cin &gt;&gt; count;     for(int i = 0; i &lt; count; i++){        cout &lt;&lt; \"enter a string:\" ;        cin &gt;&gt;str;                p = s.begin();        while(p != s.end() &amp;&amp; *p &lt;str)            p++;        s.insert(p,str);    }    for(p = s.begin(); p!=s.end(); p++)        cout &lt;&lt; *p &lt;&lt; endl;    cout &lt;&lt; endl;    return 0;}\n\n分析:\n\nwhile(p != s.end() &amp;&amp; *p &lt;str) 每次输入str时, 令迭代器从list的开头开始, 进行字典序的比较;\n\n\n[!important]\n找到插入的位置, 利用insert()方法插入到给出迭代器的前面!.\n\nDequedeque即 double-ended queue, 双端队列.\n支持:\n\n在两端快速的插入或删除;\n随机访问;\n\n语法:\n#include &lt;deque&gt;deque&lt;int&gt; dq;// 1. 插入操作dq.push_back(1);    // 在末尾插入dq.push_front(2);   // 在开头插入dq.insert(pos, val);// 在指定位置插入// 2. 删除操作dq.pop_back();      // 删除末尾元素dq.pop_front();     // 删除首部元素dq.erase(pos);      // 删除指定位置元素// 3. 访问操作dq[0];              // 随机访问dq.at(1);           // 带边界检查的访问dq.front();         // 访问第一个元素dq.back();          // 访问最后一个元素\n\n示例:\n#include &lt;deque&gt;#include &lt;iostream&gt;using namespace std;int main() {    deque&lt;int&gt; dq;        // 在两端插入元素    dq.push_back(3);    dq.push_front(1);    dq.push_back(4);    dq.push_front(8);        // dq ：{8, 1, 3, 4}        // 使用随机访问    for(size_t i = 0; i &lt; dq.size(); ++i) {        cout &lt;&lt; dq[i] &lt;&lt; \" \";    }}\n\nForward_listforward_list即 单项链表.\n\n只能向前遍历, 即对应的迭代器不支持--而支持++.\n同时不支持下标访问以及随机访问.\n单项链表的设计, 使得内部的每个节点只需要一个指针来指向下一个节点, 从而比list双向链表更加节省内存.\n\n语法:\n#include &lt;forward_list&gt;forward_list&lt;int&gt; fl;// 1. 插入操作fl.push_front(1);           // 在开头插入fl.insert_after(pos, val);  // 在指定位置之后插入// 2. 删除操作fl.pop_front();            // 删除第一个元素fl.erase_after(pos);       // 删除指定位置之后的元素// 3. 访问操作fl.front();               // 访问第一个元素// 4. 特殊操作fl.before_begin();        // 返回第一个元素之前的迭代器fl.begin();               // 返回第一个元素的迭代器\n\n示例:\n#include &lt;forward_list&gt;#include &lt;iostream&gt;using namespace std;int main() {    forward_list&lt;int&gt; fl;        // 插入元素    fl.push_front(3);    fl.push_front(2);    fl.push_front(1);        // 在特定位置后插入    auto it = fl.begin(); // 指向第一个元素    fl.insert_after(it, 4); // 在第一个元素后插入4        // 遍历打印    for(const auto&amp; val : fl) {        cout &lt;&lt; val &lt;&lt; \" \";    }    // 输出：1 4 2 3}\n\n访问前一个元素由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合before_begin()方法.\n// 如果需要访问某个元素的前一个元素，必须从头开始遍历auto prev = fl.before_begin();auto curr = fl.begin();while(curr != fl.end() &amp;&amp; *curr != target) {    ++prev;    ++curr;}\n\nMap作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键自动排序\n\n如果插入重复的key, 将会覆盖原有的value;\n通过键查找元素、插入和删除的时间复杂度均为O(log n);\n使用场景: 字典、索引、统计等.\n\n语法:\n\n使用 .end()返回一个指向容器末尾后一个位置的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于map当中;\nauto it = ages.find(\"Charlie\");  // 查找 \"Charlie\"  if (it != ages.end()) {         // 如果找到了（即没有返回 end()）      ages.erase(it);             // 则删除找到的元素  }\n使用下标(键)直接插入,或者通过键值对插入\nages[\"Alice\"] = 25;ages.insert({\"Bob\", 30});ages.emplace(\"Charlie\", 28); // 使用 emplace 插入 (更高效)\n\nemplace方法指直接在容器的内存空间中构造对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于insert而言更加高效.\n\n\n.erase()方法删除指定key的元素, 也可以通过.find()找到key对应的迭代器it, 然后erase(it).\n  ages.erase(\"Bob\");           // 删除键为 \"Bob\" 的元素auto it = ages.find(\"Charlie\");if (it != ages.end()) {    ages.erase(it);         // 删除迭代器指向的元素}\n\nages.clear(); 将会清空整个map.\n\n\nmap[key]的形式访问, 使用map.at(key)的方式可以在key不存在时抛出异常;\n\n.find(key)查找对应键的元素( 返回迭代器 ), .count(key)返回对应键的元素个数(0 or 1)\n\n.size()获取map的大小.\n\n迭代器的-&gt;first和-&gt;second可以分别访问键和值.\n  cout &lt;&lt; \"Map elements:\" &lt;&lt; endl;for (auto mapIt = ages.begin(); mapIt != ages.end(); ++mapIt) {   cout &lt;&lt; mapIt-&gt;first &lt;&lt; \": \" &lt;&lt; mapIt-&gt;second &lt;&lt; endl; // 访问键和值}\n\nIterator迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.\n\n标记位置: .begin()和.end() 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;\n\n迭代器的分类:\n\n输入迭代器: 支持读取和递增操作;\nistream_iterator: 用于从输入流读取数据;\n\n\n输出迭代器: 支持写入和递增操作;\nostream_iterator: 用于向输出流写入数据;\n\n\n前向迭代器: 具有输入、输出迭代器的所有功能, 并且可以多次遍历同一个序列;\n比如forwarf_list的迭代器:auto it = flist.begin() or forward_list&lt;int&gt;::iterator it = flist.begin();\n\n\n双向迭代器: 在前向迭代器的原有功能上, 同时支持递减操作;\n比如双向链表list的迭代器.#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() {    list&lt;int&gt; myList = {10, 20, 30, 40, 50};    // 使用双向迭代器正向遍历    cout &lt;&lt; \"Forward traversal: \";    for ( list&lt;int&gt;::iterator it = myList.begin(); it != myList.end(); ++it) {        cout &lt;&lt; *it &lt;&lt; \" \";    }    cout &lt;&lt;  endl;    // 使用双向迭代器逆向遍历    cout &lt;&lt; \"Reverse traversal: \";    for ( list&lt;int&gt;::reverse_iterator rit = myList.rbegin(); rit != myList.rend(); ++rit) {        cout &lt;&lt; *rit &lt;&lt; \" \";    }    cout &lt;&lt;  endl;    return 0;    // Forward traversal: 10 20 30 40 50     // Reverse traversal: 50 40 30 20 10 }\n\n\nreverse_iterator用于声明逆向遍历的迭代器, 也可以使用auto直接声明.\nrbegin()和rend()分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的++相当于正向遍历时的--操作.\n\n\n\n\n\n随机访问迭代器: 具有双向迭代器的所有功能, 同时支持随机访问, 如it+n,it[n].\n比如vector的迭代器.\n\nvector&lt;int&gt; vec = {10, 20, 30, 40, 50};cout &lt;&lt; \"Vector elements (random access): \";for (int i = 0; i &lt; vec.size(); ++i) {    cout &lt;&lt; vec[i] &lt;&lt; \" \"; // 使用下标随机访问}cout &lt;&lt; endl;\n\n另外, 还有一种迭代器称为插入迭代器, 比如back_inserter\nvector&lt;int&gt; vec = {10, 20, 30, 40, 50};//结合copy将容器的元素直接插入到另一个容器中vector&lt;int&gt; dest = {60,70};copy(vec.begin(), vec.end(), back_inserter(dest)); // 在 dest 末尾插入元素cout &lt;&lt; \"Copied vector: \";for (int num : dest) {    cout &lt;&lt; num &lt;&lt; \" \";}cout &lt;&lt; endl;// Copied vector: 60 70 10 20 30 40 50 \n\nfor-eachfor-each 循环的语法：\nfor (range_declaration : range_expression) {    loop_statement;}\n\nrange_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 auto 关键字让编译器自动推导类型;\nrange_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或字符串;\nloop_statement： 循环体，包含要对每个元素执行的语句.\n\ne.g:\n#include &lt;iostream&gt;#include &lt;vector&gt;int main() {    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};    // 使用 for-each 循环遍历 vector    for (int num : numbers) {        std::cout &lt;&lt; num &lt;&lt; \" \"; // 输出每个元素    }    std::cout &lt;&lt; std::endl;    // 使用 auto 关键字自动推导类型    for (auto num : numbers) {        std::cout &lt;&lt; num &lt;&lt; \" \";    }    std::cout &lt;&lt; std::endl;    // 修改容器中的元素（需要使用引用）    for (int &amp;num : numbers) {        num *= 2; // 将每个元素乘以 2    }    // 输出修改后的元素    for (auto num : numbers) {        std::cout &lt;&lt; num &lt;&lt; \" \";    }    std::cout &lt;&lt; std::endl;    return 0;}\n\nfor (int &amp;num : numbers)：使用引用 &amp;，可以直接修改容器中的元素.\n\nMap的循环当range_expression是map时, 可以使用auto自动推导range_declaration的类型.需要注意是:\n\n用迭代器的方式访问map中的键值对的形式是 it-&gt;first与it-&gt;second;\n在for-each循环当中, range_declaration是一个值, 因此使用.first与.second来访问键和值.  #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main(){    map&lt;string, string&gt; m = {{\"one\", \"1\"}, {\"two\", \"2\"}, {\"three\", \"3\"}};    vector&lt;string&gt; vec;    for(auto&amp; entry : m){        vec.push_back(entry.first + \":\" + entry.second );    }    copy(vec.begin(), vec.end(), ostream_iterator&lt;string&gt;(cout, \" \"));}\n  Output:  one:1 three:3 two:2\n\n此处由于map自动按照键的字典序进行排序, 因此输出时three的元素在two前;\n\n\n\n在上述的示例中, 也可以使用下面的方式进行vec的输出:\nfor(const auto&amp; s : vec) {    cout &lt;&lt; s &lt;&lt; \" \";}\n此时auto会自动推导为string类型, 且&amp;对数组的元素进行了引用, 使得输出更加高效.\nPro&amp;Confor-each循环的优点:\n\n消除了访问数组等越界的风险;\n不需要事先初始化迭代器;\n\nfor-each循环的缺点:\n\n无法获取元素的索引;\n只能顺序地遍历.\n\ntypedef我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.\n而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.\ntypedef old_type new_type;\n\nNotices\n直接对数组、字符串和vector进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;\n\n对于vector, 可以通过.at() = 的方式进行安全访问, 编译器会进行边界检查. 或者通过.push_back() or .emplace_back的方式在末尾赋值. 同时注意用.reserve()预先分配充分的内存空间.\n\n避免不经意地向map当中插入元素:\n\n错误的示范:\n\n if(foo[\"bob\"] == 1){...}// 设置默认的零值\n\n使用.count()方法正确检查元素是否存在:\n\n if( foo.count(\"bob\") ){...}\n\n也可以使用find()方法检查元素是否存在:\n\nauto it = m.find(\"four\");   if(it  != m.end()){    cout &lt;&lt; it-&gt;second &lt;&lt; endl;}else{    cout &lt;&lt; \"Not found\" &lt;&lt; endl;}\n使用.empty()方法来检查容器整体是否为空, 而非.count() == 0的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.\n\nerase() 方法会返回指向被删除元素的下一个元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:\n //Initialize a listlist&lt;int&gt; L;list&lt;int&gt;::iterator li = L.begin();// Wrong:L.erase(li);    // 删除元素后，li 变成了无效迭代器++li;           // 错误, 不能对无效迭代器进行操作// Correct:li = L.erase(li);  // 删除元素后，li 被更新为指向被删除元素的下一个元素\n\n指针\nPointers to Objects\n\nstring str = \"hello\";string *p = &amp;str;\n\n\nOprators with Pointers\n&amp;: 取地址;\n*: 解引用;\n-&gt;: 用于访问对象的成员.\n\n\n\n(*p).length();// 等价于p-&gt;length();\n\nlength()即为string类的成员函数, 因此可以用-&gt;来访问.\n\n常量指针\n以char为例.\n\n\n指向常量的指针 const char *p\n可以改变指针的地址.\n无法通过指针改变对象的值\n\n\n常量指针 char * const p\n指针指向的地址无法改变;\n但是可以通过指针改变对象的值如果需要同时保证地址和值都无法改变, 则需要使用const char * const p.\n\n\n\n如果sp是指向字符串的指针, 那么这两种的写法是等价的, 注意.的优先级高于*, 因此括号不可忽略.\nsp-&gt;length();(*sp).length();\n\n\n\nClass:::: resolver: 作用域解析运算符\n\n作用: \n\n访问全局的作用域当局部变量和全局变量同名时, 可以使用 :: 来访问全局变量\nint value = 10; // 全局变量void function() {    int value = 20; // 局部变量    cout &lt;&lt; value;    // 输出 20（局部变量）    cout &lt;&lt; ::value;  // 输出 10（全局变量）}\n\n访问命名空间中的成员\nnamespace Math {    const double PI = 3.14159;}double circumference = 2 * Math::PI * radius; // 使用命名空间中的常量\n\n\n语法:\n\n&lt;class_name&gt; :: &lt;function_name&gt;\n::&lt;function_name&gt;  全局作用域\n\n\n\ne.g. \nvoid S::f() {    ::f();  // Would be recursive otherwise!    ::a++;  // Select the global a    a--;    // The a at class scope}\n\n\nS::f(): 定义了属于类S的成员函数f;\n::f():表示调用全局作用域中的函数 f(), 默认为递归调用当前的成员函数;\n::a++表示将全局作用域的 a 自增, a--则访问并递减类作用域中的成员变量 a.\n\nthisthis指针是成员函数的隐藏参数. 指向当前对象的实例.\nvoid Point::move(int dx, int dy);//等价于void Point::move(Point *this, int dx, int dy);\n\n当调用成员函数时, 对象的地址会自动作为 this参数传递.\n在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 this:\ne.g\nclass Point {private:    int x, y;    public:    // 移动点的位置    void move(int dx, int dy) {        x += dx;        y += dy;    }        // 打印点的坐标    void print() {        std::cout &lt;&lt; \"Point at (\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; std::endl;    }        // 组合以上两个功能的函数    void move_and_print(int dx, int dy) {        move(dx, dy);  // 等同于 this-&gt;move(dx, dy)        print();       // 等同于 this-&gt;print()    }};\n\n\n但是也可以显式指定 this-&gt;move, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.\n\n封装特性在OOP中, Object = Attributes + Services, 即数据和操作被封装在一起, 构成一个完整的对象.\n声明与定义我们应当在头文件中声明对象的成员及其 public,private和 protected等属性, 并且在 cpp文件中给出具体的定义:\n\n最好为每个类都建立如此对应的头文件和源文件 cpp.\n\ne.g. \n// Student.h - 类的声明#ifndef STUDENT_H#define STUDENT_H#include &lt;string&gt;using namespace std;  // 在头文件中使用class Student {private:    // 数据成员    string name;         int id;    float gpa;    public:    // 构造函数原型    Student(const string&amp; name, int id);        // 成员函数原型    void setName(const string&amp; newName);    string getName() const;    void calculateGPA();    bool isEligibleForScholarship() const;};#endif // STUDENT_H\n\n// Student.cpp - 成员函数的定义#include \"Student.h\"using namespace std;  // 在源文件中使用// 构造函数实现Student::Student(const string&amp; name, int id) {    this-&gt;name = name;    this-&gt;id = id;    this-&gt;gpa = 0.0;}// 成员函数实现void Student::setName(const string&amp; newName) {    name = newName;}string Student::getName() const {    return name;}void Student::calculateGPA() {    // 实现GPA计算逻辑    // ...}bool Student::isEligibleForScholarship() const {    return gpa &gt;= 3.5;}\n\n\nStudent::getName()指的就是类 Student中的成员函数 getName().\n\n具体来说, .h头文件当中应该有:\n\n外部变量的声明e.g. extern int globalCounter;  // 仅声明，不定义\n\n函数原型e.g. int calculateSum(int a, int b);  // 函数声明，不包含实现\n\n类/结构体的声明e.g.\nclass Student;  // 前向声明// 或完整类声明（不含成员函数定义）class Rectangle {private:    double width;    double height;public:    Rectangle(double w, double h);    double getArea() const;};\n\n回顾 #include: 将被引用的文件插入 .cpp 文件当中\n\n#include \"xx.h\": 首先在当前目录下寻找;\n\n#include &lt;xx.h&gt;: 直接在指定的目录中寻找\n\n等价于 #include &lt;xx&gt;.\n\n\n\n为了避免在多个 .cpp 文件中重复引用相同的头文件, 可以通过 #ifndef等标记来判断是否需要引用当前的头文件:\n#ifndef HEADER_FLAG#define HEADER_FLAG#endif \n\n\nHEADER_FLAG一般使用完全大写来方便标识, 但是也可以大小写混合.\n\ne.g. \n// 文件: vector.h#ifndef VECTOR_H#define VECTOR_H// ...#endif // VECTOR_H\n\n生命周期管理当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.\n为了确保这些工作不被遗忘, cpp的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.\n构造函数构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.\n\n语法:\n\nclass ClassName {public:    // 默认构造函数    ClassName();        // 带参数的构造函数    ClassName(参数列表);        // 拷贝构造函数    ClassName(const ClassName&amp; other);    };\n\n\n\n默认构造函数：不带参数或所有参数都有默认值;\n带参数的构造函数：接受一个或多个参数;\n拷贝构造函数：从同类型的另一个对象创建新对象.\n\n\n\n构造函数初始化列表\nPoint::Point(int xx, int yy) :x(xx), y(yy) {  ...}\n\n\n构造函数时, 传递参数并直接赋值给内部的成员变量 x , y.\n\n\n结构体中的构造函数:\nstruct Y {     float f;     // 浮点型成员变量    int i;       // 整型成员变量    Y(int a);    // 声明了一个接受int参数的构造函数};\n\n\n\n此处只是声明了构造函数需要 int a作为参数, 但是没有给出具体的实现;\n声明结构体对象(数组)  e.g. Y y1[] = { Y(1), Y(2), Y(3) };\n\n\n\n\n默认构造auto default constructor: (自动) 默认构造函数. 当且仅当不存在任何构造函数时, 程序会自动生成默认构造函数, 不作任何的操作.\n默认构造函数： 在没有参数的情况下可以调用的构造函数， 称为默认构造函数. 其来源除了上述的程序构造以外, 还包括:\n\n显示定义的无参构造函数;\n定义的所有参数都具有默认值的构造函数.\n\n\n对于成员变量: 不进行初始化;\n\n析构函数析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 ~. 当对象超出作用域或被显式删除时，析构函数会自动被调用.\nclass ClassName {public:    ~ClassName();};\n\n\n类似于栈, 优先创建的后析构.\n\n运用的示例:\n#include &lt;iostream&gt;#include &lt;cstring&gt;class MyString {private:    char* data;public:    // 默认构造函数    MyString() : data(nullptr) {        std::cout &lt;&lt; \"默认构造函数调用\" &lt;&lt; std::endl;    }    // 带参数的构造函数    MyString(const char* str) {        if (str) {            data = new char[strlen(str) + 1];            strcpy(data, str);        } else {            data = nullptr;        }        std::cout &lt;&lt; \"参数构造函数调用\" &lt;&lt; std::endl;    }    // 拷贝构造函数    MyString(const MyString&amp; other) {        if (other.data) {            data = new char[strlen(other.data) + 1];            strcpy(data, other.data);        } else {            data = nullptr;        }        std::cout &lt;&lt; \"拷贝构造函数调用\" &lt;&lt; std::endl;    }    // 析构函数    ~MyString() {        delete[] data;        std::cout &lt;&lt; \"析构函数调用\" &lt;&lt; std::endl;    }    // 打印字符串    void print() const {        std::cout &lt;&lt; (data ? data : \"空字符串\") &lt;&lt; std::endl;    }};int main() {    // 测试各种构造函数    MyString s1;                  // 默认构造函数    MyString s2(\"Hello\");         // 带参数的构造函数    MyString s3 = s2;             // 拷贝构造函数        s1.print();    s2.print();    s3.print();        return 0;  // 所有对象在这里被销毁，调用析构函数}\n\n\n\n本地对象: \nField(字段)指的是在类中定义的变量(成员变量):\n\n可以直接被类中的所有方法访问;\n生命周期和类的对象保持一致;\n\n其他类型数据的生命周期:\n\n参数: 函数执行期间;\n局部变量: 声明的代码块内部.\n\n\n全局对象:\n\n[!NOTE]\n如果在类或对象的方法内部定义了一个和成员变量同名的变量, 那么将默认访问这个变量, 只有用 this-&gt;xxx才能显式访问成员变量. e.g. int MyClass::count .\nclass MyClass {public:    int value = 10; // 字段    void printValue() {        int value = 20; // 局部变量        std::cout &lt;&lt; \"Local value: \" &lt;&lt; value &lt;&lt; std::endl; // 输出局部变量        std::cout &lt;&lt; \"Field value: \" &lt;&lt; this-&gt;value &lt;&lt; std::endl;//使用this指针访问字段    }};\nAccess Controlclass的默认为 private, 而 struct的默认权限是 public.\n访问限制符:\nfriend在 class内部声明友元, 可以使得对应的函数访问自身的成员变量(包括私有和受保护, 也即是所有的变量).\nstruct X {private:    int i;public:    void initialize();    friend void g(X*, int i);    friend void Y::y();}\n\n\n\n\n[!NOTE]\n友元关系不具有传递性 !\n\nprotected该声明内的成员可以被以下的范围访问:\n\n该类自身的成员函数;\n该类的派生类的成员函数;\n\ne.g.\nclass Base {protected:    int protectedVar;public:    Base(int val) : protectedVar(val) {}};class Derived : public Base {public:    Derived(int val) : Base(val) {}    void accessProtectedVar() {        protectedVar = 10; // 派生类可以访问 protectedVar    }    int getProtectedVar(){        return protectedVar;    }};\n\n\n此处的 base就是一个基类, class Derived : public Base表明 Derived 是 base的一个派生类.\n因此,  派生类可以通过自己的成员函数, 访问基类的 protected内的成员变量.\n\nStatic对于本地变量和全局变量的作用不同, 前者是生命周期, 后者是访问空间.\n静态的对象的生命周期是全局, 但是不会跟全局变量一样(一开始就创建), 而是在第一次调用的时候才构造, 且只构造一次.\n\n静态成员变量由所有的实例共享, 初始化的时候不能再添加 static标签(否则无法被外文件访问), 必须在类的外部进行初始化, 且需要声明所属于的类;\n\n但是也可以被普通的成员函数所访问.\n\n\n静态成员函数属于类本身, 因此可以通过类名直接调用, 但是只能访问类的静态成员变量, 因为不存在属于实例的this指针. 静态成员函数可以在类的内部就定义, 如果在类的外部定义, 也不需要额外的static标签;\nclass MyClass {public:    static int count; // 静态成员变量    int id;    MyClass(int i) : id(i) {        count++; // 每次创建对象，count加1    }    ~MyClass() {        count--;    }    static int getCount() { // 静态成员函数        return count;    }};int MyClass::count = 0; // 静态成员变量的初始化int main() {    std::cout &lt;&lt; \"Count: \" &lt;&lt; MyClass::getCount() &lt;&lt; std::endl; // 通过类名调用静态成员函数    MyClass obj1(1);    MyClass obj2(2);    std::cout &lt;&lt; \"Count: \" &lt;&lt; MyClass::getCount() &lt;&lt; std::endl; // 通过类名调用静态成员函数    return 0;}\n\nOutput:\nCount: 0Count: 2\n\n\n\n函数内部的静态变量只会在调用的时候初始化一次, 直到程序结束.e.g. 计数函数的调用次数:\nvoid f(){  static int num_calls = 0;  ...  num_calls += 1;}\n\nextern关键字用于声明变量或函数在其他文件中定义. 告诉编译器从而允许跨文件的访问.\n\n但是这种跨文件访问只能作用于非静态的全局变量, i.e. 全局变量加上static声明之后, 将其作用域限制在了当前文件的内部.\n\n\n函数内部的静态对象, 其构造函数只会在定义的时候调用一次. 并且析构函数当退出程序时调用. 即使采取条件构造, 也只会在第一次条件满足的时候构造.\n\n静态成员的使用:\n\n通过类名: &lt;class_name&gt;::&lt;static member\n\n通过实例名: &lt;ob variable&gt;.&lt;static member&gt;\n\n让人误以为是类的对象变量, 不建议这样使用.\n\n\n\n\n\nReference引用（Reference）是一个非常重要的特性。它的引入是为了解决一些特定场景下的问题：\n\n避免不必要的拷贝：在某些情况下，传递大型对象或结构体给函数时，如果直接传递拷贝会导致性能下降。引用允许我们传递对象的别名，而不需要拷贝整个对象。\n简化代码：引用可以使代码更简洁，特别是在函数返回值和参数传递时。例如，通过引用返回一个对象可以避免构造临时对象。\n指针的安全替代：引用提供了指针的功能，但避免了指针容易导致的错误，如空指针解引用或野指针。\n\n基本语法: \n引用是一个变量的别名，它在声明时必须被初始化，并且一旦初始化后就**不能再指向其他**对象.\nint a = 10;int&amp; ref = a;  // ref 是 a 的引用\n\n\nint&amp; 表示引用类型，ref 是 a 的引用。\n引用必须在声明时初始化，并且不能重新引用到另一个对象。\n无法对引用进行引用;\n不允许存在 以引用为元素的数组\n\ne.g.\n#include &lt;iostream&gt;int main() {    int a = 10;    int&amp; ref = a;  // ref 是 a 的引用    std::cout &lt;&lt; \"Original value of a: \" &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; \"Value of ref: \" &lt;&lt; ref &lt;&lt; std::endl;    ref = 20;  // 修改引用会影响原变量    std::cout &lt;&lt; \"After modifying ref, value of a: \" &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; \"Value of ref: \" &lt;&lt; ref &lt;&lt; std::endl;    return 0;}\n\n在这个例子中：\n\nref 是 a 的引用，修改 ref 的值会影响 a 的值。\n通过引用，我们可以访问和修改原始变量 a 的值，而不需要直接操作 a。\n\n引用可以作为函数的形参, 此时函数内部的形参作为实参的引用可以改变实参的值.\n引用的绑定必须是一个具有明确地址的左值 ,而不能是临时产生的右值:\nvoid func(int &amp;);func (i * 3); // Warning or error!\n\n\n\n指针与引用\n限制:\n\n无法获得指针的引用;\nint &amp;*p;// illegal\n\n但是可以获得指向引用的指针\nvoid f(int *&amp;p);\n\n\n\n 可以如此理解, 引用实际上是对象的别名. 用于修改对象的值. 但是为了修改指针, 可以直接使用指针的指针 **.\n此外, 引用并非独立的对象, 而是直接 绑定. 因此 int&amp; ref = a;  &amp;ref就是 a的地址.\n右值引用左值是指具有明确地址的变量或者引用, 右值是计算过程中的中间结果或者字面量 (e.g.10).等不可寻址的值;\n\n涉及到计算的基本都是右值, 但是这四种的计算结果依旧是左值: *,.,[]和 -&gt;.\n\n右值一般在计算结束后就消失了, 如果我们希望延长其生命周期, 就可以使用 右值引用.\n\n格式: &lt;tyep&gt; &amp;&amp; &lt;ref_name&gt; = &lt;right_value&gt;\nint x=20; // left-value int&amp;&amp; rx = x * 2:\n\nTIps:\n\n右值引用在初始化之后就可以正常赋值;\n右值引用无法使用左值进行赋值.\n\n\n\n引用参数与函数重载#include &lt;iostream&gt;using namespace std;void fun(int&amp; lref){   cout &lt;&lt; \"lref = \" &lt;&lt; lref &lt;&lt; endl;}void fun(int&amp;&amp; rref){   cout &lt;&lt; \"rref = \" &lt;&lt; rref &lt;&lt; endl;}int main(){   int x = 10;   fun(x);   fun(10);}\n\nOutput:\nlref = 10rref = 10\n\n\n\n字面量10作为右值, 可以通过右值引用作为函数的参数;\n具有明确地址的变量 x是左值;\nC++ 允许在同一个作用域内声明多个具有相同名称但参数列表不同的函数。这被称为函数重载。编译器通过检查函数调用时提供的参数类型和数量来决定调用哪个重载函数。\n\n\n另外, 加上const之后, &amp; 的形参也可以接受右值作为实参, 比如: void fun (const int&amp; clref) {...}\n\n但是如果已经存在右值实参作为形参的同名函数, 将会优先选择后者进行重载.\n\n这是因为普通引用对于右值的修改 make no sense, 而 const 引用保证不会修改引用的对象，因此即使是临时对象（右值）也可以安全地绑定到 const 引用.\nConstants使用 const声明常量, 常量的值不可修改.\nconst声明集合的时候, 其中的值在编译期间不可知, 因此无法在代码中, 使用常量集合内部的值进行操作.\nconst int i[] = {1,2,3};float f[i[2]]; // Illegal!\n\n\n\n使用const对指针类型进行操作的时候:\n\n忽略类似于 char之类的类型, 只关注 const与 *之间的位置关系;\n如果是 const *p 意思是指针指向的内容不可通过这个指针进行更改;\n如果是 * const p意思是指针指向的对象不可更改, 但是可以通过 *p 的方式改写对象的值\n\n\n关于字符指针与字符数组:\n\nchar  *p = \"hello\"; 实际上是 const char *p, 也就是说不允许修改 *p;\n而 char p[] = 'hello'; 则可以通过*p 修改.\n\n\n如果成员函数的名称后加了 const标记, 意味着:\n\n无法通过该成员函数改变成员变量的值.\n同时无法调用其他 非const的成员函数\n实际上, 将其的 this指针转换为 const A* this, 也就是指向常量的指针\n\n\n因此 const修饰的成员函数具有 this指针(可访问), 不要与 static修饰的静态成员函数混淆! 后者不具有 this指针.\n注意不要与 const  type f()混淆, 这是限制返回的结果无法修改; 而 type f() const限制成员函数本身的操作.\n\n重载: 允许根据成员函数是否被 const限制, 以及对象本身是否为 const来重载成员函数.\nclass A {public:    void f() const {        cout &lt;&lt; \"const version\" &lt;&lt; endl;    }    void f() {        cout &lt;&lt; \"non-const version\" &lt;&lt; endl;    }};int main() {    A a;    const A ca;    a.f();    // 输出: non-const version    ca.f();   // 输出: const version    return 0;}\n\n\n\n如果成员变量是 const, 那么:\n\n必须在对象构造时进行初始化 (无法在构造函数中进行直接赋值):\nclass A {public:    const int i;    A(int value) : i(value) {} // 在初始化列表中初始化};\n\n如果在实例化对象的时候,  声明了这个实例是 const, 那么就无法调用成员函数中没有在后面声明 const的部分.( 即使实际上并没有修改的函数, 也不能通过编译).  —— 只能调用那些被标记为const的成员函数。\nclass A{  ...  int get_value();  int get_const_value const();}const A a();a.get_value; // ERROR, const对象无法调用非const声明的成员函数a.get_const_value; // ok\n\n\n\n\n\n\n无法用普通的指针来指向 const常量.\n但是可以用指向常量的指针 来指向非常量的对象.\n\n\n全局变量的构造在 main()之前. 静态本地变量在第一次执行到的时候才发生构造, 且只构造一次.\n\n动态内存在 C++ 中，使用 new 关键字分配的空间位于 堆 上，与栈上的自动变量不同，堆上的内存不会自动释放，需要手动使用 delete 来析构以避免内存泄漏。\n示例代码#include &lt;iostream&gt;using namespace std;int main() {    // 使用 new 在堆上分配一个整数    int* ptr = new int(10);    cout &lt;&lt; \"值: \" &lt;&lt; *ptr &lt;&lt; endl;    // 使用 delete 释放内存    delete ptr;    // 指针置空，避免野指针    ptr = nullptr;    return 0;}\n\n注意事项\n每次 new 分配的内存都需要对应的 delete。\n对于数组，使用 new[] 分配，释放时用 delete[]：\n\nint* arr = new int[5];  // 分配数组delete[] arr;           // 释放数组\n\n\nInline ClassDelegating Constructor委托构造函数（Delegating Constructor）是通过一个构造函数调用另一个构造函数来完成初始化的机制, 也就是在初始化列表中调用其他.\n相对于委托构造的构造函数, 被称为 target constructor 目标构造函数.\n目标构造函数的执行先于委托构造函数.\n\n什么是委托构造函数？\n定义: 一个构造函数可以在其初始化列表中调用同一个类的另一个构造函数来完成部分或全部初始化工作。\n目的: 避免在多个构造函数中重复编写相同的初始化逻辑，解决代码重复的问题。\n限制: 委托构造函数本身不能在初始化列表中再初始化其他成员变量，只能依赖被调用的构造函数。\n\n代码示例与分析考虑将下面的冗余代码通过委托构造函数简化:\n\n实现: \n#include &lt;iostream&gt;using namespace std;class ClassC {public:    int max;    int min;    int middle;    // 基础构造函数    ClassC(int my_max) {        max = (my_max &gt; 0) ? my_max : 10;  // 默认值10    }    // 委托给基础构造函数    ClassC(int my_max, int my_min) : ClassC(my_max) {        min = (my_min &gt; 0 &amp;&amp; my_min &lt; max) ? my_min : 1;  // 默认值1    }    // 委托给第二个构造函数    ClassC(int my_max, int my_min, int my_middle) : ClassC(my_max, my_min) {        middle = (my_middle &lt; max &amp;&amp; my_middle &gt; min) ? my_middle : 5;  // 默认值5    }};int main() {    ClassC c1{1, 3, 2};    cout &lt;&lt; \"max: \" &lt;&lt; c1.max &lt;&lt; \", min: \" &lt;&lt; c1.min &lt;&lt; \", middle: \" &lt;&lt; c1.middle &lt;&lt; endl;    return 0;}\n\n运行结果分析\nClassC c1{1, 3, 2}:\n调用 ClassC(int, int, int) 构造函数。\n它委托给 ClassC(int, int)，后者再委托给 ClassC(int)。\n初始化顺序：\nmax = 1（因为 1 &gt; 0）。\nmin = 1（因为 3 &gt; max，不满足条件，使用默认值 1）。\nmiddle = 2（因为 2 &lt; max 且 2 &gt; min 不成立，但逻辑上仍赋值 2，需检查代码逻辑）。\n\n\n\n\n\n关键点\n初始化位置:\n\n成员变量不能在委托构造函数的初始化列表中直接使用参数初始化，必须通过被委托的构造函数完成。\n如 ClassC(int my_max, int my_min) : ClassC(my_max) 中，不能再初始化 min，只能在函数体内赋值。\n\n\n代码重复问题:\n\n如果每个构造函数都独立初始化 max、min 等，会导致重复代码。\n委托构造函数将公共逻辑集中到基础构造函数中。\n\n\n委托链:\n\n可以形成构造函数调用链，如 ClassC(int, int, int) → ClassC(int, int) → ClassC(int)。\n\n\n限制与解决方法:\n\n委托构造函数不能再有其他初始化列表项。\n如果需要更灵活的初始化，可以引入一个私有的辅助构造函数：\n\n\n\nclass ClassC {private:    int max;      int min;    void init(int my_max) { max = my_max &gt; 0 ? my_max : 10; }public:    ClassC(int my_max) { init(my_max); }    ClassC(int my_max, int my_min) : min(my_min) { init(my_max); } // 直接在初始化列表中初始成员变量\t};\n\n\n\n\n\n\n默认参数定义\n默认参数是在函数声明中为参数指定的默认值，调用时未提供参数则使用默认值。\n规则：默认参数必须从右到左设置。\n\n代码示例#include &lt;iostream&gt;using namespace std;// 函数声明int harpo(int n, int m = 4, int j = 5);  // 合法int chico(int n, int m = 6, int j);       // 非法：j 无默认值int groucho(int k = 1, int m = 2, int n = 3);  // 合法int main() {    int beeps;    beeps = harpo(2);      // harpo(2, 4, 5) -&gt; 11    cout &lt;&lt; \"beeps = \" &lt;&lt; beeps &lt;&lt; endl;    beeps = harpo(1, 8);   // harpo(1, 8, 5) -&gt; 14    cout &lt;&lt; \"beeps = \" &lt;&lt; beeps &lt;&lt; endl;    beeps = harpo(8, 7, 6);  // harpo(8, 7, 6) -&gt; 21    cout &lt;&lt; \"beeps = \" &lt;&lt; beeps &lt;&lt; endl;    return 0;}int harpo(int n, int m, int j) {    return n + m + j;}\n\n关键点\n规则:\n默认参数从右到左设置。\nint harpo(int n, int m = 4, int j = 5) 合法。\nint chico(int n, int m = 6, int j) 非法。\n\n\n作用:\n省略参数时自动填充默认值。\n减少函数重载需求。\n\n\n注意:\n默认值在声明中指定，不在定义中。\n不能“跳跃”使用参数，如 harpo(1, , 6) 非法。\n\n\n\n改进建议\n复杂逻辑可考虑函数重载或委托构造函数。\n避免过度使用默认参数以保持代码清晰。\n\n\n内联函数\nInline Functions\n\n定义\n内联函数是用 inline 关键字修饰的函数，编译器会尝试将函数调用替换为函数体代码，减少函数调用的开销。\n\n普通函数的调用需要经历: 压栈、传递参数、跳转到函数地址、返回值处理、出栈等步骤, 由此可见内联函数可以有效提升性能.\n\n\n适用于小型、频繁调用的函数。\n\n\n代码示例#include &lt;iostream&gt;using namespace std;// 内联函数定义inline int square(int x) {    return x * x;}int main() {    int num = 5;    cout &lt;&lt; \"Square of \" &lt;&lt; num &lt;&lt; \" is \" &lt;&lt; square(num) &lt;&lt; endl;  // 输出 25    return 0;}\n\n关键点\n作用:\n减少函数调用开销（如参数传递、栈帧创建）。\n提高执行效率，适合小型函数。\n\n\n使用场景:\n函数体短小、调用频繁。\n不适合复杂函数（可能导致代码膨胀）。\n\n\n注意:\ninline 是建议，编译器可能忽略（例如函数过大或包含循环）。\n内联函数定义通常放在头文件中，避免链接错误 (在多个源文件被调用的时候, inline的声明可以告诉编译器, 重复的定义是被允许的)\n\n\n\n\n[!NOTE]\n\nAny function you define inside a class declaration is automatically an inline.\n\nclass内部**定义**的函数自动为 inline类型. 如果是类外定义(相同的.h文件), 那么需要显式声明为内联函数.\n\n\n内联函数必须在**头文件**中定义，或者在调用它的同一翻译单元中.\n\n如果定义在 .cpp 文件中，调用点无法看到定义，编译器无法内联，链接器会报错.\n\n\n如果决定将类的函数定义写在头文件中, 有以下的两种选择使其成为内联函数;\n\n直接在声明的地方给出完全的定义;\n在类外声明 inline然后定义.\n\n\ninline确实比C语言的 macro更好, 因为内联函数实现了对参数的类型检查.\n\n编译器会对声明为 inline 的函数进行检查: 如果包含了递归 或者 代码量较大, 编译器依旧不会将其视为 inline .\n\n\n\ninline 变量\n[!NOTE]\n\n为静态成员变量声明 inline, 不必在 .cpp中再次声明.\n\n用于在头文件中定义具有外部链接的变量，避免了重复定义的问题.\n\n\n\n在 C++ 传统规则中，全局变量（或者 namespace 作用域的变量）在头文件中定义会导致多个翻译单元（编译文件）出现重复定义错误。在 C++17 之前，通常的做法是：\n// myheader.hextern int myVar; // 声明// mysource.cpp#include \"myheader.h\"int myVar = 42; // 定义\n\n但在 C++17 之后，可以使用 inline 变量，直接在头文件中定义，而不会导致重复定义错误：\n// myheader.hinline int myVar = 42;  // C++17 及以上\n\n在任何 #include \"myheader.h“ 的地方，myVar 仍然是同一个变量。\n\n如果希望不同的文件不是一个实例, 需要声明为 静态全局变量.\n\ninline 变量的特点\n​\t1.\t允许在头文件中定义，避免 extern 的使用。\n​\t2.\t所有包含它的翻译单元共享同一个变量（编译时不会创建多个实例）。\n​\t3.\t必须初始化，否则编译器无法确定变量的值。\n示例：多个文件使用 inline 变量\n假设有以下两个源文件，同时包含 myheader.h，但不会引发重复定义错误：\n头文件 myheader.h\n#ifndef MYHEADER_H#define MYHEADER_H#include &lt;iostream&gt;inline int globalVar = 100; // inline 变量#endif\n\n源文件 file1.cpp\n#include \"myheader.h\"void func1() {    std::cout &lt;&lt; \"file1.cpp: \" &lt;&lt; globalVar &lt;&lt; std::endl;}\n\n源文件 file2.cpp\n#include \"myheader.h\"void func2() {    std::cout &lt;&lt; \"file2.cpp: \" &lt;&lt; globalVar &lt;&lt; std::endl;}\n\n主程序 main.cpp\n#include \"myheader.h\"void func1();void func2();int main() {    func1();    func2();    globalVar += 10;    std::cout &lt;&lt; \"main.cpp: \" &lt;&lt; globalVar &lt;&lt; std::endl;    return 0;}\n\n编译 &amp; 运行\ng++ file1.cpp file2.cpp main.cpp -o output &amp;&amp; ./output\n\n输出示例：\nfile1.cpp: 100file2.cpp: 100main.cpp: 110\n\n说明：\n​\t•\tglobalVar 是同一个变量，而不是多个副本。\n​\t•\tmain.cpp 修改 globalVar 之后，globalVar 在所有翻译单元中都被更新。\n\ninline 变量 vs constexpr 变量\n​\t•\tinline 变量可以是可变的，可以修改其值。\n​\t•\tconstexpr 变量必须是编译时常量，不能修改。\n​\t•\tinline constexpr 变量既有 inline 特性，又是编译时常量。\ninline constexpr int constantVar = 50; // 不能修改\n\n\n\nweakweak允许不同的编译单元存在同名的函数, 并且在实际调用的时候, 优先调用不是 weak的函数. 从而提供了一种默认的实现.\nweak关键字可以用于函数、变量与对象等, 与主要使用于函数的 inline不同.\n如果没有 weak标记, 就是强变量.\n\n一般的编译器需要使用 __attribute__((weak))  来声明:\n\n#include &lt;iostream&gt;// 声明 weak 变量，提供默认值__attribute__((weak)) int globalValue = 42;int main() {    std::cout &lt;&lt; \"globalValue = \" &lt;&lt; globalValue &lt;&lt; std::endl;    return 0;}\n\n\n\nComposition用已有的对象构造新的对象. 称为组合.\n可以用 has-a的关系来描述.\n类内对象的初始化假设我们有一个 Person 类，该类内部包含一个 std::vector&lt;std::string&gt; 类型的成员变量，用于存储人的爱好。我们将展示如何在类的构造函数中使用完全初始化和引用初始化来初始化这个成员变量。\n1. Fully完全初始化是指在类的构造函数中直接为成员变量赋予初始值。这通常通过成员初始化列表（member initializer list）来完成。\nclass Person {public:    std::vector&lt;std::string&gt; hobbies;    // 完全初始化：使用成员初始化列表    Person(const std::vector&lt;std::string&gt;&amp; initialHobbies)        : hobbies(initialHobbies) { }};\n\n解释\n\n成员变量初始化：在 Person 类的构造函数中，我们使用成员初始化列表 : hobbies(initialHobbies) 来完全初始化 hobbies 成员变量。这意味着 person1.hobbies 将拥有 initialHobbies 的一个拷贝。\n独立性：person1.hobbies 是 initialHobbies 的一个独立拷贝，修改 person1.hobbies 不会影响 initialHobbies，反之亦然。\n\n2. Reference引用初始化是指将类内部的成员变量声明为引用类型，并在构造函数中将其绑定到另一个对象。这意味着类内的引用将直接指向外部对象，而不是持有其拷贝。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;class Person {public:    std::vector&lt;std::string&gt;&amp; hobbiesRef;  // 引用类型的成员变量    // 引用初始化：使用成员初始化列表绑定到外部对象    Person(std::vector&lt;std::string&gt;&amp; externalHobbies)        : hobbiesRef(externalHobbies) { }};\n\n解释\n\n成员变量声明：std::vector&lt;std::string&gt;&amp; hobbiesRef; 声明了一个引用类型的成员变量 hobbiesRef，它将引用外部的 std::vector&lt;std::string&gt; 对象。\n引用绑定：在构造函数中，通过 : hobbiesRef(externalHobbies) 将 hobbiesRef 绑定到传入的 externalHobbies 对象。这意味着 person2.hobbiesRef 和 sharedHobbies 指向同一个内存位置。\n共享数据：对 person2.hobbiesRef 的修改（如添加新爱好）会直接影响到 sharedHobbies，因为它们共享相同的数据。\n\n3. 对比\n\n\n特性\n完全初始化\n引用初始化\n\n\n\n存储方式\n存储外部对象的拷贝\n存储对外部对象的引用\n\n\n内存使用\n额外占用内存用于拷贝\n不占用额外内存，直接引用外部对象\n\n\n数据独立性\n修改类内成员不会影响外部对象\n修改类内成员会影响外部对象\n\n\n生命周期依赖\n类内成员独立于外部对象的生命周期\n类内引用的生命周期必须至少与外部对象相同\n\n\n适用场景\n需要独立副本时使用\n需要与外部对象共享数据时使用, 初始情况下不知道容量\n\n\n注意事项\n引用必须在构造时初始化：引用类型的成员变量必须在构造函数的初始化列表中绑定到一个对象，不能在构造函数体内赋值。\n\n[!NOTE]\n因为引用类型的对象必须在初始化的时候绑定, 并且只能绑定一次.\n\n// 错误示例：试图在构造函数体内赋值给引用class Person {public:    std::vector&lt;std::string&gt;&amp; hobbiesRef;        Person(std::vector&lt;std::string&gt;&amp; externalHobbies) {        hobbiesRef = externalHobbies; // 错误：引用必须在初始化时绑定    }};\n\n生命周期管理：使用引用初始化时，必须确保被引用的对象在使用期间是有效的。如果引用的对象被销毁，引用将变为悬空引用，导致未定义行为。\n// 危险示例：悬空引用std::vector&lt;std::string&gt; createHobbies() {    std::vector&lt;std::string&gt; temp = {\"Temporary\"};    Person person(temp);    return temp; // temp 被销毁，person.hobbiesRef 悬空}\n\n为了避免这种情况，通常可以使用智能指针（如 std::shared_ptr 或 std::unique_ptr）来管理对象的生命周期，或者确保引用的对象在使用期间一直有效。\n\n\n总结\n[!NOTE]\n\n如果使用 完全初始化 的方式, 类内必须包含另一个类的完整定义(引用头文件);\n\n如果是引用初始化, 可以直接在这个类的内部预先声明另一个类的存在即可.\nclass A; // 前向声明class B{  A* ptr;}\n\n\n\nEmbedded objects\n[!NOTE]\n\n对于嵌入对象，如果不用初始化列表，就必须有默认构造函数。\n\n\nnamespace命名空间的别名如果 namespace过长, 可以将其重新赋值并使用:\nnamespace supercalifragilistic {\tvoid f();}namespace short = supercalifragilistic;short::f();\n\n\n\nselection除了直接在一个命名空间内部嵌套其他, 我们也可以在一个命名空间里选择性地使用其他空间的部分函数:\nnamespace mine｛\tusing orig::Cat;\t // use Cat class from origvoid ×O）；\tvoid x()；    void y();}\n\n\n\n\n[!NOTE]\n\nMultiple namespace declarations add to the same namespace.也即是说, 多个 .h文件内相同的命名空间会自动的视作一个.\n\n\nInheritance\n[!NOTE]\n\n继承的对象都具有基类的属性, 但是不一定具有访问的权限.也就是 Think of inherited traits as an embedded object\n派生类的构造函数中的初始化列表应当包含基类的构造函数.\n由于基类的私有成员无法被子类直接访问, 需要让子类调用基类的public的函数, 从而间接访问.\n如果子类和父类含有同名的变量, 将会同时存在, 并且可以在子类中声明 parent_class:A来访问父类中的属性A.\n子类中一定有部分是父类的对象, 并且处于子类的开头(父类必须首先完成初始化).\n\n\n初始化列表的常用场景\n调用基类的构造函数 (否则调用默认构造函数)\nclass Base {public:    Base(int data) { /* ... */ }};class Derived : public Base {public:    Derived(int baseVal) : Base(baseVal) { }};\n\n初始化嵌入类\nclass Member {public:    Member(const std::string&amp; str) { /* ... */ }};class Container {    Member memberObj;public:    Container(const std::string&amp; s) : memberObj(s) { }};\n\n\n需要注意的是, 此处的初始化列表中的嵌入类的构造, 变量名不是类名.\n如果嵌入类不存在默认的构造函数, 那么初始化列表中的显式构造是必要的.\n\n\n初始化常量成员:\nclass MyClass {    const int constMember;public:    MyClass(int val) : constMember(val) { }};\n\n\nconst 成员一旦定义，必须立即初始化，且只能在初始化列表中完成，不能在构造函数体内赋值。\n\n\n初始化引用成员\nclass MyClass {    int&amp; refMember;public:    MyClass(int&amp; ref) : refMember(ref) { }};\n\n\n引用成员（如 int&amp; ref）必须在初始化时绑定对象，不能在构造函数体内赋值，因此也必须使用初始化列表。\n\n\n\n继承: 基于已有的类来设计新的类，新的类的对象可以被当作已有类的对象.\n相比于 composition  的 has-a关系, 继承是 is-a的关系.\n同义词:\n\n父类、超类、基类\n派生类、子类\n\n控制基类成员在派生类中的可见性：\n\npublic：基类的 public 成员在派生类中仍然是 public，protected 成员仍然是 protected。\nprotected：基类的 public 和 protected成员在派生类中都变为 protected。\nprivate：基类的 public 和 protected 成员在派生类中都变为 private。\n\n\n[!NOTE]\n此时, 仍旧可以通过子类的方法来访问基类的属性或者方法, 但是无法通过子类直接访问基类~!\ne.g.\n#include &lt;iostream&gt;class Base{public:    void baseFunction()    {        std::cout &lt;&lt; \"Base function called.\" &lt;&lt; std::endl;    }};class Derived : private Base{public:    void derivedFunction()    {        baseFunction(); // 在子类内部可以访问基类的成员函数    }};int main(){    Derived d;    d.baseFunction();    // 错误：无法从子类外部访问基类的成员函数    d.derivedFunction(); // 可以调用子类的函数，该函数内部调用了基类的函数    return 0;}\nclint class 表示这个类要使用另一个类(中的public).\n子类的对象也可以认为是父类的对象。子类不能访问父类的私有变量，但私有变量存在于这个类中\n当调用构造函数时，我们不能调用父类的私有变量，只能用初始化列表的方式调用父类的构造函数。\n赋值的运算符不会被继承:\n赋值运算符赋值运算符是这样形式的方法:\nPoint &amp;operator=(const Point &amp;other){    cout &lt;&lt; \"Point::operator= 被调用\" &lt;&lt; endl;    if (this != &amp;other)    {        x = other.x;        y = other.y;    }    return *this;}\n\n当我们如此赋值的时候就会发生上述的调用:\nPoint p1(1,2);Point p2(3,4);p1 = p2;\n\n可见, 赋值运算符通过引用快速地将右值中的属性赋值给左侧的目标.\n但是父类的赋值运算符只会确保自身的属性能够被赋值, 无法确保子类自身的属性可以被正确设置. 因此, 为了安全性, CPP不允许子类自动继承父类的赋值运算符.\n\n[!NOTE]\n然而, 编译器可能为子类自动生成一个赋值运算符.\ne.g.\nclass Point{public:    int x, y;    Point(int x = 0, int y = 0) : x(x), y(y) {}    // 自定义赋值运算符    Point &amp;operator=(const Point &amp;other)    {        cout &lt;&lt; \"Point::operator= 被调用\" &lt;&lt; endl;        if (this != &amp;other)        {            x = other.x;            y = other.y;        }        return *this;    }};class ColoredPoint : public Point{public:    string color;    ColoredPoint(int x = 0, int y = 0, string color = \"white\") : Point(x, y), color(color) {}    void print() const    {        cout &lt;&lt; \"x:\" &lt;&lt; x &lt;&lt; \", y:\" &lt;&lt; y &lt;&lt; \", color:\" &lt;&lt; color &lt;&lt; endl;    }};int main(){    ColoredPoint cp1(1, 2, \"red\");    cp1.print();    ColoredPoint cp2(3, 4, \"blue\");    cp2.print();    cp1 = cp2;    cp1.print();}\n\n输出结果:\nx:1, y:2, color:redx:3, y:4, color:bluePoint::operator= 被调用x:3, y:4, color:blue\n\n可见, 父类的赋值运算符也被自动地调用了, 这是因为编译器为子类自动生成了一份.\n\n\n父类的构造是在子类的构造之前。\nusing声明将基类的函数派生使用必须使用 using &lt;parentClass&gt;:: func的方式, 无法忽略 using.\n#include &lt;iostream&gt;using namespace std;class Base{  public:   \tvoid f(double){      cout &lt;&lt; \"double\\n\" &lt;&lt; endl;    }};class Derived : Base{  public:  \tusing Base::f; // 将基类中的私有函数本地使用  \tvoid f(int){      cout &lt;&lt; \"int\\n\"&lt;&lt;endl;    }};int main() {    Derived d;    d.f(4);    d.f(4.5);}\n\nOutput:\nint double\n\n\n\n默认参数值无法通过重载传递在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免多重继承时参数值产生冲突或二义性。默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.\n\n如果你在派生类中重新声明或重载了基类的函数，那么你不能获得默认参数值，必须通过多个重载模拟默认参数功能.\n\nclass A {public:    void f(int a = 3, double b = 2.0);};class B : public A {public:    using A::f;         // ✅ 此时默认参数仍可见    void f(int a);      // ❌ 重载后，这个版本没有默认参数};\n\n\n\n\n但是使用 using声明的父类函数可以获得默认参数值.\n\ne.g.\n#include &lt;iostream&gt;using namespace std;class A{public:    void f(int a = 3, double b = 2.0)    {        std::cout &lt;&lt; \"A::f(\" &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \")\" &lt;&lt; std::endl;    }};class B : public A{public:    using A::f; // 继承 A::f 到 B 中};int main(){    B b;    b.f();        // ✅ 是否等价于 f(3, 2.0)？    b.f(10);      // ✅ 是否等价于 f(10, 2.0)？    b.f(10, 5.5); // ✅ 正常调用}\n\n\n输出:\nA::f(3, 2)A::f(10, 2)A::f(10, 5.5)\n\n解决重写函数的重载问题子类重新定义 (override重写) 了父类的某个函数，就会把父类中对应 overloaded 的函数覆盖:\n#include &lt;iostream&gt;class Base{public:    // 基类中的重载函数    void display(int x)    {        std::cout &lt;&lt; \"Base display(int): \" &lt;&lt; x &lt;&lt; std::endl;    }    void display(double x)    {        std::cout &lt;&lt; \"Base display(double): \" &lt;&lt; x &lt;&lt; std::endl;    }};class Derived : public Base{public:    // 子类重新定义了基类的 display(int)    void display(int x)    {        std::cout &lt;&lt; \"Derived display(int): \" &lt;&lt; x &lt;&lt; std::endl;    }    using Base::display;};int main(){    Derived d;    d.display(5); // 调用 Derived 的 display(int)    d.Base::display(5.5); // 或者d.display(5.5);    return 0;}\n\n\n\n注意, CPP中的浮点数可以隐式转换为整型.\n\n当将一个浮点数赋值给一个整型变量时，编译器会执行隐式转换，将浮点数的值转换为整型。这种转换通常涉及截断（truncation），即去掉小数部分，只保留整数部分.\n\n\n可以通过 using 声明重新引入基类中的重载函数: \nusing Base::display;\n\n\n\nPolymorphism补充\n成员函数（无论是虚函数还是非虚函数）本身不占用类对象的内存空间，因为它们的代码存储在程序的代码段中。只有成员变量和虚表指针（如果有虚函数）会占用对象的内存空间:\nclass A {    int i;    void f();};\n\n此时的 sizeof(A)为4字节.\n\n虚函数指针的大小一般是 8字节. 如果结构体内部存在虚函数指针, 就需要对齐为8字节的倍数.\n\n因为子类的构造在父类的构造之后, 也就是每一个子类对象的前部分都是父类对象. 因此, 我们可以将一个子类对象的指针赋值给父类对象, 只要忽视后续数据结构即可.\n\n多态变量: 指向子类对象的基类指针/引用.\n\n如果类内不存在任何成员变量, 它的对象依旧占用 1 个字节的空间.\n\n如果一个类将来可能具有子类, 就让其析构函数设置为 virtual. —— 任何的类都应该设置它的析构为 virtual.\nclass B: public A{};A* p = new B();delete p;\n\n如果 A 的析构函数不是virtual的, 那么编译器只会调用A的析构函数.\n\n如果父类的构造函数中调用了 virtual 的函数, 那么实际上还是调用自己的函数(静态绑定)\n\n这是因为, 创建一个派生类的对象时, 首先调用父类的构造函数, 然后执行派生类的构造函数;\n此时, 子类的成员还没有初始化, 父类无法调用其重写版本, 也就无法实现多态.\n\n\n\n[!NOTE]\n深刻理解什么叫做多态! 也就是子类对象的引用或者指针赋值给了父类! 此后调用这个对象时, 虚函数是动态绑定到子类的!\nA &amp;ra = b;    // ra是A类型的引用，但指向B类型的对象ra.f();       // 虽然ra是A类型的引用，但f()会调用B::f()\n\n如果B是A的子类:\nA *p1 = new B(3);    // p1是A类型的指针，但指向B类型的对象\n\n实际上,  p1指向的对象是B类的对象\n\n\n当一个被重写的函数在 Derived::func() 中通过 Base::func() 调用其基类版本时，会发生什么？\n\n可以正常调用, 这也正是重写存在的意义——扩充原来的功能, 同时保留.\n\n多态与返回对象类型:\n\n允许重载返回自身的 指针 与 引用, 但是不支持直接返回自身的类型:\n\ni.e. \nClass Expr｛public:  virtual Expr* newExpr （）；  virtual Expr&amp; clone （）；  virtual Expr Expr self（）；｝；class BinaryExpr ： public Expr ｛public：  virtual BinaryExpr* newExpr （）； //Ok  virtual BinaryExpr&amp; clone （）； // Ok  virtual BinaryExpr self（）；// Error！  ｝；\n\n原因: 指针和引用的大小固定, 编译时刻可以确定调用时候所需的空间, 如果按照类型返回, 由于多态的动态绑定是运行时决定调用对应的方法, 所以编译的时候caller不知道要在栈上预留多少的空间.\n\n\n\n\n\n\nPolymorphism\nvirtual functions and override\nabstract functions and classes\n\n\nMultiple Inheritance\n\n由于子类具有父类的所有属性, 因此我们可以将一个子类对象看作父类的对象, 并进行对应的操作.\n将子类对象看作父类对象的操作, 叫做 upcast. 具体是说, 将子类的指针或者引用赋值给基类的对象.\n现在的问题是, 如果采取传统的继承+重写的方式, 我们在子类内部采取重写父类方法, 可能导致 静态绑定 static binding:\n#include &lt;iostream&gt;using namespace std;class Animal{public:    void speak()    {        cout &lt;&lt; \"Animal speaks\" &lt;&lt; endl;    }};class Dog : public Animal{public:    void speak()    {        cout &lt;&lt; \"Dog barks\" &lt;&lt; endl;    }};int main(){    Animal *animal = new Dog(); // 注意：父类指针指向子类对象    animal-&gt;speak();            // 会调用哪个？    delete animal;    return 0;}\n\n\n输出:\nAnimal speaks\n\n为了解决上述的问题, 我们引入 虚函数 的概念.\n虚函数虚函数可以实现 运行时多态. 所谓多态, 就是静态+ 动态的绑定.\n通过在父类的函数前加上 virtual的声明, 我们将其定义为虚函数\ne.g.\n#include &lt;iostream&gt;using namespace std;class Animal {public:    virtual void speak() {        cout &lt;&lt; \"Animal speaks\" &lt;&lt; endl;    }};class Dog : public Animal {public:    void speak() override {        cout &lt;&lt; \"Dog barks\" &lt;&lt; endl;    }};int main() {    Animal* animal = new Dog();     animal-&gt;speak(); // 这次会调用哪个？    delete animal;    return 0;}\n\n\n输出:\nDog barks\n\n\n\noverride声明明确这个函数是重写父类的虚函数, 可以让编译器检查是否存在错误.\n但是上述的关键字也不是必须的.\n\n\n纯虚函数~指的是需要强制派生类去实现的函数:\nvirtual 返回类型 函数名(...) = 0;\n\n\n\n虚函数表\n定义: 虚函数表（virtual table）是 C++ 为了实现运行时多态而采用的一种底层技术手段;\n本质:\nvtable是一个函数指针数组;\n每个类都有自己的vtable\n对象中存在一个隐藏的指针 vptr, 指向该类的vtable\n\n\n\n内存示意图假设有如下结构:\nclass Base {public:    int a;    virtual void func();};\n\n内存布局的伪结构如下:\n+-------------------------+| vptr  → 指向vtable     |  ←隐藏成员+-------------------------+| a : int                |  ←显式成员+-------------------------+vtable (Base):[ func 的地址 ]vtable (Derived):[ 重写的 func 的地址 ]\n\n\n\n拓展说明\nvtable是类级别的, 所有该类的对象共享一个vtable;\nvptr是对象级别的, 隐含于各个对象当中.\n如果类没有虚函数, 就不存在上述的~\n\n抽象类如果一个类中包含至少一个纯虚函数, 那么这个类就是一个抽象类.\n抽象类无法被实例化, 只能用来作为基类.\n使用抽象类定义接口用图形绘制的例子来说明抽象类和纯虚函数的使用:\n#include &lt;iostream&gt;using namespace std;// 抽象类class Shape {public:    // 纯虚函数，子类必须实现    virtual void draw() = 0;};// 派生类：Circleclass Circle : public Shape {public:    void draw() override {        cout &lt;&lt; \"Drawing Circle\" &lt;&lt; endl;    }};// 派生类：Rectangleclass Rectangle : public Shape {public:    void draw() override {        cout &lt;&lt; \"Drawing Rectangle\" &lt;&lt; endl;    }};// 渲染函数：面向抽象类编程void render(Shape* shape) {    shape-&gt;draw();}int main() {    Circle c;    Rectangle r;    render(&amp;c); // Drawing Circle    render(&amp;r); // Drawing Rectangle    return 0;}\n\n\n\n继承链一个抽象类可以有多个纯虚函数, 此时继承的子类可能没有完全实现. \n子类的子类, 也就是在继承链上完成了所有纯虚函数的定义的 最末一级的派生类, 才可以被实例化.\nclass Animal {public:    virtual void speak() = 0;    virtual void run() = 0;        void breathe() {        cout &lt;&lt; \"Breathing...\" &lt;&lt; endl;    }};\n\n\n\n虚析构函数virtual destructor: 虚析构函数\n同样的, 虚析构函数的作用体现在 upcast, 也就是将子类的指针或引用转换为父类的指针或引用的过程. 此时, 如果父类的析构函数不是虚函数, 就会让向上转型之后的对象在析构时调用父类的析构函数.\n#include &lt;iostream&gt;using namespace std;class Base{public:    ~Base()    {        cout &lt;&lt; \"Base Destructor\" &lt;&lt; endl;    }};class Derived : public Base{public:    ~Derived()    {        cout &lt;&lt; \"Derived Destructor\" &lt;&lt; endl;    }};int main(){    Base *obj = new Derived();    delete obj; // 注意这里！    return 0;}\n\n此时会输出 :  Base Destructor , 也就是调用了父类的析构函数.\n这是十分危险的, 特别是我们需要确保子类的所有资源都被安全地释放.\n因此, 我们可以将父类的析构函数也设置为虚函数:\nclass Base {public:    virtual ~Base() {        cout &lt;&lt; \"Base Destructor\" &lt;&lt; endl;    }};class Derived : public Base {public:    ~Derived() {        cout &lt;&lt; \"Derived Destructor\" &lt;&lt; endl;    }};\n\n此时的输出:\nDerived Destructor  Base Destructor\n\n\n先后调用子类和父类的析构函数.\n\n接口类\n也被称为 协议类. 其实就像 swift的协议一样, 强制要求继承的子类定义某些函数实现.\n\n\n含义:\n只定义接口, 不提供实现的抽象类\n所有的成员函数都是纯虚函数;\n一般不包含任何数据成员.\n\n\n\ne.g.\nclass Printable {public:    virtual void print() = 0;    virtual ~Printable() = default; // 记得虚析构函数};class Document : public Printable {public:    void print() override {        cout &lt;&lt; \"Printing Document\" &lt;&lt; endl;    }};\n\n\n\n多重继承多重继承 multiple inheritance 指的是一个类继承自多个基类.\ne.g.\nclass A {public:    void sayA() { cout &lt;&lt; \"I am A\" &lt;&lt; endl; }};class B {public:    void sayB() { cout &lt;&lt; \"I am B\" &lt;&lt; endl; }};class C : public A, public B {    // 继承了 A 和 B 的成员};\n\n可以将多个类的功能整合到一个类中:\nC c;c.sayA(); // OKc.sayB(); // OK\n\n\n\n菱形继承多重继承中的特例:\nclass A {public:    int value;};class B : public A {};class C : public A {};class D : public B, public C {};\n\n继承结构看上去就像菱形:\n   A /   \\B     C \\   /   D\n\n如果我们直接使用D类:\nD d;d.value = 10; // ❌ 编译错误：'value' is ambiguous\n\n这是因为D继承自B和C, 而后者又各自具有自己的A子对象. 导致了二义性的问题.\n\n[!NOTE]\n注意此处的二义性的问题, 来自于在D类对象中直接访问A类对象的成员变量!  什么时候产生二义性? 就是判断此时是否存在多个相同名称的变量.\n\n虚继承C++ 提供了一个机制：虚继承（virtual inheritance），来解决上述问题:\nclass B : virtual public A{};class C : virtual public B{};class D :  public B, public C{}\n\n此时, D中只有一个共享的A子对象.\n#include &lt;iostream&gt;using namespace std;class A{public:    int value;    void ptr()    {        cout &lt;&lt; \"value: \" &lt;&lt; value &lt;&lt; endl;    }};class B : virtual public A {};class C : virtual public A {};class D : public B, public C {};int main(){    D d;    d.value = 10; // ✅ OK，只有一个 A，二义性消除    d.ptr();}\n\n此时, B,C不再具有自己的A.\n\n[!NOTE]\n由于虚继承带来的是“共享”的基类对象，所以：\n\n虚基类的构造 必须由最底层派生类负责\n派生类的构造函数中要显式初始化虚基类\n\n\nCopy and Move补充\nvptr只会初始化一次, 然后保持不变. 发生在构造函数的第一步.\n\n循环内部执行构造和析构时, 作用的地址是同一块. 此时将对象的地址传入到vector of * 时, 得到的是相同的地址;\n\n为了避免上述的情况, 我们在循环内部的构造, 需要为对象直接 new 一个新的空间.\n\n\nstd::move的作用就是告诉编译器: 这个类型是右值引用, 需要使用移动语义.\n\n\nC++中的拷贝构造与移动语义拷贝构造函数基础拷贝构造函数是创建新对象的一种方式，它从现有对象复制数据来初始化新对象。\n\n拷贝构造函数的签名：T::T(const T&amp;)\n如果不提供拷贝构造函数，C++会自动生成一个默认的拷贝构造函数\n默认拷贝构造函数执行的是成员级别的拷贝（memberwise copy），而非位级别的拷贝（bitwise copy）\n对于基本类型成员，直接复制值\n对于对象类型成员，调用其拷贝构造函数\n对于指针类型成员，只复制指针值（浅拷贝），导致两个对象共享同一块内存\n\n\n\n拷贝构造函数的调用时机拷贝构造函数在以下情况下会被调用：\n\n按值传递参数时：当对象作为参数按值传递给函数时\nvoid func(MyClass obj); // 调用时会触发拷贝构造\n\n对象初始化时：\nMyClass a;MyClass b = a;    // 初始化，调用拷贝构造函数MyClass c(a);     // 初始化，调用拷贝构造函数\n\n函数返回对象时：\nMyClass func() {    MyClass obj;    return obj;   // 可能触发拷贝构造（取决于编译器优化）}\n\n拷贝构造函数的最佳实践\n显式定义拷贝构造函数，不要依赖默认版本\n如果类不需要被复制，可以声明私有的拷贝构造函数（不需要定义）\n如果类包含指针成员，必须实现深拷贝的拷贝构造函数\n\n深拷贝构造函数将拷贝的值另外寻找新的内存空间, 而不是指向同一处地址.\n\n如果没有显式定义深拷贝构造函数, 观察下面的代码:\n\nStringHolder original(\"Hello World\");{    StringHolder copy = original; // 调用拷贝构造函数    std::cout &lt;&lt; \"copy包含: \" &lt;&lt; copy.getString() &lt;&lt; std::endl;    // 修改copy，如果是浅拷贝，也会影响original    copy.setString(\"Modified\");    std::cout &lt;&lt; \"修改后，copy包含: \" &lt;&lt; copy.getString() &lt;&lt; std::endl;    std::cout &lt;&lt; \"修改后，original包含: \" &lt;&lt; original.getString() &lt;&lt; std::endl;    // copy在此作用域结束时被销毁}\n\n\n\noriginal的层级在  copy 的外面;\n\n在代码块的内部, 通过浅拷贝构造, 两者的数据共享一个内存空间;\n\n二者先后析构, 导致 double free的问题!\n02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: Double free of object 0x11f6060c002_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: *** set a breakpoint in malloc_error_break to debug\n\n\n由此, 我们需要如此定义:\nclass StringHolder{private:    char *data;public:    // 构造函数    StringHolder(const char *str)    {        if (str)        {            data = new char[strlen(str) + 1];            strcpy(data, str);            std::cout &lt;&lt; \"构造函数: 为\\\"\" &lt;&lt; data &lt;&lt; \"\\\"分配内存\" &lt;&lt; std::endl;        }        else        {            data = nullptr;            std::cout &lt;&lt; \"构造函数: 创建空字符串\" &lt;&lt; std::endl;        }    }    // 自定义拷贝构造函数（深拷贝）    // 如果复制掉这部分的自定义, 将会调用默认的浅拷贝构造函数, 导致问题:浅拷贝的指针两次释放内存    StringHolder(const StringHolder &amp;other)    {        if (other.data)        {            data = new char[strlen(other.data) + 1];            strcpy(data, other.data);            std::cout &lt;&lt; \"深拷贝构造函数: 为\\\"\" &lt;&lt; data &lt;&lt; \"\\\"分配新内存\" &lt;&lt; std::endl;        }        else        {            data = nullptr;            std::cout &lt;&lt; \"深拷贝构造函数: 复制空字符串\" &lt;&lt; std::endl;        }    }    // 析构函数    ~StringHolder()    {        std::cout &lt;&lt; \"析构函数: 释放\\\"\" &lt;&lt; (data ? data : \"nullptr\") &lt;&lt; \"\\\"的内存\" &lt;&lt; std::endl;        delete[] data;    }};\n\n这样就可以避免上面的问题.\n函数参数和返回值的选择\n传入参数：\n\n按值传递：void func(Student s) - 创建新对象，适用于需要存储对象的情况\n如果对象内部的属性存在指针类型的属性, 为了避免浅拷贝, 就需要自定义一个深拷贝构造函数.\n\n\n常量引用：void func(const Student&amp; s) - 不创建新对象，适用于只读取值的情况\n指针/引用：void func(Student* s) 或 void func(Student&amp; s) - 适用于需要修改对象的情况\n\n\n返回值：\n\n按值返回：Student func() - 返回新创建的对象\n返回指针：Student* func() - 注意内存管理问题\n返回引用：Student&amp; func() - 注意生命周期问题\n\n\n\n右值引用与移动语义左值与右值\n左值：可以出现在赋值号左边的表达式\n变量名、引用\n解引用操作符（*）和下标操作符（[]）的结果\n\n\n右值：只能出现在赋值号右边的表达式\n字面量\n表达式结果\n函数返回的临时对象\n\n\n\n右值引用\n使用 &amp;&amp; 声明\n可以绑定到右值，延长其生命周期\n右值引用变量本身是左值\n可以使用 std::move() 将左值转换为右值引用\n\nint x = 10;int&amp;&amp; rx = x * 2;  // 绑定右值rx = 100;          // rx本身是左值，可以被赋值\n\n\n两种可以同时输入左值和右值引用作为参数的方法:\n\n重载\n// 重载函数，分别处理左值和右值void process(int&amp; x) {    std::cout &lt;&lt; \"重载函数 - 处理左值: \" &lt;&lt; x &lt;&lt; std::endl;}void process(int&amp;&amp; x) {    std::cout &lt;&lt; \"重载函数 - 处理右值: \" &lt;&lt; x &lt;&lt; std::endl;}\n\nconst int&amp; x \n// 接受const左值引用的函数（可以接受左值和右值）void processAny(const int&amp; x) {    std::cout &lt;&lt; \"处理任意值: \" &lt;&lt; x &lt;&lt; std::endl;}\n\n\n\n移动构造函数\n签名：T::T(T&amp;&amp; other), 也就是将右值引用作为参数的构造函数\n用于”窃取”即将销毁的对象的资源，避免不必要的深拷贝\n通常将源对象的指针成员置为nullptr，防止资源被错误释放\n\nMyClass(MyClass&amp;&amp; other) :     ptr{other.ptr} {      other.data = 0      other.ptr = nullptr;  // 防止源对象析构时释放内存}\n\n\n与浅拷贝类似, 但是需要在内部将源对象的指针成员 设置为 nullptr , 其他成员设置为有效但是为空的状态\n\n 标准库容器（如 std::vector）在进行元素移动时会优先选择不会抛异常的移动构造函数，否则会退而求其次选择拷贝构造函数（更慢）。\ne.g.\nstd::vector&lt;DynamicArray&gt; vec;vec.push_back(DynamicArray(5));\n\n\n在这个 push_back 中，如果 DynamicArray 的移动构造函数被标记为 noexcept，那么 vector 会使用移动构造（高效）。\n\n初始化方式C++11提供了多种初始化对象的方式：\n\n小括号初始化：MyClass obj(arg1, arg2);\n\n等号初始化：MyClass obj = value;\n\n大括号初始化（统一初始化）：MyClass obj{arg1, arg2};\n\n列表初始化：\nint arr[] = {1, 2, 3};MyClass* ptr = new MyClass{arg1, arg2};\n\n基本类型的初始化// 基本类型的初始化方式int a = 10;             // 等号初始化int b(20);              // 小括号初始化int c{30};              // 大括号初始化（C++11）int d = {40};           // 等号+大括号初始化（C++11）int arr1[] = {1, 2, 3}; // 数组初始化int arr2[]{4, 5, 6};    // 数组大括号初始化（C++11）\n\n\n\n对象的初始化// 对象的初始化方式Person p1(\"张三\", 25);          // 小括号初始化Person p2 = Person(\"李四\", 30); // 等号+临时对象初始化Person p3{\"王五\", 35};          // 大括号初始化（C++11）Person p4 = {\"赵六\", 40};       // 等号+大括号初始化（C++11）\n\n\n\n\n动态分配对象的初始化\n// 动态分配对象的初始化方式Person *pp1 = new Person(\"动态张三\", 25); // 传统newPerson *pp2 = new Person{\"动态李四\", 30}; // 大括号初始化（C++11）\n\n深拷贝与浅拷贝\n浅拷贝：默认拷贝构造函数执行的是浅拷贝，只复制指针值，不复制指针指向的内容\n深拷贝：自定义拷贝构造函数可以实现深拷贝，为指针成员分配新内存并复制内容\n\n何时使用移动语义\n类包含动态分配的资源（如指针成员）\n对象需要在函数间传递\n需要避免不必要的深拷贝操作\n使用容器时（如std::vector、std::string等）\nmove会将一个左值变成右值引用, 从而允许调用移动构造函数!\n使用 move 时, 如果存在对应的移动构造函数, 就会优先调用;\n数组的 push_back也是如此, 优先调用移动构造函数\n但是我们可以使用 emplace来继续优化上述的效率问题——直接将对象存储到数组的末端.\n\n\n\n\n\n总结\n拷贝构造函数用于创建对象的副本，深拷贝需要自定义实现\n移动语义通过右值引用实现资源的高效转移，避免不必要的拷贝, 同时规避了浅拷贝导致的 double free 的问题.\n根据需要选择合适的参数传递和返回值方式\n使用std::move()可以将左值转换为右值引用，触发移动语义\n\n\nOverloaded Operators补充自定义类型的方向转换:  T ==&gt; C\n\n当下面情况存在一种时, 可以发生上述的转换:\n\nC存在以 T 作为输入参数的构造函数;\n\nT 存在 operator C(){ }的成员函数.e.g.\nclass Rational {public:    operator double() const {  // Rational到double的转换        return numerator_ / (double)denominator_;    }};Rational r(1, 3);double d = r;  // 隐式转换：r =&gt; double\n\n\n不同同时存在两者的转换(编译器无法知道采取什么方式)\n\n\n题目:\n\n并非所有运算符都可以用三种方式重载。例如赋值运算符 =、下标运算符 []、函数调用运算符 ()、成员访问运算符 -&gt; 只能作为成员函数重载;\n\n流提取符 &gt;&gt; 和插入符 &lt;&lt; 可以被重载\n\n运算符 + 返回的类型 不一定 要与参数类型一致;\n\n对于友元函数, 在声明处加上 friend标识, 但是在定义处是没有这个标识的. \n\n\n[!NOTE]\n无法被重载的运算符:\n\n条件运算符: ?:\n成员指针访问运算符: .*\n\n\nnew是可以重载的!\n\n运算符的分类:\n\n成员运算符: 在类内部以成员函数形式重载的运算符 ==&gt; 具有隐式的 this;\n\n友元运算符: 定义在类外部（在类内部用 friend 声明），没有 this 指针.\n因此, 一个重载函数只有一个参数时 ==&gt; 二员成员运算符 / 一元友元运算符.\n\n\n\n隐式转换的尝试是从左到右的:\n\n1+a会尝试将类的对象 a 尝试转换为int类型.\n\n\n注意类型:\n// 前缀++const Integer&amp; Integer::operator++() {    *this += 1;  // 先增加    return *this;  // 再返回}// 后缀++（参数int未使用，仅用于区分）const Integer Integer::operator++(int) {    Integer old(*this);  // 先保存    ++(*this);  // 再增加    return old;  // 返回旧值}\n\n前缀++的返回是 &amp; 类型, 因为比较节省空间和时间. 后缀++的返回是值.\n\n[] 的返回必须是 &amp; 类型, 这样可以作为左值赋值.\n\n\n\n返回类型设计的总体原则：\n\n如果运算符需要作为左值（可以出现在赋值左侧），返回非常量引用。\n\n否则, 声明为const类型, 避免成为左值.\n\n\n如果运算符创建新对象，返回值（通常是常量值）。\n\n如果运算符返回布尔结果，直接返回 bool 类型。\n\n如果需要支持链式操作，返回引用。\n\n\n全局和成员函数的设计思路:\n\n一元运算符（如 -a）应该用成员函数，因为只操作一个对象\n赋值相关运算符（=, +=, [], -&gt;()与 -&gt;* 等）必须是成员函数，因为它们需要修改对象状态\n对于二元运算符（如 +, -, *, /)建议使用全局函数，因为：\n支持操作数的对称转换\n更好地支持与其他类型的互操作\n保持了运算符的自然语义（如 3 * x 和 x * 3 应该都能工作）\n\n\n\nC++运算符重载基础运算符重载是C++的一项强大特性，它允许用户定义的类型像内置类型一样使用各种运算符。本质上，运算符重载是函数调用的另一种形式。\n可重载与不可重载的运算符C++允许重载大多数运算符，但以下运算符不能被重载：\n\n. (成员访问运算符)\n.* (成员指针访问运算符)\n:: (作用域解析运算符)\n?: (条件运算符)\nsizeof (获取类型大小)\ntypeid (获取类型信息)\n类型转换运算符 (static_cast, dynamic_cast, const_cast, reinterpret_cast)\n\n运算符重载的限制\n只能重载已存在的运算符\n\n不能创建新的运算符（如Python中的**）\n可以改变运算符的语义（如重载+实现减法），但不推荐\n\n\n运算符必须在类或枚举类型上重载\n\n至少有一个操作数必须是用户定义类型\n\n\n必须保持操作数数量\n\n如二元运算符/重载后仍必须是二元的\n\n\n必须保持优先级和结合律\n\n运算符的优先级和结合律是固定的，不能被改变\n\n\n\n运算符重载的实现方式运算符重载本质上是一个以operator关键字为前缀，后跟运算符的特殊函数。\n成员函数方式作为类的成员函数实现运算符重载时：\n\n第一个操作数（左操作数）隐式为this指针\n不对接收者（左操作数）执行类型转换\n\nclass A {public:    A(int ii) : i(ii) {}    int get() { return i; }        // 重载+运算符，返回新对象    const A operator+(const A&amp; that) const {        A c(this-&gt;i + that.i);        return c;    }private:    int i;};\n\n使用成员函数重载时，左操作数必须是该类的对象：\n\na + b 可行（a是A类对象）\na + 9 可行（9会被隐式转换为A类对象）\n9 + a 不可行（9不是A类对象）\n\n\n[!NOTE]\n隐式转换: 编译器查找是否存在从给出参数作为构造函数的输入, 从而创建一个指定对象的方式:\ne.g.\nInteger h = a + 7; // 7被隐式转换为Integer\n\n上述发生的前提条件是 类 Integer 存在对应的构造函数:\nInteger(int val = 0) : value(val)\n全局函数方式作为全局函数实现运算符重载时：\n\n所有操作数都是显式参数\n开发者不需要特殊访问类的权限\n可能需要声明为友元函数以访问私有成员\n\nclass Integer{private:  int value;  friend const Integer operator*(const Integer &amp;left, const Integer&amp; right);};// 可以直接在全局函数中访问私有成员const Integer operator*(const Integer &amp;left, const Integer &amp;right){    std::cout &lt;&lt; \"调用全局函数*运算符: \" &lt;&lt; left.value &lt;&lt; \" * \" &lt;&lt; right.value &lt;&lt; std::endl;    return Integer(left.value * right.value);}\n\n\n\n当然, 全局函数实现的运算符重载, 可以通过调用类的public中的函数接口, 来间接访问内部的私有成员变量:\nclass Integer{  public:   int getValue(){    return value;  }};// 通过public接口访问内部的私有成员变量.const Integer operator/(const Integer &amp;left, const Integer &amp;right){    std::cout &lt;&lt; \"调用全局函数/运算符: \" &lt;&lt; left.getValue() &lt;&lt; \" / \" &lt;&lt; right.getValue() &lt;&lt; std::endl;    if (right.getValue() == 0)    {        std::cerr &lt;&lt; \"错误: 除数不能为零\" &lt;&lt; std::endl;        return Integer(0);    }    return Integer(left.getValue() / right.getValue());}\n\n\n\n使用全局函数重载时，可以处理左操作数不是该类对象的情况：\n\n9 - b 可行（9会被隐式转换为A类对象）\n因为两个操作数都是普通参数，地位平等, 体现了运算符的对称性\n\n成员函数vs全局函数的选择\n一元运算符应该作为成员函数\n赋值运算符（=, (), [], -&gt;, -&gt;）必须是成员函数\n其他二元运算符最好作为非成员函数（全局函数）\n\n参数传递与返回类型参数传递\n对于只读参数，使用const引用传递（除了内置类型）\n对于不修改对象的成员函数，声明为const\n对于全局函数，如果左操作数会被修改，使用引用传递\n\n返回类型根据运算符的预期含义选择返回类型：\n\n算术运算符（+, -, *, /, %, ^, &amp;, |, ~）\nconst T operator X(const T&amp; l, const T&amp; r);\n\n\n返回新对象，不应返回引用（除非返回成员引用）\n返回const对象防止(a+b) = c这样的操作\n\n\n逻辑运算符（!, &amp;&amp;, ||, &lt;, &lt;=, ==, &gt;=, &gt;）\nbool operator X(const T&amp; l, const T&amp; r);\n\n\n返回布尔值\n\n\n下标运算符（[]）\nE&amp; T::operator[](int index);\n\n\n返回左值（非const引用），允许a[i] = value操作\n不能返回新对象，否则赋值操作无效\n\n\n\n特殊运算符重载自增自减运算符C++区分前缀和后缀自增自减运算符：\n// 前缀++const Integer&amp; Integer::operator++() {    *this += 1;  // 先增加    return *this;  // 再返回}// 后缀++（参数int未使用，仅用于区分）const Integer Integer::operator++(int) {    Integer old(*this);  // 先保存    ++(*this);  // 再增加    return old;  // 返回旧值}\n\n调用方式：\n\n++x 调用 x.operator++()\n\n返回的是引用, 从而支持链式操作 如:\nCounter g = ++(++f); // 可以，因为前缀返回引用\n\n\nx++ 调用 x.operator++(0)\n\n返回的是临时的对象, 也就是旧值的副本. 声明const避免了后缀的链式调用\nCounter h = (f++)++; // 不可以，因为后缀返回const值\n\n之所以要防止上述的后缀链式调用, 是因为 对f++继续自增将会导致语义的混乱.\n\n\n\n\n下标运算符e.g.\n// 下标运算符（返回左值引用，允许修改）int&amp; operator[](int index) {    if (index &lt; 0 || index &gt;= size) {        std::cerr &lt;&lt; \"错误: 下标越界 [\" &lt;&lt; index &lt;&lt; \"]\" &lt;&lt; std::endl;        // 返回第一个元素作为应急措施（实际应用中应抛出异常）        return data[0];    }    return data[index];}// 下标运算符的const版本（返回值，不允许修改）int operator[](int index) const {    if (index &lt; 0 || index &gt;= size) {        std::cerr &lt;&lt; \"错误: 下标越界 [\" &lt;&lt; index &lt;&lt; \"]\" &lt;&lt; std::endl;        // 返回0作为应急措施（实际应用中应抛出异常）        return 0;    }    return data[index];}\n\n\n\n\n\n关系运算符关系运算符通常成对实现，可以相互利用：\nbool Integer::operator==(const Integer&amp; rhs) const {    return i == rhs.i;}bool Integer::operator!=(const Integer&amp; rhs) const {    return !(*this == rhs);  // 利用==运算符}bool Integer::operator&lt;(const Integer&amp; rhs) const {    return i &lt; rhs.i;}bool Integer::operator&gt;(const Integer&amp; rhs) const {    return rhs &lt; *this;  // 利用&lt;运算符}bool Integer::operator&lt;=(const Integer&amp; rhs) const {    return !(rhs &lt; *this);  // 利用&lt;运算符}bool Integer::operator&gt;=(const Integer&amp; rhs) const {    return !(*this &lt; rhs);  // 利用&lt;运算符}\n\n流运算符输入输出流运算符通常实现为全局函数：\n// 输出流运算符ostream&amp; operator&lt;&lt;(ostream&amp; os, const A&amp; a) {    os &lt;&lt; a.get();    return os;  // 返回流对象以支持链式操作}// 输入流运算符istream&amp; operator&gt;&gt;(istream&amp; is, A&amp; a) {    string line;    cin &gt;&gt; line;    // 读取a的数据    return is;  // 返回流对象以支持链式操作}\n\n注意：\n\n输出流运算符的第一个参数不能是const，因为输出会修改流\n输入流运算符的第二个参数不能是const，因为需要修改对象\n通常需要声明为友元以访问私有成员\n\n自定义流操纵符可以定义自己的流操纵符：\nostream&amp; tab(ostream&amp; out) {    return out &lt;&lt; '\\t';}// 使用：cout &lt;&lt; \"Hello\" &lt;&lt; tab &lt;&lt; \"World!\" &lt;&lt; endl;\n\n\n\n\n\n赋值运算符与类型转换赋值运算符赋值运算符有几个重要特点：\n\n必须是成员函数\n如果不提供，编译器会自动生成（行为类似默认拷贝构造函数）\n需要检查自赋值情况\n确保为所有数据成员赋值\n返回*this的引用\n\nA&amp; A::operator=(const A&amp; rhs) {    if (this != &amp;rhs) {  // 检查自赋值        // 释放当前资源        delete[] data;                // 分配新资源        data = new int[rhs.size];        size = rhs.size;                // 复制数据        for (int i = 0; i &lt; size; i++) {            data[i] = rhs.data[i];        }    }    return *this;  // 返回对象引用}\n\n类型转换隐式转换C++支持两种用户定义的类型转换：\n\n构造函数转换：从其他类型到当前类型\nclass PathName {    string name;public:    PathName(const string&amp; s) : name(s) {}  // string到PathName的转换};string abc(\"abc\");PathName xyz = abc;  // 隐式转换：abc =&gt; PathName\n\n可以使用explicit关键字禁止隐式转换：\nexplicit PathName(const string&amp; s);  // 只能用于显式构造\n\n转换运算符：从当前类型到其他类型\nclass Rational {public:    operator double() const {  // Rational到double的转换        return numerator_ / (double)denominator_;    }};Rational r(1, 3);double d = r;  // 隐式转换：r =&gt; double\n\n同样可以使用explicit关键字要求显式转换：\nexplicit operator double() const;double d = (double)r;  // 必须显式转换\n\n注意：如果同时提供了从T到C的构造函数和从C到T的转换运算符，编译器可能会产生歧义。\n显式转换显式转换的外在特点:\n\n使用直接初始化语法\n明确指出要用构造函数创建对象\n转换过程更加清晰可见\n\ne.g.\n// 构造函数转换：double到RationalRational r1 = 3.14;  // 隐式转换Rational r2(2.5);    // 显式转换\n\n\n\n如果声明 explict, 就必须使用强制的显式转换:\n// 如果想要强制显式转换，应该这样声明：explicit Rational(double value) {    const int PRECISION = 10000;    numerator = static_cast&lt;int&gt;(value * PRECISION);    denominator = PRECISION;    simplify();}Rational r1 = 3.14;        // 错误：不允许隐式转换Rational r2(2.5);          // 正确：显式构造Rational r3 = Rational(3.14); // 正确：显式转换\n\n\n\n类型的显式转换:\ndouble d2 = static_cast&lt;double&gt;(r2);  // 显式转换\n\n\n\n混合类型的转换根据运算结果, 自动地将运算的操作数进行类型转换:\n// 混合类型运算Rational r3(1, 2);double d3 = 0.5;// 这里会将r3转换为double，然后进行double加法double result = r3 + d3;\n\n\n\nTemplate模板概述模板是C++中实现**泛型编程**的核心机制，允许我们编写可以处理不同数据类型的代码，而不必为每种类型重复编写相同的逻辑。\n\n首先尝试匹配普通的函数, 否则尝试匹配模板函数\n\n函数模板是声明, 而非定义. 是在实际调用时候去 实例化 对应类型的函数.\n\n必须都放在头文件的实现包含:\n\n函数模板;\n\ninline函数\n\n带有default参数的声明.\n\n类模板的成员函数\ntemplate&lt;T&gt;int Vector&lt;T&gt;::getSize()const{  return size;}\n\n注意, 都需要声明模板类, 并且需要在 &lt; &gt;内部声明类.\n\n\n\ntemplate&lt;class T&gt; 和 template&lt;typename T&gt; 是等价的, 后者是后来引入的更明确的语法.\n\n类模板的每个成员函数在类外定义时，都必须以template&lt;class T&gt;（或template&lt;typename T&gt;）开头，即使该成员函数没有直接使用模板参数T.\n\nVector&lt; int (*)&gt;\n\n\n函数模板基本语法template&lt;class T&gt;void swap(T&amp; x, T&amp; y) {    T temp = x;    x = y;    y = temp;}\n\n\ntemplate 关键字引入模板声明\nclass T 指定参数化类型名称（class在这里表示任何内置类型或用户定义类型）\n在模板内部，T 被用作类型名称\n\n模板实例化int i = 3, j = 4;swap(i, j);  // 使用int类型的swapfloat k = 4.5, m = 3.7;swap(k, m);  // 实例化float类型的swapstd::string s(\"Hello\"), t(\"World\");swap(s, t);  // 实例化std::string类型的swap\n\n编译器会根据传入的参数类型自动生成相应的函数实例。\n模板匹配规则\n只使用类型的精确匹配\n不应用类型转换操作\n即使是隐式转换也会被忽略\n\nswap(int, int);     // 正确swap(double, double); // 正确swap(int, double);  // 错误！类型不匹配\n\n模板函数与普通函数共存如果同时存在模板函数和普通函数，编译器会优先选择**普通函数**.\n显式指定可以显式地指定模板参数类型:\n// 带有返回值的函数模板template &lt;class T&gt;T myMax(T a, T b){    cout &lt;&lt; \"调用模板版本的myMax\" &lt;&lt; endl;    return (a &gt; b) ? a : b;}int main(){  cout &lt;&lt; \"myMax&lt;double&gt;(10, 20.5) = \" &lt;&lt; myMax&lt;double&gt;(10, 20.5) &lt;&lt; endl; }// myMax(10, 20.5);  // 错误：参数类型不一致\n\n\n\n多参数的函数模板同理的, 我们可以设置多个参数类型, 根据输入的类型来推断:\ntemplate &lt;class T1, class T2&gt;T1 myMax(T1 a, T2 b){    cout &lt;&lt; \"调用模板版本的myMax2\" &lt;&lt; endl;    return (a &gt; b) ? a : b;}int main(){  cout &lt;&lt;  myMax(10, 20.5) &lt;&lt; endl; }\n\n 此时, 上述的函数不需要显式的声明参数类型, 因为存在匹配的模板函数.\n同时, 此时根据类型推断, 返回的类型是 int, 然后舍弃 20.5的小数部分, 最终的结果是 20.\n类模板基本语法此处的 Vector是自己定义的.\ntemplate&lt;class T&gt;class Vector {public:    Vector(int);    ~Vector();    Vector(const Vector&amp;);    Vector&amp; operator=(const Vector&amp;);    T&amp; operator[](int);private:    T* m_elements;    int m_size;};\n\n类模板的使用类模板必须显式指定类型参数：\nVector&lt;int&gt; v1(100);Vector&lt;Complex&gt; v2(256);v1[20] = 10;v2[20] = v1[20];  // 如果定义了int到Complex的转换，则正确\n\n类模板成员函数的定义所有成员函数定义都需要包含模板声明：\ntemplate &lt;class T&gt;Vector&lt;T&gt;::Vector(int size) : m_size(size) {    m_elements = new T[m_size];}template &lt;class T&gt;T&amp; Vector&lt;T&gt;::operator[](int indx) {    if (indx &lt; m_size &amp;&amp; indx &gt;= 0) {        return m_elements[indx];    } else {        // 错误处理    }}\n\n注意：\n\n每个成员函数定义前都要加上 template &lt;class T&gt;\n类名必须写为 Vector&lt;T&gt;\n类模板的函数通常在头文件中实现，不需要分离的.cpp文件\n\n多参数模板模板可以使用多个类型参数：\ntemplate&lt;class Key, class Value&gt;class HashTable {    const Value&amp; lookup(const Key&amp;) const;    void install(const Key&amp;, const Value&amp;);    // ...};\n\n嵌套模板模板可以嵌套使用，因为它们只是新的类型：\nVector&lt;Vector&lt;double&gt;&gt; matrix;  // 注意C++11之前需要空格：Vector&lt;Vector&lt;double&gt; &gt;Vector&lt;int (*)(Vector&lt;double&gt;&amp;, int)&gt; functionPointers;  // 函数指针的向量\n\n\n\n非类型模板参数~也就是没有使用模板类型的普通参数.\ntemplate&lt;class Key, class Value, int TableSize = 10&gt;class HashTable {    // ...};\n\n其中的 TableSize 就是普通的参数. 在编译时就确定了类型.\n模板的局限性与注意事项\n模板代码通常放在头文件中，因为编译器需要在编译时看到完整的模板定义\n模板错误通常在实例化时才会被发现，错误信息可能很复杂\n模板可能导致代码膨胀，因为每种类型都会生成一份代码\n模板参数必须支持模板中使用的所有操作\n\n其他\n使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.\n另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.\n\n\n\n访问控制继承关系中的访问控制控制基类成员在派生类中的可见性：\n\npublic：基类的 public 成员在派生类中仍然是 public，protected 成员仍然是 protected。\nprotected：基类的 public 和 protected成员在派生类中都变为 protected。\nprivate：基类的 public 和 protected 成员在派生类中都变为 private。\n\n作用域与生存期本地: 均为本地\n全局: 均为全局\n静态本地: 作用域是本地, 生存期是全局\n静态全局: ~\nIncludesAlgorithmcopy(first, last, result):\n\nfisrt和last是输入迭代器, 表示要复制的范围, 左闭右开即last应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;\nresult是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作\ne.g.std::vector&lt;int&gt; source = {1, 2, 3, 4, 5};std::vector&lt;int&gt; destination(5); // 确保目标容器有足够的空间std::copy(source.begin(), source.end(), destination.begin());for (int num : destination) {    std::cout &lt;&lt; num &lt;&lt; \" \"; // 输出：1 2 3 4 5}std::cout &lt;&lt; std::endl;\n\n\nresult可以直接输出到cout中.  vector&lt;int&gt; vec;for(int i = 0; i &lt; 5; i++){    vec.push_back(i);}vec.erase(vec.begin()+2); //删除第三个元素copy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout, \",\"));cout &lt;&lt; endl;// 0,1,3,4,\n\n\n\n数组之间不可以直接赋值, 但是字符串可以直接赋值\n\nchar str1[] = \"Hello\";char str2[] = \"World\";str1 = str2;  // 错误，数组之间不可以直接赋值string s1 = \"Hello\";string s2 = \"World\";s1 = s2;  // 正确，字符串可以直接赋值\n\n\n深拷贝string s1 = \"Hello\";string s2 = \"World\";cout &lt;&lt; \"初始状态：\" &lt;&lt; endl;cout &lt;&lt; \"s1: \" &lt;&lt; s1 &lt;&lt; endl;  // 输出：Hellocout &lt;&lt; \"s2: \" &lt;&lt; s2 &lt;&lt; endl;  // 输出：Worlds1 = s2;  // 赋值操作cout &lt;&lt; \"赋值后：\" &lt;&lt; endl;cout &lt;&lt; \"s1: \" &lt;&lt; s1 &lt;&lt; endl;  // 输出：Worldcout &lt;&lt; \"s2: \" &lt;&lt; s2 &lt;&lt; endl;  // 输出：World// 修改 s2 不会影响 s1，因为是深拷贝s2 = \"Changed\";cout &lt;&lt; \"修改 s2 后：\" &lt;&lt; endl;cout &lt;&lt; \"s1: \" &lt;&lt; s1 &lt;&lt; endl;  // 输出：Worldcout &lt;&lt; \"s2: \" &lt;&lt; s2 &lt;&lt; endl;  // 输出：Changed\n\nTemp// 迭代器I.begin();I.end();// Item AccessV.front();;V.back();\n\n区分findfind是字符串类的一种方法, 同时也是标准库algorithm中的一个函数.\n\nfind方法: 用于在字符串中查找子字符串的位置。\n\nstring str = \"Hello World\";size_t pos = str.find(\"World\");if (pos != string::npos) {    cout &lt;&lt; \"Found 'World' at position \" &lt;&lt; pos &lt;&lt; endl;}\n\nalgorithm中的find函数: 用于在容器（如数组、向量等）中查找元素。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() {    vector&lt;int&gt; vec = {1, 2, 3, 4, 5};    vector&lt;int&gt;::iterator it = find(vec.begin(), vec.end(), 3);    if (it != vec.end()) {        cout &lt;&lt; \"Found 3 at position \" &lt;&lt; distance(vec.begin(), it) &lt;&lt; endl;    }}// Found 3 at position 2\n\n编译: g++ -std=c++11 test.cpp -o test\n\nerase\n对于字符串的方法: str.erase(pos, len)\n删除从指定位置开始的指定个数字符\n\n\n\nstring str = \"Hello World\";str.erase(6, 5);cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello\n\n\n\n对于容器的方法: erase(pos1, pos2)\n左闭右开式删除容器当中的元素.\n\n\n\n#include &lt;iostream&gt;#include &lt;vector&gt;int main() {    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5, 6};    std::cout &lt;&lt; \"Original vector: \";    for (int i : vec) {        std::cout &lt;&lt; i &lt;&lt; \" \";    }    std::cout &lt;&lt; std::endl;    // 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素    vec.erase(vec.begin() + 1, vec.begin() + 4); // 删除 vec[1], vec[2], vec[3]    std::cout &lt;&lt; \"Modified vector: \";    for (int i : vec) {        std::cout &lt;&lt; i &lt;&lt; \" \";    }    std::cout &lt;&lt; std::endl; // 输出 \"1 5 6\"    return 0;}\n\n不知道放在哪里的代码块#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() {// 1. 创建并填充链表list&lt;int&gt; L;                      // 创建一个空的整数链表for(int i=1; i&lt;=5; ++i)          // 循环5次    L.push_back(i);              // 依次在链表尾部添加数字1,2,3,4,5                                 // 此时链表内容为：1,2,3,4,5// 2. 删除第二个元素L.erase( ++L.begin() );          // L.begin()指向第一个元素                                 // ++L.begin()指向第二个元素                                 // erase删除迭代器指向的元素                                 // 此时链表内容为：1,3,4,5// 3. 打印链表内容copy(                            // 标准库算法，用于复制序列    L.begin(),                   // 源序列的起始位置    L.end(),                     // 源序列的结束位置    ostream_iterator&lt;int&gt;(       // 输出流迭代器        cout,                    // 指定输出到标准输出        \",\"                      // 每个元素后面追加的分隔符    ));cout &lt;&lt; endl;                    // 换行}\n\n\n\n课堂缓冲区\n私有的边界是 class而非对象. 也就是说, 相同类的对象可以直接访问对方的私有属性.\n\n不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们之间没有初始化的依赖.\n\n需要尽可能地避免使用全局变量.\n\n一个良好的习惯: 当成员函数不需要改变成员变量的值时, 在后面加上 const的关键字, 确保不会改变;\n\n\nchar* s = \"Hello,world！\"；\n\n\n此时的右侧字符串位于 段 text, 不可写. s本身是一个固定内存的指针.\n\nchar s［］ = \"Hello,world！\"；\n\n\n此时的 s是一个大小等于数组内容的对象.\n\nconst int* f();// 只能将函数的返回值赋值给一个 const int*\n\n\n\n函数内部的对象的空间分配编译器在编译的时候计算得到函数内部所有的对象的空间, 在实际进入函数的时候**, 立即分配所有对象的空间;**\n\n实际执行到的时候发生构造.\n\nQuiz静态全局、本地和成员变量都存储于全局数据区.\n\n静态成员变量的构造也在 main()之前.\n\n题目梳理HW2\n\nANS:  B\n由于此处的map以char *作为key, 同时初始化str的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.\n\n\n\n\n逗号表达式, 从左到右分别计算,最后返回的结果是最右侧的值, 此处为1.\n\n\n\nvector&lt;int&gt; v(10); 创建包含10个元素的容器, 每个元素初始化为 0;\n\nvector &lt;int&gt; v(10, 1);: 创建包含10个元素的容器, 但是都初始化为 1;\n\nvector &lt;int&gt; v{10, 1};: 创建包含10,1 这2个元素的容器;\n\n此外, 还可以使用 vector &lt;int&gt; v;创建一个空的容器; \n\n同时也还可以用 迭代器进行初始化: vector &lt;int&gt; v(arr, arr + 5);\n\n\n\nHW3\n类成员的默认访问权限是 私有的, 即不显式声明访问修饰符, 默认为 private;\n\nHW4可变大小矩阵:#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Matrix{private:    int r,c;    vector&lt;vector&lt;int&gt;&gt; m; // 二维向量, 每个向量元素是一个一维向量public:    Matrix(int r, int c) : r(r),c(c){        m.resize(r, vector&lt;int&gt;(c)); // 分配r个一维向量, 每个一维向量的大小为c    }\t...    void transform(){        vector&lt;vector&lt;int&gt;&gt; new_m(c, vector&lt;int&gt;(r,0)); //\t声明一个临时的二维向量            \t// 将矩阵转置, 放入临时的向量        for(int i = 0; i &lt; c; i++){            for(int j = 0 ; j&lt; r; j++){                new_m[i][j] = m[j][i];            }        }        swap(r,c); //改变矩阵的行与列        m = move(new_m); //使用 move 直接将临时变量的所有权交给m, 避免拷贝    }};\n\n\n此处值得注意的是 resize在二维向量中的使用, 以及 move直接给予“所有权”的特性.\n\nHW5判断题: const成员函数不能作用于非const对象\n\n答案是 False. \n题目的意思大致是: 非const对象无法调用 const对象, 实际上是事实是相反的描述. 只需要理解题目的表述即可做出判断.\n\nHW6右值引用本身是一个左值, 可以取地址.\nint&amp;&amp; r = 5;std::cout &lt;&lt; r; // r 在这里是左值，因为它有名字\n\n\n\nHW7HW9\n因为静态成员函数不能是虚函数，所以它们不能实现多态\n\n静态成员函数不与类的任何具体实例（对象）相关联;\n\n\n在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序\n#include &lt;iostream&gt;// 基类Aclass A{public:    A()    {        std::cout &lt;&lt; \"A的构造函数被调用\" &lt;&lt; std::endl;    }};// 基类Bclass B{public:    B()    {        std::cout &lt;&lt; \"B的构造函数被调用\" &lt;&lt; std::endl;    }};// 派生类C，继承自A和Bclass C : public A, public B{public:    // 构造函数中显式调用基类构造函数    C() : B(), A()    { // 注意：这里虽然B在A之前，但实际调用顺序由类定义决定        std::cout &lt;&lt; \"C的构造函数被调用\" &lt;&lt; std::endl;    }};int main(){    C c; // 创建C的实例    return 0;}\n\n输出:\nA的构造函数被调用B的构造函数被调用C的构造函数被调用\n\n由此可见, 虽然在C的初始化列表中声明了B前A后, 但是实际上A优先调用.\n\n如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针）\n\n这句话的括号内部是错误的.\n\n因为我们依旧可以将其的子类 upcast\n#include &lt;iostream&gt;using namespace std;class A{public:    virtual void ptr() = 0;};class B : public A{public:    void ptr() override    {        cout &lt;&lt; \"B\" &lt;&lt; endl;    }};int main(){    A *a = new B();    a-&gt;ptr();    return 0;}\n\n\n\n\n类内的纯虚函数被认为是 inline的函数;\n\n在创建派生类的对象时, 构造函数的执行顺序为—— 基类对象-&gt;对象成员-&gt;派生类自身:\n#include &lt;iostream&gt;using namespace std;class Base{public:    Base() { cout &lt;&lt; \"Base 构造函数\" &lt;&lt; endl; }};class Member{public:    Member() { cout &lt;&lt; \"Member 构造函数\" &lt;&lt; endl; }};class Derived : public Base{    Member m;public:    Derived() { cout &lt;&lt; \"Derived 构造函数\" &lt;&lt; endl; }};int main(){    Derived d;    return 0;}\n\n输出:\nBase 构造函数Member 构造函数Derived 构造函数\n\n私有继承问题: 可以通过方法访问私有继承的public, protected的基类成员(不包括私有成员), 但是无法直接访问.\n#include &lt;iostream&gt;using namespace std;class Base{private:    int a = 1; // 私有protected:    int b = 2; // 保护public:    int c = 3; // 公有};class Derived : private Base{private:    int d = 4; // 派生类自己的私有成员public:    void show()    {        // cout &lt;&lt; a;  // ❌ 错误！Base 的私有成员 a，派生类根本不能访问        cout &lt;&lt; b &lt;&lt; endl; // ✅ OK：Base 的 protected 成员，在 Derived 中变成了 private        cout &lt;&lt; c &lt;&lt; endl; // ✅ OK：Base 的 public 成员，在 Derived 中变成了 private        cout &lt;&lt; d &lt;&lt; endl; // ✅ OK：Derived 的私有成员当然能访问    }};int main(){    Derived d;    d.show();    // cout &lt;&lt; d.b; // ❌ 错误！Base 的 protected 成员，在 Derived 中变成了 private    return 0;}\n\n虚函数也具有 this 指针.\n\n在构造函数中调用虚函数，不是动态联编\n\n原因是：对象还未完全构造完成（或已经开始析构）时，虚函数表（vtable）可能尚未指向最终派生类.\n所以，在构造函数中调用虚函数时，只会调用当前类中该函数的版本，不会发生多态。\n\n\n\n虚析构函数\n为了在多重继承的时候, 可以正确的调用各个阶段的析构函数, 我们需要声明基类的析构为虚函数, 然后在子类中重写:\n\nvirtual ~CRAFT(){    cout &lt;&lt; \"销毁航行器(速度: \" &lt;&lt; speed &lt;&lt; \")\" &lt;&lt; endl;}...~PLANE() override{    cout &lt;&lt; \"销毁飞机(翼展: \" &lt;&lt; width &lt;&lt; \")\" &lt;&lt; endl;}\n\n\n\n\n菱形继承的时候, 注意 virtual public的声明 以及 在底层的子类中的初始化列表的顺序!\nSEAPLANE(float speed, float width, float depth) : CRAFT(speed), PLANE(speed, width), SHIP(speed, depth){  ...}\n\nHW10\n判断: 对象间赋值将调用拷贝构造函数。  \n错误. 对象间的赋值调用的是 拷贝复赋值运算符.\n\n\n\n异常类\n\nA是错误的。C++允许自定义异常类，可以继承标准异常类如std::exception。\nB是正确的，C++异常机制会在异常抛出前自动销毁局部对象。\nC是正确的，抛出异常时对象会被拷贝（或移动）到catch块中。\nD是正确的，在catch块中可以使用对象引用来接收异常对象。\n\n赋值运算符重载\n语法:\n类名&amp; operator=(const 类名&amp; 对象名)\n\n特点:\n\n返回类型是类的引用（为了支持连续赋值 a=b=c）\n参数是const引用（防止修改原对象）\n通常需要先释放自己的资源，再复制数据\n\n\n\ne.g.\nArray&amp; operator=(const Array&amp; a) {    if (this != &amp;a) {  // 防止自赋值        delete[] data;  // 释放原有内存        size = a.size;  // 复制大小        data = new int[size];  // 分配新内存        for (int i = 0; i &lt; size; i++) {  // 复制数据            data[i] = a.data[i];        }    }    return *this;  // 返回对象自身的引用}\n\n\n\nW12\n建立类模板对象的实例化过程为: 模板类-对象.\n编译器根据提供的模板参数将类模板实例化为一个具体的模板类（也称为实例化类或特化类），然后才能创建该模板类的对象。\n类模板的使用实际上是将类模板实例化成一个 类\n\n\n类模板与模板类\n类模板是类的蓝图或规范，它本身不是一个类\n模板类（或实例化类、特化类）是使用具体的类型参数实例化类模板后得到的具体的类。\n\n\n类模板和函数模板的实例化的时期 – 均为编译时期\n函数模板在编译时期检查定义中的基本语法;\n尝试调用某一个函数模板时, 编译器根据实际的参数类型来推导模板参数类型/或者由显式指定类型得到, 如果合法就生成函数实例(i.e. 模板函数), 这个过程就是模板实例化(生成代码).\n\n\n除了使用构造函数, 还可以直接调用 make_pair 让编译器自动推导类型来创建pair对象;\n\n\nL3\n[!NOTE]\n\n内联函数在 编译时展开, 而不是运行时.\n内联函数的声明以及最终的生效与否, 是由 编译器 决定的. 也就是说, 无论是否存在 inline 的声明, 编译器最终决定函数的类型.\n\n\nC++ 初始化列表与成员变量初始化\n[!NOTE]\n\nint和自己定义的类都是cpp的类, 所以可以直接在初始化列表中用 :class_instance{input},...{}来初始化类内的类对象.\n推荐使用 {}来初始化, 不会产生是函数的歧义.\n\n\n1. 构造顺序\n在 C++ 中，成员变量的初始化顺序由它们在类中声明的顺序决定，而不是在初始化列表中的顺序。\n初始化列表用于 直接初始化 成员变量，而不是在构造函数体内先创建未初始化的对象再赋值。\n\n2. 为什么必须使用初始化列表？\n成员变量在进入构造函数体之前就已经完成了初始化，不能在构造函数体内赋值来替代初始化。\n如果成员变量是一个没有默认构造函数的对象，必须在初始化列表中显式调用其构造函数，否则编译会报错。\n在构造函数体内赋值，意味着：\n先调用默认构造函数创建对象（如果 NumberDisplay 没有默认构造函数，这一步会失败）。\n然后使用赋值运算符进行赋值，而赋值运算与初始化是不同的过程。\n\n\n\n3. 示例代码❌ 错误示例（可能会编译失败）class NumberDisplay {public:    NumberDisplay(int max) { /* 初始化代码 */ }};class Clock {private:    NumberDisplay hour_display;    NumberDisplay minute_display;    NumberDisplay second_display;    public:    Clock(int hour, int minute, int second) { // ❌ 错误：NumberDisplay 没有默认构造函数        hour_display = NumberDisplay(24);     // 不能这样赋值        minute_display = NumberDisplay(60);        second_display = NumberDisplay(60);    }};\n✅ 正确示例class Clock {private:    NumberDisplay hour_display;    NumberDisplay minute_display;    NumberDisplay second_display;    public:    // 使用初始化列表    Clock(int hour, int minute, int second)        : hour_display(24), minute_display(60), second_display(60) {        // 构造函数体内的代码可以进行额外的赋值操作    }};\n\n\n\n4. 结论\n​\t•\t所有成员变量都会在构造函数体执行前被初始化，不能依赖在构造函数体内赋值。\n​\t•\t如果成员变量是没有默认构造函数的对象，必须使用初始化列表进行初始化，否则会导致编译错误。\n​\t•\t初始化列表的顺序应与成员变量的声明顺序一致，否则可能会导致未定义行为。\nProjectP1cout &lt;&lt; \"\\\"\" &lt;&lt; value &lt;&lt; \"\\\"\";\n\n如果要输出引号, 需要加入 \\来进行转义!\n使用匿名函数来排序sort(sortedRecords.begin(), sortedRecords.end(),     [](const Record&amp; a, const Record&amp; b) {         if (a.qso_date != b.qso_date) return a.qso_date &lt; b.qso_date;         return a.time_on &lt; b.time_on;     });\n\nsort是 algorithm头文件中的库函数, 支持原地排序.\n第三个参数是一个函数, 返回 true表示这个函数的第一个参数应该排在第二个参数的前面.\n比如此处, 使用了匿名函数 [], 同时比较 date, 当 \nreturn a.qso_date &lt; b.qso_date;\n\n指的是当前者的时间较小, 应该排在前面, 因此是升序.\n\n不要因为语句太长而忘记末尾的 ;.\n\nP2思路分析\n整体设计:\n程序随机生成一组设置, 然后用户开始输入\n大概率, 用户不可避免地会失败, 此时应当让用户选择是否继续参与这场游戏, 否则程序生成下一组的设置;\n\n\n房间:\nmonster所在;\nprincess所在\nlobby;\n普通的room\n具有毒药的房间(接触后限制之后行动的次数)\n解药房间(可以解除中毒的状态)\n地图房间(接触后可以通过输入 map来显示当前的位置)\n\n\n房间个数: \n每次都将上述的因素都加入, 不太合适, 因此需要用户输入游戏的类型/难度;\n经典模式: 只会产生monster, princess,lobby和普通房间. 房间的个数较少;\n挑战模式:  加入毒药, 解药和地图因素; 房间个数较多.\n\n\n\n刷题\nDestructors can not be overloaded.\n\n因为析构函数没有任何的参数和返回类型, 无法重载.\n\n\n类的成员函数可以访问同类的私有成员，即使是其他对象的成员。 回顾类的私有边界不是相对于对象的, 而是类. \n\ncpp中, 构造函数一定不能是 virtual 的! \n\n静态变量需要再类的外部定义, 但是静态函数不一定.\n\n“In C++， struct is actually the same thing as class， except for minor differences in usage.”\n\n这句话是正确的, 注意结构体也是支持继承的. 只是默认的继承方式也是 public.\n\n\nIn C++, inheritance allows a derived class to directly access all of the functions and data of its base class.（T/F）\n\n错误的. 对于 public 类型的继承, 依旧无法直接访问父类的私有成员, 只能通过子类的方法来间接访问.\n\n\n下面的代码段, 能够能够通过编译, 但是存在运行时的错误(越界访问):\nint main() { vector&lt;float&gt; v; v[0] = 2.5; }\n\n\n编译器在编译时候, 检查的主要是程序的语法和类型;\n越界访问的问题存在于运行时检测.\n\n\n64位系统系统环境, 按照8个字节进行对齐:\n// 参考的类定义方式class A1{public:    int i;    void f(){}};// 其他的类型定义\n\nOutput:\nSize of A1 (non - virtual function with int member): 4 bytesSize of A2 (virtual function with int member): 16 bytesSize of A3 (non - virtual function without int member): 1 bytesSize of A4 (virtual function without int member): 8 bytesSize of B (derived from A1): 8 bytes\n\n主要注意2点:\n\n没有任何成员的类, 也占用1个字节的大小;\n\n4+8 将会对齐得到16个字节的空间大小.\n\n[!NOTE]\nvoid* 和 int* 的大小相同! (题目通常给出 int*的大小, 然后给出虚函数)\n\n\n\n\nmalloc 不会调用对象的构造函数, 仅仅分配内存, 并不涉及对象的初始化;\n\nnew会调用构造函数\n\nmalloc 需要显式地类型转换:\nclass MyClass {public:    MyClass() { std::cout &lt;&lt; \"Constructor called!\" &lt;&lt; std::endl; }};MyClass* p1 = new MyClass();  // 输出 \"Constructor called!\"MyClass* p2 = (MyClass*)malloc(sizeof(MyClass));  // 无输出，构造函数未调用\n\n\nnew 是CPP的运算符, 可以重载; malloc是标准库的函数, 无法重载.\n\n每个类最多具有一个析构函数\n\n\n重载问题在 ::, () 和 -&gt;中, 只有 -&gt;可以被重载:\n#include &lt;iostream&gt;class MyClass {public:    void sayHello() {        std::cout &lt;&lt; \"Hello from MyClass!\" &lt;&lt; std::endl;    }};class MyPtr {private:    MyClass* ptr;  // 内部存储一个原生指针public:    // 构造函数    MyPtr(MyClass* p) : ptr(p) {}    // 重载 -&gt; 运算符    MyClass* operator-&gt;() {        return ptr;  // 返回原生指针，使得可以继续用 -&gt; 访问成员    }};int main() {    MyClass obj;    MyPtr myPtr(&amp;obj);  // 用 MyPtr 包装 MyClass 对象    myPtr-&gt;sayHello();  // 调用 MyClass 的成员函数    return 0;}\n\nnew与对象转换#include &lt;iostream&gt;using namespace std;class B;class A{protected:    int x;public:    A(int x = 0) : x(x) {}    operator B();    int getx() { return x; }};class B : public A{public:    B(int x = 0) : A(x) { this-&gt;x++; }    B(const B &amp;b) : A(b.x) { this-&gt;x++; }};A::operator B() { return *new B(x + 1); } // 特别注意此处int main(){    A *p1 = new B(3); // new的时候触发B的构造函数, 自增    A *p2 = new A(9);    B b0 = *p1; // 发生了A类对象向B类对象的转化, 详见下面两行:    // *p1 将要转化的时候,  先传入x+1作为B的初始化参数输入,    // 然后new将触发B的构造函数, 最后返回, 返回结果用于初始化b0, 继续触发拷贝构造函数    B &amp;r = b0;    B b1 = b0;  // 发生了 B类对象的拷贝构造, b1的x为8, 但是不会改变b0的x=7    B b2 = *p2; // 这一步的转换与上面的同理. 也是+3    cout &lt;&lt; p1-&gt;getx() &lt;&lt; endl;    cout &lt;&lt; p2-&gt;getx() &lt;&lt; endl;    cout &lt;&lt; b0.getx() &lt;&lt; endl;    cout &lt;&lt; r.getx() &lt;&lt; endl;    cout &lt;&lt; b1.getx() &lt;&lt; endl;    cout &lt;&lt; b2.getx() &lt;&lt; endl;}\n\n解题过程中的关键步骤已经写在注释当中, 最后的输出是:\n4977812\n\n梳理考察的重要知识点:\n\nupcast的时候, 是子类的属性赋值给父类, 包括虚函数表. 因此, 此时看作是父类的对象, 但是虚函数能够动态绑定.\n\nnew和delete分别自动调用类的构造函数和析构函数;\n\nA::operator B() 形式表示A类对象如何转换成B类型对象的, 在发生转换的时候自动调用这部分的函数.\nA *p1 = new B(3); // 拷贝构造的时候直接自增为4A *p2 = new A(9);\n\n注意上面的指针都指向A类的对象.\n\n\n链式的析构顺序\n构造顺序: 父类-&gt;成员对象-&gt; 自身\n析构顺序: 自身-&gt; 成员对象-&gt; 父类\n\n下面的这道题目涉及的类的关系如下:\n\nP是父类, S是子类;\nP内部有两个P类型的指针成员.\n\n#include &lt;iostream&gt;using namespace std;// 1. 先声明基类 Pclass P{public:    static bool flag; // 静态成员声明    int x;            // 数据成员    P *left, *right;  // 指针成员    // 构造函数    P(P *left = nullptr, P *right = nullptr)        : x(0), left(left), right(right) {}    // 虚析构函数（因为有继承关系，应该是虚函数）    ~P()    {        if (flag)        {            if (left != nullptr)            {                delete left;            }            if (right != nullptr)            {                delete right;            }        }        else        {            if (right != nullptr)            {                delete right;            }            if (left != nullptr)            {                delete left;            }        }        cout &lt;&lt; \"P\" &lt;&lt; x;    }};// 2. 静态成员的定义（必须在类外定义）bool P::flag = false;// 3. 派生类 Sclass S : public P{public:    // 构造函数，调用基类构造函数    S(P *left = nullptr, P *right = nullptr) : P(left, right) {}    // 析构函数    ~S()    {        cout &lt;&lt; \"S\" &lt;&lt; x;    }};int main(){    S *p1 = new S;    p1-&gt;x = 1; // 设置第一个节点的值    S *p2 = new S;    p2-&gt;x = 2;   // 设置第二个节点的值    S s(p1, p2); // 创建根节点，连接p1和p2    s.x = 3;     // 设置根节点的值/    return 0;    // 程序结束时析构对象}\n\n最终的输出:\n\n析构s, 首先析构子类自身, 调用s的析构函数, 输出s;\n然后析构父类, 父类是P, 析构的时候直接调用自身的析构函数, 一词析构右指针和左指针;\n执行到末尾, 输出自身的P3.\n\nOutput:\nS3P2P1P3\n\n\n\n\n\n\n\n操作符的重载#include &lt;iostream&gt;#include &lt;iomanip&gt;#define MAXN 110/* Your answer will be inserted here. Feel free to add anything needed here.*/class vec{private:    int first, second;public:    vec(int a, int b) : first(a), second(b) {}    //  &lt; 的重载    bool operator&lt;(const vec &amp;other) const    {        return second &lt; other.second;    }    // 类型转换的重载    operator double() const    {        return static_cast&lt;double&gt;(first);    }    // 输出的重载    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const vec &amp;v)    {        return os &lt;&lt; \"(\" &lt;&lt; v.first &lt;&lt; \",\" &lt;&lt; v.second &lt;&lt; \")\";    }};void printArrayInfo(vec **arr, int n){    vec *maxv = arr[0], *minv = arr[0];    double avg = 0;    for (int i = 0; i &lt; n; ++i)    {        vec *val = arr[i];        if (*val &lt; *minv)            minv = val;        if (*maxv &lt; *val)            maxv = val;        avg = avg + static_cast&lt;double&gt;(*val);    }    avg /= n;    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; \"min = \" &lt;&lt; *minv &lt;&lt; \", max = \" &lt;&lt; *maxv &lt;&lt; \", avg = \" &lt;&lt; avg &lt;&lt; std::endl;}int main(){    vec *pool[MAXN];    int n;    int a, b;    std::cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    {        std::cin &gt;&gt; a &gt;&gt; b;        pool[i] = new vec(a, b);    }    printArrayInfo(pool, n);    return 0;}\n\n\n\n菱形继承与二义性问题并不是菱形继承的操作都会导致二义性, 要从本质–访问的操作是否导致无法区分正确的单独对象?\n#include &lt;iostream&gt;using namespace std;class A{public:    int x;    A() : x(6) {}    int fun()    {        return x;    }};class B : public A{public:    int fun()    {        return A::fun() + x;    }};class C : public A{public:    int fun()    {        return A::fun() + x;    }};class D : public B, public C{public:    int fun()    {        return B::fun() + C::fun();    }};int main(){    D d;    cout &lt;&lt; d.fun();    // cout &lt;&lt; d.A::fun(); 存在二义性的问题, 因为在D当中分别存在来自于B和C的这个函数!}\n\n在上面代码中, D是菱形继承, 但是可以直接访问d的fun, 因为在d的fun中涉及的是B和C自己的fun. 而后者又能够直接调用自己的继承自A的fun\n\n无法直接调用 d.A::fun(), 参见注释.\n\n最后的枚举转换运算符A::operator B()的含义： 定义了如何将 A 类型的对象转换为 B 类型的对象。\n\nA:: 表示这是 A 类的成员函数\noperator B 表示这是一个到 B 类型的转换运算符\n() 表示这是一个函数\n\n// A 具有一个成员变量且在构造函数中可以赋值A::operator B() { return *new B(x + 1); }\n\n\nnew B(x + 1) 创建一个新的 B 对象，其中 x 是 A 类的成员变量\n* 解引用这个新创建的对象\n返回这个 B 类型的对象\n\n\n[!NOTE]\n注意, 这只是决定了B类对象的如何构造, 并不会影响A类对象本身.\n\n调用的场景: 需要将A类型的对象转换为B类型的对象 e.g.——\nA a(5);B b = a;  // 这里会自动调用 A::operator B()\n\n\n\nconst相关对象与方法的对应C++在选择成员函数时会考虑对象的const属性：\n\nconst对象只能调用const成员函数 \n\n非const对象优先调用非const版本，如果没有非const版本才会调用const版本\n\n\n[!NOTE]\n函数定义的顺序并不会影响调用的选择!\n\n\n\ne.g.\n#include &lt;iostream&gt;using namespace std;class MyClass{public:    MyClass(int x) : val(x) {}    void Print()    {        cout &lt;&lt; 2 &lt;&lt; endl             &lt;&lt; val &lt;&lt; endl;    }    void Print() const { cout &lt;&lt; 1 &lt;&lt; endl                              &lt;&lt; val &lt;&lt; endl; }private:    int val;};int main(){    const MyClass obj1(10);    MyClass obj2(20);    obj1.Print();    obj2.Print();    return 0;}\n\noutput:\n110220\n\n\n\n\n\n初始化先后的问题C++中对象的初始化和销毁顺序遵循特定的规则，这对于理解程序行为和避免内存问题至关重要\n初始化列表类的构造与析构顺序在C++中，对象的构造和析构顺序遵循以下规则：\n\n构造顺序：\n\n基类先于派生类构造\n成员变量按声明顺序构造\n基类构造完成后，才执行派生类构造函数体\n\n[!NOTE]\n对象在调用构造函数之前, 首先完成内部成员对象的构造\n\n\n\n\n析构顺序：\n\n与构造顺序相反\n先执行派生类析构函数体\n然后按声明顺序的逆序析构成员变量\n最后析构基类\n\n\n\n示例分析int main(){    Child c;}\n\n类层次结构X (基础类)↑Y (继承自X)Parent (包含X成员)↑Child (继承自Parent，包含Y成员)\n\n构造过程分析当创建Child对象时，构造顺序为：\n\n首先构造基类Parent\n在Parent构造前，先构造其成员x（调用X::X()）\n然后执行Parent构造函数体（输出”Parent::Parent()”）\n\n\n基类构造完成后，构造Child的成员y\n在构造y前，先构造其基类部分（调用X::X()）\n然后执行Y构造函数体（输出”Y::Y()”）\n\n\n最后执行Child构造函数体（输出”Child::Child()”）\n\n析构过程分析当Child对象离开作用域时，析构顺序为：\n\n首先执行Child析构函数体（输出”Child::~Child()”）\n然后析构成员y\n先执行Y析构函数体（输出”Y::~Y()”）\n然后析构其基类部分（调用X::~X()）\n\n\n最后析构基类Parent\n先执行Parent析构函数体（输出”Parent::~Parent()”）\n然后析构其成员x（调用X::~X()）\n\n\n\n预期输出执行test.cpp程序时，预期输出为：\nX::X()              // Parent的成员x构造Parent::Parent()    // Parent构造函数体X::X()              // Y的基类部分构造Y::Y()              // Y构造函数体Child::Child()      // Child构造函数体Child::~Child()     // Child析构函数体Y::~Y()             // Y析构函数体X::~X()             // Y的基类部分析构Parent::~Parent()   // Parent析构函数体X::~X()             // Parent的成员x析构\n\n重要注意事项\n虚析构函数：当使用多态时，基类应该有虚析构函数，确保正确调用派生类析构函数。\n\n成员初始化列表：推荐使用成员初始化列表而非在构造函数体内赋值，这样可以直接初始化而非先默认构造再赋值。\n\n异常安全：构造过程中如果抛出异常，已构造的成员会被正确析构，但未完全构造的对象不会调用析构函数。\n\nRAII原则：资源获取即初始化，在构造函数中获取资源，在析构函数中释放资源，确保资源管理安全。\n\n\n实际应用理解对象生命周期对以下场景尤为重要：\n\n资源管理：确保资源在不再需要时被释放\n依赖关系处理：确保依赖对象在被依赖对象之前构造，之后析构\n继承层次设计：合理设计基类和派生类的构造和析构行为\n\n"}]