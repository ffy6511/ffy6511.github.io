[{"title":"利用认知工具激发LLM的推理能力","url":"/2025/07/08/Cognitive-Tools/","content":"\n  \n    \n      Note\n\n    \n    \n      \nPaper：Eliciting Reasoning in Language Models with Cognitive Tools\nMedium上的分析\n\n\n    \n  \n\n传统的Agent框架中，工具是与外部世界连接的窗口——比如MCP服务器、API等\n\n\n这篇IBM的研究模仿 AI 代理的模块化架构，将认知心理学中的模块化认知操作理论引入现代LLM中，通过赋予模型一组认知工具来执行特定的推理操作。这些工具由LLM自身实现，并在工具调用框架下进行序列化执行。\n这种方法与当前主流的链式思维或强化学习不同，强调通过结构化方式激发LLM的潜在推理能力\nWhat is Cognitive Tools\n\n通过将推理阶段封装到模块化的提示驱动工具中，将认知架构中的内部认知操作重新表述为现代工具调用代理框架中的工具，主要分为：\n\nUnderstand Question：将问题分解为其核心组成部分，识别关键概念、变量和相关定理\n\nRecall Related：检索类似问题和它们的解决方案，通过例子指导推理\n\nExamine Answer：通过self-reflexion的形式检查答案正确性，包括可能的缺陷、错误的假设与计算，以及没有考虑在内的约束\n\n同时使用解决当前问题的思路检验类似的问题，判断正确性\n\n\nBacktracking ：识别推理过程中存在缺陷的步骤，并给出替代的解决方案，类似于在解决问题时探索新的路径。\n\n\n这几个工具都作为prompt-driven的模块运行，由同一个LLM执行；工具的输出结果被反馈到主要的推理循环中，使模型能够动态地优化其方法\n论文中给出了各个工具详细的提示词，在此给出一例：\n\n\nCompared With Cognitive PromptingCognitive Prompting： 通过模拟人类认知过程中的结构化思维操作，来引导大型语言模型（LLMs）解决复杂问题的新型提示方法\n\n相关的Paper\n\n\n\n认知提示的特点是结构化提示，暗示与引导LLM进行分步思考，但缺乏显式模块化\nIBM的研究认为他们的认知工具通过参考认知提示的经验，在效果上超越了后者：\n\n\nWhy Cognitive Tools Matters\nThe introduction of cognitive tools addresses a critical limitation of traditional prompting methods, such as flat prompts or monolithic chain-of-thought (CoT) approaches.\n\n引入认知工具解决了传统提示方法，如扁平提示或整体式思维链（CoT）方法的关键局限性\nThe shortcomings of traditional CoTCoT (chain-of-thought)  通过在提示词中加入类似于“让我们一步步思考”的指令，鼓励LLM生成推理的中间步骤\n\n缺乏灵活性和适应性：虽然CoT能够展现推理过程，但是作为预设的、线性的生成过程，难以回溯纠正过程中存在的错误，缺乏中间阶段的自我纠正能力；同理，对于需要反复审视、多角度分析、甚至回溯重试的问题，单一的CoT很难有效地管理这些复杂的逻辑流\n另外，黑盒问题依旧存在：尽管CoT展示了推理步骤，但这些步骤仍然是LLM内部生成的结果，我们无法直接控制或干预其中的特定认知操作。如果CoT中出现了推理错误，我们也很难知道具体是哪个“认知功能”出了问题；\n\nImprovements in cognitive tools\n引入模块化和显式控制：\n将复杂任务从一个黑盒分解为人类思考时经历的一系列可识别、独立的认知操作 cognitive operation\n将这些操作封装成独立的、可调用的“工具”。每个工具专注于完成一个特定的认知子任务\n\n\n实现动态编排和自我修正：主LLM可以根据需要，动态地选择和调用这些工具\n这使得推理过程不再是线性的，而是可以进行分支、循环、回溯和自我修正。\n例如，当LLM发现推理有误时，可以显式调用“检查答案”工具进行反思，然后调用“回溯”工具返回并重新尝试\n\n\n提高可解释性和鲁棒性：通过将推理分解为模块化的步骤，并赋予LLM自主调用这些工具的能力，使得推理过程更加透明和可控，也更容易纠错和优化，从而显著提高了LLM在复杂推理任务上的性能和鲁棒性\n\nOther features\nBy compartmentalising reasoning steps, cognitive tools reduce interference between operations, enabling clearer and more focused problem-solving.\n\n\n通过将推理步骤模块化，认知工具减少了操作之间的干扰，从而实现更清晰和专注的问题解决\n\n\nFirst, modularity helps the LLM focus on implementing the specific cognitive operation at hand, in isolation from the rest of the context window that has been provided so far\n\n\n模块化的设计有助于LLM专注于当前的任务，避免受到长上下文的干扰\n\nComparisons with baseline\n\n与flat prompts进行比较，cognitive tools方法下的回答正确率都有提高\n思考与总结启示除了强化学习，还有其他方法可以激活LLM的推理能力，比如本文的modular cognitive tools，就证明了在高难度推理任务上的可行性\n从 AI 代理的角度来看，这种方法弥补了传统工具调用（依赖外部 API 和函数）与模块化内部推理需求之间的gap\n认知工具的发现被认为与情境学习同等重要且意义重大，尤其对于需要结构化推理和透明度的任务\n\nThe discovery of cognitive tools can be argued to be as important and significant as in-context learning, particularly for tasks requiring structured reasoning and transparency\n\n更多问题文章没有给出主LLM内部的提示词，给出Gemini拟合的参考：\nYou are an advanced AI assistant designed to solve complex problems by orchestrating a set of specialized cognitive tools. Your primary goal is to accurately and comprehensively answer the user&#x27;s query by breaking it down, analyzing it deeply, utilizing available resources, and ensuring the correctness of your reasoning.**Here are the cognitive tools at your disposal, and their functions:**1.  **Understand Question (`understand_question`)**:    * **Purpose**: To thoroughly analyze and deconstruct a complex problem, identify key components, extract known information, and recognize potential methodologies.    * **Input**: `problem_statement` (The full problem text).    * **Output**: Structured analysis including sub-problems, key concepts, extracted data, and suggested approaches.2.  **Recall Related (`recall_related`)**:    * **Purpose**: To retrieve and leverage relevant prior knowledge, similar problems, related theorems, formulas, or common solution patterns that could aid in the current problem-solving process.    * **Input**: `current_context` (Current problem state or analysis).    * **Output**: List of recalled knowledge, similar examples, applicable theories, and common pitfalls.3.  **Examine Answer (`examine_answer`)**:    * **Purpose**: To meticulously review a proposed solution or ongoing reasoning chain for logical consistency, erroneous assumptions, calculation errors, or unaddressed constraints.    * **Input**: `reasoning_chain` (The step-by-step reasoning process), `current_answer` (The derived answer or intermediate result).    * **Output**: Detailed critique highlighting issues, missing elements, or confirming correctness.4.  **Backtracking (`backtracking`)**:    * **Purpose**: To revert to a previous correct or promising state in the reasoning process when the current path is deemed incorrect or unproductive, and to suggest alternative approaches from that point.    * **Input**: `error_report` (Details from &#x27;examine_answer&#x27; or other identified errors), `last_valid_state` (The point in the reasoning chain to return to).    * **Output**: Identification of the backtrack point, analysis of the error&#x27;s root cause, and suggestions for new strategies.**Your Operating Protocol (Think-Act Loop):**1.  **Thought**: Carefully consider the current problem, the progress made so far, and the output from the last tool. Determine the most logical next step. Are you trying to understand the problem better? Recall relevant information? Generate a solution? Or verify your work?2.  **Action**: Based on your &#x27;Thought&#x27;, choose *one* of the available tools and call it with the appropriate parameters. If you believe the problem is fully solved and verified, state &quot;FINISH&quot; followed by your final answer.**Example Action Format:**`Action: understand_question(problem_statement=&quot;Solve the equation x^2 + 2x - 3 = 0&quot;)``Action: examine_answer(reasoning_chain=&quot;Step 1:...&quot;, current_answer=&quot;x=1, x=-3&quot;)``Action: FINISH: [Your Final Answer Here]`**Initial Problem:**[USER&#x27;S ORIGINAL PROBLEM STATEMENT GOES HERE]\n","categories":["文献阅读"],"tags":["agent","提示词"]},{"title":"将MVVM开发模式引入Swift-UI","url":"/2025/07/07/%E5%B0%86MVVM%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%BC%95%E5%85%A5Swift-UI/","content":"引言\n最近在以赛促学地使用swift语言开发一款ios端的应用。汲取了web端开发的一些经验和教训，开发的初期我意识到了类似于全局设置的“CSS”变量的重要性，以及框架结构的重要性。本篇文章将以开发过程中的“古琴设计”这一模块为例，介绍Swift UI中的MVVM开发模式的实践\nMVVM 模式什么是MVVM\n\n\nfrom 维基百科.\n\nMVVM, i.e. Model–view–viewmodel 是一种软件架构模式, 将图形界面与业务逻辑的开发相分离:\n\nModel 模型: 数据和业务逻辑层, 包含对象基本的属性;\nview 视图: 用户界面层，负责展示内容，比如 SwiftUI 的各种界面组件;\nviewModel 视图模型: 连接 Model 和 View 的桥梁，负责处理数据、业务逻辑，并将数据以适合 View 展示的方式提供给 View\n\n因此, MVVM框架的核心思想是Model 负责定义底层数据, viewModel负责数据处理, view负责元素的显示\nSwift UI中数据绑定的功能, 比如如 @State, @ObservedObject, @StateObject, @EnvironmentObject, 使得不同模块之间的通信变得十分容易, 从而方便在Swift UI框架下实现MVVM风格的开发.\ne.g.\nstruct ContentView: View &#123;    @StateObject var viewModel = ContentViewModel()    var body: some View &#123;        Text(viewModel.title)    &#125;&#125;class ContentViewModel: ObservableObject &#123;    @Published var title = &quot;Hello, MVVM!&quot;&#125;\n\nMVVM的好处作为一种分层架构模式, 它使得在Swfit UI框架下的开发更加接近web端开发的前后端分离. 一方面，通过MVVM将界面显示和数据更新的操作解耦，便于维护和测试；另一方面，Swfit语法的特性使得视图很容易自动响应视图模型的数据变化，界面和数据同步比React中更加简单\n从一个开发需求实践MVVM\n\n假设我们的开发目标如图所示——古琴的设计分为琴身和琴弦两大整体：\n\n琴身内部的样式细分为形制、材质、铭文；\n琴弦内部的样式细分为弦数、材质和音准\n\n在交互方面，我们希望用户可以专注于选择其中一个古琴特征进行配置，并且可以保存当前的全局配置\n\nModel从上述的描述中，我们可以分析得到对应的数据模型，比如可以直接为固定的形制类型设计一个枚举及其内部对应的计算属性:\nenum GuqinShape: String, CaseIterable, Identifiable, Codable &#123;    case fuxi = &quot;伏羲式&quot;    case hundun = &quot;混沌式&quot;    case zhenghe = &quot;正和式&quot;    case zhongni = &quot;仲尼式&quot;    case liezi = &quot;列子式&quot;    var id: String &#123; self.rawValue &#125;    /// 形制图片名称    var imageName: String &#123;        switch self &#123;        case .fuxi:            return &quot;guqin_fuxi&quot;        ...    &#125;\n\n\nCodable 使得设计配置可以方便地以JSON格式加密和解密或者存储\n\n分别为古琴的特征设计在model层面的数据模型之后，从视图的角度出发，我们需要根据用户选择的特征来显示对应的选项内容，因此需要额外定义类别的枚举：\nenum CustomizationCategory: String, CaseIterable, Identifiable &#123;    case shape = &quot;形制&quot;    case material = &quot;材质&quot;    case inscription = &quot;铭文&quot;    case stringsCount = &quot;弦数&quot;    case stringsMaterial = &quot;弦材质&quot;    case tuning = &quot;音准&quot;    var id: String &#123; self.rawValue &#125;    &#125;\n\n为了存储配置，以及显示当前的配置信息等要求，我们定义一个当前配置的结构体：\nstruct GuqinConfiguration: Codable, Equatable &#123;    var shape: GuqinShape    var material: GuqinMaterialType    var inscription: GuqinInscription    var stringsCount: GuqinStringsCount    var stringsMaterial: GuqinStringsMaterial    var tuning: GuqinTuning       /// 默认配置    // 使用 &#x27; 避免成为关键字处理    static let `default` = GuqinConfiguration(        shape: .fuxi,        material: .blackLacquer,        inscription: .default,        stringsCount: .sevenStrings,        stringsMaterial: .nylon,        tuning: .defaultSevenStrings,        isShowingBack: false    )    /// 配置名称（用于保存和显示）    var displayName: String &#123;        return &quot;\\(shape.rawValue) · \\(material.rawValue) · \\(stringsCount.rawValue)&quot;    &#125;    /// 根据弦数更新音准设置    mutating func updateTuningForStringsCount() &#123;        tuning = GuqinTuning.defaultTuning(for: stringsCount)    &#125;&#125;\n\n\nmutating用于声明该方法可以改写结构体或者枚举的属性，因为出于数据安全的角度考虑， swift默认禁止值类型修改自身的属性\n\n总结：模型层是纯粹的数据和业务规则的定义，它不关心 UI 如何展示这些数据，也不直接处理用户交互\nviewmodel视图模型是数据与逻辑的桥梁，让 UI 能够响应用户的操作并展示最新的数据\n在 SwiftUI 中，视图模型通常是一个遵循 ObservableObject 协议的 class，并通过 @Published 属性发布其状态变化\n// MARK: - Published Properties    @Published var currentConfiguration: GuqinConfiguration = .default    @Published var selectedCategory: CustomizationCategory = .shape    @Published var isPreviewMode: Bool = false\n\n状态管理：\n\n@Published var currentConfiguration: GuqinConfiguration：这是视图模型的核心。它持有 GuqinConfiguration 的实例，代表了用户当前定制古琴的实时状态。当 currentConfiguration 的任何属性发生变化时，由于 @Published 的存在，所有观察它的视图都会自动刷新，从而实现 UI 的响应式更新\n@Published var selectedCategory: CustomizationCategory：管理用户当前选择的定制类别（如形制、材质），这直接影响到 UI 中显示哪些具体的定制选项\n\n业务逻辑与方法：我们在视图模型中定义一系列的公共方法，类似于oop中的方法，供其他对象调用（在这里是高层的视图）\n\nselectShape(_ shape: GuqinShape)、selectMaterial(_ material: GuqinMaterialType) 等方法是视图模型暴露给视图的公共接口。当用户在 UI 中选择一个形制或材质时，视图会调用 viewModel 中对应的方法。这些方法负责更新currentConfiguration，并可能包含额外的业务逻辑（如触觉反馈、动画触发）。\nfunc selectMaterial(_ material: GuqinMaterialType) &#123;        withAnimation(.easeInOut(duration: 0.3)) &#123;            currentConfiguration.material = material        &#125;        // 触觉反馈        let impactFeedback = UIImpactFeedbackGenerator(style: .medium)        impactFeedback.impactOccurred()    &#125;\n\n\nwithAnimation 作为动画包裹器，接受一个动画参数和闭包作为输入，为闭包内部相关的UI变化自动赋予动画效果\n\n\n\n数据转换（计算属性）：通过使用计算属性，比如上述model的琴身形制中的 imageName返回在assests中的实际图片名称，此时在view中定义的方法很简单：\nvar currentShapeImageName: String &#123;        return currentConfiguration.shape.imageName&#125;\n\n如果我们希望在view中使用默认的SF符号，可以在view中定义计算属性：\nprivate var systemIconName: String &#123;        switch category &#123;        case .shape:            return &quot;rectangle.3.group&quot;        case .material:            return &quot;paintbrush.fill&quot;        case .inscription:            return &quot;text.word.spacing&quot;        case .stringsCount:            return &quot;waveform&quot;        case .stringsMaterial:            return &quot;fiberchannel&quot;        case .tuning:            return &quot;tuningfork&quot;        &#125;    &#125;\n\n然后可以直接在当前结构体（view本身也是结构体）中调用：\nImage(systemName: systemIconName)  .foregroundColor(isSelected ? .accentColor : .secondary)\n\n\ncurrentShapeImageName、currentMaterialTextureImageName 等计算属性：这些属性将 currentConfiguration 中的原始模型数据（如枚举值）转换为视图可以直接使用的格式（如图片名称字符串、Color 类型），避免视图直接处理复杂的模型逻辑，保持视图的简洁性\n\n为了判断某个选择项是否被选中，比如下方“伏羲式”是选中的，需要处理额外的视觉、触觉处理：\n\n\n我们可以使用泛型的思想定义一个函数：\nfunc isSelected&lt;T: Equatable&gt;(_ option: T, in category: CustomizationCategory) -&gt; Bool &#123;    switch category &#123;    case .shape:        if let shape = option as? GuqinShape &#123;            return currentConfiguration.shape == shape // 如果输入的参数类型正确，与当前的配置比较        &#125;    ...    default:        break    &#125;    return false&#125;\n\n\n以shape为例，首先尝试将输入的泛型参数option转换为形制的类型；\nas是条件类型转换运算符：如果转换成功，返回转换之后的值；否则返回 nil\n此处配置中的shape同样是一个枚举 GuqinShape，枚举值就是具体的形制名称 。所以上述的比较就是\n\n我们也可以使用泛型约束的方式来改写上述检查：\nfunc isSelected&lt;T: Equatable&gt;(_ option: T, in category: CustomizationCategory) -&gt; Bool &#123;    switch category &#123;    case .shape:        guard let shape = option as? GuqinShape else &#123;return false&#125;      \treturn currentConfiguration.shape == shape    ...    default:        break    &#125;    return false&#125;\n\n总结：视图模型是应用逻辑的核心。它从模型中获取数据，处理用户交互，更新模型状态，并通过 @Published 属性将最新的状态通知给视图。它充当了模型和视图之间“翻译官”和“协调者”。\n\nview视图层是用户直接看到和交互的部分。在 SwiftUI 中，视图是轻量级的 struct，它们声明式地描述了 UI 的外观，并响应视图模型发布的状态变化:\n\n主视图 (GuqinCustomizationView.swift)：\n\n职责：作为古琴定制功能的主入口和布局容器, 不直接处理复杂的业务逻辑，而是将这些职责委托给视图模型和子视图。\n\n状态绑定：通过 @StateObject private var viewModel = GuqinCustomizationViewModel() 实例化并持有视图模型。@StateObject 确保了视图模型在视图生命周期内只被创建一次，并且其 @Published 属性的变化能够驱动视图的刷新。\n@StateObject private var viewModel = GuqinCustomizationViewModel()\nUI 结构：它将整个界面划分为几个主要区域：\n\ncenterPreviewArea：用于显示古琴的实时预览;\ncategoryScrollView：横向滚动的类别选择器;\nCustomizationOptionSelector：底部的定制选项面板;\n\n\n交互委托：视图中的按钮（如切换预览模式、重置）直接调用 viewModel 中对应的方法，将用户操作传递给视图模型处理。\n\n\n\n组件（Components）——可重用的 UI 模块：\n\n职责：这些是更小、更专注的 UI 单元，它们封装了特定的 UI 元素和行为，提高了代码的复用性。\nGuqinPreviewView：\n职责：专门负责古琴的视觉渲染。它接收来自 GuqinCustomizationViewModel 的各种参数（如 shapeImageName、materialTextureImageName、stringsImageName、inscription 等），并利用 ZStack、Image、mask、blendMode 等 SwiftUI 修饰符，将这些图像层叠加组合，最终呈现出定制后的古琴\n状态传递：它通过属性接收数据，而不是直接观察视图模型，这使得它成为一个“哑视图”（Dumb View），只负责展示.\n\n\nOptionThumbnailButton：\n职责：通用的选项缩略图按钮。\n状态传递：接收 thumbnailImage、title 和 isSelected 等参数。isSelected 参数决定了按钮的视觉状态（如边框颜色、缩放效果），这个值通常来自视图模型。\n交互：通过 action 闭包将点击事件回调给父视图（通常是 CustomizationOptionSelector），再由父视图调用视图模型的方法。\n\n\n\n\n\n子视图中, 如果需要观察对应的视图模型, i.e. :\nstruct CustomizationOptionSelector: View &#123;    @ObservedObject var viewModel: GuqinCustomizationViewModel      var body: some View &#123;        VStack(spacing: 12) &#123;               // 选项滚动视图            ScrollView(.horizontal, showsIndicators: false) &#123;                HStack(spacing: 16) &#123;                    switch viewModel.selectedCategory &#123;                    case .shape:                        ForEach(GuqinShape.allCases) &#123; shape in                          ...                        &#125;\n\n\n使用视图模型中存储的“当前选中类别”的信息, 选择显示对应的选项滚动视图\n\n此时, 由于我们已经在外层的视图创建并管理了一个视图模型的实例, 只需要将这个实例作为参数输入给子视图:\nstruct GuqinCustomizationView: View &#123;    @StateObject private var viewModel = GuqinCustomizationViewModel()    @Environment(\\.dismiss) private var dismiss      var body: some View &#123;        NavigationView &#123;            GeometryReader &#123; geometry in                VStack(spacing: 0) &#123;                   ...                    // 底部选择面板                    CustomizationOptionSelector(viewModel: viewModel)                        .frame(height: 140)                &#125;            &#125;            ...        &#125;\n\n\n节（Sections) : 用于组织复杂视图\n职责：将一个大视图分解成逻辑上独立的、可重用的“节”。每个节可以有自己的视图模型或直接观察父视图模型的一部分\n\n\n\n\n状态变量的使用我们之前提到过, Swift UI之所以适合使用MVVM模式, 是因为内置的一系列状态变量的优势. 此处补充总结几个状态变量的用途和示例:\n\n@State：\n\n用途：用于管理视图内部的、简单的、私有的状态。当 @State 变量的值改变时，SwiftUI 会自动重新渲染使用该变量的视图。\n示例：在 InscriptionEditor 中，@State private var inscriptionText: String 和 @State private var fontSize: CGFloat 就是典型的 @State 变量，它们管理着铭文编辑器的临时输入和字体大小。这些状态只在 InscriptionEditor 内部有意义，当它们需要影响到全局的古琴配置时，会通过调用 viewModel.updateInscription() 来更新 viewModel 中的 currentConfiguration。\n\n\n@StateObject：\n\n用途：用于在视图的生命周期内创建并持有 ObservableObject 的实例。当视图首次出现时，@StateObject 会创建并初始化一个视图模型实例，并在视图的整个生命周期中保持这个实例。\n示例：在 GuqinCustomizationView 中，@StateObject private var viewModel = GuqinCustomizationViewModel() 就是这样使用的。它确保了 GuqinCustomizationViewModel 在 GuqinCustomizationView 存在期间唯一，并且其 @Published 属性的变化能够驱动 GuqinCustomizationView 及其子视图的刷新;\n\n\n@ObservedObject：\n\n用途：用于在子视图中观察父视图或其他来源传递过来的 ObservableObject 实例。它不负责创建实例，只负责观察。\n\n\n@Binding：\n\n用途：用于在父视图和子视图之间创建双向绑定。子视图可以读取和修改绑定值，而这些修改会反映到父视图的原始数据源上。\n\n示例：在 TuningEditor 中，Slider 的 value 参数使用了 Binding：\nSlider(    value: Binding(        get: &#123; viewModel.currentConfiguration.tuning.stringTunings[index] &#125;,        set: &#123; newValue in            var tuning = viewModel.currentConfiguration.tuning            tuning.stringTunings[index] = newValue            viewModel.updateTuning(tuning)        &#125;    ),    in: 0.0...1.0)\n\n这里创建了一个临时的 Binding，它从 viewModel.currentConfiguration.tuning.stringTunings[index] 获取值，并在值改变时调用 viewModel.updateTuning() 来更新视图模型中的数据。\n\n\n\n\n \n  \n    Binding通常用于修改父视图的部分属性, 不会持有或者管理数据, 只是引用父视图的数据 \n\n  \n\n\n@Environment：\n用途：用于访问 SwiftUI 环境中提供的共享数据，如 \\.dismiss（用于关闭视图）、\\.colorScheme 等。\n\n\n\n如果希望避免视图模型实例的层层嵌套的传递, 我们可以在创建和管理该实例的view中将其作为环境对象注入到子视图中:\nstruct GuqinCustomizationView: View &#123;    @StateObject private var viewModel = GuqinCustomizationViewModel() // 保持不变, 创建和管理实例    @Environment(\\.dismiss) private var dismiss      var body: some View &#123;        NavigationView &#123;            GeometryReader &#123; geometry in                VStack(spacing: 0) &#123;                    // 古琴预览区域                    centerPreviewArea                        .frame(maxHeight: .infinity)                    // 类别选择滚动条                    categoryScrollView                        .frame(height: 80)                        .padding(.vertical, 8)                    // 底部选择面板                    CustomizationOptionSelector // 不再需要显式给出参数                        .frame(height: 140)                &#125;                .environmentObject(viewModel) // 注入环境对象, 供子视图直接访问            &#125;\n\n对应的, 我们在需要访问该视图模型的子视图中声明观察:\nstruct CustomizationOptionSelector: View &#123;    @EnvironmentObject var viewModel: GuqinCustomizationViewModel // &lt;-- 更改为 @EnvironmentObject    var body: some View &#123;        // ... existing code ...        // 内部使用 viewModel 的方式不变        switch viewModel.selectedCategory &#123;        // ...        case .inscription:            // 传递给 InscriptionEditor 也不再需要显式参数            InscriptionEditor() // &lt;-- 不再需要 viewModel: viewModel        case .tuning:            // 传递给 TuningEditor 也不再需要显式参数            TuningEditor() // &lt;-- 不再需要 viewModel: viewModel        &#125;        // ... existing code ...    &#125;&#125;\n\n\n  \n    只需要在顶层视图注入一次, 由此避免了繁琐的参数传递 \n\n  \n\n\n数据流与事件流现在，让我们把所有模块串联起来，看看它们是如何协同工作的：\n数据流向：\n\n自上而下（数据流）：ViewModel 发布状态变化 (@Published) -&gt; View 观察 (@StateObject&#x2F;@ObservedObject) -&gt; View 刷新 UI，并将数据传递给子视图（通过属性或 @Binding）。\n自下而上（事件流）：用户在 View 中交互 -&gt; View 调用 ViewModel 的方法 -&gt; ViewModel 更新 Model 状态 -&gt; ViewModel 发布状态变化，循环开始。\n\n这种模式使得代码高度解耦，每个模块只关注自己的职责\n","categories":["开发记录"],"tags":["swift","编程语言"]},{"title":"倦鸟","url":"/2025/01/08/poets/bird/","content":"\n\n我盘旋的目光是漂泊不息的倦鸟\n\n越过人海 坠入你乌黑瞳仁中的夜\n\n\n\n下附最初的三节诗, 以及灵感来源.\n\n\n 完整三节诗\n\n我盘旋的目光是漂泊不息的倦鸟 \n越过人海终于落入你乌黑瞳仁中的夜\n\n你澄澈的眼眸映照着闪烁明灭的晨星\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记\n\n我们的目光还是悄然相遇了\n你温和的凝视又让我想起黎明的微光\n我漆黑的羽翼微微颤动 随后灼灼燃烧\n于是 我的目光载着余烬 再度飞远了\n\n\n\n\n 「灵感」Tagore's\n\n\nMy heart, the bird of the wilderness, \nhas found its sky in your eyes.\n\n(出自泰戈尔的园丁集)\n\n\n\n\n","categories":["随笔"],"tags":["短诗"]},{"title":"Prisma","url":"/2025/04/28/Prisma/","content":"Prisma 命令行相关数据库迁移\n创建并应用新的迁移：\nnpx prisma migrate dev --name add_timestamps\n\n根据 schema.prisma 的更改生成迁移文件，并应用到数据库。\n--name 指定迁移的名称。\n\n\n重置并重新应用所有迁移：\nnpx prisma migrate reset\n\n重置数据库并重新应用所有迁移，适用于开发环境。\n\n\n生成迁移文件但不应用：\nnpx prisma migrate dev --create-only\n\n生成迁移文件但不应用到数据库，可以手动修改迁移文件后再应用。\n\n\n应用未应用的迁移：\nnpx prisma migrate deploy\n\n将未应用的迁移应用到生产环境。\n\n\n查看迁移状态：\nnpx prisma migrate status\n\n查看当前数据库的迁移状态。\n\n\n回滚迁移状体;\nnpx prisma migrate resolve --rolled-back &lt;migration_name&gt;\n\n\n数据库操作\n生成 Prisma 客户端：\nnpx prisma generate\n\n根据 schema.prisma 生成 Prisma 客户端代码。\n\n\n推送 schema 到数据库（不生成迁移）：\nnpx prisma db push\n\n将 schema.prisma 的更改直接应用到数据库，不生成迁移文件。\n\n\n查看数据库数据：\nnpx prisma studio\n\n启动 Prisma Studio，一个可视化工具，用于查看和操作数据库数据。\n\n\n\n\n数据操作\n执行种子脚本：\nnpx prisma db seed\n\n运行 prisma/seed.ts 或 prisma/seed.js 脚本，用于填充数据库初始数据。\n\n\n运行自定义脚本：\nnpx prisma execute --file ./scripts/my-script.ts\n\n执行自定义的 TypeScript 或 JavaScript 脚本。\n\n\n\n\n其他常用命令\n初始化 Prisma：\nnpx prisma init\n\n初始化 Prisma，生成 prisma/schema.prisma 和 .env 文件。\n\n\n格式化 schema.prisma：\nnpx prisma format\n\n格式化 schema.prisma 文件，使其更易读。\n\n\n检查 Prisma 版本：\nnpx prisma --version\n\n查看当前安装的 Prisma 版本。\n\n\n清理未使用的迁移文件：\nnpx prisma migrate resolve --applied &quot;20231010123456_add_timestamps&quot;\n\n标记迁移文件为已应用，用于修复迁移状态不一致的问题。\n\n\n\n\n语言特性Prisma 中的关系定义需要双向声明\n\n在引用表中进行外键的声明\nmodel BorrowRecord &#123;\tbookId string \tbook       Book       @relation(fields: [bookId], references: [id])&#125;\n\n\n表示当前表中的 bookId字段是被应用表 Book 的属性 id的外键.\n\n\n同时在被引用表中定义:\nmodel Book&#123;  id             String         @id  borrowRecords  BorrowRecord[] // 添加反向关系&#125;\n\n\n使用TS交互客户端Prisma Client 是一个类型安全的数据库查询工具，它根据 schema.prisma 文件生成 TypeScript 类型定义和数据库操作 API。\n以下是其主要功能及代码示例。\n\n1. 初始化 Prisma Client在使用 Prisma Client 之前，需要初始化一个 PrismaClient 实例。\nimport &#123; PrismaClient &#125; from &#x27;@prisma/client&#x27;;const prisma = new PrismaClient();\n\n\n2. 查询数据\n查询所有记录\n\n使用 findMany 方法查询表中的所有记录。\nasync function getAllUsers() &#123;  const users = await prisma.user.findMany();  console.log(&#x27;All users:&#x27;, users);&#125;getAllUsers();\n\n\n查询单条记录\n\n使用 findUnique 方法根据唯一条件查询单条记录。\nasync function getUserById(id: number) &#123;  const user = await prisma.user.findUnique(&#123;    where: &#123; id &#125;,  &#125;);  console.log(&#x27;User:&#x27;, user);&#125;getUserById(1);\n\n\n条件查询\n\n使用 where 条件过滤查询结果。\nasync function getUsersByName(name: string) &#123;  const users = await prisma.user.findMany(&#123;    where: &#123; name &#125;,  &#125;);  console.log(&#x27;Users with name:&#x27;, name, users);&#125;getUsersByName(&#x27;Alice&#x27;);\n\n\n3. 创建数据使用 create 方法插入新数据:\nasync function createUser(name: string, email: string) &#123;  const newUser = await prisma.user.create(&#123;    data: &#123;      name,      email,    &#125;,  &#125;);  console.log(&#x27;Created new user:&#x27;, newUser);&#125;createUser(&#x27;Bob&#x27;, &#x27;bob@example.com&#x27;);\n\n\n4. 更新数据使用 update 方法修改现有数据。\nasync function updateUserEmail(id: number, newEmail: string) &#123;  const updatedUser = await prisma.user.update(&#123;    where: &#123; id &#125;,    data: &#123; email: newEmail &#125;,  &#125;);  console.log(&#x27;Updated user:&#x27;, updatedUser);&#125;updateUserEmail(1, &#x27;alice_new@example.com&#x27;);\n\n\n5. 删除数据使用 delete 方法删除数据。\nasync function deleteUser(id: number) &#123;  const deletedUser = await prisma.user.delete(&#123;    where: &#123; id &#125;,  &#125;);  console.log(&#x27;Deleted user:&#x27;, deletedUser);&#125;deleteUser(1);\n\n\n6. 关系查询\n查询关联数据\n\n使用 include 查询关联的模型数据。\nasync function getUserWithPosts(userId: number) &#123;  const userWithPosts = await prisma.user.findUnique(&#123;    where: &#123; id: userId &#125;,    include: &#123; posts: true &#125;, // 假设 User 模型与 Post 模型有关联  &#125;);  console.log(&#x27;User with posts:&#x27;, userWithPosts);&#125;getUserWithPosts(1);\n\n\n嵌套查询\n\n支持嵌套查询关联数据。\nasync function getPostWithAuthor(postId: number) &#123;  const postWithAuthor = await prisma.post.findUnique(&#123;    where: &#123; id: postId &#125;,    include: &#123; author: true &#125;, // 假设 Post 模型与 User 模型有关联  &#125;);  console.log(&#x27;Post with author:&#x27;, postWithAuthor);&#125;getPostWithAuthor(1);\n\n\n7. 分页查询使用 skip 和 take 实现分页查询。\nasync function getUsersPaginated(page: number, pageSize: number) &#123;  const users = await prisma.user.findMany(&#123;    skip: (page - 1) * pageSize,    take: pageSize,  &#125;);  console.log(&#x27;Paginated users:&#x27;, users);&#125;getUsersPaginated(1, 10); // 查询第 1 页，每页 10 条记录\n\n\n8. 排序查询使用 orderBy 对查询结果排序。\nasync function getUsersSortedByName() &#123;  const users = await prisma.user.findMany(&#123;    orderBy: &#123; name: &#x27;asc&#x27; &#125;, // 按 name 字段升序排序  &#125;);  console.log(&#x27;Sorted users:&#x27;, users);&#125;getUsersSortedByName();\n\n\n9. 聚合查询使用 count、sum、avg 等聚合函数。\n\n统计记录数\n\nasync function countUsers() &#123;  const userCount = await prisma.user.count();  console.log(&#x27;Total users:&#x27;, userCount);&#125;countUsers();\n\n\n计算字段平均值\n\nasync function averageUserAge() &#123;  const avgAge = await prisma.user.aggregate(&#123;    _avg: &#123; age: true &#125;, // 假设 User 模型有 age 字段  &#125;);  console.log(&#x27;Average user age:&#x27;, avgAge._avg.age);&#125;averageUserAge();\n\n\n10. 事务操作使用 $transaction 执行事务操作。\nasync function transferBalance(fromId: number, toId: number, amount: number) &#123;  await prisma.$transaction([    prisma.user.update(&#123;      where: &#123; id: fromId &#125;,      data: &#123; balance: &#123; decrement: amount &#125; &#125;, // 假设 User 模型有 balance 字段    &#125;),    prisma.user.update(&#123;      where: &#123; id: toId &#125;,      data: &#123; balance: &#123; increment: amount &#125; &#125;,    &#125;),  ]);  console.log(&#x27;Balance transfer completed&#x27;);&#125;transferBalance(1, 2, 100);\n\n\n11. 关闭 Prisma Client在程序结束时，关闭 Prisma Client 以释放数据库连接。\nasync function main() &#123;  // 数据库操作代码&#125;main()  .catch(e =&gt; &#123;    console.error(e);  &#125;)  .finally(async () =&gt; &#123;    await prisma.$disconnect();  &#125;);\n\n\n","categories":["前后端开发"],"tags":["数据库"]},{"title":"makefile","url":"/2025/02/12/%E5%85%B6%E4%BB%96/makefile/","content":"编译基本概念默认目标\nMakefile当中的第一个目标会成为默认目标;\n不指定参数的make命令会执行默认目标;\n通常使用all的伪目标作为默认目标.\n\n伪目标当我们需要执行清理工作、运行测试等操作时, 我们不希望与实际文件名发生冲突, 此时就需要用到 伪目标.\n语法\n.PHONY: 目标名目标名:    命令\n\n使用示例\n# 情景：需要清理编译产生的 .o 文件和可执行文件.PHONY: cleanclean:    rm -f *.o program# 情景：需要运行测试.PHONY: testtest:    ./run_tests.sh# 使用方法：# make clean  # 清理文件# make test   # 运行测试\n\n其中-f表示强制删除, 其他的参数如-r表示递归删除目录, -rf表示强制递归删除目录.\n\n多重构建我们还可以利用伪目标使得默认目标具有多个对象:\n.PHONY: all debug release clean# 默认目标包含常用的构建类型all: debug release# 调试版本debug: main.c    @echo &quot;构建调试版本...&quot;    gcc -g main.c -o debug-program# 发布版本release: main.c    @echo &quot;构建发布版本...&quot;    gcc -O2 main.c -o release-programclean:    rm -f debug-program release-program# 使用：# make          # 构建调试版和发布版# make debug    # 只构建调试版# make release  # 只构建发布版# make clean    # 清理\n\n多目标e.g: \nbigoutput littleoutput : text.g    generate text.g -$(subst output,,$@) &gt; $@\n\n解析bigoutput littleoutput : text.g    generate text.g -$(subst output,,$@) &gt; $@\n\n\nbigoutput littleoutput - 两个目标文件\ntext.g - 依赖文件\n$(subst output,,$@) -变量展开：\n$@ 是自动变量，表示当前目标名\nsubst 是替换函数，格式为 $(subst from,to,text)\n此处将目标名中的 “output” 替换为空\n\n\n\n当规则执行时：\n\n对于 bigoutput 目标：\n\n$@ 展开为 bigoutput\n$(subst output,,$@) 结果为 big\n最终命令变为：generate text.g -big &gt; bigoutput\n\n\n对于 littleoutput 目标：\n\n$@ 展开为 littleoutput\n$(subst output,,$@) 结果为 little\n最终命令变为：generate text.g -little &gt; littleoutput\n\n\n\n\n\n因此, 上述的多目标规则等价于:\nbigoutput : text.g    generate text.g -big &gt; bigoutputlittleoutput : text.g    generate text.g -little &gt; littleoutput\n\n规则语法多目标规则（Multiple Targets）是 Makefile 中的一个重要特性：\n\n基本语法：\ntarget1 target2 : prerequisites    commands\n\n特点：\n\n多个目标共享相同的依赖关系\n命令会对每个目标分别执行一次\n可以使用 $@ 引用当前正在构建的目标\n\n\n使用场景：\n\n生成相似但略有不同的文件\n多个目标需要类似的构建过程\n减少重复代码\n\n\n示例：\n# 生成不同大小的图片big.jpg small.jpg : original.jpg    convert original.jpg -resize $* &gt; $@# 生成不同格式的文档manual.pdf manual.html : manual.txt    pandoc manual.txt -o $@\n\n优势：\n\n代码更简洁\n易于维护\n避免重复规则\n更好的规则组织\n\n\n注意事项：\n\n命令对每个目标都会执行一次\n需要合理使用自动变量（如 $@）来区分不同目标\n确保命令对所有目标都适用\n\n\n\n静态模式好的，让我从这几个角度来介绍 Makefile 中的静态模式规则。\n1. 引入背景在 Makefile 中，当我们需要将多个源文件编译成对应的目标文件时，如果按照普通的规则写法，往往需要为每个文件都写一条规则：\nfoo.o : foo.c    $(CC) -c $(CFLAGS) foo.c -o foo.obar.o : bar.c    $(CC) -c $(CFLAGS) bar.c -o bar.otest.o : test.c    $(CC) -c $(CFLAGS) test.c -o test.o\n\n这种写法存在明显问题：\n\n规则重复，维护困难\n当新增源文件时需要手动添加规则\n代码冗长，不够优雅\n\n虽然可以使用多目标规则，但在处理源文件和目标文件的对应关系时仍然不够灵活。这就是引入静态模式规则的原因。\n2. 基本语法静态模式规则的基本语法如下：\ntargets ...: target-pattern: prereq-pattern    commands\n\n其中：\n\ntargets: 要生成的目标文件列表\ntarget-pattern: 目标的模式，通常包含 % 通配符\nprereq-pattern: 依赖的模式，通常也包含 % 通配符\ncommands: 构建命令\n\n% 在 target-pattern 中匹配的内容，会在 prereq-pattern 中作为相同的替换内容。\n3. 综合示例让我们通过几个逐渐复杂的例子来说明静态模式的使用：\n基础示例：编译 C 文件objects = foo.o bar.o test.o$(objects): %.o: %.c    $(CC) -c $(CFLAGS) $&lt; -o $@\n\n复杂示例：多种源文件处理# 定义源文件和目标文件cpp_sources := $(wildcard *.cpp)c_sources := $(wildcard *.c)cpp_objects := $(cpp_sources:.cpp=.o)c_objects := $(c_sources:.c=.o)all_objects := $(cpp_objects) $(c_objects)# C++ 源文件的编译规则$(cpp_objects): %.o: %.cpp    $(CXX) -c $(CXXFLAGS) $&lt; -o $@# C 源文件的编译规则$(c_objects): %.o: %.c    $(CC) -c $(CFLAGS) $&lt; -o $@# 生成可执行文件program: $(all_objects)    $(CXX) $^ -o $@\n\n$(cpp_sources:.cpp=.o)是一种模式替换, 会将cpp_sources中的所有.cpp文件替换为.o文件;\n即$(varname:pattern1=pattern2) 会将varname中的所有pattern1替换为pattern2;\n\n\n\n更复杂的示例：多目录处理# 目录结构SRCDIR = srcOBJDIR = obj# 源文件和目标文件SOURCES = $(wildcard $(SRCDIR)/*.c)OBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)# 确保目标目录存在$(OBJDIR):    mkdir -p $@# 静态模式规则$(OBJECTS): $(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)    $(CC) -c $(CFLAGS) $&lt; -o $@# 最终目标program: $(OBJECTS)    $(CC) $^ -o $@\n\ntodo\n\n这个复杂示例展现了 Makefile 在处理现代项目时的多个高级特性。在文件组织方面，示例实现了跨目录的文件处理能力，通过将源文件和目标文件分别组织在不同的目录（如 src 和 obj）中，体现了项目结构的清晰性和模块化。Makefile 能够智能地在这些目录间进行文件操作，保持项目的整洁有序。\n在目录管理方面，示例引入了自动创建目标目录的机制。通过使用条件依赖（用 | 分隔符标识），确保在编译过程开始前目标目录已经存在。这种方式优雅地解决了目录创建的时序问题，避免了因目录不存在而导致的编译失败。特别是当多个目标文件同时需要某个目录时，条件依赖能够确保目录创建操作只执行一次，提高了构建效率。\n在文件名处理方面，示例展示了复杂的文件名转换技巧。通过巧妙运用 Make 的模式替换功能，实现了从源文件到目标文件的路径和扩展名转换。例如，将 src/main.c 转换为 obj/main.o，这种转换不仅处理了文件扩展名的变化，还同时处理了目录路径的变化。这种灵活的文件名处理机制，使得 Makefile 能够适应更复杂的项目结构和构建需求，同时保持了规则的简洁性和可维护性。\n\n基本规则target ... : prerequisites ...    recipe    ...    ...\ntarget: 目标文件 | 可执行文件 | 标签;prerequisites: 依赖文件 | target;recipe: 对应target所需的命令(以Tap缩进开头).\n\n\n执行recipe命令的条件:\n\nprerequisites中存在文件的日期早于target的日期;\ntarget的文件不存在.\n\n使用变量# 定义变量: 类似于C的宏定义objects = main.o display.o# 使用变量edit: $(objects)    cc -o edit $(objects)\n\n必须使用Tab缩进;\n采取$(variable)的形式引用变量, 将会展开为变量的值;\ncc -o edit 声明采用C语言编译器同时指定输出文件名为edit.\n\nMake的自动推导自动推导规则\n文件关联：\n\n当make看到.o文件时，会自动将对应的.c文件加入依赖关系\n例如：发现whatever.o时，会自动关联whatever.c作为依赖文件\n\n\n命令推导：\n\n自动推导编译命令，如cc -c whatever.c\n无需在每个.o文件后都手动写编译命令\n\n\n\n示例结构\n依赖关系：\n\n# 自动推导之前main.o : main.c defs.h    cc -c main.c# 自动推导下的简化书写main.o : defs.h\n\n\n清理目标：\n\n.PHONY : cleanclean :    rm edit $(objects)\n\n\n.PHONY表示clean是伪目标文件;\n这种自动推导方式大大简化了Makefile的编写;\nclean总是放在文件的末尾.\n\nmake命令在默认情况下会在当前目录下依次寻找文件名为GNUmakefile,makefile,Makefile的文件.\n\n推荐使用Makefile作为文件名;\n也可以使用-f或者-file参数来指定特定的Makefile文件.\n\nmake -f Make.Linux\n\n\n\n\ninclude命令# 使用include命令可以将其他Makefile包含进来include &lt;file-name&gt;\n\ninclude命令前可以存在空字符, 但是不能为Tab缩进;\ninclude与文件之间可以存在多个空格.\n\n直接指定文件# 最基本的include用法是直接指定文件名include config.mkinclude ./build/rules.mk# 同时包含多个文件include config.mk rules.mk tests.mk\n\n使用通配符 *# * 匹配任意字符串include *.mk              # 包含当前目录下所有.mk文件include src/*.mk         # 包含src目录下的所有.mk文件include **/build/*.mk    # 包含任意子目录中build目录下的所有.mk文件\n\n我们同样可以在变量中使用通配符 *:\n# 使用时展开objects = *.o# 定义时展开(除非重新赋值, 否则保持定义时的展开状态)objects := $(wildcard *.o)\n\ne.g:\n$(patsubst %.c,%.o,$(wildcard *.c))\n\npatsubst是一个函数, 用于模式替换;\n语法为patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;;\n此处表示利用通配符, 将所有的.c文件名称替换为.o文件.\n\n使用单字符通配符# ? 匹配单个字符include test?.mk         # 匹配test1.mk, testA.mk等include rule_?.mk        # 匹配rule_1.mk, rule_2.mk等include config???.mk     # 匹配config后带三个字符的.mk文件\n\n使用目录路径# 可以指定不同的目录路径include ./configs/*.mk    # 当前目录下的configs子目录include ../shared/*.mk    # 上级目录的shared子目录include /usr/local/include/make/*.mk  # 绝对路径\n\n使用字符集[]# [] 用于匹配字符集中的任意一个字符include make[123].mk     # 匹配make1.mk, make2.mk, make3.mkinclude test[a-z].mk     # 匹配testa.mk到testz.mkinclude config[0-9].mk   # 匹配config0.mk到config9.mk\n\n错误处理# 默认情况下，如果include的文件不存在，make会报错# 使用-include或sinclude可以忽略文件不存在的错误-include optional.mk     # 如果文件不存在，继续执行不报错sinclude optional.mk     # 与-include完全相同# 多个可选文件-include config/*.mk     # 如果config目录下有任何.mk文件不存在，继续执行\n\n组合使用示例# 可以组合使用多种模式include config.mk \\        rules/*.mk \\        test[0-9].mk \\        ./build/**/*.mk# 使用变量INCLUDE_DIR = ./includesinclude $(INCLUDE_DIR)/*.mk# 条件包含ifdef CUSTOM_RULES    include $(CUSTOM_RULES)endif\n\nmake的工作方式\n读取所有的Makefile;\n读取include涉及的Makefile文件;\n初始化文件当中的变量;\n推导隐式规则并分析所有规则;\n为目标文件创建依赖关系链;\n根据依赖关系, 决定需要重新生成的文件;\n执行生成命令.\n\n文件搜寻VPATH默认情况下, make会在当前目录和所有子目录下寻找依赖文件和目标文件.为了能够在较大工程中扩大make的搜索范围, 我们可以通过特殊变量VPATH来指定搜索路径.\nVPATH = src:../headers\n\n不同的目录之间由:分隔, 上述定义指定了额外的src以及../headers目录;\n当前目录的优先级最高, 在当前目录下无法找到相关文件时将会从指定的目录中从左到右继续寻找.\n\nvpath上述的VPATH指定了全局文件的搜索路径, 而vpath允许为不同类型的文件指定不同的搜索路径.\n语法\n# 1. 为指定模式的文件设置搜索路径vpath pattern directory1:directory2# 2. 清除指定模式的搜索路径vpath pattern# 3. 清除所有已设置的 vpathvpath\n\n特点\n\n可以为不同类型的文件指定不同的搜索路径;\n支持使用 % 通配符匹配文件名;\n可以有多条 vpath 指令, 且针对相同模式的命令将会起到附加而非覆盖的作用.\n\ne.g.\n# 定义编译器CC = gccvpath %.h includevpath %.c srcvpath %.o buildvpath %.a libprogram: main.o utils.o    $(CC) -o program main.o utils.o -L. -lmylibmain.o: main.c project.h    $(CC) -c main.cutils.o: utils.c utils.h    $(CC) -c utils.c\n\n\nvpath的指令必须都写在Makefile当中, 在Make解析Makefile文件时被处理, 例如:\n# 如果需要清理 .o 文件的搜索路径并重新设置clean-paths:\t# 清除 .o 文件的搜索路径\tvpath %.o\t# 设置新的搜索路径\tvpath %.o new/build# 如果需要完全重置所有搜索路径reset-paths:\t# 清除所有 vpath 设置\tvpath\t# 重新设置所需的搜索路径\tvpath %.h include\tvpath %.c src\tvpath %.o build\n在终端中对应的指令:\n$ make              # 使用默认搜索路径编译$ make clean-paths  # 执行搜索路径清理和重设$ make reset-paths  # 重置所有搜索路径\n\n\n优先级: 当前目录 &gt; vpath &gt; VPATH. \n"},{"title":"晚霞","url":"/2025/01/09/poets/%E6%99%9A%E9%9C%9E/","content":"\n\n白昼飞红了她的脸颊 \n以隐匿于远山之后的凝望  \n默默期待着  \n月色的降临  \n\n","categories":["随笔"],"tags":["短诗","自然"]},{"title":"pip-tools","url":"/2025/01/15/%E5%85%B6%E4%BB%96/pip-tools/","content":"\n在 Python 项目开发中，依赖管理是一个常见但棘手的问题。特别是在团队协作时，不同成员的环境可能存在细微差异，导致”在我这里能运行”的经典问题。针对上述问题, 本文将详细介绍如何使用 pip-tools，实现精确的依赖版本控制。\n为什么需要 pip-tools？传统的依赖管理方式存在以下问题：\n\nrequirements.txt 手动维护容易出错\n间接依赖版本难以控制\n团队成员环境不一致\n依赖更新流程繁琐\n\npip-tools 通过以下特性解决这些问题：\n\n自动生成完整的依赖关系\n锁定所有依赖的具体版本\n支持开发环境和生产环境分离\n提供简单的依赖更新机制\n\n环境准备1. 创建虚拟环境首先，我们需要创建一个独立的 Python 虚拟环境：\n# 安装 virtualenv（如果还没有安装）pip install virtualenv# 创建虚拟环境virtualenv venv# 激活虚拟环境# Linux/macOS:source venv/bin/activate# Windows:.\\venv\\Scripts\\activate\n\n2. 项目结构推荐的项目结构如下：\nmy_project/├── venv/├── requirements.in├── requirements.txt├── requirements-dev.in   # 可选：开发环境依赖├── requirements-dev.txt  # 可选：开发环境依赖锁定文件└── src/\n\npip-tools 的安装与使用1. 安装 pip-toolspip install pip-tools\n\n2. 创建依赖文件创建 requirements.in 文件，列出直接依赖：\n# requirements.inflaskpython-dotenvopenaimarkdown-it-pyfairy-doc[cpu]\n\n注意, 此处不同的依赖包必须分行呈现.\n\n3. 生成锁定文件# 生成 requirements.txtpip-compile requirements.in# 如果有开发依赖pip-compile requirements-dev.in\n\n生成的 requirements.txt 示例：\n## This file is autogenerated by pip-compile# To update, run:##    pip-compile requirements.in#flask==2.3.3  --hash=sha256:...python-dotenv==1.0.0  --hash=sha256:...openai==0.27.8  --hash=sha256:...markdown-it-py==3.0.0  --hash=sha256:...fairy-doc[cpu]==1.2.0  --hash=sha256:...\n\n4. 安装依赖# 安装所有依赖pip-sync requirements.txt# 如果同时需要开发依赖pip-sync requirements.txt requirements-dev.txt\n\n最佳实践1. 版本控制# requirements.inflask&gt;=2.0.0,&lt;3.0.0  # 指定版本范围python-dotenv~=1.0.0  # 允许补丁版本更新openai==0.27.8       # 锁定具体版本\n\n2. 依赖分组# requirements-dev.in-r requirements.in    # 包含基础依赖pytest               # 测试框架black                # 代码格式化flake8               # 代码检查\n\n3. 更新依赖# 更新单个包pip-compile --upgrade-package flask requirements.in# 更新所有包pip-compile --upgrade requirements.in\n\n常见问题解决1. 依赖冲突如果遇到依赖冲突，可以：\n\n检查 requirements.in 中的版本约束\n使用 pip-compile --verbose 查看详细信息\n考虑降级某些包的版本\n\n2. Hash 不匹配如果出现 hash 不匹配：\npip-compile --generate-hashes requirements.in\n\n3. 环境不一致确保团队成员：\n\n使用相同的 Python 版本\n严格执行 pip-sync\n不要手动 pip install\n\n高级用法1. 自定义输出格式# 生成带注释的依赖文件pip-compile --annotate requirements.in# 生成带 hashes 的依赖文件pip-compile --generate-hashes requirements.in\n\n2. 多环境配置# 开发环境pip-compile requirements-dev.in# 生产环境pip-compile requirements.in --output-file requirements-prod.txt\n\n3. 依赖更新策略# 只更新安全相关的包pip-compile --upgrade-package flask --upgrade-package &quot;requests&gt;=2.31.0&quot;# 保持现有版本pip-compile --no-upgrade requirements.in\n\n结语通过使用 pip-tools，我们可以：\n\n实现精确的依赖版本控制\n简化依赖管理流程\n确保团队环境一致性\n提高项目的可维护性\n\n希望这篇指南能帮助你更好地管理 Python 项目的依赖！\n参考资料\npip-tools 官方文档\nPython Packaging User Guide\nPEP 508 – Dependency specification for Python Software Packages\n\n","categories":["通用技能"],"tags":["python","环境配置"]},{"title":"React 主题切换","url":"/2025/01/23/%E5%85%B6%E4%BB%96/themechange/","content":"$\\underline{主题切换}$  即通过点击某个组件来切换背景与文字的颜色等 CSS 属性。这要求我们的组件能够控制某个”环境变量”, 且index.css中的 CSS 应随这个”环境变量”而改变。\n要实现这个需求,我们需要解决以下几个问题：\n\n如何定义和管理这个”环境变量”？\n组件如何控制这个变量？\nCSS 如何响应变量的变化？\n\n这些问题的解决方案涉及到几个重要的基础概念,让我们逐一了解。\n基础知识Context 的创建和使用Context 提供了一种在组件树中共享数据的方式,无需手动在每一层传递 props。\n// 创建 Contextconst ThemeContext = createContext&lt;ThemeType | undefined&gt;(undefined);// 提供 Contextconst ThemeProvider = (&#123; children &#125;) =&gt; &#123;  const [theme, setTheme] = useState(&#x27;light&#x27;);    return (    &lt;ThemeContext.Provider value=&#123;&#123; theme, setTheme &#125;&#125;&gt;      &#123;children&#125;    &lt;/ThemeContext.Provider&gt;  );&#125;;// 使用 Contextconst ChildComponent = () =&gt; &#123;  const &#123; theme &#125; = useContext(ThemeContext);  return &lt;div&gt;Current theme: &#123;theme&#125;&lt;/div&gt;;&#125;;\n因此, 我们可以在src/context/目录下创建一个ThemeContext来定义和管理相关上下文.\n\n在其中利用useState定义主题反转的函数;\n在点击按钮组件中使用上述的函数,\n\nCSS 变量CSS 变量(也称为自定义属性)允许我们定义可重用的值：\n/* 定义变量 */:root &#123;  --primary-color: #007bff;&#125;/* 使用变量 */.button &#123;  background-color: var(--primary-color);&#125;\n\n为了区分CSS的变量与常量, --xx-y的命名格式是CSS变量的规范;\n通过var(&lt;c--xx-y&gt;)的形式使用CSS变量.\n\nHTML data-* 属性document.documentElement.setAttribute(&#39;data-theme&#39;, theme) 的作用是在 HTML 根元素上设置一个自定义数据属性：\n// JavaScript 设置document.documentElement.setAttribute(&#x27;data-theme&#x27;, &#x27;dark&#x27;);// 结果的 HTML&lt;html data-theme=&quot;dark&quot;&gt;  ...&lt;/html&gt;// 对应的 CSS[data-theme=&#x27;dark&#x27;] &#123;  --bg-color: #141414;&#125;\n\n主题切换实现主题变量设计首先设计主题相关的 CSS 变量：\n:root &#123;  /* Light theme variables */  --bg-color: #ffffff;  --text-color: #000000;  --sidebar-bg: #f0f2f5;  --border-color: #e5e2e2;  --shadow-color: rgba(0, 0, 0, 0.1);&#125;[data-theme=&#x27;dark&#x27;] &#123;  --bg-color: #141414;  --text-color: #ffffff;  --sidebar-bg: #1f1f1f;  --border-color: #434343;  --shadow-color: rgba(0, 0, 0, 0.3);&#125;\n\n可根据实际需要增减CSS变量.\n\n主题状态管理创建主题 Context 进行状态管理：\nimport React, &#123; createContext, useState, useContext, useEffect &#125; from &#x27;react&#x27;;type Theme = &#x27;light&#x27; | &#x27;dark&#x27;;interface ThemeContextType &#123;  theme: Theme;  toggleTheme: () =&gt; void;&#125;const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);export const ThemeProvider: React.FC&lt;&#123; children: React.ReactNode &#125;&gt; = (&#123; children &#125;) =&gt; &#123;  const [theme, setTheme] = useState&lt;Theme&gt;(() =&gt; &#123;    const savedTheme = localStorage.getItem(&#x27;theme&#x27;);    return (savedTheme as Theme) || &#x27;light&#x27;;  &#125;);  useEffect(() =&gt; &#123;    document.documentElement.setAttribute(&#x27;data-theme&#x27;, theme);    localStorage.setItem(&#x27;theme&#x27;, theme);  &#125;, [theme]);  const toggleTheme = () =&gt; &#123;    setTheme(prev =&gt; prev === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;);  &#125;;  return (    &lt;ThemeContext.Provider value=&#123;&#123; theme, toggleTheme &#125;&#125;&gt;      &#123;children&#125;    &lt;/ThemeContext.Provider&gt;  );&#125;;export const useTheme = () =&gt; &#123;  const context = useContext(ThemeContext);  if (context === undefined) &#123;    throw new Error(&#x27;useTheme must be used within a ThemeProvider&#x27;);  &#125;  return context;&#125;;\n\n\n\n在设置上下文组件之后, 我们需要明确其作用的范围. 我们希望主题变色需要在全局范围内生效, 以react框架为例:\n&lt;!-- App.tsx --&gt;import &#123; ThemeProvider &#125; from &#x27;./context/ThemeContext&#x27;;function App()&#123;    ...    return (        &lt;ThemeProvider&gt;            &lt;div className = &quot;App&quot;&gt;                ...            &lt;/div&gt;        &lt;/ThemeProvider&gt;    )&#125;\n主题切换组件实现主题切换按钮：\nimport React from &#x27;react&#x27;;import &#123; Tooltip &#125; from &#x27;antd&#x27;;import &#123; useTheme &#125; from &#x27;../context/ThemeContext&#x27;;import &#123; BsSun, BsMoonStars &#125; from &#x27;react-icons/bs&#x27;;import styles from &#x27;./ThemeToggle.module.css&#x27;;const ThemeToggle: React.FC = () =&gt; &#123;  const &#123; theme, toggleTheme &#125; = useTheme();  return (    &lt;Tooltip title=&#123;theme === &#x27;light&#x27; ? &#x27;切换到暗色模式&#x27; : &#x27;切换到亮色模式&#x27;&#125; placement=&quot;right&quot;&gt;      &lt;button         className=&#123;styles.themeToggle&#125;         onClick=&#123;toggleTheme&#125;        aria-label=&quot;Toggle theme&quot;      &gt;        &#123;theme === &#x27;light&#x27; ? &lt;BsMoonStars /&gt; : &lt;BsSun /&gt;&#125;      &lt;/button&gt;    &lt;/Tooltip&gt;  );&#125;;export default ThemeToggle;\n\n此处使用antd的Tooltip, 用于在鼠标悬浮按钮组件时显示文字提示;\naria-label=&quot;Toggle theme&quot; 在&lt;button&gt;内设置这个属性不是必要的, 但是可以帮助屏幕阅读器读出 “Toggle theme“.\n\n组件样式应用在组件内部使用CSS变量的方式已经在 CSS变量 中介绍, 在此给出示例:\n.sidebar_container &#123;    background-color: var(--sidebar-bg);    color: var(--text-color);&#125;.icon_button &#123;    color: var(--text-color);    background-color: transparent;&#125;.icon_button:hover &#123;    background-color: var(--sidebar-hover-color);&#125;\n\n\n\n如果某个CSS不需要作为变量进行统一管理, 可以直接使用 属性选择器 进行单独设置:\n[data-theme=&#x27;dark&#x27;] .icon_example&#123;  --bg-color: #141414;&#125;\n\n总结与参考通过以上实现,我们构建了一个完整的主题切换系统。关键点包括：\n\n使用 CSS 变量管理主题样式\n通过 Context API 实现状态管理\n利用 data-theme 属性切换主题\n本地存储保持主题持久化\n\n参考 🔗\nReact Context API\nCSS Custom Properties\nHTML data-* Attributes\n\n"},{"title":"媒体查询","url":"/2025/01/08/%E5%85%B6%E4%BB%96/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","content":"\n媒体查询入门指南使用编程方法测试媒体查询\n\n媒体查询入门对于前端, 如果我们想实现响应式的设计, 那么媒体查询是必不可少的工具. 媒体查询可以帮助我们根据不同的设备和屏幕尺寸, 调整我们的网页的布局和样式.\n媒体查询的范式:\n@media media-type and (media-feature) &#123;    /*css rules*/&#125;\n\n\n媒体类型用于声明css文件被用作什么类型的媒体;\n媒体表达式用于指定媒体特征, 只有满足媒体特征的条件下, 才会应用css规则;\n通过测试且符合媒体类型的情况下应用内部的CSS样式.\n\n\nmedia-type: all, print, screen, speech.\n媒体特征屏幕尺寸使用min,max在一定的数值范围内启用当前的CSS样式.\n\n如果去掉前缀, 将仅在恰好为当前数值中启用.\n\n/* 启用宽度大于或等于600px的屏幕 */@media screen and (max-width: 600px)&#123;    ...&#125;/* 启用宽度小于或等于600px的屏幕 */@media screen and (min-width: 600px)&#123;    ...&#125;/* 窗口恰好等于600px时 */@media screen and (width: 600px) &#123;    ...&#125;\n\n朝向orientation可以检测设备的方向, 如竖屏或横屏.\n@media screen and (orientation: portrait) &#123;    /* 竖放时的CSS样式 */&#125;@media screen and (orientation: landscape) &#123;    /* 横屏时的CSS样式 */&#125;\n\n更复杂的媒体查询\nand实现与逻辑:\n\n@media screen and (min-width: 400px) and (orientation: landscape) &#123;  body &#123;    color: blue;  &#125;&#125;\n\n\n,实现或逻辑:\n\n@media (min-width: 768px) and (orientation: landscape), (max-width: 480px) &#123;  /*   (屏幕宽度大于等于 768px 且屏幕方向为横向) 或 (屏幕宽度小于等于 480px)  */&#125;\n\n与C中的&amp;和|类似, 与的优先级更高, 先将and的条件进行判断, 然后视作整体.\n\n\nnot实现非逻辑:\n\n@media not all and (orientation: landscape) &#123;/* 非全部屏幕且屏幕方向为横向 */&#125;\n\n\nnot实现 反转查询:\n与最近的and组合所绑定, 注意优先级\n\n\n\n@media not screen and (color), print and (color) &#123; ... &#125;\n,将媒体查询的表达式分为了前后两级, 因此上述的媒体查询等价于:\n@media (not (screen and (color))), print and (color) &#123; ... &#125;\n\n\n\n利用查询结果扩展设计上述在CSS中利用@media可以实现响应式的设计, 如果我们希望在js&#x2F;ts中使用媒体查询的结果呢? 利用媒体查询列表进行设计可以帮助我们实现更加自由的设计.\n\n使用window.matchMedia()方法存放媒体查询结果:\n\n// 检测设备的旋转方向是否为纵向var mediaQueryList = window.matchMedia(&quot;(orientation: portrait)&quot;);\n\n\n检查属性matches获取对应的查询结果:\n\nif (mediaQueryList.matches) &#123;  /* 设备的旋转方向为纵向 portrait */&#125; else &#123;  /* 设备的旋转方向不是纵向，也就是横向 landscape */&#125;\n\n\n通过addListener()方法注册监听器, 持续监听查询列表的结果\n\n// 定义媒体查询字符串const mediaQueryString: string = &quot;(orientation: portrait)&quot;;// 创建查询列表const mediaQueryList: MediaQueryList = window.matchMedia(mediaQueryString);// 定义回调函数，使用 MediaQueryListEvent 类型function handleOrientationChange(event: MediaQueryListEvent): void &#123;  if (event.matches) &#123;    // 媒体查询匹配（竖屏）    console.log(&quot;Orientation changed to portrait&quot;);    // 在这里执行竖屏时的逻辑  &#125; else &#123;    // 媒体查询不匹配（横屏）    console.log(&quot;Orientation changed to landscape&quot;);    // 在这里执行横屏时的逻辑  &#125;&#125;// 先运行一次回调函数，传入 MediaQueryList 对象handleOrientationChange(&#123;    matches: mediaQueryList.matches,    media: mediaQueryList.media,    type: &#x27;change&#x27;,&#125; as MediaQueryListEvent);// 为查询列表注册监听器，同时将回调函数传给监听器mediaQueryList.addEventListener(&#x27;change&#x27;, handleOrientationChange);// (可选) 在组件卸载时或不再需要监听时，移除事件监听器// mediaQueryList.removeEventListener(&#x27;change&#x27;, handleOrientationChange);\n\n","categories":["学习笔记"],"tags":["前端","CSS"]},{"title":"MAIC","url":"/2025/05/17/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/MAIC/","content":"主题’CSS’的设计AppTheme为了方便统一管理颜色，我们可以创建一个主题相关的结构体，并设置主题相关的环境变量：\nimport SwiftUIstruct AppTheme &#123;    // 通过 Assets.xcassets 定义的颜色    let primaryColor = Color(&quot;PrimaryColor&quot;)    let secondaryColor = Color(&quot;SecondaryColor&quot;)    // 直接在代码中定义颜色    let backgroundColor = Color(UIColor.systemGray6)    // 字体    let largeTitleFont = Font.system(size: 34, weight: .bold)    let bodyFont = Font.system(size: 17, weight: .regular)    // 间距    let paddingSmall: CGFloat = 8    let paddingMedium: CGFloat = 16    let paddingLarge: CGFloat = 24    // 圆角    let cornerRadius: CGFloat = 12&#125;\n\n\n注意不能设置此处的变量为 static， 否则无法在其他文件中使用.\n\n\n在Assets中定义颜色：\n\n\n\n导入主文件在主文件中导入主题相关的结构体，并设置环境变量：\nimport SwiftUI@mainstruct MAICApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()                .environment(\\.appTheme, AppTheme()) // 将 AppTheme 注入到环境中        &#125;    &#125;&#125;\n\n使用主题在其他文件中，可以通过环境变量来访问主题相关的变量：\nimport SwiftUIstruct ContentView: View &#123;    @Environment(\\.appTheme) var appTheme: AppTheme // 从环境中获取 AppTheme    &#125;\n\n设置底部导航栏基础的Tab视图struct MainView: View &#123;    var body: some View &#123;        TabView&#123;            HomeView()                .tabItem &#123;                    Label(&quot;花园&quot;,systemImage: &quot;house.circle&quot;)                &#125;                      HealthView()                .tabItem &#123;                    Label(&quot;健康&quot;,systemImage: &quot;heart.circle&quot;)                &#125;                      MeditationView()                .tabItem&#123;Label(&quot;冥想&quot;,systemImage: &quot;figure.mind.and.body.circle&quot;)                &#125;                      SettingsView()                .tabItem&#123;                    Label(&quot;设置&quot;,systemImage: &quot;gear.circle&quot;)                &#125;                  &#125;    &#125;&#125;\n\n\n导入各个定义好的视图；\nLabel设置导航栏的文字；\nsystemImage设置导航栏的图标\n\n然后在项目入口中指定这个视图：\n@mainstruct MAICApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            MainView()                .environment(\\.appTheme, AppTheme()) // 将 AppTheme 注入到环境中        &#125;    &#125;&#125;\n\n设置触感反馈为了在切换底部导航栏时，提供触感反馈，我们可以设置一个状态变量，记录当前的Tab：\n@State private var selectedTab = 0var body: some View &#123;    TabView(selection: $selectedTab)&#123;        HomeView()                    .tabItem &#123;                        Label(&quot;花园&quot;,systemImage: &quot;house.circle&quot;)                    &#125;                    .tag(0)    ...    &#125;    .sensoryFeedback(.selection, trigger: selectedTab)\n\n\nselection 是一种标准的系统触觉反馈，通常用于表示用户在选择器、列表或其他 UI 元素中进行了选择或状态改变\n\n","categories":["开发记录"],"tags":["swift"]},{"title":"𝐜𝐡𝐚𝐭𝐒𝐐𝐋","url":"/2025/05/08/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/chatSQL/","content":"\n  Website\n  Github Repo\n\n\n  \n\n\n什么是chatSQL:\nchatSQL 是一个交互式 SQL 学习平台，通过人工智能技术生成个性化的 SQL 练习题，帮助用户从入门到精通 SQL 查询语言。平台结合了直观的数据库可视化工具、智能代码编辑器和即时反馈系统，为用户提供沉浸式学习体验。无论您是 SQL 初学者还是希望提升查询技能的开发者，chatSQL 都能根据您的水平定制适合的学习内容，让 SQL 学习变得更加高效和有趣。\n产生背景在初学sql的时候, 总觉得在纸上谈兵的感觉不太切实, 总是不知道自己胡乱写的sql语句是否正确. 偶然的机会看到了一个在线的自学sql网站, 提供了数据库结构,元组信息以及sql编辑平台, 供用户实时查询:\n\n然而该网站的习题内容对免费用户十分有限, 不足以sql学习者反复的练习. 于是我想到, 为什么不自己做一个呢? \nsql题目的生成gemini免费的api + dify上免费的工作流 &#x3D; 无穷无尽的sql题目~\n由于有过dify平台上搭建工作流的经验, 我还是选择用dify来针对用户的需求生成不同难度和类型的sql题目. \nschema的可视化在写数据库作业的时候, 意外发现了chartDB这个网站, 其中的数据库结构的可视化十分优雅.经过对其源码的”探测”, 我挖掘到了xyflow这个组件库.\n同时, 我决定直接用MUI组件库中的表格作为数据库元组的展示, 让元组的信息更加直观.\nsql语句的执行这部分可谓是项目中最难实现的任务了.\n其实一开始并没有立刻开始做chatSQL, 就是因为我没有现成的在虚拟&#x2F;实际数据库中执行sql语句的方法. \n然而, 某天浏览数据库教材的时候, 意外发现了官网上存在一个前端执行sql语句查询的demo! 发现叫做sql.js的库似乎就可扮演在前端的sql引擎角色. 因此, 我觉得万事俱备了! 开始设计前后端的字段, 布局排版, 然后实现基础的UI…\n然而然而, 当我准备开始做sql引擎的时候, 发现sql.js竟然与react高版本框架和一些依赖不兼容! 然而我只剩下sql引擎的执行部分了… 也不好就此放弃. 那么就借助augment的力量自己写一个吧~\n\n首先, 从monaco editor入手, 建立一个类似于vscode风格的代码编辑区;\n然后, 利用node-sql-parser库, 我们将标准的sql语句传入给解析组件, 获得ast语法树;\n最后, 我们编写自己的sql执行引擎, 利用ast语法树执行sql语句.\n\n\n下面基本是项目仓库中README的部分.\n\n✨ 特性\n🤖 AI 生成练习：提供两种方式的习题来源\n\n通过预设的教程, 循序渐进地练习select, join, 聚合操作与嵌套子查询等知识点.\n与dify工作流交互, 输入难度,标签与描述自动生成 SQL 练习题.\n\n\n📊 数据库结构可视化：直观展示表关系和字段信息, 外检约束等信息一目了然;\n\n⌨️ Monaco编辑器与schema的补全整合：\n\n支持sql语法高亮和悬浮的语法提示\n针对当前schema信息提供tab的自动补全\n\n\n📝 即时结果验证：实时验证查询结果\n\n由构建于前端的sql引擎0延迟地处理sql查询结果.\n支持将查询结果与期望结果进行比较, 评价查询结果是否正确.\n\n\n\n🖥 界面预览初始化界面\n\n点击侧边栏中的“初始化教程”, 可以同预设的数据库表结构进行交互;\n点击侧边栏中的“帮助”, 可以查看基本的操作演示.\n\n数据库结构可视化\n\n默认显示数据库结构的可视化视图;\n可在左下角切换元组视图.\n\nSQL 编辑器演示\n\n对应快捷键:\n\ncommand+enter : 执行查询\ncommand+j: 检测查询结果是否匹配;\ncommand+k: 搜索历史记录.\n\n🛠 技术栈\n  \n  \n  \n  \n  \n  \n  \n\n\n\n框架: Next.js 15.3.0\nUI 组件:\nAnt Design 5.24.6\nMaterial-UI 7.0.2\n\n\n编辑器: Monaco Editor\n流程图:\nXY Flow (@xyflow&#x2F;react)\n用于数据库表关系可视化\n支持自定义节点和边的样式\n提供图表交互操作\n基于 D3.js 的缩放和拖拽功能\n\n\nAI 集成: Dify.ai\n类型检查: TypeScript\n\n🚀 快速开始\n得益于预制课教程系列的完善, 您可以直接clone仓库后, 通过npm install安装依赖, npm run dev启动前端即可进行基本教程的学习, 而无需配置dify工作流. 😌\n\n前置要求\nNode.js 18.0 或更高版本\nnpm 包管理器\nDify.ai 账号和 API 密钥\n\n安装步骤\n克隆仓库\n\ngit clone https://github.com/ffy6511/chatSQL.gitcd chatSQL/chat-sql\n\n\n安装依赖\n\nnpm install\n\n\n配置环境变量\n\ntouch .env\n\n编辑 .env 文件并添加你的 Dify API 密钥：\nNEXT_PUBLIC_DIFY_API_KEY=your_api_key_here\n\n\n启动开发服务器\n\nnpm run dev\n\n\n更新git日志: 如果您希望更新自己的”更新日志”界面, 请执行\n\nnpm run generate-git\nDify 工作流配置\n在 Dify 平台 创建新应用（选择工作流）\n导入工作流配置：\n从项目中下载 public/chatSQL.yml 文件\n在 Dify 平台中导入该配置文件\n\n\n\n获取 API 密钥并在个人设置中配置（工作流默认使用 Gemini，可根据需要修改）\n\n🤝 贡献欢迎提交 Pull Request 和 Issue！\n\n重要更新25-04-30\nfeat: 在主页的侧边栏增加了”初始化教程”功能, 提供不同难度的教程系列;\n\nfeat: 增加分享链接, 可以导出当前的历史记录, 通过粘贴地址在不同设备之间共享(notice: 可能覆盖当前已有的记录)\n\n\n25-05-11\nfeat: 在”初始化教程”中增加了教材Database System Concepts中schema, 根据25春夏DB的PPT的字段要求在官网基础上调整得到.\n\nfeat: 优化了代码编辑的体验(根据上下文修改补足的建议)\n\nstyle: 增加了loading的动画, 优化更新日志的页面\n\n\n","categories":["前后端开发"],"tags":["奇思妙想"]},{"title":"SSH隧道","url":"/2025/01/17/%E6%9C%8D%E5%8A%A1%E5%99%A8/SSH%E9%9A%A7%E9%81%93/","content":"在进行服务器运维时，经常会遇到需要代理来访问某些资源的情况。本文将介绍如何通过 SSH 隧道，让远程服务器共享使用本地电脑的代理，实现优雅的科学上网解决方案。\n背景通常我们在本地电脑上都配置了代理软件（如 Clash），但远程服务器往往没有代理。如何让远程服务器也能使用上我们本地的代理呢？这就需要用到 SSH 的端口转发功能。\n原理解释SSH 隧道技术允许我们将本地端口转发到远程服务器。通过建立一个加密的通道，远程服务器可以通过这个通道访问本地电脑的代理服务。\n[远程服务器] &lt;--- SSH隧道 ---&gt; [本地电脑] &lt;--- 代理 ---&gt; [互联网]\n\n具体步骤1. 前提条件\n本地电脑已安装并运行代理软件（如 Clash，默认端口 7890）\n能够通过 SSH 连接到远程服务器\n确保本地代理软件正常工作\n\n2. 建立 SSH 隧道在本地电脑的终端中执行：\nssh -R 7890:127.0.0.1:7890 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 用户名@服务器IP\n\n参数说明：\n\n-R 7890:127.0.0.1:7890：将远程服务器的 7890 端口转发到本地的 7890 端口\n-o ServerAliveInterval=60：每 60 秒发送一次心跳包\n-o ServerAliveCountMax=3：最多允许丢失 3 次心跳包\n\n\n\n然后根据提示输入服务器用户的密码:\n3. 配置服务器代理在服务器终端中执行：\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n\n4. 验证代理是否生效在服务器上执行：\ncurl -v https://github.com\n\n如果能够正常访问，说明代理配置成功。\n持久化配置如果想让代理设置持久生效，可以将代理配置命令添加到 Shell 的配置文件中：\n# 编辑 ~/.bashrc 或 ~/.zshrcecho &#x27;export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890&#x27; &gt;&gt; ~/.bashrc# 重新加载配置source ~/.bashrc\n\n注意事项\n安全性考虑：SSH 隧道是加密的，相对安全\n连接维护：保持 SSH 连接不断开，否则代理会失效\n带宽限制：代理流量会经过你的本地电脑，注意带宽占用\n临时使用：这种方法适合临时使用，长期使用建议直接在服务器上配置代理\n\n常见问题排查\n隧道无法建立\n\n检查本地代理是否正常运行\n确认端口号是否正确\n检查服务器防火墙设置\n\n\n代理失效\n\nSSH 连接是否断开\n本地代理软件是否正常运行\n环境变量是否正确设置\n\n\n\nClash设置在默认的代理设置基础上进行了如下修改, 但是不确保这是正常访问的必须操作:以mac的ClashX Pro为例, 在更多设置中\n结论通过 SSH 隧道共享本地代理是一个简单而优雅的解决方案，特别适合临时需要代理访问的场景。它不需要在服务器上安装额外的软件，配置简单，安全可靠。\n","categories":["通用技能"],"tags":["ssh","服务器"]},{"title":"Tmux","url":"/2025/01/17/%E6%9C%8D%E5%8A%A1%E5%99%A8/Tmux/","content":"\n在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~\n\n什么是 Tmux？Tmux（Terminal Multiplexer）是一个终端复用器，它允许用户在单个终端窗口中运行和管理多个终端会话。作为一个强大的命令行工具，tmux 特别适合需要长时间运行程序或需要同时管理多个终端窗口的场景。\n为什么需要 Tmux？在以下场景中，tmux 特别有用：\n\n远程服务器管理\n\nSSH 连接意外断开时，tmux 会话仍然保持运行\n可以随时重新连接到之前的工作环境\n\n\n多任务管理\n\n在同一个终端窗口中同时运行多个程序\n方便地在不同任务之间切换\n\n\n结对编程\n\n多人可以同时连接到同一个 tmux 会话\n实时查看和协作编辑\n\n\n\n基本概念tmux 采用三层架构：\n\n会话（Session）：最顶层的概念，包含多个窗口\n窗口（Window）：类似于浏览器的标签页\n窗格（Pane）：窗口内的分割区域\n\n常用操作指南1. 安装不同系统的安装命令：\n# MacOSbrew install tmux# Ubuntu/Debiansudo apt install tmux# CentOS/RHELsudo yum install tmux\n\n2. 会话管理启动新会话# 创建默认会话tmux# 创建命名会话tmux new -s session_name\n\n会话操作# 断开当前会话Ctrl+b d# 列出所有会话tmux ls# 连接到指定会话tmux attach -t session_name# 关闭指定会话tmux kill-session -t session_name\n\n3. 窗口管理所有命令都需要先按前缀键 Ctrl+b：\n\nc: 创建新窗口\n&amp;: 关闭当前窗口\np: 切换到上一个窗口\nn: 切换到下一个窗口\n数字键: 切换到指定编号的窗口\n\n4. 窗格操作同样需要先按前缀键 Ctrl+b：\n\n%: 垂直分割窗格\n&quot;: 水平分割窗格\n方向键: 在窗格之间移动\nx: 关闭当前窗格\nz: 最大化&#x2F;还原当前窗格\n\n进阶技巧1. 自定义配置创建 ~/.tmux.conf 文件来自定义 tmux 配置：\n# 修改前缀键为 Ctrl+aset -g prefix C-aunbind C-bbind C-a send-prefix# 开启鼠标支持set -g mouse on# 设置窗口编号从 1 开始set -g base-index 1\n\n2. 复制模式\n按 Ctrl+b [ 进入复制模式\n使用方向键移动光标\n按 Space 开始选择\n按 Enter 复制选中内容\n按 Ctrl+b ] 粘贴\n\n\ntmux 是一个强大的终端管理工具，掌握它可以显著提高命令行工作效率。从基本的会话管理到高级的自定义配置，tmux 都提供了灵活而强大的功能。随着使用经验的积累，你会发现它是开发工作中不可或缺的工具之一。\n参考资源\nTmux 官方文档\nTmux 速查表\nAwesome Tmux\n\n","categories":["通用技能"],"tags":["服务器","多会话管理"]},{"title":"VNC与云服务器","url":"/2025/06/28/%E6%9C%8D%E5%8A%A1%E5%99%A8/VNC%E4%B8%8E%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","content":"在上多智能体短学期课程的时候，碰到了实验——“基于 IsaacGym 的 Unitree G1 机器人平地行走实验”，其要求是：\n\n前期准备：Isaac Gym Preview 4 Release 目前仅支持 Linux 操作系统（本地运行安装双系统，请勿使用 WSL，系统版本推荐 Ubuntu 20.04&#x2F;22.04）\n\n没想到双持用户还是逃不开环境的配置😇 整体上看，有两条解决路径：\n\n在windows上独立安装一个Ubuntu系统\n租用云服务器资源，但是需要配置VNC来实现可视化\n\n经过短暂的调研，我发现方案1需要为新系统划分新的磁盘区域，同时下载不小容量的系统。考虑到我大概不会一直在我的windows上用到这个ubuntu，因此我转而采取方案2\n整体而言，方案2涉及到的步骤包括：\n\n准备云服务器\n安装桌面环境和VNC服务器端\n配置VNC\n\n准备云服务器在一众按月计费的产品中，我终于找到了腾讯云服务的按小时计费的计算资源——高性能应用服务:\n\n\n选择合适的基础环境，勾选“按量计费”即可\n之后可以在腾讯云-高性能应用服务中管理云服务：\n\n\n\n首次创建之后默认开机，并且需要“重置密码”来设置一个密码\n\n之后，可以通过ssh连接服务器：\nssh ubuntu@&lt;公网IP&gt;\n\n\n公网IP可能随时间变化，注意参考最新的IP\n\n然后输入之前设置好的密码即可连接\n\n\n安装桌面环境和VNC服务端VNC（Virtual Network Computing）：\n\n一种图形化远程控制协议和工具，允许用户通过网络远程访问和操作另一台计算机的桌面环境；\nVNC分为服务器端（VNC Server）和客户端（VNC Viewer）。服务器端运行在被控设备上，客户端运行在需要远程访问的设备上\n\n在服务器领域，尤其是Linux服务器，默认通常只有命令行界面。如果需要图形化桌面环境，可以安装桌面环境并运行VNC Server。这样，远程用户就能通过VNC客户端访问服务器的完整图形桌面，进行可视化操作和管理。\n因此，我们需要在之前的云服务器上先后安装桌面环境与VNC服务端，然后通过本地的VNC客户端来可视化访问云服务器端\n安装xfce4\nXfce4（通常简称 Xfce）是一款轻量级、易于定制的 Linux&#x2F;Unix 桌面环境。它的设计目标是实用、快速且节省系统资源\n\n首先，确保系统是最新配置：\nsudo apt update\n\n然后，安装轻量的桌面环境，此处以 xfce4为例：\nsudo apt install xfce4\n\n安装TigerVNCsudo apt install tigervnc-standalone-server\n\n\n适用于 Ubuntu 20.04 LTS及之后的版本\n\n配置VNC Server\n设置密码：\nvncpasswd\n启动VNC服务：\nvncserver :1\n\n\n这会在5901端口监听VNC连接\n\n\n\n如果启动失败，很可能是vnc脚本的配置问题——~/.vnc/xstartup指定了VNC启动的桌面环境。如果脚本内容与之前下载的桌面环境不匹配，就无法正常启动，此时我们需要改写该文件\n\n用nano或vim编辑器打开脚本文件：\n\nnano ~/.vnc/xstartup\n\n\n将内部的文件改写如下：（以桌面环境xfce4为例）\n\n#!/bin/shunset SESSION_MANAGERunset DBUS_SESSION_BUS_ADDRESSstartxfce4 &amp;\n\n\n确保脚本文件有执行权限：\n\nchmod +x ~/.vnc/xstartup\n\n\n重启VNC服务：\n\nvncserver -kill :1  # 关闭当前VNC会话vncserver :1        # 重新启动VNC会话\n\n\n\n我们可以通过命令 vncserver -list 查看当前的VNC对话\n使用VNC客户端连接服务器此处以realvnc为例——官方的下载地址\n安装完毕之后输入VNC server的 IP:端口：\n\n\n然后按照提示，输入之前在server初始化的时候设置的密码，即可连接\n通过SSH隧道安全连接查看5901端口监听的地址：\nnetstat -tlnp | grep 5901\n\n如果类似输出：\n(base) ubuntu@VM-0-5-ubuntu:~$ netstat -tlnp | grep 5901(Not all processes could be identified, non-owned process info will not be shown, you would have to be root to see it all.)tcp        0      0 127.0.0.1:5901          0.0.0.0:*               LISTEN      2583/Xtigervnc    tcp6       0      0 ::1:5901                :::*                    LISTEN      2583/Xtigervnc    (base) ubuntu@VM-0-5-ubuntu:~$ \n\n说明此时云服务器端正在监听本机的端口，可以声明：\nvncserver :1 -localhost no\n\n此时可以监听所有IP。但是这样需要同步在腾讯云的云服务器处改写规则，允许监听所有IP，存在一定风险\n如果担心VNC端口暴露在公网不安全，可以用SSH隧道方式进行加密连接：\n\n本地开启端口转发：\nssh -L 5901:localhost:5901 用户名@服务器IP# 启动对话vncserver :1\n客户端连接本地端口——在viewer中输入：\nlocalhost:5901\n\n\n\n至此，我们就可以使用本地的VNC client来操作图形化的云服务器 🎉\n附录可能遇到的问题使用浏览器查看实验结果实验中rl运行的结果在logs文件夹中如图所示：\n\n\n\n第一个是TensorBoard日志文件，由框架自动生成，记录训练过程中的各种指标\n\n为二进制形式，需要使用 Tensorboard 工具查看\n# pip install tensorboardtensorboard --logdir=.# 或者指定名称 tensorboard --logdir=output\n\n\n后续以 pt结尾的文件是PyTorch模型权重文件 ，即保存的神经网络模型参数\n\n是模型快照\n\n用PyTorch的 torch.load()函数加载，用于测试、继续训练或推理\n# 加载pt模型import torchmodel = torch.load(&#x27;xxx.pt&#x27;)\n\n\n\n我首先尝试使用scp直接传输日志文件到本地，但是传输之后使用上述工具查看时显示：\n\n\n\n唔， 我也不知道这是什么情况？可能是传输过程的问题？\n\n于是，我尝试直接在服务器上查看，但是碰到了另一个问题——轻量级的桌面似乎没有自带的浏览器？（我点击下方的浏览器，弹出的却是Terminal），于是有两个方法——\n\n在服务器端安装一个浏览器并查看：\n# 假设在6006端口sudo apt install chromium-browserchromium-browser http://localhost:6006\n\n使用之前提到过的SSH隧道的方法，将6006端口映射到本地：\nssh -L 6006:localhost:6006 user@server\n\n此时我们就可以在本地查看日志：\n\n\n使用训练完毕的模型执行play文件：\n\n假设需要使用的模型快照路径为：legged_gym/logs/rough_g1/Jul02_14-13-57_rough_g1/model_350.pt\n\npython legged_gym/legged_gym/scripts/play.py \\    --task=g1 \\    --sim_device=cuda:0 \\    --rl_device=cuda:0 \\    --experiment_name=rough_g1 \\    --load_run=Jul02_14-13-57_rough_g1 \\    --checkpoint=350 \\    --num_envs=1\n\n\n\n从一个模型快照继续训练执行train文件：\n\n假设使用的模型快照与之前的相同\n\npython legged_gym/legged_gym/scripts/train.py \\    --task=g1 \\    --rl_device=cuda:0 \\    --sim_device=cuda:0 \\    --headless \\    --resume \\    --experiment_name=rough_g1 \\    --load_run=Jul02_14-13-57_rough_g1 \\    --checkpoint=350\n\n\n通过 --resume 参数指定继续训练, \n\n新的日志将会在指定的experiment_name目录下生成\n常用的VNC server命令# 启动对话，默认监听本地vncserver :1# 启动并监听所有IP（不安全）vncserver :1 -localhost no# 停止VNC对话vncserver -kill :1# 设置密码vncpasswd# 查看当前对话vncserver -list# 结束当前所有对话pkill Xtigervnc\n\n\n\n参考资料\nhttps://blog.csdn.net/weixin_44262492/article/details/128365248\nhttps://blog.csdn.net/yinjl123/article/details/136853195\n\n","categories":["通用技能"],"tags":["ssh","服务器"]},{"title":"css笔记","url":"/2025/01/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/css%E7%AC%94%E8%AE%B0/","content":"\n在线编辑平台\n\n伪元素使用伪元素before和after可以为元素添加内容.\n&lt;div class=&quot;author&quot;&gt;待抉&lt;/div&gt;&lt;style&gt;.author:before &#123;  content: &quot;Author: &quot;;  font-weight: bold; /* 加粗字体 */  color: blue; /* 文本颜色为蓝色 */&#125;.author:after &#123;  content: &quot; ✍️&quot;;  font-size: 1.2em; /* 调整图标大小 */  margin-left: 5px; /* 添加左边距 */&#125;&lt;/style&gt;\n\n\n:nth-child可用于对序列中不同的元素进行有序的样式设计:\n&lt;div class=&quot;index-card&quot;&gt;内容1&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容2&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容3&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容4&lt;/div&gt;&lt;style&gt;.index-card:nth-child(odd) &#123;  flex-direction: row-reverse;&#125;&lt;/style&gt;\n\n选择所有类名为 “index-card” 的元素;\nrow-reverse 会让 flex 容器中的项目从右到左排列;\n同理, even选择偶数位置的元素; 3n+1等函数表达式也可以起作用.\n\n\n\n基本的元素属性布局属性\nmargin: 控制元素的外边距;\npadding: 控制元素的内边距;\n\n文本属性\nfont-size: 控制字体大小;\nfont-weight: 控制字体粗细;\ntext-align: 控制文本的对齐方式;\ntext-decoration: 控制文本的装饰;\nline-height: 控制行高;\nletter-spacing: 控制字符间距;\ntext-transform: 控制文本的大小写;\n\n边框属性\nborder: e.g. border: 1px solid red; 简写属性;\nborder-radius: 控制元素的圆角;\nborder-style: solid, dashed, dotted…\n\n其他\noverflow: visible, hidden, scroll, auto;\nopacity: 控制元素的透明度;\ncursor: pointer, default, move, not-allowed…\n\n动感魔法hover效果通过为class设置:hover伪类，可以为元素添加鼠标悬停时的效果。\n.my-element:hover &#123;  background-color: green;  color: red;  transform: scale(1.1);  font-size:20px;&#125;\n\n空格将不会被忽略, 需要确保类名与:hover之间不存在空格;\n\n其他的一些常用的伪类:\na:hover &#123;      color: red;    &#125;    button:active &#123;      background-color: green;    &#125;    input:focus &#123;      border-color: blue;    &#125;    a:visited &#123;      color: purple;    &#125;    p:first-child &#123;      font-weight: bold;    &#125;    p:last-child &#123;      font-style: italic;    &#125;    li:nth-child(2) &#123;      color: red;    &#125;    p:only-child &#123;      color: green;    &#125;    div:empty &#123;      background-color: yellow;    &#125;\n\nFlex&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;style&gt;    /* 定义Flex容器 */    .container &#123;      display: flex; /* 将容器设置为Flexbox容器 */            /* flex-direction: 定义主轴方向 */      /* row: 水平从左到右（默认） */      /* row-reverse: 水平从右到左 */      /* column: 垂直从上到下 */      /* column-reverse: 垂直从下到上 */      flex-direction: row; /* 可以改为row-reverse, column, column-reverse */      /* flex-wrap: 定义是否换行 */      /* nowrap: 不换行（默认） */      /* wrap: 换行 */      /* wrap-reverse: 反向换行 */      flex-wrap: wrap; /* 可以改为nowrap, wrap-reverse */      /* flex-flow: flex-direction 和 flex-wrap 的简写 */      /* flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; */      flex-flow: row wrap; /* 可以改为column nowrap等组合 */      /* justify-content: 定义在主轴上的对齐方式 */      /* flex-start: 起始对齐（默认） */      /* flex-end: 末端对齐 */      /* center: 居中对齐 */      /* space-between: 两端对齐，项目之间间隔相等 */      /* space-around: 项目之间间隔相等，项目两边有半个间隔 */      /* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */      justify-content: space-between; /* 可以改为flex-start, flex-end, center, space-around, space-evenly */      /* align-items: 定义在交叉轴上的对齐方式 */      /* stretch: 拉伸适应容器（默认） */      /* flex-start: 交叉轴起始对齐 */      /* flex-end: 交叉轴末端对齐 */      /* center: 交叉轴居中对齐 */      /* baseline: 项目基线对齐 */      align-items: center; /* 可以改为flex-start, flex-end, stretch, baseline */      /* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */      /* stretch: 拉伸适应容器（默认） */      /* flex-start: 交叉轴起始对齐 */      /* flex-end: 交叉轴末端对齐 */      /* center: 交叉轴居中对齐 */      /* space-between: 多行两端对齐，行之间间隔相等 */      /* space-around: 多行之间间隔相等，行两边有半个间隔 */      align-content: space-between; /* 可以改为flex-start, flex-end, center, space-around */            height: 100vh; /* 设置容器高度 */      background-color: #f0f0f0; /* 设置容器背景颜色 */    &#125;        /* 定义Flex项目 */    .item &#123;      flex: 1; /* 设置项目的flex属性，项目平分空间 */      padding: 20px; /* 设置项目内边距 */      background-color: lightblue; /* 设置项目背景颜色 */      margin: 10px; /* 设置项目外边距 */      text-align: center; /* 设置项目文本居中 */      flex-grow: 1;/*尝试向flex容器扩展空间*/    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;item&quot;&gt;Item 1&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;Item 2&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;Item 3&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["学习笔记"],"tags":["前端","CSS"]},{"title":"JavaScript","url":"/2025/01/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/","content":"\nJavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「料理的加护」下, 尽可能将JS处理得更加可口一些)\n\n创建JS代码块变量var or let?var先于let的产生, 后者是现代版本的JS中新的关键字.\n使用var, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是let并不适用.\nmyName = \"Chris\";function logName() {  console.log(myName);}logName(); //输出\"Chris\"var myName = \"Aniya\";logName(); //输出\"Aniya\"\n\n除此之外, 可以使用var前后声明相同的变量, 这并不会报错:\nvar myName = \"Chris\";var myName = \"Bob\";\n\n而let只能声明一次:\nlet myName = \"Chris\";myName = \"Bob\";\n\n因此, 在代码编写中应尽量多使用let而非var, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.\n变量命名的规则与C语言类似, 建议以 字母、数字、下划线 组成的标识符来命名变量.\n\n不可用_开头, 因为可能被JS设计为特殊的含义;\n不可用数字开头, 否则引发错误;\n大小写敏感;\n建议采用 小写驼峰命名法 ,即小写整个命名的第一个字母然后大写剩下单词的首字符;\n避免使用保留字, 比如var,let,for等.\n\n变量类型let myAge = 20 ;// 数字let dolphinGoodbye = \"So long and thanks for all the fish\"; // 字符串let test = 6 &lt; 3; //boolean//数组类型let myNameArray = [\"Chris\", \"Bob\", \"Jim\"];let myNumberArray = [10, 15, 40];//对象类型let dog = { name: \"Spot\", breed: \"Dalmatian\" };\n\n对象类型的访问与结构体相似, dog.name;\n\n在上面的几种变量类型中, 我们都采用let关键字声明变量, 这体现了JS是一种 动态类型语言 ,即无需指定变量包含的数据类型.\n同时, 这也意味着我们可以像python一样对同一个变量先后赋值不同类型的值:\nlet myNumber = \"500\";typeof myNumber;// 输出 'string'myNumber = 500; typeof myNumber;//输出'number'\n\n\n函数\n提升 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.\n\nexampleFunction();function exampleFunction() {  console.log(\"函数内\");  console.log(x);}\n\n由于 提升 的存在, 上述的函数调用不会出错.\n\n默认参数在编写函数时, 可以通过在参数名称后添加=, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。\nfunction greeding(name = \"my friend\") {    console.log(`Hello, ${name}!`);}hello(); //Hello, my friend!hello(\"world\"); //Hello, world!\n\n\n\n事件处理函数的默认接受值是event:\n&lt;button&gt;onclick&lt;/button&gt;&lt;p&gt;nothing here&lt;/p&gt;&lt;script&gt;btn = document.querySelector(\"button\")para = document.querySelector(\"p\")btn.onclick = click;function click(string){  console.log(\"clicked!\")  para.textContent = string;}&lt;/script&gt;\n\n上述的btn在点击之后调用函数click, 该函数需要一个参数string, 由于btn.onclick = click;的绑定方式, 我们无法指定传参的值, 因此点击之后的para的内容显示为: [object PointerEvent];\ntextContent是属性而非方法, 因此采用赋值实现;\n\nbtn.onclick = function click(string) {  console.log(\"clicked!\")  para.textContent = \"You have clicked the button!\";}\n\n将上述的绑定方式如此改写, 可以在btn外对string进行赋值, 然后点击按钮可以传入指定参数供后续处理.\n\n箭头函数在了解箭头函数的作用之前, 需要先介绍 匿名函数:\nfunction myFunction() {  alert(\"你好\");}// 匿名函数(function () {  alert(\"你好\");});\n\n正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.\n\n如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:\nfunction logKey(event) {  console.log(`You pressed \"${event.key}\".`);}textBox.addEventListener(\"keydown\", logKey);\n这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:\ntextBox.addEventListener(\"keydown\", function (event) {  console.log(`You pressed \"${event.key}\".`);});\n\n只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.\n\n而箭头函数则是在此情况下更简洁的函数定义方式:\ntextBox.addEventListener(\"keydown\", (event) =&gt; {  console.log(`You pressed \"${event.key}\".`);});//如果函数只接受一个参数, 也可以省略参数周围的括号textBox.addEventListener(\"keydown\", event =&gt; {  console.log(`You pressed \"${event.key}\".`);});\n\n如果只包含一行的return,则可以忽略{}和return关键字:\nconst originals = [1, 2, 3];const doubled = originals.map(item =&gt; item * 2);console.log(doubled); // [2, 4, 6]\n\nitem =&gt; item * 2等价于:\n\nfunction doubleItem(item) {  return item * 2;}\n\n一个实例&lt;input id=\"textBox\" type=\"text\" /&gt;&lt;div id=\"output\"&gt;&lt;/div&gt;\nconst textBox = document.querySelector(\"#textBox\");const output = document.querySelector(\"#output\");textBox.addEventListener(\"keydown\", (event) =&gt; {  output.textContent = `You pressed \"${event.key}\".`;});\n通过监听输入框的keydown事件, 输出按下的键盘按键.\n函数作用域和冲突作用域 指当前的执行上下文, 在其中的值和表达式可以被访问. \n\n全局作用域: 脚本模式运行所有代码的默认作用域;\n模块作用域: 模块模式中运行代码的作用域;\n函数作用域: 由函数创建的作用域\n\n和C语言相似, 在函数外部let定义的变量, 以及const定义的常量可以在函数内部访问.\n如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:\n&lt;!-- Excerpt from my HTML --&gt;&lt;script src=\"first.js\"&gt;&lt;/script&gt;&lt;script src=\"second.js\"&gt;&lt;/script&gt;&lt;script&gt;  greeting();&lt;/script&gt;\n\n如果两个JS文件都定义了greeting函数, 则只有第一个文件中的函数才会被调用.\n\n数据类型数字和操作符大部分与C语言相同, 概括需要注意的差异:\n\nJS当中只有一种数字类型 – number, 对于整型或者浮点数的初始化得到的量, 由typeof均得到number;\n算术运算符: 求幂为**;\n常量无法使用自增或自减,好像也是C语言的 忘了\n===表示严格等于, !==表示不等于;\n同时存在==和!=来判断是否相等, 但是它们只是测试 值 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用===和!==来避免类型不一致的错误.\n\n\n\n字符串创建字符串\nlet myString = \"A string\";const constString = myString;console.log(constString);//A string\n可以使用单引号,双引号和反引号来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:\nconst single = '单引号';const double = \"双引号\";const backtick = `反引号`;\n\n反引号包裹的字符串称为模板字符串, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:\n\n可以嵌入 JavaScript;\n可以声明多行的模板字面量.\n\n字符串的拼接字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 串联法:\nconst name = \"克里斯\";const greeting = `你好，${name}`;console.log(greeting); // \"你好，克里斯\"\n\n在模板字面量中用${}包装JS的变量或者表达式.\n\nconst one = \"你好，\";const two = \"请问最近如何？\";const joined = `${one}${two}`;console.log(joined); // \"你好，请问最近如何？\"\n\n连接2个变量.\n\nconst song = \"青花瓷\";const score = 9;const highestScore = 10;const output = `我喜欢歌曲《${song}》。我给它打了 ${  (score / highestScore) * 100} 分。`;console.log(output); // \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"\n\n在模板字面量的${}内部包含表达式.\n\n\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\nconst greeting = \"你好\";const name = \"克里斯\";console.log(greeting + \"，\" + name); // \"你好，克里斯\"\n\n多行字符串模板字符串会保留源代码中的换行符，因此可以编写跨越多行的字符串:\nconst newline = `终于有一天，你知道了必须做的事情，而且开始……`;console.log(newline);/*终于有一天，你知道了必须做的事情，而且开始……*/\n\n如果希望用普通的字符串得到等效的输出, 必须在字符串中包含\\n,而非直接跨行:\nconst newline = \"终于有一天，\\n你知道了必须做的事情，而且开始……\";console.log(newline);/*终于有一天，你知道了必须做的事情，而且开始……*/\n\n显示引号\n转义  通过在符号前加上反斜杠\\, 可以转义字符串中的特殊字符,包括字符串中的引号:\n\nconst bigmouth = 'I\\'ve got no right to take my place…';\n\n换用其他字符: 在字面量内用不同于包裹字符串的引号:\n\nconst goodQuotes1 = 'She said \"I think so!\"';const goodQuotes2 = `She said \"I'm not going in there!\"`;\n\n\n常用方法对于字符串对象实例,其常用的方法:\n\n.length: 获取字符串的长度;\n[]: 返回字符串中对应索引的字符, 索引同样从0开始;\n.indexOf(\"\"): 查找子字符串\ninput: 希望查找的子字符串;\noutput: 子字符串开始的下标(如果不存在则返回-1);\n\n\n.slice(indedxStart, indexEnd): 截取字符串\ninput: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;\noutput: 截取的子字符串;\n\n\n\n更多的slice知识:\n\n标准化负值 如果索引是个负数, 取index+str.length进行标准化;\n如果indexStart大于str.length, 返回空字符串;\n如果标准化负值之后, indexStart大于indexEnd, 也返回空字符串;\n\n\n.toLowerCase() &amp; .toUpperCase(): 转换字符串中的所有字符为小写或大写;\n.replace(original, new): 替换字符串中original子字符串为new;\n此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.\n\n\n\nCases利用 indexOf 和 slice 方法, 获取新字符串:\n\ninput: \"str3\"三位长字符串+\"...\"(无关字符串)+\";\"+strLast(剩余字符串);\noutput: \"str3\"+\";\"+strLast\n\nvar stations = ['MAN675847583748sjt567654;Manchester Piccadilly',                'GNF576746573fhdg4737dh4;Greenfield',                'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street',                'SYB4f65hf75f736463;Stalybridge',                'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'];for(var i = 0; i &lt; stations.length; i++){    var input = stations[i];    var str3 = input.slice(0,3);    var strLast = input.slice(input.indexOf(\";\")+1); //indexOf获取;位置    var output = str3 + \";\" + strLast;}\n\n\n通过 indexOf 根据子字符串筛选字符串数组:\n\ninput: 可能包含 Christmas 的字符串数组;\noutput: 包含 Christmas 的字符串数组;\n\nvar list = document.querySelector('.output ul');list.innerHTML = '';var greetings = ['Happy Birthday!',                 'Merry Christmas my love',                 'A happy Christmas to all the family',                 'You\\'re all I want for Christmas',                 'Get well soon'];for(var i = 0; i &lt; greetings.length; i++) {  var input = greetings[i];  if(greetings[i].indexOf('Christmas') !== -1) {    var result = input;    var listItem = document.createElement('li');    listItem.textContent = result;    list.appendChild(listItem);  }}\n\n数字与字符串相互转换非常神奇, 在JS当中, 数字和字符串可以直接通过函数Number()和String()进行转换, 与C语言不同.\nconst myString = \"123\";const myNum = Number(myString);console.log(typeof myNum);// numberconsole.log(myNum);// 123\n\nconst myNum2 = 123;const myString2 = String(myNum2);console.log(typeof myString2);// stringconsole.log(myString2);// \"123\"\n\n对于浮点数同样成立.\n\n前后拼接使用+将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:\nconst name = \"Front \";const number = 242;const combine = name + number;console.log(combine); //Front 242console.log(typeof(combine));  //string\n\n数组\n存储任意类型元素–字符串，数字，对象，变量，另一个数组;\n可以 混合 元素类型:\n\nlet random = [\"tree\", 795, [0, 1, 2]];\n\n像访问字符串一样, 利用索引访问数组元素;\n多维数组 包含数组的数组结构称为~\n\nsplit()\n作用: 将一个字符串根据给定的字符分隔为字符串数组;\n\nlet myData = \"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\";let myArray = myData.split(\",\");console.log(myArray); // [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]\n\njoin()split的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:\nlet myNewString = myArray.join(\",\");myNewString;\n\ntoString()与join方法相似, 但是无法自定义分隔符, 默认为,:\nlet dogNames = [\"Rocket\", \"Flash\", \"Bella\", \"Slugger\"];dogNames.toString(); //Rocket,Flash,Bella,Slugger\n\npush &amp; poppush()方法可以将1或多个元素添加到数组的 末尾:\n\n将会直接改写原来的数组,不需要重新赋值;\n该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);\n\nlet myArray = [1, 2, 3];let newLength = myArray.push(4, 5,\"string\");console.log(myArray); // [1, 2, 3, 4, 5, \"string\"]console.log(newLength); // 6\n\n使用.pop()从数组中删除最后一个元素:\nmyArray.pop(); //\"string\"console.log(myArray); // [1, 2, 3, 4, 5]\n\n方法调用返回值就是删除的元素本身;\n直接对原始数组操作并赋值, 不需要另外的赋值操作;\n\n\nshift &amp; unshift:在功能上分别与push和pop相同, 但是作用于数组的开始位置.\n\n条件语句JS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:\n天气预报&lt;label for=\"weather\"&gt;选择今天的天气：&lt;/label&gt;&lt;select id=\"weather\"&gt;  &lt;option value=\"\"&gt;--作出选择--&lt;/option&gt;  &lt;option value=\"sunny\"&gt;晴天&lt;/option&gt;  &lt;option value=\"rainy\"&gt;雨天&lt;/option&gt;  &lt;option value=\"snowing\"&gt;雪天&lt;/option&gt;  &lt;option value=\"overcast\"&gt;阴天&lt;/option&gt;&lt;/select&gt;&lt;p&gt;&lt;/p&gt;\n\nlable当中的for标签与select标签的id属性对应, 用于关联两个标签.\n\nconst select = document.querySelector(\"select\");const para = document.querySelector(\"p\");select.addEventListener(\"change\", setWeather);function setWeather() {  const choice = select.value;  switch (choice) {    case \"sunny\":      para.textContent = \"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\";      break;    case \"rainy\":      para.textContent = \"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\";      break;    case \"snowing\":      para.textContent =        \"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\";      break;    case \"overcast\":      para.textContent =        \"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\";      break;    default:      para.textContent = \"\";  }}\n\n\n通过querySelector方法获取select和p标签;\n然后为select标签添加事件监听器, 当内容改变时触发 change 事件, 同时调用setWeather函数;\n进而通过 switch 语句处理不同天气的情况, 并设置相应的文字内容;在线网页示例:simple-switch\n\n\n事件介绍什么是事件? \n\n用户选择、点击或者光标悬停在某一元素;\n用户在键盘中按下某个按键;\n网页结束加载;\n…\n\n事件处理器 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.\n处理点击事件以点击事件为例, 介绍html与js如何进行事件处理的交互:\n&lt;button&gt; 改变颜色 &lt;/button&gt;\nconst btn = document.querySelector(\"button\");function random(number){  return Math.floor(Math.random()*(number+1));  }btn.addEventListener(\"click\", ()=&gt;{  const rndCol = `rgb(${random(255)},${random(255)},${random(255)})`;  document.body.style.backgroundColor = rndCol;})\n\nMath.random()方法生成一个介于[0,1)之间的随机数;\n*(number+1)之后利用向下取整的方法Math.floor()将其转换为整数, 范围为[0,number];\n假如输入的number为4, 则random(4)的结果可能为0, 1, 2, 3, 4中的一个;假设输入的number为3.6, 则输出的结果还是0~4中的整数.\n\n\nrndCol = `rgb(${random(255)},${random(255)},${random(255)}) 采用的是在模板字符串内部使用${}调用函数变量的方法.\n\naddEventListener()adEventListener方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.\n通过EventTarget.adddEventListener()的方法, 将指定的监听器注册到对象上, 具体的语法如下:\naddEventListener(type, listener);addEventListener(type, listener, options);addEventListener(type, listener, useCapture);\n\ntype: 事件类型, 如click, mouseover, mouseout, keydown, keyup等;\nlistener: 事件处理函数, 该函数将在事件发生时被调用;\n包括 回调函数 以及 实现了 EventListener 接口的对象;\n\n\noptions: 可选参数, 用于配置事件监听器的行为;\n可以为单个事件添加多个事件监听器.\n\n\n\nlistener回调函数 简单来说, ~指的是当某个事件发生时被调用的一段代码.\n\n是一个函数, 但是只有等到特定的事件发生时才会执行.\n\n实现了 EventListener 接口的对象:\n\n特点: 以对象作为listener, 对象中具有名为handleEvent()的方法;\n作用: \n将事件处理封装到一个对象当中, 可以更好地组织代码;\n便于在对象中保存更多的状态信息;\n\n\n\nconst listenerObject = {    count: 0,    handleEvent(event) {        this.count++;        console.log(`事件类型是：${event.type}，已触发 ${this.count} 次`);    }};const button = document.querySelector('button');button.addEventListener('click', listenerObject);\n\noptions一个指定有关 listener 属性的可选参数对象.\nCapture\n含义:\n\n一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;\n默认为false, 表示只有在冒泡阶段才触发.\n\n\n区别:\n\ncapture和useCapture实际上指的都是 监听器是否在捕获阶段触发 的布尔值.\n捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.\n\n\n后来DOM的规范更新时引入了options参数, 此后capture取代了useCapture的作用.\n如果addEventListener的第三个参数不指定对象, 只有布尔值, 那么默认是在设置useCapture\n\n\n\n\n可以先查看事件传播的阶段来辅助理解不同的阶段.\n\nOnce\n含义:\n一个布尔值，表示 listener 在添加之后最多只调用一次;\n默认为false, 表示可以多次调用.\n\n\ne.g.\n\nchild.addEventListener('click', () =&gt; {    console.log('子元素 - 目标阶段');},{once: true});\n\nonce属性被设置为true, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.\n\nPassive\n含义:\n\n一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();\n\n\n作用:\n\n明确不会在listener中不会调用preventDefault()方法, 即不会阻止浏览器的默认行为;\n此时, 浏览器可以直接渲染默认行为的结果, 无需等待listener的执行与默认行为的检查, 从而提高了性能.\n\n\nNotice:\n\n如果设置passive为true, 则listener当中不可出现preventDefault()方法, 否则会报错.\n\n\n\ne.g.\ndocument.addEventListener('wheel',()=&gt;{\tevent.preventDefault();  console.log(\"scrolling\");},{passive: false});\n\nwheel事件的默认行为是滚动页面;\nevent.preventDefault();表示会阻止鼠标滚动带来的页面滚动;\n\ndocument.addEventListener('wheel',()=&gt;{  console.log(\"scrolling\");},{passive: true});\n\n明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.\n\ndocument.addEventListener('wheel',()=&gt;{  event.preventDefault();  console.log(\"scrolling\");},{passive: true});\n\npassive的设置与listener内部矛盾, 将会报错.\n\nSignal用于有条件地移除事件监听器, 具体使用参见可被移除的监听器.\n事件传播的阶段\n捕获阶段 : 事件从根节点开始向目标节点传播;\ne.g. 点击事件从document开始传播, 经过html,body直到目标元素.\n\n\n目标阶段阶段 : 事件到达目标元素;\n冒泡阶段 : 事件从目标元素开始沿着DOM树向上传播.\n\nCase&lt;div id=\"parent\"&gt;  parent  &lt;div id=\"child\"&gt;child&lt;/div&gt;&lt;/div&gt;\nconst parent = document.querySelector('#parent');const child = document.querySelector('#child');parent.addEventListener('click', () =&gt; {    console.log('父元素 - 冒泡阶段');});parent.addEventListener('click', () =&gt; {    console.log('父元素 - 捕获阶段');}, { capture: true });child.addEventListener('click', () =&gt; {    console.log('子元素 - 目标阶段');});\n上述的child被包裹在parent内部.\n\n当点击parent时将会显示:\n\n\"父元素 - 捕获阶段\"\"父元素 - 冒泡阶段\"\n\n由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;\n\n\n当点击child时将会显示:\n\n\"父元素 - 捕获阶段\"\"子元素 - 目标阶段\"\"父元素 - 冒泡阶段\"\n\nchild是整个事件流的目标元素, 所以触发时机介于二者之间.\n\nNotice\n如果将div换成button, 则点击child时可能只会显示 目标 阶段的输出.\n\n这是因为, 不同浏览器对于button元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段\n\n\nevent.stopPropagation();加入该咒语代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:\n\n\nparent.addEventListener('click', () =&gt; {    console.log('父元素 - 捕获阶段');    event.stopPropagation();}, { capture: true });\n\n此时, 点击parent时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.\n\n可被移除的监听器&lt;table id=\"outside\"&gt;  &lt;tr&gt;    &lt;td id=\"t1\"&gt;one&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td id=\"t2\"&gt;two&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;\n// 为 table 添加可被移除的事件监听器const controller = new AbortController();const el = document.getElementById(\"outside\");el.addEventListener(\"click\", modifyText, { signal: controller.signal });// 改变 t2 内容的函数function modifyText() {  const t2 = document.getElementById(\"t2\");  if (t2.firstChild.nodeValue === \"three\") {    t2.firstChild.nodeValue = \"two\";  } else {    t2.firstChild.nodeValue = \"three\";    controller.abort(); // 当值变为 \"three\" 后，移除监听器  }}\n\n\nAbortController是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;\nsignal属性是一个AbortSignal对象, 用于控制监听器的移除;\ncontroller.abort()方法用于移除监听器;\n当t2的内容变为”three”时, 移除监听器, 使得modifyText函数不再执行. 此后, 点击t2不会触发modifyText函数.\n\n\n具体的构造步骤:\n\n创建一个AbortController实例: const controller = new AbortController();\n在事件监听器内的参数中添加signal: controller.signal选项;\n在需要移除监听器的地方调用controller.abort()方法;\n\n\n我们也可以直接使用removeEventListener()方法来移除事件监听器:\nremoveEventListener(type, listener);removeEventListener(type, listener, options);removeEventListener(type, listener, useCapture);\n\n\n\nNotices:\n如果同一个对象上存在2个事件监听器, 且仅在useCapture参数存在差异, 那么需要先后2次调用removeEventListener()方法才能完全移除其事件监听器;\n如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;\ntype,listener参数必须完全匹配才能移除事件监听器;\n对于options参数:\n字段相同: 一定可以移除;\n字段不同: 需要与默认值false匹配才可以移除.\n\n\n\n\n\nelement.addEventListener(\"mousedown\", handleMouseDown, { passive: true });element.removeEventListener(\"mousedown\", handleMouseDown, { passive: true }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, { capture: false }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, { capture: true }); // 失败element.removeEventListener(\"mousedown\", handleMouseDown, { passive: false }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, false); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, true); // 失败\n\n\n添加与移除的结合使用:\nconst body = document.querySelector(\"body\");const clickTarget = document.getElementById(\"click-target\");const mouseOverTarget = document.getElementById(\"mouse-over-target\");let toggle = false;function makeBackgroundYellow() {  body.style.backgroundColor = toggle ? \"white\" : \"yellow\";  toggle = !toggle;}clickTarget.addEventListener(\"click\", makeBackgroundYellow, false);mouseOverTarget.addEventListener(\"mouseover\", () =&gt; {  clickTarget.removeEventListener(\"click\", makeBackgroundYellow, false);});\n\n\n使用匿名函数在上述html例子下:\n// 改变 t2 内容的函数function modifyText(new_text) {  const t2 = document.getElementById(\"t2\");  t2.firstChild.nodeValue = new_text;}// 用匿名函数为 table 添加事件监听器const el = document.getElementById(\"outside\");el.addEventListener(  \"click\",  function () {    modifyText(\"four\");  },  false,);\n通过匿名函数封装代码, 将参数传入函数modifyText, 使得函数可以被调用.\n使用箭头函数// 改变 t2 内容的函数function modifyText(new_text) {  var t2 = document.getElementById(\"t2\");  t2.firstChild.nodeValue = new_text;}// 用箭头函数为 table 添加事件监听器const el = document.getElementById(\"outside\");el.addEventListener(  \"click\",  () =&gt; {    modifyText(\"four\");  },  false,);\n通过=&gt;{}形式的箭头函数简化代码书写.\n\n比较匿名与箭头匿名函数与箭头函数在此处的应用基本相同, 但是在this的指向上有所不同:\n\n匿名函数与其他普通的JS函数:this指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为undefined);\n\nfunction sayHello() {  console.log(this); // 在非严格模式下，this 指向 window}sayHello();\n\n\n箭头函数的this继承自外部作用域, 即调用该方法的对象.\n\nconst obj = {  name: \"ZJU\",  greet: function () {    console.log(this.name); // this 指向 obj  },};obj.greet(); // 输出：ZJU\n\n\ne.g.\n\nconst obj = {  name: \"ZJU\",  getNameWithAnonymous: function () {    return function () {      console.log(this.name);    };  },  getNameWithArrow: function () {    return () =&gt; {      console.log(this.name);    };  },};const anonymousFn = obj.getNameWithAnonymous();anonymousFn(); // 输出：undefinedconst arrowFn = obj.getNameWithArrow();arrowFn(); // 输出：ZJU\n\n进一步完善.\n\n事件对象事件对象 在事件处理函数的内部, 以固定指定名称出现的参数, 例如event,e,evt. 它被自动传递给事件处理函数，以提供额外的功能和信息。\ne.target始终是对 事件刚刚发生的元素 的引用\n表达式和运算符new() 用来创建对象实例的一个关键字. \n\n作用: 调用 一个 构造函数, 并返回一个由该构造函数创建的对象实例.\n\n语法new constructornew constructor()new constructor(arg1)new constructor(arg1, arg2)new constructor(arg1, arg2, /* …, */ argN)\n\n如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即new foo 等价于 new foo();\n构造函数内部的this将被绑定到新建的对象实例上;\n\n\ne.g.\n\nfunction Car(color, brand) {  this.color = color;   // 将 color 赋值给新对象  this.brand = brand;   // 将 brand 赋值给新对象}const myCar = new Car(\"red\", \"Toyota\");console.log(myCar.color); // 输出 \"red\"console.log(myCar.brand); // 输出 \"Toyota\"\n\n使用new()的步骤:\n\n定义构造函数;\n使用new()并传入构造函数的参数;\n将返回的对象实例赋值给一个变量;\n\n新增属性\n为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:\n\ncar1.color = \"black\" //为car1新增color属性\n\n\n\n添加共享属性到构造函数中的prototype:\n\nfunction Car() {}car1 = new Car();car2 = new Car();console.log(car1.color); // undefinedCar.prototype.color = \"原色\";console.log(car1.color); // '原色'car1.color = \"黑色\";console.log(car1.color); // '黑色'console.log(Object.getPrototypeOf(car1).color); // '原色'console.log(Object.getPrototypeOf(car2).color); // '原色'console.log(car1.color); // '黑色'console.log(car2.color); // '原色'\n\n\n此处的构造函数名为Car, 因此通过Car.prototype可以访问到构造函数的原型对象;\ngetPrototypeOf 表示获取对象的原型对象, 因此此处均为最初定义的 原色.\n\n\nnew.target函数通过new.target属性可以判断是否通过new关键字调用, 即构造.\n\n如果函数是正常调用, 则返回undefined;\n\n如果函数是通过new调用, 返回被调用的构造函数.\n\ne.g.\n\n\nfunction Car(color) {  if (!new.target) {    // 以函数的形式被调用。    return `${color}车`;  }  // 通过 new 被调用。  this.color = color;}const a = Car(\"红\"); // a 是“红车”const b = new Car(\"红\"); // b 是 `Car { color: \"红\" }`\n\n对象类型与实例对象类型 通过构造函数可以创建一个对象类型:\nfunction Car(make, model, year) {  this.make = make;  this.model = model;  this.year = year;}\n\n对象实例 通过使用new()方法, 由对象类型构造一个对象实例:\nconst myCar = new Car(\"鹰牌\", \"Talon TSi\", 1993);\n\n类与new在JS当中, 类 必须 通过new调用.\n\n可以优先阅读类相关的知识\n\n\ne.g.\n\nclass Animal {  //构造函数  constructor(name) {    this.name = name;  }  //实例方法  greet() {    console.log(`你好，我的名字是${this.name}`);  }}\n对于上述的类, 必须使用如下的调用方式:\nconst animal = new Animal(\"Dog\"); // 正常\n而下面这样类似于普通函数的调用方式会抛出错误:\nAnimal(\"Cat\"); // TypeError:  Class constructor Animal cannot be invoked without 'new'\n\n\n在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:\nanimal.greet(); // 输出 \"你好，我的名字是Dog\"\n\n\n下面给出与普通函数的区别:\nfunction Car(model) {  this.model = model;}const car = new Car(\"Toyota\"); // 正常Car(\"Honda\"); // 不抛出错误，但 this 会指向全局对象.const anotherCar = Car(\"cat\"); //此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.\n总结:\n\n以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;\n如果以new方法构造得到对象实例, 依旧正常.\n\n\n补充默认行为默认行为 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.\n\n比如存在以下的默认行为:\n滚动事件：触摸屏上滑动手指，页面会滚动;\n拖拽文件到浏览器：浏览器会尝试加载文件;\n点击链接 (&lt;a href=\"...\"&gt;)：跳转到指定的 URL;\n\n\n\n阻止默认行为 使用 event.preventDefault() 方法可以阻止事件的默认行为.\n\ne.g: 阻止链接跳转\n\ndocument.querySelector('a').addEventListener('click', function(event) {    event.preventDefault(); // 阻止点击链接时的默认行为    console.log('链接被点击，但没有跳转');});\n\n\n作用:\n通过阻止默认行为, 可以实现自定义逻辑.\n\n\n\nthis\nthis可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;\nthis 指向的是当前函数的调用者，而不是函数内部定义的变量.\n\n\n\n\ne.g.\n\nconst obj = {    a: \"a in the obj\",    b: \"b in the obj\",    f: function() {        const b = \"b in the function\"; // 函数作用域        console.log(this.b); // 访问 this.b    }};const b = \"b outside of the func\";obj.f();\n\n此处的f\n\n函数上下文中的this\nthis参数的值取决于函数如何被调用, 而不是函数如何被定义.\n\n// 对象可以作为第一个参数传递给 'call' 或 'apply'，// 并且 'this' 将被绑定到它。const obj = { a: \"Custom\" };// 使用 var 声明的变量成为 'globalThis' 的属性。var a = \"Global\";function whatsThis() {  return this.a; // 'this' 取决于函数如何被调用}whatsThis(); // 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'obj.whatsThis = whatsThis;obj.whatsThis(); // 'Custom'; 'this' 参数被绑定到 obj\n\n同样是调用函数whatsThis(), 但是this参数被绑定到不同的对象上, 导致返回值不同;\n在非严格模式下, this参数默认指向globalThis, 即全局对象;\n对于典型函数, this指向函数访问的对象;\n\n\ne.g.\n\nconst obj = {    b: \"b in the obj\",    f: function() {        const b = \"b in the function\"; // 函数作用域        console.log(this.b); // 访问 this.b    }};const b = \"b outside of the func\";obj.f();\n\n此处f作为obj对象的方法被调用, 因此普通函数的this指向obj.\n\n\ne.g. 直接调用的普通函数this指向全局:\n\nconst obj = {    a: \"a in the obj\",    f: function() {        const funcA = function () { return this.a }; // 普通函数，this 由调用方式决定        console.log(funcA()); // 访问 this.a    }};var a = \"a in the global\";obj.f(); // \"a in the global\"\n\n\n此处的funcA并没有类似于作为对象的属性调用(obj.funcA()), 因此其this指向全局作用域(window), 输出undefined, 而是直接调用的形式, 因此其this指向全局作用域.\n\n\n对this传值使用call()以及apply()方法可以将this绑定到其他对象上.\ncall()\n形式: func.call(thisArg, arg1, arg2, ...)\ne.g:\n\nfunction add(c, d) {  return this.a + this.b + c + d;}const o = { a: 1, b: 3 };// 第一个参数被绑定到隐式的 'this' 参数；// 剩余的参数被绑定到命名参数。add.call(o, 5, 7); // 16\n\napply()\n形式: func.apply(thisArg, [argsArray])\ne.g:\n\nfunction add(c, d) {  return this.a + this.b + c + d;}const o = { a: 1, b: 3 };// 第一个参数被绑定到隐式的 'this' 参数；// 第二个参数是一个数组，其成员被绑定到命名参数。add.apply(o, [10, 20]); // 34\n\nbind()\n形式: f.bind(someObject);\n作用: \n创建一个新的函数(需要重新赋值), 具有与f相同的函数体和作用域;\n新函数的this被 永久地 绑定到someObject, 不随调用方式的变化而变化.\n\n\n限制: \nbind无法多次生效. 即对函数fbind得到的g, 无法继续用bind得到期望的h;\n\n\ne.g. 多次bind:\n\nfunction f() {  return this.a;}const g = f.bind({ b: \"azerty\" });console.log(g()); // undefinedconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！console.log(h()); // undefinedconst o = { a: 37, f, g, h };console.log(o.a, o.f(), o.g(), o.h()); // 37 37 undefined undefined\n\n\n由于bind只能对一个原始函数作用, 因此由f得到的g无法继续由bind绑定this得到期望的h, 此处h的this依旧是{b: \"azerty\"}, 因此在输出对象a时显示undefined;\no.f()的调用是普通函数的调用, 因此其this继承自对象o, 输出37;\n\n\n\ne.g. 对象\n\nfunction f() {  return this.a + \" \" + this.c;}const g = f.bind({ b: \"azerty\" , c:\"ccc\"});console.log(g()); // \"undefined ccc\"const h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！console.log(h()); // \"undefined ccc\"const o = { a: 37, f, g, h };console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty\n\n\nbind绑定的this是永久覆盖, 而非简单叠加;\n由于bind绑定的this不随者调用方式的变化而变化, 因此即使处于对象o当中, g,h依旧不会输出o中的a.\n\n\n箭头函数中的this使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。\n普通函数:\nconst a = \"a in the global\";const foo = function () {return this.a};const obj = { a: \"a in the obj\", f: foo};console.log(obj.f()); // \"a in the obj\"\n\ncall()、 apply()、 bind() 无法改变箭头函数的this(但是call与apply的其他参数可以正常传递:\nconst foo = ()=&gt; this.a;const obj = { a: \"a in the obj\", f: foo.bind({a:\"a in the bind\"}) // 显式绑定 this 到 obj, 但是无法生效};console.log(obj.f()); // undefined\n\n换成普通函数则输出a in the obj.\n\n\n全局作用域\n\nvar a = \"a in the global\";const foo1 = () =&gt; this.a;const obj = {\ta: \"a in the obj\",\tf: ()=&gt; a};console.log(obj.f());\n\n作用域作用域 指当前的执行上下文, 在其中的值和表达式可以被访问. \n\n全局作用域: 脚本模式运行所有代码的默认作用域;\n模块作用域: 模块模式中运行代码的作用域;\n函数作用域: 由函数创建的作用域\n块级作用域: 由let或const声明的变量的作用域.(对于var无效);\n\n{  var x = 1;}console.log(x); // 1{  const x = 1;}console.log(x); // undefined\n\nNotices:\n\n对象本身并不会创建作用域, 只是一个键值对的集合;\n箭头函数也不会创建自己的作用域, 而是 继承 外层作用域中的this;\n\n变量与作用域\nvar在全局作用域中声明时会成为 全局对象 (window或global)的属性;\nlet和const即使在全局作用域中声明, 也不会成为全局对象的属性;\n\nvar a = \"1\";let b = \"2\";window.a; // \"1\"window.b; // undefined\n\n因此, 建议在全局作用域中不要使用var声明变量, 而使用let或const声明变量. 从而避免导致意外的覆盖和冲突.\n\n函数与作用域普通函数普通函数和匿名函数的作用域继承自其定义时的作用域.\nconst obj = {    a: \"a in the obj\",    insideObj: {        g: function() {            return this.a; // 普通函数，this 动态绑定到 insideObj        }    },    f: function() {        return this.a; // 普通函数，this 动态绑定到 obj    }};console.log(obj.f());        // \"a in the obj\"console.log(obj.insideObj.g()); // undefined，因为 insideObj 中没有 a\n\n箭头函数e.g. 箭头函数继承外层作用域:\nvar a = \"a in the global\";const obj = {    a: \"a in the obj\",    insideObj: {        g: () =&gt; this.a    },    f: () =&gt; this.a};console.log(obj.f());        // \"a in the global\"console.log(obj.insideObj.g()); //\"a in the global\"\n由于对象不会创建作用域, 因此此处的箭头函数的this继承了外层作用域(window)的this, 且var创建的变量存在于全局作用域中.\n语法糖语法糖 一种让代码更简洁、更易读的语法形式.\n\n本质上没有增加语言的功能, 而是对已有功能的 包装 或者优化;\n可读性提升: 让代码更填 使得代码更加容易理解和书写;\n底层实现: 实质上依旧用基础的语法实现.\n\n类类 class 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承prototype的封装.\n使用class的写法:\nclass Person {  constructor(name) {    this.name = name;  }  greet() {    console.log(`Hello, my name is ${this.name}`);  }}const person = new Person(\"Alice\");person.greet(); // 输出：Hello, my name is Alice\n\n等价的原型写法:\nfunction Person(name) {  this.name = name;}Person.prototype.greet = function() {  console.log(`Hello, my name is ${this.name}`);};const person = new Person(\"Alice\");person.greet(); // 输出：Hello, my name is Alice\n\n箭头函数箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.\n\ne.g.\n\n// 使用箭头函数const add = (a, b) =&gt; a + b;// 等价的普通函数const add = function add(a, b) {  return a + b;}\n\n结构赋值结构赋值 手动提取对象属性的语法糖.\n\n使用结构赋值:\n\nconst person = {name:\"Zhuo\", gender:\"male\"};const {name, gender} = person;\n\n\n等价的原型写法:\n\nconst person = {name:\"Zhuo\", gender:\"male\"};const name = person.name;const gender = person.gender;\n\n赋值规则结构赋值时, 基于 属性名匹配 而非顺序.因此, 对象结构的{}内部属性必须和 对象的属性名 相对应.\n错误的示例:\nconst person = { name: \"Alice\", age: 25 };const { a, b } = person;console.log(a); // 输出：undefinedconsole.log(b); // 输出：undefined\n\n重命名属性的写法:\nconst person = { name: \"Alice\", age: 25 };const { name: a, age: b } = person;console.log(a); // 输出：Aliceconsole.log(b); // 输出：25\n\n手动赋值: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:\nconst person = { name: \"Alice\" };const { name, age = 30 } = person;console.log(name); // 输出：Aliceconsole.log(age);  // 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）\n数组的结构赋值上述讨论的结构赋值都是对 对象 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— 基于顺序赋值:\nconst arr = [\"Alice\", 25];const [a, b] = arr;console.log(a); // 输出：Aliceconsole.log(b); // 输出：25\n","categories":["学习笔记"],"tags":["前端","JS"]},{"title":"计算机体系结构复习","url":"/2025/06/21/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/arch%E5%A4%8D%E4%B9%A0/","content":"\n任课老师：何水兵\n\n知识点梳理CH1可靠性\navailability = MTTF / MTBF\nFIT：faliure in time = 1 / MTTF\n\n计算系统整体的MTTF时，我们可以优先计算FIT（各个组件的rate相加），然后求倒数\nMIPSmillions of instructions per second\nPerformanceperformance是执行时间的倒数\n不同的性能比较策略\n\n\n几何平均就是将各个程序的执行时间相乘然后开根号，作为平均的执行时间；\ndepends on which machine is the reference：在不清楚加权算法中的权值情况时，采取参照的方法计算平均值，类似于加权的效果，但是结果与选择的参照对象相关，因此说～\n\n几何平均：\n\n\n流水线相关可以一定程度上允许结构冲突：\n\n为了减少cost和减少单元的latency\n\nthroughputThe throughput of a CPU pipeline is the number of instructions completed per second\n\nCPU流水线的吞吐量指的就是每秒执行的指令数\n\nhow to stall\n设计stall控制单元，检测是否存在冲突需要stall\n如果需要stall，就disable writing PC and IF/ID latch，并且插入一个nop指令到ID/EX，禁止写回寄存器和写入MEM\n\ndouble bump如果在一个cc内允许 write-then-read，就可以只插入两条nop：\n\n\n跳转指令∆ = 目标地址 - 跳转指令的下一条指令的地址！\n\n因为在取出指令后PC+4就生效了；\n与汇编指令具有异曲同工之妙\n\n\n\n同时注意，是在MEM阶段而非EX阶段写回PC寄存器，在跳转指令的WB阶段开始取址\n\n总共stall了3个cc\n\n对应的简单问题：\n\n\n为了解决上述的stall损失，我们可以考虑在EX阶段前递，或者在ID阶段增加硬件单元。\n另外的可行办法是延迟槽技术：\n\n因为跳转指令在ID阶段才确定，此时IF已经取址了。我们将一定会执行的指令（无论跳转是否发生）放置在条件跳转指令的下一条，避免这条(组)指令的浪费\n延迟槽中的指令应当由编译器选择合适的指令(组)\n\n移位寄存器为了解决写端口的冲突，直接增加写端口是不经济的。\n我们考虑一种检测矛盾并实现序列化写操作的技术——使用移位寄存器：\n\n\n\n在ID阶段分析指令之后，如果与已经发射（此处应该指的是应该开始执行？）的指令存在写端口的冲突（利用移位寄存器判断），就stall这条指令\n\n如果指令需要写回，利用一个移位寄存器，设置与当前指令将要写回所需的cc相等的值，作为移位寄存器位数的1.每个cc将对应的移位寄存器右移。\n数据冲突\nRAW：true dependance，因为无法通过寄存器重命名或者指令重排来优化\nWAW：output dependance\nWAR：anti-dependance，因为和RAW是相反的\n\nCH2 存储器层级block identification\nindex 用于选中cache的set / cache line\nindex bits = \n\n\noffset：用于选择block内部的data\noffset size = \n\n\ntag：用于比较block是否匹配\nbits: 地址size - index size - offset size\n\n\n\n一个简单的直接映射的计算例子：\n\n\n\n地址总位数可能由memory size间接给出：e.g. Memory-size = 4G = ， 得到一共有32位\n\nwrite strategy一般来说：\n\n写回策略 + write allocate\n写穿策略 + write around：发生write miss的时候，只会写入到内存\n\n一个简单的例子：\n\n\n\n当发生了read miss的时候，将mem[200]加载到cache，下一次的写将命中\n\nCache performanceMemory stall\n\n\n\n\n\nCPU Execution time = (CPU clock cycles + Memory stall cycles) x Clock cycle time\n\n其中后者可以如此计算： \n注意判断是否需要将data和ins.的mem区分\n\n一个简单的例子：\n\n\nAMAT\n\nAMAT也就是: Average memory access time.\n所以可以用来计算 real CPI= Ideal CPI + Average stalls per instruction  , 其中后者根据:\n\n计算得到,  且 HitTime为理想的CPI, access times是每条指令平均访问memory的次数 = MPI , e.g. 有30%的数据访存指令, 对应了1.3.（考虑指令cache的1 on unified cache）\n一个简单的例子——AMAT按照data和ins加权计算：\n\n\n补充：\n\nMPI(memory reference per instruction)＝1.5 , 也就是指令对mem的平均访问次数.\n注意AMAT的计算涉及了hit time，unified cache的hit time可能比split cache的大\n无特别说明的情况下，hit time = Ideal CPI\n\nSplit &amp; Unified\nmiss rate的计算：\n\n\n\n\n表格中给出的数据是miss相关的估计，实际上的MPI可能由题目进一步给出，因为不同的程序对应的访存比例可能不同，根据实际情况计算\n\nImprove cache performance减少hit时间 4’\nsmall and simple caches\n\n更少的硬件支持；直接映射的速度更快\n\n\navoiding address translation\n\n使用TLB作为page table的cache，Virtual indexed, Physically tagged\n\n\nway prediction\n\n在cache中采取extra bits预测way，如果预测正确只需要1cc；否则需要额外的cc改变预测位\n\n\ntrace caches\n\ntrace：动态指令序列，主要为 branch设计\n将branch在内的指令打包放入trace cache，由于大部分时间，分支跳转后要指令的指令序列是相同的，因此我们可以直接从trace cache中取用\n\n\n\n增加cache的bandwidth 3‘\npipelined cache access\n顾名思义，将cache的访问流水线化\n\n\nmultibanked caches\n将cache划分为几个不同的区域，从而允许同时的访问\n\n\nnon-blocking caches\n针对 hit under miss 的情况设计，允许CPU在miss之后继续执行指令，避免陷入阻塞block\n\n\n\n减少miss penalty 4’\nmultilevel caches\n多级cache带来的概念：local miss rate（当前level的缺失率） 与 global miss rate（与上层的cache相关）\n\n\ncritical word first\n在block中找到需要的word后就快速启动，后续指令的执行和block的剩余内容的搬运并行执行，因此通常用于block的size较大的情况\n又称为 wrapped fetch 与 requested word first\n\n\nread miss prior to writes\n在写回策略下, 如果发生了 read miss, 需要从主存中读取对应的块并写入 cache. 可以直接取出数据并开始执行指令, 将待写的数据放入 buffer.\n\n\nmerging write buffers\n多次的写合并到一次的操作， 特别是写的地址是相同的时候，显著降低了penalty\n\n\nvictim caches\n在相邻的cache层级之间增设牺牲缓存\n发生一次 miss之后并不直接将其踢出 cache, 而是放入~\n\n\n\n降低miss rate 4’\n控制变量分析\n\n\nlarger block size\n降低了强制miss rate\n但是增大了miss penalty，以及发生冲突miss的可能（block的数量减少）\n\n\nlarge cache size\n经验法则: 翻倍的cache容量, 带来降低25%的缺失率.\n降低了容量miss\n但是增大了hit time和cost\n\n\nhigher associativity\n经验法则: 一个大小为N的直接映射缓存 , 与一个大小为N/2的2路组相联 缓存具有相同的未命中率.\n8-way比较理想。更大的组关联度导致比较时间的增加，从而可能导致时钟周期的增大/周期数的增加\n\n\ncompiler optimization\n在不改变硬件的情况下, 使用编译器重排指令的序列\n数组合并\n循环交换：改变循环的嵌套顺序\n循环融合\nblocking策略\n\n\nway prediction and Pseudo-Associative Cache\n路预测的技术与之前提到的相同，用一个预测位来预测\n伪关联缓存：divide cache，然后在miss之后查看当前cache的剩余部分\n如果此时命中，称为 pseudo-hit，时间介于hit 与  miss penalty之间\n\n\n\n\n\n3C回顾：\n\nCompulsory: 冷启动，又称为强制miss;\nCapacity:  缓存的空间不足导致的 miss. 发生在全关联当中.\nConflict（collision）:  set associative or direct mapped当中发生.\n\n\n主要关注冲突miss和强制miss的优化\n\n通过流水线降低miss penalty和rate 2’\nhardware prefetching\n使CPU预先取用一部分的数据到特殊的缓存块当中, 从而降低了 冷启动的影响.\n预取的结果放入 stream buffer，\n\n\ncompiler prefetching\n由编译器插入prefetch ins.来获取需要的数据\n根据预取数据存放到寄存器还是cache，分为binding prefetch 和 non-binding prefetch\n\n\n\nCH3scoreboard\n看一眼\n\n\n\n流水线的阶段\nIF: 取指令\nIS: 以下条件同时满足时允许发射：\nFU空闲——避免结构冲突；\n正在执行的指令，没有一条要写回的Rd与当前指令相同——避免了WAW冲突\n\n\nRO: 监视数据冲突，当且仅当两个源寄存器都准备好了，才读取\nEX: 在不同的FU中执行(MEM涵盖在整数的FU当中)\nWB：更新状态表之后的下一个cc可以RO\n\n表的设计\n指令状态表 Instruction Status Table\n记录指令的状态，在哪个阶段\n\n\n功能单元状态表 Functional Unit Status Table\nbusy：FU 是否空闲；op：FU 正在执行什么操作\nVi, Vj, Vk：FU 的操作数对应着哪个寄存器\nQj, Qk：FU 的操作数如果没准备好，应该从哪个 FU 读取\nRj, Rk：操作数是否准备好，如果准备好了就填 yes，然后在RO阶段读取之后立即改为 NO\n率先执行的指令在WB的时候检查写入的寄存器是否在某个FU的ready-list中为 YES，表示等待另一个操作数准备好之后同时读取（还未读取）\n\n\n\n\n寄存器状态表 Register Status Table\n如果某个寄存器的值正在被某个 FU 的操作生成，填入这个操作FU的编号\n生成好了之后，填入实际值\n\n\n\n显式重命名通过设置更多的物理寄存器, 同时维护一个 free list.\n\n每一条需要写寄存器的盒指令，均分配一个新的物理寄存器；\n此时还需要记录原来的map（对应的物理寄存器），这是为了在发生中断/rollback的时候可以复原之前的映射关系；\n\n\n当可以写回的时候，再将得到的值写回到逻辑寄存器，同时将锁定的物理寄存器 free up（加入到free list的末尾）\n\n\n\n加入显式重命名之后的计分板阶段分析：\n\n\n显式重命名消除冲突的示例：\n\n\nTomasolo\n\n算法的思想\nScoreboard 算法的控制权全部在 Scoreboard 的三张表中\nTomasulo 算法将 FU 的控制权交给 FU 自己，每个 FU 有自己的指令缓存\n\n\n\n\nIF\nIS\nEX\nWB\n\n\n\n硬件设计\n每个 FU 有一个 buffer，叫做保留站（reservation station）\nbusy：FU 是否空闲；op：FU 正在执行什么操作\nVj, Vk：两个源寄存器对应的寄存器值（注意是值）\nQj, Qk：两个源寄存器如果没准备好，应该从哪个 FU 读取\n此外还会记录 FU &lt;u&gt;距离完成执行这条指令的剩余周期数 &lt;/u&gt;\n\n\n内存也有自己的保留站，叫做 Load/Store Buffer\nbusy：这个位置是否有内存读写请求\naddress：读写的地址\n\n\n有一个 Register Status Table，和 Scoreboard 算法中的一样\n有一个 Common Data Bus（CDB），负责将结果广播到所有的保留站和寄存器\n将需要的数据从总线上直接取用, 而不用通过寄存器\n因此传递的时候, 不仅传递值, 同时传递对应操作的编号\n\n\n\n带投机的实现\n\n为了在遇到分支指令的时候避免stall，我们可以采取投机的方式——假设分支指令不会跳转，继续执行之后的指令\n为了实现投机机制，我们需要一种在预测失败之后可以rollback的机制——新增Reorder buffer i.e. ROB\n在之前的流程基础上，增加commit阶段，让CDB的结果先写入ROB，然后在ROB中实现顺序提交，如果头部指令是：\n\n普通指令：将结果写回到寄存器和内存，然后从ROB中删除\n分支指令，并且预测：\n正确：当做普通指令，继续执行\n错误：清空flush此时ROB中的所有指令\n\n\n\nNotice：\n\nIS阶段需要将指令同时写到ROB中，因此只有当保留站和ROB都有空余的情况下，可以issue\nissue之后，可以从ROB和寄存器中读取操作数到保留站中\n内存中的数据也可能存在RAW的冲突，因此在load的时候，需要从ROB中的store的地址相比较：\n\n\n\n\n只有当我们明确知道load对应的内存地址与先前store指令的目标地址不冲突的时候，才执行load（向内存发送请求），否则stall\n\nMEM的RAW与解决参考的解决：\n\n\n对应的例子：\n\n\n\n此处右下角的应该是load buffer？所以实际填写的不是存在冲突的store地址，而是load的地址；\n猜测是这样的流程：如果load前面的某个store的目标地址还没有计算完毕，就将load的地址栏填入store的ROB编号，然后store完成的时候带着ROB编号在load内部检查，同时让store的地址与load的实际地址进行比较？\n所以上图中的“填入到load参照的表格中”有问题\n\n总结\n\n\nTomasulo也无法解决RAW冲突，这是无法解决的冲突\n\n分支预测技术分支预测表\n一位预测器：分支历史表，使用PC的低位作为索引，0预测不跳转，1预测跳转\n两位预测器\nN位预测器：\n使用 来预测不跳转\n使用来预测跳转\n如果要求计算准确率，注意是等到稳定的时候再计算（一开始的初始值并不重要）\n\n\n\n相关预测器当前分支指令依赖别的分支指令的结果：\n\n\nm,n预测器\nm：使用m位的移位寄存器来储存m条指令是否跳转的结果\n每当得到一条最近的指令是否跳转的时候，就进行移位并填充0表示not-taken 或者 1表示taken\n\n\nn： 使用n-bit来预测当前指令是否跳转\n分支预测缓冲区：一个记录分支跳转历史的buffer，使用上述的m-bit global history + 指令的低位进行index，每一行都对应了指定分支指令的预测器\n\n\n\n预测器大小的计算实际的硬件组成：\n\n\n对应的大小计算：\n\n\n其他预测器\nTournament predictor：为了避免PC低位的相同干扰, 采用 global 和 local两个预测器，但是区别于上述的预测器，此处二者采取或得到对应的预测器\nTODO：课件3.2的size计算\n\n\nGshare预测器：将PC低位和历史记录进行异或, 从而进行选择\n\nBTBbranch target buffer ｜ 分支目标缓冲区\n\n\n\n记录分支指令预测的跳转地址\n利用指令地址index，如果在BTB中找到了就取出预测地址并执行\nif branch taken，照常执行，没有stall\nif not taken，将fetch的ins.清空，并且将预测错误的entry从BTB中删除\n\n\n同理，如果一开始没有在BTB中index找到对应指令的entry，并且结果显示指令需要跳转，就在BTB中加入这一对的entry用于之后的快速预测\n\n\n\nIntegrated Instruction Fetch Units随着CPI降低，取址单元可能成为瓶颈\n因此，考虑将fetch unit与分支预测器、指令预取器以及指令的buffer相集成\nReturn Address Predictors预测目标地址在运行时变化的间接跳转的技术。\n将返回地址记录在类似于栈的buffer中，避免到内存中取返回地址，加速函数的返回\n分支预测技术总结\n\n\nCH4  DLPFlynn标准分类\n\n\nLLP时的依赖检查：关注是否在同一层读取了其他层写入的结果\n可以使用本层中串行计算的结果\n\n\nreductions\n\nRename来解除依赖\n\n\n根据题目找到对应的依赖，然后据此rename寄存器\n\n\nStrip Mining 条带挖掘MVL指的是向量处理器中寄存器最多的字长.\n当用户实际的处理长度超过MVL时, 进行取模, 首先用标量处理余数, 然后用向量计算剩余的部分.\n一个简单的例子：\n\n\n向量机的问题\n需要 set-up 时间;\n内存的访问带宽会影响向量机的性能\n\n提升向量机的表现convoy:\n\n可以并行的向量计算指令的集合\n不存在结构冲突\n可以通过vector chain来解决RAW冲突\n\nchime  ：the unit of time taken to execute one convey\nVector Chaining解决了RAW的冲突.\n\n\n实际等价于流水线的 forwarding. 不同的是向量机是对向量的打包计算.\nConditional Execution为了处理 if 语句的优化.\nfor（I=0； I&lt;N; I++）\tif （A[I］！= B［I］） A［I］ -= B［I]；\n\n\n\nV0就是其中的标志寄存器.\n根据标志位, 选择需要的位进行计算(压缩), 然后将其扩展成完整的向量.\n\n\nsparce matrices为了解决矩阵乘法中太多0的问题.\n涉及到 Vector Scatter/Gather 的方法, 实际就是不连续的访存操作.\ngather：从不连续的地址读取并加载到一个向量寄存器中\nfor (i=0; i&lt;N; i++)    A[i] = B[i] + C[D[i]]\n\n\n对应的指令: (LVI)\n\nLV\t\t\tVD, RD        ; Load indices in D vectorLVI\tVC,(RC, VD)   ; Load indirect from RC baseLV \tVB, RB\t  ; Load B vectorADDV.D \tVA, VB, VC\t  ; Do addSV \tVA, RA\t  ; Store result\n\nscatter：将一个向量寄存器中的数据写入到不连续的地址中\nfor (i=0; i&lt;N; i++)    A[B[i]]++;\n\n\n对应的指令:（SVI）\n\nLV \tVB, RB      ; Load indices in B vectorLVI \tVA,(RA, VB) ; Gather initial A valuesADDV \tVA, RA, 1\t; IncrementSVI \tVA,(RA, VB) ; Scatter incremented values\n\nMulti-lane Implementation同一个向量指令的不同分量，可以在不同的lane上执行\n\n不同的lane之间不能存在数据冲突\n\n在多个FU的流水线中优化:\n\n\nChain &amp; Multiple Lane可以将上述的思路和chain相结合.\n向量机通过展开, 减少了条件判断等指令来减少了指令数.\n\n操作数指的是涉及的运算个数(比如一条向量计算涉及512个操作数, 但是指令数是1).\n\n编译器和用户可以互相提示数组是否可以向量化.\nSIMD: single instruction multiple data\nGPUGraphical Processing Units.\n采取 SIMT: Single Instruction Multiple Thread.\n\n每个线程负责一条指令的部分计算.\n\nthread =&gt; block =&gt; grid\n与向量机的主要区别\n不存在标量处理器\n使用多线程解决内存访问的延迟\n向量机通过bank扩大内存访问的带宽\n\n\n具有很多的function units (类似于具有很多小的处理器.)\n\n术语warp\n\n32 threads ==&gt; warp / SIMD thread\n必须执行相同的指令.\nwarp之间不存在数据依赖.\n\n\n\nPTX\n对应的机器汇编.\npredicate register\n谓词寄存器, 类似于向量机中的标量寄存器.\nMEM层次\nprivate memory\nlocal memory: 1个block内部共享\nGPU memory: 公共.\n\n循环级别的并行有的循环间的数据依赖可以被消除:\nfor (i=0; i&lt;100; i=i+1) {  A[i] = A[i] + B[i]; /* S1 */  B[i+1] = C[i] + D[i]; /* S2 */}\n\n取出首尾的两条指令，改写:\nA[0] = A[0] + B[0];for (i=0; i&lt;99; i=i+1) {  B[i+1] = C[i] + D[i];  A[i+1] = A[i+1] + B[i+1];}B[100] = C[99] + D[99];\n\n寻找循环依赖\n\n不同的迭代中, 存在读取和存储的地址相同的情况 ==&gt; 存在循环依赖.\n\n计算方式: If a dependency exists, GCD(c,a) must evenly divide (d-b)\n通过枚举  来判断是否存在冲突，本质上就是图示的公式是否成立\n\n可以通过变量的重命名来解决WAW等冲突.\n\n\nCH5 TLP其他概念\nNUMA又叫distributed shared-memory multiprocessor (DSM / DSP)\nUMA又被叫做 symmetric multiprocessors (SMP)  or  centralized shared-memory multiprocessors\n\n概念区分\ncoherence：规定了针对同一内存地址读写操作的行为\nconsistency：定义了涉及不同内存地址访问时的读写顺序行为\n\n\n\n硬件原语\nexch 用于将寄存器的值与内存地址中的值交换\n该操作是原子性的，一次性完成读取旧值和写入新值的操作\n\n\n\nlr与sc\n补充这部分的指令介绍，方便后续相关汇编的理解\n\nLoad-Reserved（加载保留）\n\n加载之后在硬件层面预留了这个内存地址，表示有向其写入的意图，用于后续的sc指令是否允许写入\nlr 与 ll也就是 load linked 本质上是一样的，只不过后者是MIPS架构中的指令名称，都是加载并预留的原子指令\n\nStore-Conditional（条件存储）\n\n尝试将值写入到内存地址；\n只有在之前对该地址有成功的lr预留 且 未被其他处理器干扰的情况下，才能成功写入\n具有返回值：\n如果失败：返回0\n如果成功返回非0\n\n\n\n\n\nlr与sc的原子性操作应用\n\n\nNote：Only Regitser-Register instruction can be insert between LL &amp; SC\n\n自旋锁spin lock指的是程序陷入了不断尝试获得lock的loop\n一个简单的版本\nli R2, #1lockit: exch R2, 0(R1)bnez R2, lockit\n\n\nR1所对应的内存地址保存了锁是否为空闲的信息，0 表示 free， 1表示被占用\n上述版本将1加载到R2，并不断尝试将它的值与R1对应的内存地址的值交换\n如果锁正在被占用，R2还是1，因此会不断陷入lockit的循环，直到某次的loop成功加锁（R2被交换为0），然后继续执行\n\n上述的问题是，不断尝试 exch涉及到了多次的读写操作，会带来总线上的invalidate信号的traffic\n因此，我们考虑采取下面的优化方案\n优化的版本\nlockit: ld x2,0(x1)         ; load of lock        bnez x2,lockit      ; not available-spin        addi x2,R0,#1       ; load locked value        EXCH x2,0(x1)       ; swap        bnez x2,lockit      ; branch if lock wasn’t 0\n\n\n相比于简单版本的反复exch，优化之后的loop里只涉及到了读操作，因此对程序的表现更加友好\n\n使用 exch的指令由于读写合一，操作不灵活，我们考虑将读写利用同样是原子性指令的 ll和 sc来分离，实现等价的效果：\n采取LL和SC实现：\nlockit: lr x2,0(x1)         ; load reserved        bnez x2,lockit      ; not available-spin        addi x2,R0,#1       ; locked value        sc x2,0(x1)         ; store （成功写入/加锁 返回0）        bnez x2,lockit      ; branch if store fails\n\n\n因为lr、sc和exch一样，也是原子性操作，确保了“检查锁是否可以用”和“设置锁”不会被其他线程打断；\n不同的是，exch通过交换之后的寄存器值来判断是否加锁成功，而sc利用自身操作的返回值来判断是否成功加锁\n\n自旋锁的性能分析\n\n\nTODO\n\nSnoopy两种转换规则：\n\n一定要转换成 S 状态再read（除了自己read自己的hit）；\n\n一定要转换成 E / M 状态再write\n\nP1写入X的新值之后，需要确保其他处理器知道变化，分为两种策略：\n\nWrite Invalidate：将其他P的副本置为无效（搭配写穿透）\n但是也适合写回策略搭配，注意dirty位的使用\n\n\nWrite Broadcast：将其他的副本直接写入新值（搭配写回策略）\n\n\n\n一个简单的例子；\n\n\n\n注意此时bus信号的桥梁作用：\n发生了read miss之后，首先将P2的对应cache line设置为share状态（此时还不知道值）\n总线信号传到P1之后，P1的对应状态修改为share，并且发起了write back的信号，将A1的值写入mem\n之后，总线信号read data让P2读取了mem中的值，完成了 P2：read A1的操作\n\n\n\n每一个处理器/线程对每一个block具有自己的状态\n状态机\n\n\n处于E状态时，如果收到了bus上的read-miss信号，会将该P改为S状态\n\n\n\nDirectory\nlocal node  发起请求的处理器\nhome node  对应地址所在的处理器\nremote node 拥有这个副本的处理器\n\n在homeNode中存储一个block在不同处理器/线程中的状态\n\n\n\n其中的 fetch/invalidate发生在：local发生了write miss，并且home中对应的block为E状态，向独占该block的P发送～信号，确保将仅在对应P中的数据读取再非法化（内存中数据过时）\n\n读取之后的数据先存放在了home中，然后再由home发送data reply给local（一般来说local写入了新值，并不需要这个旧值；但是如果写入的新值是 X+1，就必须获得正确的旧值了，因此还是有必要的）\n\n\nwrite miss初始：\n\n\n写入：\n\n\nfetch/invalidate初始：\n\n\n过程：\n\n\n\n如果目录节点中记录的状态是E，就向对应的处理器发送 fetch的信号\n\n根据cache填写目录\n\n对应的简单例子：\n\n\n另一个语言描述的例子（答案）：\n\n\n\n22-23回忆卷的最后一题\n\ncache失效问题P将自己cache中的block kick out时，需要将对应的home中的sharer中将P踢出序列，如果原本仅有P本身，就需要将对应的状态改为U，表示uncached.\n\n\nMESI\n如果没有特别说明，就当做MSI\n\n\n\n状态：\n\nInvalid: 缓存块无效，不能被使用；\nShared: 缓存块未被修改，且可能存在于多个缓存中，内存中的数据是最新的；\nModified: 缓存行已被修改，且该缓存行是唯一的有效副本，内存中的数据已过时；\nExclusive：缓存块未被修改，且是唯一的有效副本，内存中的数据是最新的。\n\nE的存在是为了优化写入性能和减少总线流量，具体来说，我们用E来区分某个缓存块只被一个处理器读取且还没有写入的状态，是为了在此后该处理器写入该缓存时，不需要在总线上发送Invalidate的信号（因为没有共享缓存的其他处理器）\n\n如果是传统的MSI，即使share的成员只有一个，还是要发送信号到总线，被其他的处理器接收并处理，这带来了额外的时间开销\n\nConsistencySequential consistency特征：Delay next memory access until the previous one is completed.\n\n对指令的执行有着严格的顺序要求，虽然保证了正确性，但是延时较高\n\n\n相同处理器内部的内存访问是有序的\n不同处理器的内存访问是交错的\n\n课本的例子：\n\n\n简单的计算：\n\n\nRelaxed Models为了降低SC带来的延时，我们采取 Synchronized program 来让指令的读写在乱序执行中保持与串行执行等价的效果，以下是不同等级的model：\n\n\n\n下方的顺序表示该模型在前者的基础上去除了对应的顺序约束，但是要求访问的对象不是相同地址的\n比如在TSO中， C= 作为写操作，允许和 = D 的读操作一起执行，解除了W-R的约束\n\njxh老师的PPT\n针对核心的补充摘录\n\nTomasulo的三个主要优点\n\nThe distribution of the hazard detection logic\n保留站和CDB\n如果多条指令在等待一个结果 或者 一条指令等待多个操作数，可以同时通过CDB的广播读取（避免了通过寄存器读取）\n\n\nThe elimination of stalls for WAW and WAR hazards\noverlap iterations of loops：循环迭代的重叠\n相当于从HW（硬件）上实现了循环展开\n\n\n\n\n计分板无法实现 overlap iterations of loops\n\n为什么Tomasulo可以实现循环迭代的重叠？\n\n寄存器重命名\n保留站允许指令的提前发射以及旧值的存储（避免了WAR冲突）\nTomasulo building data flow dependency graph on the fly.\n\n计分板阶段的回顾\n\nISSUE：当下面的条件同时满足时issue：\n具有可用的功能单元\n没有与正在执行的指令具有相同的目标寄存器\n此时避免了结构冲突和WAW冲突\n\n\nRO：当两个操作数都准备好了的时候才会读取\n避免了RAW的冲突\n\n\nEX\nWB：此时检测WAR冲突并在必要的时候stall\n\n计分板和Tomasulo的对比\n\n\nTomasulo消除了WAW与WAR冲突；没有显式寄存器重命名的计分板无法消除～\nOOO：out of order，此处指乱序完成\n\nCDB的额外信息\n\n\nTODO： 为什么需要source address？\n\n使得CPI &lt; 1的几种方法\n\n\n向量处理；超标量；VLIW\n\n超标量使用基于Tomasulo的算法，可以实现乱序执行的动态调度\nIssue Packet：\n\n从fetch unit获得的指令组合，可以在一个周期内同时发射\nIssue阶段也被流水线化：\n第一个阶段检查当前packet可以一次性发射的指令数（不存在数据冲突）；\n第二个阶段检查上一步选中的指令是否与已经发射的指令存在冲突\n\n\n\n\n对于N-issue的多发射，每个cc实际发射 0-N条指令\n\n多发射存在的问题\n\n必须在一个cc内多次重命名相同的寄存器\n\n\n\n\n拓宽总线\n\n两种实现多发射的方法\n\n\n\npipeline\nwiden issue logic\n\n双发射的例子不带投机执行的双发射：\n\n\n带有投机执行的双发射：\n\n\nWB与IS的并行执行\n\n\n然而事实证明很少会考虑这种情况？除非题目明确说明或者给出充分的暗示，否则认为还是在下一个cc才能issue到原本冲突的FU\n\nGlobal code motion全局代码调度：通过跨分支移动指令来有效地调度带有内部控制流的循环体。\nDRAM与SRAM\n\n大题整理CH1\nTODO\n\nCH2\ncache相关的计算题参考知识点梳理的ch2-cache performance\n\nGlobal / Local Miss Rate\n\n课本的例题：\n\n\n分析：\n\nL1的global和local缺失率相等，都是 40 / 1000\nL2的global缺失率为 20 / 1000， local缺失率为 20 / 40\n\nAMAT：\n\n\nAverage stall cycles per instruction：( AMAT - hit time ) x MPI = (5.4-1) x 1.5 = 6.6 cc\n是否满足时间和空间局部性\n\n分析：根据给出的cache容量、组关联等信息计算block的大小，然后比较block大小是不是大于系统的字长（如果小于就不满足空间局部性）\n此处计算得到block大小为 8KB / 4K = 2B  &lt; 4B\n\n似乎有cache就一定满足时间局部性？如果按照byte访问的话，能够存储指定的word就可以？\n\ncache与tag给定物理地址的宽度 ，cache的容量和组关联度决定了tag的位数：\n假设block是字节的大小，cache的容量是B, 为直接映射，据此计算得到：\n\nbyte offset bit = \nindex bit = \n所以tag的位数是：地址位数N - n\n\n\n\n\n虚拟页的容量和虚拟地址的位宽在此为干扰信息；\n如果不是直接映射，就先计算一个set的容量，然后据此计算index\n\n假设组关联度是  那么：\n\nindex bit = \n对应的tag位数 = N - n + i\n\n由此可见，题目中没有给出的block的容量恰好是不需要的计算量\ne.g. 加入组关联：一个8-way的例子\n\n\nCH3\n建议参考老师的ppt推一遍计分板和Tomasulo的填表，然后记住什么时候要推迟一个cc、什么时候可以直接执行\n\n延迟一个cc的情况\n计分板和Tomasulo存在结构冲突时，上一条指令WB之后的一个cc下一条指令Issue\n计分板和Tomasulo的指令需要读取待写回的数据时，上一条指令WB之后的下一个周期分别进入RO / EX 阶段\n\n但是Tomasulo的issue队列里可以直接在上一条结束的cc接替执行下一条的EX：\n\n\nCH4\nrename 、 string strip和循环级别并行部分的例题请参考知识点梳理部分\n\nconvoy与chain\n详细内容可以参考英文第六版的p291\n\n\n\n参考解答：\n\n\n\n此处忽略了向量机的set-up等时间\n\n下面是回忆卷：\n\n\n\n参考答案：个人观点\n\n第一问：\n\n指令的执行时间分为：取指+启动+向量长度， e.g. 第一条vld为 1+4+64 = 69\n但是后续的指令的取指可以在前一条指令执行期间完成，因此此处的vadd可以在cc=69开始执行：69 + 7+64 = 140cc\n后续指令同理分析\n….\n\n第二问：3（vsd与vld存在结构冲突）\n第三问：\n\n估计：3x64 + 3 + 7 + 10 + 4\n考虑了取指时间以及各个convoy内部最长的启动时间\n\nblocked 与 unblockedHere is a blocked and unblocked version of C code to perform a matrix operation on a 256x256 matrix:\nfor (int i = 0; i &lt; 1024; i += 16) {    for (int j = 0; j &lt; 1024; j += 16) {        for (int m = 0; m &lt; 16; m++) {            for (int n = 0; n &lt; 16; n++) {                output[j + n][i + m] = input[i + m][j + n];            }        }    }}\n\nfor (int i = 0; i &lt; 1024; i++) {    for (int j = 0; j &lt; 1024; j++) {        output[j][i] = input[i][j];    }}\n\nSuppose the size of the element in the matrix is 32 bits and we execute the codes above on a processor with a 2KB fully associative data cache using the least recently used (LRU) replacement strategy. The cache block size is 64 bytes. What is the relative number of cache misses when running the blocked and unblocked version?\nA. 2 : 17\nB. 1 : 8\nC. 1 : 17\nD. 1 : 16\n\nA\nSOLUTION：\n\n\n\n\n之所以说blocked version一轮循环只会发生32次miss，是因为计算得到这个cache正好有32个cache line，因此在内层循环所需的32个block都只需要读取一次；\n因此，我们首先根据题目给出的cache容量和block信息，算出index；然后结合元素的大小计算内层循环需要的block数量，检查是否可以被cache存放\n\nCH 5\nTODO: 感觉记一下例题就差不多了（知识点梳理部分）\n\n小贴士\nprecise exceptions：\n定义：On handling exceptions, if the pipeline can be stopped so that the instruction issued before the faulting instruction complete and those after it can be restarted\n\n\n计分板的WAW冲突检测：Scoreboard Algorithm issue a instruction when no other active instruction has the same destination register to avoid WAW hazard.\n写更新也就是写广播，与写失效构成了常用的处理缓存不一致性问题的策略\n\n补充常见的CSR常见的CSR有mstatus,mtvec,mepc,mcause,mtval。这些寄存器都属于M mode：\n\nmstatus：机器模式下的状态寄存器，包含开关中断的MIE、保存进入异常之前特权模式的MPP等\nmtvec：发生异常时跳转的PC入口；\nmepc：发生异常时，指向导致异常的指令；发生中断时，指向中断处理后应该恢复的位置；\nmcause：根据异常来源设置\n如果是访问存储器造成的异常，就将其地址更新到mtval；\n如果是非法指令导致的异常，将指令编码更新到mtval寄存器中\n\n\nmtval：反映引起当前异常的存储器访问地址或者指令编码\n\nVIPT\nVirtual Indexed and Physically Tagged Cache\n\n也就是从VA中提取低位作为实际物理地址对应的index，用VA的高位在TLB中查询得到物理地址，然后用物理地址中的tag进行比较。这两个步骤分别称为 缓存查找和地址翻译 ，可并行执行\n这样做是为了消除同义词问题：\n\n如果采取完全的虚拟地址寻址VIVT，一个物理地址可能对应不同的虚拟地址，从而导致其具有了多份的拷贝，带来了数据的不一致性的问题\n\n写失效的冲突写\n\n带有投机的store\n\n由于带有投机的Tomasulo在commit之前都不会实际更新寄存器或者mem，所以 store指令在此之前不会实际向内存中写入数据，那么我们可以在其地址相关寄存器准备好的时候就进入Exe阶段（地址计算）\n\n实际上，不带投机的store也是这样（参见下面“多发射的例子”中的标注）\n\n相应的，当 store指令结束write result的时候如果此时还没有准备好源寄存器的值，就会在ROB中记录（对应指令的ROB编号），并在对应指令完成后准备好commit\n\n由于每条指令都只在ROB有空位的时候issue，因此我们用ROB编号来标记每一条指令（用于数据冲突时等情况）\n\n多发射的例子\n\n作业复盘HW1\n资源占比等价于所需的时间，可并行化程度意味着采取多核处理的时候，有多少的比例可以参与优化；\n利用资源占比分配核数，应当向下取整，避免整体的核数超出总核数\n计算整体加速比的时候，先分别计算对应的时间，然后利用并行前后的总时间来计算加速比\n由此计算得出的总时间，可以用于重新分配所需的计算资源\n\n\n\nHW2功耗计算\n\nans：\n\n\n\n注意分别计算静态功耗和访问功耗，前者需要先计算对应的时间\n\nHW3\nB.5 涉及cache、AMAT和CPI的计算，可以参考作业的解答\n\n\n其他没有什么问题\n\nHW4\nGFLOP：以G为单位，执行的浮点数操作\n\n\n其他没有什么问题\n\nTODO硬件原语部分\nTODO：5.3ppt的18/40开始没有记录（学无余力）\n\n","categories":["课程笔记"],"tags":["计算机系统","CS课程"]},{"title":"oop复习","url":"/2025/06/21/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/oop%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"\n任课老师：翁恺\n\n知识点回顾\nend（）返回的是容器最后一个位置的下一个位置的迭代器\n\nstring::npos是 size_t类型的最大值;\n\nto_string将数字转换成字符串:\nint num = 123;string str = to_string(num);\nstoi将字符串转换成整数\n\n参数的默认值只能从右到左给出；默认值只能出现在函数的原型或者将定义和声明放在一起，而不能在分离的定义中声明\n\n列表初始化是按成员的声明顺序执行的，和成员在列表中的顺序无关。\n\n\n实验操作截取字符串用邮箱地址的截取，说明 rfind与 str等方法的使用：\nstring email = \"user.name@example.com\";// 获取用户名的部分int atPos = email.find('@');string username = email.substr(0, atPos); // result: \"user.name\"// 获取域名部分string domain =  email.substr(atPos + 1); // result: \"example.com\"// 获取顶级域名(最后一个.之后的部分)int lastDotPos = email.rfind('.');string topLevelDomain = email.substr(lastDotPos + 1); // result: \"com\"\n\nStream文件流\n一个简单的输入/输出：流\n\n#include &lt;fstream&gt;  // 需要包含这个头文件using namespace std;// 文件输出（写入文件）ofstream outFile(\"output.txt\");outFile &lt;&lt; \"Hello World\" &lt;&lt; endl;outFile.close();// 文件输入（读取文件）ifstream inFile(\"input.txt\"); string line;getline(inFile, line);inFile.close();\n\n\ngetline()函数可以显式指定终止符（第三个参数），默认为 \\n也就是换行符。并且会将终止符丢弃\n\n位或运算符指定模式可以使用 ｜来指定多个模式：\n// 组合使用打开模式ofstream outFile(\"test.txt\", ios::out | ios::app);\n\n字符串流字符串流的作用原理：\n\n作用: 将字符串转换成一个类似于输入流的对象;\n内部维护了一个字符串和一个位置指针;\n每次读取时, 位置指针向后移动, 且自动跳过空白字符.\n\nstringstream表示双向字符串流\n字符串分词我们可以将字符串转换成字符串流，来实现字符串的分词：\n#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;...string name(\"xiao ming\");istringstream is(name);string token;while(is &gt;&gt; token)\tcout &lt;&lt; token &lt;&lt; endl;\n\n\n按照空白字符i.e. 空格、\\t, \\n来分词\n\n字符串的拼接#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() {    ostringstream oss;    string name = \"Alice\";    int age = 25;      oss &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age;    string result = oss.str();    cout &lt;&lt; result &lt;&lt; endl;}\n\nOutput:\nName: Alice, Age: 25\n\n\n通过 .str()方法可以对象转换为字符串类型, 从而格式化输出.\n.str(\"\")方法可以清空字符串流:\n\nSTLfor-each以更简单的方式遍历容器内元素:\nstd::map&lt;std::string, double&gt; price;// Assume we've inserted a lot of name-price pairsfor(auto [key, value]: price){    std::cout &lt;&lt; key &lt;&lt; \": \" &lt;&lt; value &lt;&lt; std::endl;}\n\nmaplower_bound使用～函数可以查找不小于某个值的第一个键：\nstd::map&lt;long long, int&gt; tags{{10, 1}, {100, 2}, {1000, 3}, {10000, 4}, {10000000000, 10}};std::map&lt;long long, int&gt;::iterator it = tags.lower_bound(2000);std::cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; std::endl; // it should be \"10000 4\"it++;std::cout &lt;&lt; it-&gt;first &lt;&lt; \" \" &lt;&lt; it-&gt;second &lt;&lt; std::endl; // it should be \"10000000000 10\"\n\nclassinclude机制#include 语句的作用是将某个文件插入到语句所在位置。根据搜索的顺序，可以划分不同的用法。\n\n#include \"xx.h\"：先搜索当前文件夹，再搜索系统库\n#include &lt;xx.h&gt;：搜索系统库\n#include &lt;xx&gt;：搜索系统库\n\n注意权限的管理是针对于类的，同一类的不同对象可以在其成员函数内任意访问别的成员\n友元不具有传递性：\n\nfriend class+一个类名，可以指定友元类\nfriend+一个函数的声明，指定友元函数\n\n生命周期：\n\nmain外的类的对象（i.e. 全局作用域），其构造函数调用的时间早于 main函数；其析构函数的调用也在 main函数返回之后\n\n静态静态指的是：\n\n空间的静态\n受限的访问\n静态局部变量在第一次遇到的时候初始化\n静态成员变量在 .h文件中的声明有 static标签，但是在 .cpp 中不应该有～标签；否则无法被其他文件中使用。 静态成员函数同理\n\n两种访问静态内容的方式：\n&lt;class name&gt;::&lt;static member&gt;&lt;object name&gt;.&lt;static member&gt;\n\n引用一般的字面量都是右值，但是字符串是例外，因为字符串实际上存储在静态内存区\n一般来说，左值引用不能绑定右值，但是常量左值引用可以绑定右值，因为常量的特性确定了不会对右值进行修改\n\n但是如果同时存在右值引用，右值作为参数时还是会优先重载右值引用的版本\n\n规范：\n\n不允许定义引用的引用；\n\n不允许定义引用的数组；\n\n引用不是单独存在的对象，无法按照数组存储\n\n\n不允许定义指向引用的指针\n\n指针必须指向对象，而引用不是对象\n\n\n\n常量使用 const标记声明为常量\n常量可以直接让编译器尝试替换：\nconst int bufsize = 1 &lt;&lt; 10;const int index[] = {1, 2, 3, 4};int f[bufsize]; // Ok: f[1024]int f[index[3]]; // Error\n\n但是需要特别注意的是：对象的常量不是编译器常量！ i.e.\nclass Array{    const int size = 10;    int array[size]; // Error！};\n\n\n可以使用枚举或者 static来解决上述的问题：\nenum {size = 10};static const int size = 10;\n常量和指针；\n\nconst *p表示不能通过指针改变指向的对象内容；\n* const p表示不能改变指针的指向位置\n\n\n不需要关注类型与 *的位置关系\n\n字符指针和字符数组；\nchar *sp = \"Hello World!\"; // 字符指针可以移动，不能修改char array[] = \"Hello World!\"; // 字符数组不能移动，可以修改array[0] = 'h' ; // 合法array = 'hello'; // 非法！sp = 'world'; // 合法\n\n\n实际上，char *sp就是 const char *sp，所以不能改变字符串的值，但是可以改变sp的指向\n而字符串数组的数组名是栈中的固定地址，无法移动，但是可以修改\n\n注意区分常量函数和返回值的常量：\nint getName(int id) const; // 常量函数，无法改变成员变量，常量对象只能调用自己的常量成员函数（与静态成员函数）const int getAge(int id); // 限制了返回值是一个常量\n\ndelete注意 []搭配的使用：\nint *p = new int[10];...delete [] p;\n\nInside class代理构造可以在一个构造函数中调用另一个构造函数，减少代码的重复：\nclass sorted{public:    sorted(){}    sorted(int _x){        x = _x &gt; 0? _x: 10;    }    sorted(int _x, int _z): sorted(_x){        z = _z &gt; 0 &amp;&amp; _z &lt; x? _z: 1;    }    sorted(int _x, int _y, int _z): sorted(_x, _z){        y = _y &lt; x &amp;&amp; _y &gt; z? _y: 5;    }private:    int x, y, z;};\n\n内联函数通过 inline关键字，建议编译器将函数调用处替换为函数体代码本身 ，从而避免函数调用开销。\n\n是否作为内联函数，实际上由编译器所决定\n\n内联函数必须提供完整的函数定义\n\ni.e. 内联函数的声明必需伴随实现（在同一个头文件中即可，二者可以分离）\n\n组合与继承组合组合的对象分为完全包含和引用包含，什么时候使用引用包含呢？\n\n逻辑上子对象应该在对象的外部；\n子对象的大小不确定\n子对象的空间应该在运行时被分配或者链接\n\n命名空间namespace sp1{    void f();    void g();}namespace sp2{    void f();    void g();}// No terminating end colon!namespace alias = sp1;void f();void g();int main(){    sp1::f();    sp2::f();    ::f();    f();// the same as ::f()    alias::f();// the same as sp1::f()    return 0;}\n\n\n\n可以为命名空间声明别名；\n命名空间的末尾没有分号 ；\n\n\nusing使用 using可以在当前的作用域引入其他的命名空间的成员、函数：\n\nusing &lt;namespace&gt;::&lt;member&gt; 引入部分的成员\nusing namespace &lt;namespace&gt; 引入该命名空间的全部成员\n\ne.g.\nusing std::cin; // 只引入 cinusing namespace std; // 引入std的所有成员\n\n\n如果引入同名的对象或者函数，将会导致编译器链接失败\n\n继承父类的析构函数更晚调用\n父类的私有成员变量在子类的对象中依旧存在，但是不可直接访问（只能通过父类方法来间接访问）\n父类的受保护成员可以被子类访问，但是无法被外界访问\n非公开的继承class B: protected A{    ...  };class B: private A{//default    ...};\n\n\n如果定义 protected 继承，只有子类及其派生类可以调用父类方法，外部是不可以的。\n如果定义 private 继承，只有子类本身可以调用父类方法。\n\n静态成员的继承父类的静态成员不会在子类中具有自己的副本，子类和父类共享一个静态成员！\n以下介绍using相关的几个问题：\nname hiding如果子类重载了父类的函数，父类的同名函数将会失效，无法直接调用，需要使用 using来声明：\ne.g.\nclass Base{  public:   \tvoid f(double){      cout &lt;&lt; \"double\\n\" &lt;&lt; endl;    }};class Derived : Base{  public:  \tusing Base::f; // 将基类中的私有函数本地使用  \tvoid f(int){      cout &lt;&lt; \"int\\n\"&lt;&lt;endl;    }};\n\n默认参数的重载传递在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免 多重继承时参数值产生冲突或二义性 。\n\n默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.\n\ne.g.\nclass A {public:    void f(int a = 3, double b = 2.0);};class B : public A {public:    using A::f;         // ✅ 此时默认参数仍可见    void f(int a);      // ❌ 重载后，这个版本没有默认参数};\n\n子类重写父类函数如果子类直接重写了父类的函数，但是父类中的同名函数本身具有重载的版本，那么也需要使用 using来声明：\n#include &lt;iostream&gt;class Base{public:    // 基类中的重载函数    void display(int x)    {        std::cout &lt;&lt; \"Base display(int): \" &lt;&lt; x &lt;&lt; std::endl;    }    void display(double x)    {        std::cout &lt;&lt; \"Base display(double): \" &lt;&lt; x &lt;&lt; std::endl;    }};class Derived : public Base{public:    // 子类重新定义了基类的 display(int)    void display(int x)    {        std::cout &lt;&lt; \"Derived display(int): \" &lt;&lt; x &lt;&lt; std::endl;    }    using Base::display;};int main(){    Derived d;    d.display(5); // 调用 Derived 的 display(int)    d.Base::display(5.5); // 或者d.display(5.5);    return 0;}\n\n多态\n我们应当将所有类的析构函数都设置为虚析构函数，因为每个类都有成为父类的可能\n\nclass Base {public:    virtual ~Base() {        cout &lt;&lt; \"Base Destructor\" &lt;&lt; endl;    }};class Derived : public Base {public:    ~Derived() {        cout &lt;&lt; \"Derived Destructor\" &lt;&lt; endl;    }};\n\n\n子类和父类的析构函数先后调用\n\n\nvptr在构造的时候确定，虚继承的子类在调用父类的构造函数时，默认调用父类的成员函数\nclass A {public:    A() {        f();    }    virtual void f() {        cout &lt;&lt; \"A::f()\";    }};class B : public A {public:    B() {        f();    }    void f() {        cout &lt;&lt; \"B::f()\";    }};B temp;\n\n虚函数的规范注意 virtual与 override的搭配：\nclass Animal {public:    virtual void speak() {        cout &lt;&lt; \"Animal speaks\" &lt;&lt; endl;    }};class Dog : public Animal {public:    void speak() override {        cout &lt;&lt; \"Dog barks\" &lt;&lt; endl;    }};\n\n\noverride是为了让编译器检查该函数在父类中是虚函数，但不是必须的\n\n\nvtable是类级别的, 所有该类的对象共享一个vtable;\nvptr是对象级别的, 隐含于各个对象当中.并且在内存的开头\n\n抽象类抽象类：至少包含一个纯虚函数的类是～\nclass Shape {public:    // 纯虚函数，子类必须实现    virtual void draw() = 0;};\n\n\n纯虚函数类似于协议，要求子类必须实现\n只有完成了所有纯虚函数定义的、抽象类的子类，才能够实例化\n\n接口类 Interface Class：\n\n比抽象类更加抽象）\n只定义接口, 不提供实现的抽象类\n所有的成员函数都是纯虚函数;\n一般不包含任何数据成员.\n\n菱形继承与虚继承在继承时添加 virtual 关键字实现,子类中不存在父类的对象，而是保有父类的指针。\nclass A{public:    int value;    void ptr()    {        cout &lt;&lt; \"value: \" &lt;&lt; value &lt;&lt; endl;    }};class B : virtual public A {};class C : virtual public A {};class D : public B, public C {};\n\n上述的虚继承确保了B，C只会拥有A的一份value，从而避免了从D的对象访问 value时存在的二义性\n\n并非所有的菱形继承都会因为二义性的访问而导致访问的问题！\n\nTODO：检查什么时候没有二义性？\n由于虚继承带来的是“共享”的基类对象，所以：\n\n虚基类的构造 必须由最底层派生类负责\n派生类的构造函数中要显式初始化虚基类\n\nCopy &amp; Move\n拷贝构造函数的签名：T::T(const T&amp;)\n默认的拷贝构造函数的指针类型成员是直接赋值的，也就是共享同一地址\n因此我们需要显式定义类的拷贝构造函数，避免依赖默认的～\n默认拷贝构造中，成员对象也会调用自己的拷贝构造函数\n\n\n\n拷贝构造函数的调用时机\n按值传递参数时：当对象作为参数按值传递给函数时void func(MyClass obj); // 调用时会触发拷贝构造\n对象初始化时：MyClass a;MyClass b = a;    // 初始化，调用拷贝构造函数MyClass c(a);     // 初始化，调用拷贝构造函数\n函数返回对象时：MyClass func() {    MyClass obj;    return obj;   // 可能触发拷贝构造（取决于编译器优化）}\n\n一个简单的例子：\nStringHolder(const StringHolder &amp;other)    {        if (other.data)        {            data = new char[strlen(other.data) + 1];            strcpy(data, other.data);            std::cout &lt;&lt; \"深拷贝构造函数: 为\\\"\" &lt;&lt; data &lt;&lt; \"\\\"分配新内存\" &lt;&lt; std::endl;        }        else        {            data = nullptr;            std::cout &lt;&lt; \"深拷贝构造函数: 复制空字符串\" &lt;&lt; std::endl;        }    }\n\n右值引用两种可以同时输入左值和右值引用作为参数的方法:\n\n重载\n// 重载函数，分别处理左值和右值void process(int&amp; x) {    std::cout &lt;&lt; \"重载函数 - 处理左值: \" &lt;&lt; x &lt;&lt; std::endl;}void process(int&amp;&amp; x) {    std::cout &lt;&lt; \"重载函数 - 处理右值: \" &lt;&lt; x &lt;&lt; std::endl;}\nconst int&amp; x \n// 接受const左值引用的函数（可以接受左值和右值）void processAny(const int&amp; x) {    std::cout &lt;&lt; \"处理任意值: \" &lt;&lt; x &lt;&lt; std::endl;}\n\n移动构造函数\n签名：T::T(T&amp;&amp; other), 也就是将右值引用作为参数的构造函数\n用于”窃取”即将销毁的对象的资源，避免不必要的深拷贝\n通常将源对象的指针成员置为 nullptr，防止资源被错误释放. 其他成员设置为零值\n\n一个简单的例子：\nclass DynamicArray{private:    int *m_array;    size_t m_size;...}// 移动构造函数DynamicArray(DynamicArray &amp;&amp;other) noexcept : m_array(other.m_array), m_size(other.m_size)    {        // \"窃取\"other的资源，并将other置为安全状态        other.m_array = nullptr;        other.m_size = 0;        std::cout &lt;&lt; \"移动构造函数: 移动大小为\" &lt;&lt; m_size &lt;&lt; \"的数组\" &lt;&lt; std::endl;    }\n\n\nnoexcept标记表示不会抛出异常；\n标准库容器在进行元素移动时会优先选择不会抛异常的移动构造函数，如果不存在～会退而求其次选择拷贝构造函数（更慢）。\n\nmove如果对象不是右值引用，我们可以使用 std::move来显式调用移动构造函数：\nvector&lt;int&gt; v1{1, 2, 3, 4};vector&lt;int&gt; v2 = v1; // v2 是 v1 的副本vector&lt;int&gt; v3 = std::move(v1); // 调用移动构造函数\n\n初始化的方式C++11提供了多种初始化对象的方式：\n\n小括号初始化：MyClass obj(arg1, arg2);\n\n等号初始化：MyClass obj = value;\n\n大括号初始化（统一初始化）：MyClass obj{arg1, arg2};\n\n列表初始化：\nint arr[] = {1, 2, 3};MyClass* ptr = new MyClass{arg1, arg2};\n\n基本类型的初始化// 基本类型的初始化方式int a = 10;             // 等号初始化int b(20);              // 小括号初始化int c{30};              // 大括号初始化（C++11）int d = {40};           // 等号+大括号初始化（C++11）int arr1[] = {1, 2, 3}; // 数组初始化int arr2[]{4, 5, 6};    // 数组大括号初始化（C++11）\n\n对象的初始化// 对象的初始化方式Person p1(\"张三\", 25);          // 小括号初始化Person p2 = Person(\"李四\", 30); // 等号+临时对象初始化Person p3{\"王五\", 35};          // 大括号初始化（C++11）Person p4 = {\"赵六\", 40};       // 等号+大括号初始化（C++11）\n\n\n动态分配对象的初始化\n// 动态分配对象的初始化方式Person *pp1 = new Person(\"动态张三\", 25); // 传统newPerson *pp2 = new Person{\"动态李四\", 30}; // 大括号初始化（C++11）\n\n统一初始化对于简单的类或者容器内部的类，我们可以不写构造函数，而是用花括号进行 统一初始化 。\n如果类没有构造函数，参数应按照成员的声明顺序给出；如果有，参数应按照构造函数的参数顺序给出。\nclass Test{    int a, b;};Test t{0, 0};Test *pt = new Test{1, 2};int *a = new int[3]{1, 2, 0};vector&lt;string&gt; vec = { \"first\", \"second\", \"third\"};\n\n操作符重载运算符重载本质上是一个以 operator关键字为前缀，后跟运算符的特殊函数\n\n赋值运算符首先要检查是否为自赋值\n必须在类或者枚举类上定义\n类内成员函数的重载将第一个参数作为隐式的 this传递，操作符左端的类型决定了使用的操作符的类型\n3+a1非法 if a1无法转换为 int\n\n\n\n成员函数与自由函数\n=, (), [], -&gt;, -&gt;* 必须是成员函数\n单目运算符应该声明为成员；\n二目运算符应该声明为自由函数\n\n无法重载的运算符. .* :: ?:sizeof typeidstatic_cast dynamic_cast const_castreinterpret_cast\n\n参数传递与返回类型\n+ - * / % ^ &amp; | ~ 返回新的对象\nconst Tp operator X(const Tp &amp; l, const Tp &amp; r);\n\n\n布尔运算，返回 bool类型\n[ ] 返回可以修改的引用，类似于数组的赋值\nTp &amp; operator X(int index);\n\n\n= += *= /= &lt;&lt;= &gt;&gt;= 返回可以修改的引用，确保链式操作\nTp &amp; operator X(const Tp &amp;l, const Tp &amp;r);\n\n\n\n前缀自增和后缀自增需要区分，在后缀自增的参数列表中添加 int即可\n// 前缀自增返回引用const Integer&amp; Integer::operator++(){    *this += 1;    return *this;}// 后缀自增返回对象const Integer Integer::operator++(int){// just leave the parameter unnamed    Integer old(*this);    ++(*this);    return old;}\n\n比较运算符考虑实现基础的 == 与 &lt; ，其余的比较重载在上述的基础上通过 ! 运算实现，便于直接迁移\n流运算istream&amp; operator&gt;&gt;(istream&amp; is, _Tp&amp; obj){    // read obj from is    return is;}ostream&amp; operator&lt;&lt;(ostream&amp; os, const _Tp&amp; obj){    // output obj in os    return os;}ostream&amp; tab(ostream&amp; os){// manipulator    return os &lt;&lt; '\\t';}\n\n\n输出流运算符的第一个参数不能是 const，因为输出会修改流\n输入流运算符的第二个参数不能是 const，因为需要修改对象\n通常需要声明为友元以访问私有成员\n\n赋值运算符_Tp&amp; _Tp::operator=(const _Tp&amp; rhs){    if(this != &amp;rhs){        size = rhs.size;        delete[] p;        p = new int[size];        for(int i = 0 ; i &lt; size; ++i)            p[i] = rhs.p[i];    }    return *this;}\n\n\n首先检查是否为自赋值\n\n如果不希望进行赋值运算，将上述的 = 重载声明为 private，并且无需实现。\n\n这是因为 a = b;  // 实际等价于：a.operator=(b)， 发起调用的是当前代码片段所在的作用域，如果不是类内函数，那么就是非法的\n\n隐式转换1. 构造函数转换：从其他类型到当前类型\nclass PathName {    string name;public:    PathName(const string&amp; s) : name(s) {}  // string到PathName的转换};string abc(\"abc\");PathName xyz = abc;  // 隐式转换：abc =&gt; PathName\n\n2.转换运算符：从当前类型到其他类型\n\noperator &lt;typename&gt; {}关键字\n\nclass Rational {public:    operator double() const {  // Rational到double的转换        return numerator_ / (double)denominator_;    }};Rational r(1, 3);double d = r;  // 隐式转换：r =&gt; double\n\n可以使用 explicit关键字要求显式转换：\nexplicit operator double() const;double d = (double)r;  // 必须显式转换\n\n显式转换\n构造函数的显式转换\n\n// 如果想要强制显式转换，应该这样声明：explicit Rational(double value) {    const int PRECISION = 10000;    numerator = static_cast&lt;int&gt;(value * PRECISION);    denominator = PRECISION;    simplify();}Rational r1 = 3.14;        // 错误：不允许隐式转换Rational r2(2.5);          // 正确：显式构造Rational r3 = Rational(3.14); // 正确：显式转换\n\n\n类型转换运算符的显式转换\n\nexplicit operator double() const;double d = (double)r;  // 显式转换 or double(r)double d2 = static_cast&lt;double&gt;(r2);  // 显式转换\n\n转换优先级如果同时存在两种方向的转换，将优先采取构造函数的转换方式\n\n可以通过声明其中的一种情况必须显式调用来并存；比如必须显式调用构造函数的转换，那么下面的情况将会调用构造函数将A转换到B的对象：\nclass B{public:    B();    explicit B(A); // 从A到B的显式构造函数};void functionTakingB(B thing){    cout &lt;&lt; \"OK\" &lt;&lt; std::endl;}functionTakingB(static_cast&lt;B&gt;(a));\n转换运算符C++ 中有四个转换运算符 Cast Operator：\n\nstatic_cast：\n\n基本类型的转换\n子类向父类的指针/引用的转换\nvoid与其他类型指针的转换\n\n\ndynamic_cast：down-cast，安全\n\n父类向子类的指针/引用的转换，不一定总是安全（要求原本指向的对象就是子类对象）\n要求基类中至少存在一个虚函数（因此具有 vptr，从而可以通过不同类的 vptr进行类的区分）\nBase* basePtr = new Derived();\nDerived* derivedPtr = dynamic_cast&lt;Derived*&gt;(basePtr);\n\nif(derivedPtr){\n...\n}\n\n* `const_cast`：修改 `const` 属性  * ```cpp    const int a = 10;    int *b = const_cast&lt;int*&gt;(&amp;a);    *b = 20; // 转换之后可以修改value\n\n&gt; 但是更加常见的是将非const类型的属性修改为 `const`；原本是常量类型的属性可能被编译器存储在只读内存区域，如果编译器没有在 `const_cast`的转换中进行优化，可能导致运行问题？\n&gt;\n\n\n\n\nreinterpret_cast：忽略类型检查，强制转换，低安全性\n\n\nTemplate一个模板完全都是声明，应该只有 .h，而不含有 .cpp\n\n必须都放在头文件的实现包含:\n\n函数模板;\ninline函数\n带有default参数的声明.\n类模板的成员函数\n\n\n函数模板参数匹配#include &lt;algorithm&gt;#include &lt;iostream&gt; int add(int x, int y){    return x + y;} template&lt;typename _Tp&gt;_Tp add(_Tp x, _Tp y){    return x + y;} signed main(int argc, char **argv){    std::cout &lt;&lt; add(1, 2) &lt;&lt; std::endl;     std::cout &lt;&lt; add(1.1, 2.2) &lt;&lt; std::endl;    return 0;}/* T add(int, int) 和 T double add&lt;double&gt;(double, double) */\n\n\n如果有原生的完全匹配的函数，优先使用原生函数，例如 add(1, 2) 调用 add(int, int)。\n其次，如果有模板能完全匹配的函数，使用模板生成函数，例如 add(1.1, 2.2) 调用 add&lt;double&gt;(dobule, double)。\n再其次，尝试使用类型转换来匹配其他原生函数。但是，类型转换不能用于匹配模板，例如 add(1, 2.2)。\n\n类模板简单的示例：\ntemplate&lt;typename T&gt;class Vector{public:    Vector(int s):size(s){        content = new T[size];    }    virtual ~Vector(){        delete[] content;    }    T&amp; operator[](int p){        return content[p];    }private:    T* content;    int size;};\n\nException异常的类型如何定义？\n\n// 异常对象的定义class DivisionError {private:    string message;public:    DivisionError(const string&amp; msg) : message(msg) {        cout &lt;&lt; \"创建DivisionError异常对象\" &lt;&lt; endl;    }      ~DivisionError() {        cout &lt;&lt; \"销毁DivisionError异常对象\" &lt;&lt; endl;    }      string what() const {        return message;    }};// 内层函数double divide(double a, double b) {    cout &lt;&lt; \"进入divide函数\" &lt;&lt; endl;    Resource r(\"divide函数的局部资源\");      if (b == 0) {        throw DivisionError(\"除数不能为零\");    }      cout &lt;&lt; \"divide函数正常返回\" &lt;&lt; endl;    return a / b;}\n执行流程：\n\n通过 throw 创建对应的异常对象\n将异常所在的内层函数的资源释放；\n再被外层的 catch 所捕获\n\n在 catch块中可以通过 throw;再次抛出当前的异常\n自定义异常类时，通常应该继承自 std::exception或其派生类\n异常规范在函数原型中声明可能返回的异常类型：\nvoid print(Document&amp; p) throw(PrintOffLine, BadDocument);void goodguy() throw();// throw no exceptions, until C++11void alloc() throw(...);// can throw any exceptionvoid abc() noexcept;// throw no exceptions, since C++11\n\n\n如果函数返回了规范之外的异常，将调用 std::unexpected()处理（默认调用 std::terminate()终止程序）\n\nnoexcept也可以作为运算符使用，检查表达式是否声明为不抛出异常：\nbool willNotThrow = noexcept(func());  // 检查func()是否声明为noexcept\n\n层次结构std::exception├── std::logic_error│   ├── std::invalid_argument│   ├── std::domain_error│   ├── std::length_error│   ├── std::out_of_range│   └── std::future_error├── std::runtime_error│   ├── std::range_error│   ├── std::overflow_error│   ├── std::underflow_error│   └── std::system_error├── std::bad_alloc├── std::bad_cast├── std::bad_typeid├── std::bad_exception└── std::bad_function_call\n\n\n数组的 .at可以自动抛出数组访问异常的 range_error；\n容器的 resize方法可以自动抛出长度异常 length_error；\n\n构造与析构析构函数应该避免抛出异常，否则会导致系统调用 std::terminate()\n由于在 try-catch中，如果发生了异常，本地变量将自动调用自己的析构函数，此时如果存在 new申请的空间资源，将导致其无法指向正确的地址\n因此，我们采取两阶段的构造确保构造函数不会抛出异常：\n\n在构造函数内对基本变量赋值\n在 init()函数中显式申请内存空间\n\nclass Widget {public:    Widget() : initialized(false) {        // 只做最小的初始化： 不存在抛出异常的可能    }      bool initialize() {        try {            // 执行可能失败的初始化操作            initialized = true;            return true;        } catch (...) {            return false;        }    }      void use() {        if (!initialized) {            throw std::runtime_error(\"对象未初始化\");        }        // 使用对象    }  private:    bool initialized;};\n\n\n知识蒸馏\n将个人印象比较浅的部分重新摘了一遍\n\n\n字符指针与字符数组\n\nchar *sp = \"Hello World!\"; // 字符指针可以移动，不能修改char array[] = \"Hello World!\"; // 字符数组不能移动，可以修改array[0] = 'h' ; // 合法array = 'hello'; // 非法！sp = 'world'; // 合法\n\n\n实际上，char *sp就是 const char *sp，所以不能改变字符串的值，但是可以改变sp的指向\n而字符串数组的数组名是栈中的固定地址，无法移动，但是可以修改\n\n\n不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们之间没有初始化的依赖.\n\n返回类型的常量\nconst int* f();// 只能将函数的返回值赋值给一个 const int*\n\nvptr的大小如果父类具有 virtual也就是虚函数，子类继承之后也会得到一个虚函数表，对应有一个vptr指针指向自己的虚函数表：\n\n在64位的机器下，一个vptr指针的大小是8字节\n普通函数不占据类的大小，因为函数地址存放在全局空间\n如果类内没有成员变量，也没有虚函数，那么大小就是1（告诉编译器这个类的存在）\n\n编译器的对齐\nC++ 编译器会对类进行按最大对齐的成员进行对齐\n\n#include &lt;iostream&gt;using namespace std;class Nothing {public:    Nothing() {}    int a;    virtual ~Nothing() {}};int main() {    Nothing obj;    cout &lt;&lt; \"Sizeof Nothing: \" &lt;&lt; sizeof(Nothing) &lt;&lt; endl;    cout &lt;&lt; \"Address of obj: \" &lt;&lt; &amp;obj &lt;&lt; endl;    cout &lt;&lt; \"Address of a: \" &lt;&lt; &amp;(obj.a) &lt;&lt; endl;}\n\n对应的输出：\nSizeof Nothing: 16Address of obj: 0x16d57e830Address of a: 0x16d57e838\n\n我们可以观察到两个现象：\n\nsize=16说明了对齐现象；\nNothing对象的地址首先是其vptr，然后是其他的成员\n\n期末题集\n补天专用楼\n\n程序填空题目摘录类模板：Array#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;class Array {public:    Array() {        data = new T[BLK_SIZE];        next = nullptr ;     }    ~Array() {        delete [] data;        delete next;     }    T&amp; operator[](int i);    void iterate(void (*f)(T&amp;));private:    T  *data; // data of type T    static const int BLK_SIZE=32; // fixed block size    Array *next;  // the next array block};template &lt;typename T&gt;T&amp; Array&lt;T&gt;::operator[](int i) {    if (i &lt; BLK_SIZE) {        return data[i];     } else {        if (next == NULL) {            next = new Array&lt;T&gt;;         }        return (*next)[i-BLK_SIZE];    }}template &lt;typename T&gt;void Array&lt;T&gt;::iterate(void (*f)(T&amp;)) {    for (int i = 0; i &lt; BLK_SIZE; i++) {        f(data[i]);    }    if (next != NULL) {        next-&gt; iterate(f);    }}int main(){    Array&lt;int&gt; a;    int size = 100;    cin &gt;&gt; size;    for (int i = 0; i &lt; size; i++) {        a[i] = i;    }    a.iterate([](int &amp;x) { cout &lt;&lt; x &lt;&lt; endl; });}\n\n函数模板：内积此处的 op操作之前没有接触过，利用的是标准库提供的二元操作：\n#include &lt;functional&gt;#include &lt;iostream&gt;#include &lt;vector&gt;template &lt;class InputIt1, class InputIt2, class T, class BinaryOp1, class BinaryOp2&gt;T inner_product(InputIt1 first1, InputIt1 last1, InputIt2 first2, T init, BinaryOp1 op1, BinaryOp2 op2){  while (first1 != last1)  {    init = op1 (init, op2(*first1, *first2) );    ++first1;\t++first2;  }  return init;} int main(){  std::vector&lt;int&gt; a{0, 1, 2, 3, 4};  std::vector&lt;int&gt; b{5, 4, 2, 3, 1};  int r1 = inner_product(a.begin(), a.end(), b.begin(), 0, std::plus&lt;&gt;(), std::multiplies&lt;&gt;());  std::cout &lt;&lt; \"Inner product of a and b: \" &lt;&lt; r1 &lt;&lt; '\\n';   int r2 = inner_product(a.begin(), a.end(), b.begin(), 0, std::plus&lt;&gt;(), std::equal_to&lt;&gt;());  std::cout &lt;&lt; \"Number of pairwise matches between a and b: \" &lt;&lt;  r2 &lt;&lt; '\\n';}\n\n类模板的填写\n非内联定义成员函数时，需要在类型与函数名之间加上 &lt;class-name&gt;&lt;T&gt;:: ，不要忘记了其中的 &lt;T&gt;\n\ntemplate &lt;typename T&gt;T&amp; Array&lt;T&gt;::operator[](int i) {    if (i &lt; BLK_SIZE) {        return data[i];     } else {        if (next == NULL) {            next = new Array&lt;T&gt;;         }        return (*next)[i-BLK_SIZE];    }}\n\n长话短说注意函数模板的返回类型：\n#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt;T func(T x, double y) {    return x + y;}int main() {    cout &lt;&lt; func(2.7, 3) &lt;&lt; endl;    cout &lt;&lt; func(3, 2.7) &lt;&lt; endl;}\n\n此时第二个输出从 5.7 向 int转换，得到的结果是 5\n如果是数组空间的管理, 注意 new 和  delete 都需要对应的 []\n如果没有显式定义任何的构造函数，那么编译器会自动创建一个默认构造函数\n\n但是如果程序员定义了任何的构造函数（无论是否带有默认参数），编译器就不用自动创建默认构造函数\n\nupcast：将一个派生类的指针或者引用赋值给基类的指针或引用\n\n动态绑定：发生upcast之后，通过基类指针或引用调用虚函数时，实际调用的是指针或引用锁指向的对象的虚函数的实现；而不是根据指针或引用的静态类型\n如果此时发生了析构，如果基类的析构函数是虚函数，就会先后调用子类和父类的析构函数；如果父类的析构函数不是虚函数，就只会调用父类的析构函数\n为了确保子类的资源可以被释放，总是应当将类的析构函数作为虚析构函数\n\n\n\n析构函数不允许被重载\n\n事实上，析构函数的名称固定，并且没有参数，因此无法通过参数列表来区分不同的韩苏版本，自然也就无法重载\n\nC++标准只规定了整数类型的相对顺序：\nsizeof(char) &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long) &lt;= sizeof(long long)\n\n\n也就是说, 可能存在 size上 int = long的情况\n\nA program is a bunch of objects telling each other how to do by sending messages\n\n此处的消息在oop中指的就是通过调用对象内部的方法\n\n一句话说不清楚的重载与友元函数\n完全无法重载的：\n. .* :: ?:sizeof typeidstatic_cast dynamic_cast const_castreinterpret_cast\n只能作为成员函数（无法作为友元函数）重载的：\n=, (), [], -&gt;, -&gt;*\n\n\n以及单目运算符\n\n\n\n父类的构造函数\n\n构造函数与普通的成员函数不同：\n\n如果父类的构造函数被声明为 private 的，和普通的成员函数一样——只能被自己的成员和友元函数可以调用\n如果父类的构造函数被声明为 protected 的，那么只有父类的成员、友元以及派生类的构造函数可以调用；\n这意味着此时无法直接在子类除了构造函数之外的地方来直接创建独立的父类对象\n\n\n\nC++对编程范式的支持\n\n\n过程式编程的特性包括：函数、全局变量、顺序执行、选择（if/else, switch）、循环等\nC就是过程式编程的一种，C++继承了C的特性，因此对过程式变成支持良好\n\n\n声明式编程指的是“做什么”而非如何做，比如SQL、HTML、Swift等。C++和C是命令式语言，关注“如何做”\n\n\n因此答案选C\n\n对象切片C2* pC2 = new C2();cout &lt;&lt; endl;{    C1 a = *pC2; // 发生了对象切片，只保留了基类对象的属性    cout &lt;&lt; endl;}C1* pC1 = pC2;delete pC1; // 基类的析构函数是virtual的，所以此处发生多态析构cout &lt;&lt; endl;\n\n拷贝初始化用基本类型的值来隐式调用构造函数以创建对象:\nclass ResId {public:    ResId(int Id);};ResId res = 5;// 等价于// ResId res(5);// ResId res = ResId(5);\n\n这个过程分为两步:\n\n用 5 构造一个临时的ResId对象;\n用这个临时对象初始化res\n\n因此我们整体上可以说:\nAn object of class ResId will be created by 5\n\n禁止隐式的拷贝初始化通过声明 explicit 来禁止上述通过值隐式调用构造函数:\n#include &lt;iostream&gt;class C {public:    explicit C(int) {        std::cout &lt;&lt; \"i\" &lt;&lt; std::endl;    }    C(double) {        std::cout &lt;&lt; \"d\" &lt;&lt; std::endl;    }};int main() {    C c1(7); // 匹配了第一个构造函数    C c2 = 7; // 隐式构造, 只能将7转换为double, 然后调用第二个构造函数}\n\n输出:\nid\n\n子类对父类函数的重载与重写子类如果重载或者重写了父类的同名函数，将无法通过子类的对象访问父类中的这些函数：\n#include &lt;iostream&gt;using namespace std;class A {public:    void F(int) { cout &lt;&lt; \"A::F(int)\" &lt;&lt; endl; }    void F(double) { cout &lt;&lt; \"A::F(double)\" &lt;&lt; endl; }    void F2(int) { cout &lt;&lt; \"A::F2(int)\" &lt;&lt; endl; }};class B : public A {public:\t  using A::F;    void F(double) { cout &lt;&lt; \"B::F(double)\" &lt;&lt; endl; }};int main() {    B b;    b.F(2.0);    b.F(2);    b.F2(2);}\n\n输出：\nB::F(double)B::F(double)A::F2(int)\n\n但是我们可以通过在子类中声明 using A::F来重新获得访问权限：\nclass B : public A {public:    using A::F;    void F(double) { cout &lt;&lt; \"B::F(double)\" &lt;&lt; endl; }};\n\n此时的输出为：\nB::F(double)A::F(int)A::F2(int)\n\n默认参数的静态绑定\n虚函数：运行时多态（动态绑定）\n默认参数：编译时确定（静态绑定）\n\n#include &lt;iostream&gt;struct A {    virtual void foo(int a = 1) {        std::cout &lt;&lt; \"A\" &lt;&lt; '\\n' &lt;&lt; a;    }};struct B : A {    virtual void foo(int a = 2) {        std::cout &lt;&lt; \"B\" &lt;&lt; '\\n' &lt;&lt; a;    }};int main() {    A *a = new B;    a-&gt;foo();    delete a;}\n\n输出：\nB1\n\n\n为什么cpp要选择让静态参数实现静态绑定？\n为了保持语言的一致性与可预测性，设计者让静态参数作为编译时期自动替换的值，避免在运行过程中动态替换\n\n函数模板与模板特化模板特化：在函数模板的基础上，如果我们希望对某个类型实现不一样的逻辑，就可以使用～\ntemplate&lt;typename T&gt;void f(const T&amp; value) {    std::cout &lt;&lt; \"泛型模板: \" &lt;&lt; value &lt;&lt; std::endl;}// 对int类型采取模板特化template&lt;&gt;void f&lt;int&gt;(const int&amp; value) {    std::cout &lt;&lt; \"特化版本: int 类型\" &lt;&lt; std::endl;}\n\n\n因此，模板特化必须首先存在一个主模板\n\n模板特化的结果无法被重载\n#include &lt;iostream&gt;template&lt;class T&gt; void f(T &amp;i) { std::cout &lt;&lt; 1; }template&lt;&gt; void f(const int &amp;i) { std::cout &lt;&lt; 2; }int main() {    int i = 24;    f(i);}\n\n将会输出： 1\n\n如果我们只保留 void f(const int &amp;i) { std::cout &lt;&lt; 2; }  函数，将会触发类型转换，可以调用\n如果我们只去除模板特化中的 const， 就可以匹配（输出 2）\n\n再比如：\ntemplate&lt;typename T&gt;void add(T, T);add(1, 2.2); // ❌ 模板不能推导出统一的 T（int vs double）\n\n常量对象\n静态函数同样参与函数重载，但是优先匹配非静态函数\n静态函数不受 const限制——即使没有被声明为 const也可以被常量对象调用\n\n#include &lt;iostream&gt;using namespace std;class A {public:    static void f(double) {        cout &lt;&lt; \"f(double)\" &lt;&lt; endl;    }    void f(int) {        cout &lt;&lt; \"f(int)\" &lt;&lt; endl;    }};int main() {    const A a;    a.f(3);}\n\n输出：\nf(double)\n\n如果存在完全匹配的普通函数，就会直接调用非静态函数：\nvoid f(int) const {    cout &lt;&lt; \"f(int) const\" &lt;&lt; endl;}void f(int) {    cout &lt;&lt; \"f(int)\" &lt;&lt; endl;\n\n\n此处的 void f(int) const 无法改为 void f(double) const, 否则与同名静态函数的参数完全一致\n\n异常的 catch顺序catch块的匹配是从上到下的，因此只要遇到第一个匹配的，后续的匹配就会结束\n\n子类的对象可以被父类捕获\n注意此时的动态绑定——如果父类层级（引用或者指针）在前，内部抛出的是子类的异常对象，捕捉之后调用的函数是子类的对象\n\n#include &lt;iostream&gt;using namespace std;class Base {public:    virtual const char* what() const {        return \"Base::what()\";    }    virtual ~Base() {}  // 虚析构保证多态安全};class Derived : public Base {public:    const char* what() const override {        return \"Derived::what()\";    }};int main() {    try {        throw Derived();  // 抛出子类对象    } catch (const Base&amp; e) {  // 用父类引用接收        cout &lt;&lt; \"由父类层级捕获到异常: \" &lt;&lt; e.what() &lt;&lt; endl;  // 动态绑定调用子类 what()    } catch (const Derived&amp; e) {        cout &lt;&lt; \"由子类层级捕获到异常: \" &lt;&lt; e.what() &lt;&lt; endl;    } catch (...) {        cout &lt;&lt; \"捕获到未知异常\" &lt;&lt; endl;    }    return 0;}\n\n输出：\n由父类层级捕获到异常: Derived::what()\n\n\n如果将 catch内部改为普通的对象，将会输出 由父类层级捕获到异常: Base::what()\n\n由此可见，我们应该遵循：将子类对象的捕捉放在其父类之前，最后是 catch(...)\n","categories":["课程笔记"],"tags":["编程语言","CS课程","面向对象编程"]},{"title":"Swift学习摘记","url":"/2025/04/17/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/swift/","content":"初见默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用 _ 表示不使用参数标签:\nfunc greet(_ person: String, on day: String) -&gt; String &#123;    return &quot;Hello \\(person), today is \\(day).&quot;&#125;greet(&quot;John&quot;, on: &quot;Wednesday&quot;)\n\n\n参数标签指的是调用时候的名称, 参数名指的是函数内部.\n\n函数是第一等类型，这意味着函数可以作为另一个函数的返回值。\nfunc makeIncrementer() -&gt; ((Int) -&gt; Int) &#123;    func addOne(number: Int) -&gt; Int &#123;        return 1 + number    &#125;    return addOne&#125;var increment = makeIncrementer()increment(7)\n\n函数也可以作为另一个函数的输入参数:\nfunc hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool &#123;    for item in list &#123;        if condition(item) &#123;            return true        &#125;    &#125;    return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123;    return number &lt; 10&#125;var numbers = [20, 19, 7, 12]hasAnyMatches(list: numbers, condition: lessThanTen)\n\n可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。\nlet sortedNumbers = numbers.sorted &#123; $0 &gt; $1 &#125;print(sortedNumbers)\n\nactor与 class类似, 但是可以序列化访问, 保护共享、可变的数据.\n对象和类构造与析构使用 self.替代 this-&gt;, 使用  init 和  deinit分别声明构造和析构函数:\nclass NamedShape &#123;    var numberOfSides: Int = 0    var name: String    init(name: String) &#123;        self.name = name    &#125;    func simpleDescription() -&gt; String &#123;        return &quot;A shape with \\(numberOfSides) sides.&quot;    &#125;&#125;\n\n子类如果要重写父类的方法的话，需要用 override 标记:\nclass Square: NamedShape &#123;    var sideLength: Double    init(sideLength: Double, name: String) &#123;        self.sideLength = sideLength        super.init(name: name)        numberOfSides = 4    &#125;    func area() -&gt;  Double &#123;        return sideLength * sideLength    &#125;    override func simpleDescription() -&gt; String &#123;        return &quot;A square with sides of length \\(sideLength).&quot;    &#125;&#125;let test = Square(sideLength: 5.2, name: &quot;my test square&quot;)test.area()test.simpleDescription()\n\n\n\n使用 :className的方法声明父类.\nsuper.init 是用来调用父类（超类）的初始化方法的。当创建一个子类的实例时，子类可能需要初始化一些自己的属性，同时还需要确保父类的属性也被正确初始化。这时就需要使用 super.init 来调用父类的初始化方法，完成父类的初始化过程\n严格的顺序要求: 子类必须先初始化自己的属性，然后调用 super.init，最后才能访问或修改继承来的属性。\n\n\n计算属性普通的计算属性在属性内部使用 &#123;&#125;并加上 return, 可以让访问这个属性的时候, 返回值由结构体的其他属性计算得到.\nstruct Temperature &#123;  var celsius: Double  var fahrenheit: Double&#123;    return celsius *1.8 + 32  &#125;    init(celsius: Double)&#123;    self.celsius = celsius  &#125;&#125;\n\n\n\n此时实例化一个结构体就只需要给出一个属性的值.\nself在上述的Swift代码中是不可或缺的, 因为形参和内部属性的名称相同.\n\n\n使用 getter 和 setter 的计算属性:class EquilateralTriangle: NamedShape &#123;    var sideLength: Double = 0.0    init(sideLength: Double, name: String) &#123;        self.sideLength = sideLength        super.init(name: name)        numberOfSides = 3    &#125;    var perimeter: Double &#123;      // 根据存储属性进行计算        get &#123;            return 3.0 * sideLength        &#125;      // 设置属性        set &#123;            sideLength = newValue / 3.0        &#125;    &#125;    override func simpleDescription() -&gt; String &#123;        return &quot;An equilateral triangle with sides of length \\(sideLength).&quot;    &#125;&#125;var triangle = EquilateralTriangle(sideLength: 3.1, name: &quot;a triangle&quot;)print(triangle.perimeter)triangle.perimeter = 9.9print(triangle.sideLength)\n\n计算属性同样是一个属性, 但是根据调用方式的不同, 有返回和设置两种方式.\ntriangle.perimeter = 9.9print(triangle.perimeter)\n\nMutating默认情况下, 结构体中的方法不能直接修改结构体的属性. 需要显式声明为 mutating:\nstruct User&#123;  let username:String  var isVisible:Bool = true  var friends: [string] = []    mutating func addFriend(username: String)&#123;    friends.append(username)  &#125;&#125;\n\n属性监视器使用 willSet 和 didSet。写入的代码会在属性值发生改变时调用，但不包含构造器中发生值改变的情况:\n\n分别可以使用 newValue与 oldValue来表示属性将要改变的值以及改变之前的值.\n\ne.g. 确保三角形的边长总是和正方形的边长相同。\nclass TriangleAndSquare &#123;    var triangle: EquilateralTriangle &#123;        willSet &#123;            square.sideLength = newValue.sideLength        &#125;    &#125;    var square: Square &#123;        willSet &#123;            triangle.sideLength = newValue.sideLength        &#125;    &#125;    init(size: Double, name: String) &#123;        square = Square(sideLength: size, name: name)        triangle = EquilateralTriangle(sideLength: size, name: name)    &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10, name: &quot;another test shape&quot;)print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square = Square(sideLength: 50, name: &quot;larger square&quot;)print(triangleAndSquare.triangle.sideLength)\n\n枚举enum Rank: Int &#123;    case ace = 1    case two, three, four, five, six, seven, eight, nine, ten    case jack, queen, king    func simpleDescription() -&gt; String &#123;        switch self &#123;        case .ace:            return &quot;ace&quot;        case .jack:            return &quot;jack&quot;        case .queen:            return &quot;queen&quot;        case .king:            return &quot;king&quot;        default:            return String(self.rawValue)        &#125;    &#125;&#125;let ace = Rank.acelet aceRawValue = ace.rawValue\n\n\n如果没有设置第一个成员的初始值, 默认从 0 开始;\n缺省值按照递增处理;\ncase之外可以设置方法.\n\n使用 init?(rawValue:) 初始化构造器来从原始值创建一个枚举实例:\nif let convertedRank = Rank（rawValue:3）｛\tlet threeDescription = convertedRank.simpleDescription（）｝\n\n\n\nif let表示可选绑定, 安全地解包可选值\n\n\n解包\nif let解包\n\nif let A = B &#123;  ...&#125;\n\n如果 B不是 nil, 就将其赋值给A, 然后执行 &#123;&#125;内部的语句.\n\n??\n\nvar score : Int ?  = nilprint(score ?? default_score)// 成绩score不是nil, 就将其打印, 否则输出默认的成绩\n\n对字典进行索引:\n// scores是一个Int数组for ( major, scores) in all_scores &#123;  for score in scores&#123;    ...  &#125;&#125;// 如果key没有使用, 可以直接忽略for( _, socres) in all_scores&#123;  ...&#125;\n\nswift支持对字典进行更新或者移除的时候, 返回并使用就值:\nif let oldValue = scores.updateValue(100, forKey:&quot;fad&quot;)&#123;  print(..)&#125;else&#123;  ...&#125;if let oldValue = scores.removeValue(forKey: &quot;fad&quot;)&#123;  print(&quot;fad&#x27;s old value was \\(oldValue)&quot;)&#125;\n\n\n@IBAction表示组件交互和代码相绑定(允许在交互的时候执行外部定义的函数);\n@IBOutlet表示允许代码的响应改变组件本身的状态(字体、大小等).\n\n\n\n概念闭包闭包指的是可以在特定位置运行的、不需要名称的函数.\nscene.setOnStartHandler｛ // 闭包的主体｝\n\n\ntoggle()可以自动切换变量的布尔值.\nButton(&quot;Press Me&quot;) &#123;    isOn.toggle()&#125;\n\n状态属性\n使用 @State在视图之外定义;\n当状态属性的值发生改变时, 会自动更新视图中相关的部分.\n对于状态对象, 使用 @StateObject来声明.\n\n绑定由 @Binding声明将属性连接到其他地方, 允许子视图对属性的修改并同步.\n在属性的前面增加 $，表明会同步修改可信源.\n字符串插值在较长字符串中使用常量、变量或代码表达式，使它们替换为其当前值以求出字符串的值。\n例如，在字符串”Katy ate a \\（fruit）.”中，如果fruit 是带有值 “peach”的变量，那么在求字符串的值时，\\（fruit）由”peach”替换，变为 “Katy ate a peach.”。\n其他自动的动画效果当状态属性发生改变时, 我们希望对应控制的视图元素的变化具有动画效果, 那么可以指定: e.g.\nCircle()    .frame(maxHeight: 200)    .foregroundColor( isOn ? .purple : .mint     .shadow(color:isOn ? .indigo : .orange , radius: 20)    .scaleEffect(isOn ? 1: 0.75)    .animation( .default, value: isOn)\n\n\n其中的 value： isOn表示追踪的状态属性.\n\n在一个视图中创建状态对象,  然后在 app中声明为环境变量并在子视图中使用.\n设计原则principle\n\n需要长按进行交互的组件, 在轻触时ICON放大或者缩小\n\n官方手册学习记录基础知识\nSwift 使用字符串插值将常量或变量的名称作为占位符包含在较长的字符串中，并提示 Swift 将其替换为该常量或变量的当前值。将名称包在括号中，并在左括号前用反斜杠进行转义：\nprint(&quot;The current value of friendlyWelcome is \\(friendlyWelcome)&quot;)// 打印 &quot;The current value of friendlyWelcome is Bonjour！&quot;\n不必使用 ;, 但是如果想在一行中编写多个独立语句，则必须使用分号：\nlet cat = &quot;🐱&quot;; print(cat)// 打印 &quot;🐱&quot;\n整数边界: 使用 min, max进行访问\nlet minValue = UInt8.min  // minValue 等于 0，类型为 UInt8let maxValue = UInt8.max  // maxValue 等于 255，类型为 UInt8\n类型别名: typealias\ntypealias AudioSample = UInt16var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound 现在为 0\n\n元组\n作用: 多个值组合成一个复合值\n\nlet http404Error = (404, &quot;Not Found&quot;)// http404Error 的类型为（Int，String），且等于（404，&quot;Not Found&quot;）\n\n如果只需要元组的部分值，则在分解元组时使用下划线 (_) 忽略不需要的部分\n\n分解元组\nlet (statusCode, statusMessage) = http404Errorprint(&quot;The status code is \\(statusCode)&quot;)// 打印 &quot;The status code is 404&quot;print(&quot;The status message is \\(statusMessage)&quot;)// 打印 &quot;The status message is Not Found&quot;\n可以在定义元组时为元组中的各个元素命名：\nlet http200Status = (statusCode: 200, description: &quot;OK&quot;)\n\n然后可以使用元素名访问:\nprint(&quot;The status code is \\(http200Status.statusCode)&quot;)// 打印 &quot;The status code is 200&quot;print(&quot;The status message is \\(http200Status.description)&quot;)// 打印 &quot;The status message is OK&quot;\n也可以直接使用从零开始的索引来访问, e.g. http200Status.0\n\n\n\n\n可选  : 存储这种类型的值或者 nil.\n\n提供后备值: ??\nlet name: String? = nillet greeting = &quot;Hello, &quot; + (name ?? &quot;friend&quot;) + &quot;!&quot;print(greeting)// 打印 &quot;Hello, friend!&quot;\n\n\n如果 ?? 之前的值不是 nil, 就会正常解包, 否则选择后备值;\n使用 () 包裹.\n\n\n隐式解包可选  : 安全假定一直都有值时使用\n\n\n  let possibleString: String? = &quot;An optional string.&quot;let forcedString: String = possibleString! // 需要显式解包let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedString // 隐式解包\n\n\n错误处理函数在声明中包含 throws 关键字，表示它可以抛出错误。调用可以抛出错误的函数时，要在表达式前加上 try 关键字.\nSwift 会自动将错误传播到当前作用域之外，直到它们被 catch 子句处理为止。\ndo &#123;    try canThrowAnError()    // 无错误的情况&#125; catch &#123;    // 抛出错误的情况&#125;\n\n\n细节部分在后面补充\n\n断言和先决条件使用断言进行调试let age = -3assert(age &gt;= 0, &quot;A person&#x27;s age can&#x27;t be less than zero.&quot;)// 该断言失败的原因是 -3 并不 &gt;= 0。\n\n断言的第一个参数是预期的、正确的结果, 如果不满足条件就会显示报错. 但是不会阻止程序继续运行.\n强制执行先决条件当条件有可能为假，但必须为真才能继续执行代码时，请使用先决条件.\n向该函数传递一个计算结果为 true 或 false 的表达式，以及一条在条件结果为 false 时显示的信息:\n// 在下标的实现中...precondition(index &gt; 0, &quot;Index must be greater than zero.&quot;)\n\n\n运算符基本运算符\n与 C 和 Objective-C 中的赋值运算符不同，Swift 中的赋值运算符本身不返回值。以下语句无效：\nif x = y &#123; // 这是无效的，因为 x = y 不返回值。&#125;\n\n\n可以防止不小心使用赋值运算符（&#x3D;） 而非等于运算符（&#x3D;&#x3D;）.\n\n\n基本的四则运算不允许值的溢出.\n\n\n\n[!NOTE]\n在 Swift 中对负数的处理与模运算符有所不同:\n为了确定 a % b 的答案，% 运算符计算以下等式并返回 余数 作为输出：\na` = (`b` x `某个乘数`) + `余数\n\n其中 某个乘数 是 b 在 a 中能容纳的最大倍数。\n9 % 4    // 等于 1-9 % 4   // 等于 -1\n\n数值的正负号可以使用前缀 - 切换，称为 一元负号运算符  .\n\n中间没有任何空格.\nlet three = 3let minusThree = -three       // minusThree 等于 -3\n\n\n\n元组的计算\n前提: 如果两个元组具有相同的类型和相同数量的值，则可以比较它们.\n规则:\n元组是从左到右逐个值进行比较的，直到比较发现两个不相等的值为止。\n这两个值将进行比较，并且该比较的结果决定了整个元组比较的结果。\n如果所有元素都相等，那么这两个元组本身就相等。\n\n\n\n\n[!NOTE]\n只有当给定的运算符可以应用于各自元组中的每个值时，元组才能与该运算符进行比较.\n\n(&quot;blue&quot;, false) &lt; (&quot;purple&quot;, true)  // 错误，因为 &lt; 不能比较布尔值\n\n空合并运算符a ?? b的结果与下面的运算相同:\na != nil ? a! : b\n\n区间运算\n闭区间运算符（a...b）定义了一个从 a 到 b 的范围，包括 a 和 b 的值。a 的值不能大于 b;\n\n在需要使用所有值的情况下很有用\n\ne.g.\nfor index in 1...5 &#123;    print(&quot;\\(index) 乘以 5 等于 \\(index * 5)&quot;) &#125;\n\n\n半开区间运算符（a..&lt;b）定义了一个从 a 到 b 但不包括 b 的范围.\n\n对于处理从基数 0 开始的列表（如数组）时特别有用，因为它可以计数到列表长度（但不包括列表长度）.\n\ne.g.\nlet names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;] let count = names.countfor i in 0..&lt;count &#123;    print(&quot;第 \\(i + 1) 个人叫 \\(names[i])&quot;)&#125;\n\n\n闭区间运算符有一种替代形式，用于一直延伸到尽可能远的区间 —— 例如，一个包含从索引 2 到数组末尾所有元素的区间。\nfor name in names[2...] &#123; print(name) &#125;// Brian// Jack\n半开区间运算符也有一种只写最后一个值的单侧形式\nfor name in names[..&lt;2] &#123; print(name) &#125;// Anna// Alex\n\n逻辑运算\n[!NOTE]\nSwift 逻辑运算符 &amp;&amp; 和 || 遵循 从左到右  的结合顺序，这意味着带有多个逻辑运算符的复合表达式会首先评估最左边的子表达式.\n\n控制流协议\n如果类需要继承, 需要将父类写在所有的协议之前\n不能在协议定义中为方法参数指定默认值。\n协议也可以要求遵循协议的类型实现指定的构造器, 和协议内部的方法一样, 不需要写花括号和构造期的实体\n如果是类, 必须在构造函数的开头加上 required修饰符. 这是为了确保所有继承的子类也提供这个构造函数的实现, 从而确保遵守协议;\n但是如果一个类被声明为了 final, 也就是无法被继承, 那么就不需要 required的声明\n\n\n\n协议的基本用法协议可以规定属性类型以及属性被操作的权限, 通常和类、结构体和枚举进行绑定, 作为一种强制的约束.\nprotocol Tax&#123;  var national: Double &#123; get &#125;   var individual: Double&#123; set get&#125;&#125;\n\n同样可以在协议中使用 mutating 来声明一个改变自身属性的方法:\nprotocol Tax&#123;  var national: Double &#123; get &#125;   var individual: Double&#123; set get&#125;    mutating func changeTax(newValue: Double)&#125;\n\n\n需要注意的是, 结构体内部的方法如果要修改自身属性, 也需要声明 mutating, 但是类则不需要额外的声明.\nstruct Taxas: Tax&#123;   var national: Double  var individual: Double  mutating func changeTax(newValue: Double)&#123;    national = newValue  &#125;&#125;\n\n常见的协议CaseIterable： 让枚举可以自动生成所有case的集合， 使用 xx.allCases可以获得枚举的所有枚举值，适用于列表、选择器等\nfor shape in GuqinShape.allCases &#123;    print(shape.rawValue) // 输出所有形制的名称&#125;\n\n\n\nIdentifiable： 让每个枚举值有唯一的 id，方便在 SwiftUI 的 List、ForEach 等视图中唯一标识每一项\npublic protocol Identifiable &#123;    associatedtype ID: Hashable    var id: Self.ID &#123; get &#125;&#125;\n\n\n如果实现了这一协议，可以确保通过id完成高效的增删改查\n\n// 如果我们的枚举值本身就可以唯一标识var id: String &#123; self.rawValue &#125;// 或者自动生成唯一标识let id = UUID()  // 在结构体中struct Book: Identifiable &#123;    let isbn: String  // 国际标准书号本身就是唯一的    var title: String    var author: String        var id: String &#123; isbn &#125;  // 使用 isbn 作为 id&#125;\n\n\n\nCodable：让枚举可以方便地被编码和解码，比如存储到文件、发送到网络或从 JSON 解析回来\ne.g.\nlet shape = GuqinShape.fuxilet data = try JSONEncoder().encode(shape)let decoded = try JSONDecoder().decode(GuqinShape.self, from: data)\n\n\n\nEquatable：定义如何比较两个实例是否想等的标准方式\npublic protocol Equatable &#123;    static func == (lhs: Self, rhs: Self) -&gt; Bool&#125;\n\n\n对于简单的结构体，swift会自动合成Equatable的实现；\n\n如果结构体比较复杂，需要显式定义：\nclass Person: Equatable &#123;    let id: String    var name: String    var age: Int        init(id: String, name: String, age: Int) &#123;        self.id = id        self.name = name        self.age = age    &#125;        static func == (lhs: Person, rhs: Person) -&gt; Bool &#123;        // 只比较 id，因为 id 是唯一标识符（也可以声明为UUID类型确保唯一）        return lhs.id == rhs.id    &#125;&#125;let person1 = Person(id: &quot;1&quot;, name: &quot;Alice&quot;, age: 25)let person2 = Person(id: &quot;1&quot;, name: &quot;Alice&quot;, age: 30) // 同名但不同年龄let person3 = Person(id: &quot;2&quot;, name: &quot;Bob&quot;, age: 30)print(person1 == person2) // true (因为 id 相同)print(person1 == person3) // false\n\n\n枚举会默认实现Equatable，根据枚举值判断两个实例是否相等\n\n补充协议\n使用 , 连接不同的协议\n\nextension可以为协议的函数设置默认方法, 就不需要继续在每一个类、结构体或枚举中重新定义\n\n同样可以补充数据类型\nextension Int &#123;  var abs: Int &#123;    get &#123;      if self &gt;= 0 &#123;        return self      &#125;else&#123;        return -self      &#125;    &#125;  &#125;&#125;print((-3).abs);// 3\n\n\n\n有条件地遵循协议让 Array 类型只要在存储遵循 TextRepresentable 协议的元素时，就遵循 TextRepresentable 协议:\nextension Array: TextRepresentable where Element: TextRepresentable &#123;    var textualDescription: String &#123;        let itemsAsText = self.map &#123; $0.textualDescription &#125;        return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot;    &#125;&#125;let myDice = [d6, d12]print(myDice.textualDescription)// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;\n\n扩展里声明协议遵循当一个类型已经遵循了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空的扩展来让它遵循该协议:\nstruct Hamster &#123;    var name: String    var textualDescription: String &#123;        return &quot;A hamster named \\(name)&quot;    &#125;&#125;extension Hamster: TextRepresentable &#123;&#125;\n\nError handling系统提供了 Error协议用于错误处理, 主动给予错误的捕捉情况.\n使用方法:\n\n定义遵循相关协议的枚举类型, 作为错误的类型;\n定义可能抛出错误的函数;\n使用 do...catch块来结构化地处理错误.\n\ne.g.\n// 定义一个错误类型，遵循 Error 协议enum PasswordError: Error &#123;    case tooShort    case tooWeak&#125;// 一个函数，可能抛出错误func validate(password: String) throws &#123;    if password.count &lt; 6 &#123;        throw PasswordError.tooShort    &#125;    if password == &quot;123456&quot; &#123;        throw PasswordError.tooWeak    &#125;&#125;// 使用 do-catch 捕捉错误do &#123;    try validate(password: &quot;123456&quot;)    print(&quot;密码验证通过 ✅&quot;)&#125; catch PasswordError.tooShort &#123;    print(&quot;❌ 密码太短，请至少使用 6 个字符&quot;)&#125; catch PasswordError.tooWeak &#123;    print(&quot;❌ 密码太弱，不能使用简单的序列&quot;)&#125; catch &#123;    print(&quot;❌ 发生未知错误：\\(error)&quot;)&#125;\n\n\n\nthrows：在函数声明中标注该函数会抛出错误;\ntry：在调用可能抛出错误的函数时使用.\n\n\n其他的协议CaseIterable用于获取枚举的属性个数, 从而进行遍历.\nenum Status:CaseIterable&#123;    case low,middle,high        mutating func change()&#123;        switch self&#123;        case .high:            self = .low        case .low:            self = .middle        case .middle:            self = .high        &#125;    &#125;      func ptr()&#123;        print(&quot;Current Status is \\(self)&quot;)    &#125;&#125;var status = Status.lowfor _ in 0..&lt;Status.allCases.count&#123;    status.ptr()    status.change()&#125;\n\n\nfor _ in 0..&lt; 当中的 _表示忽略遍历时候的循环变量的值.\n\n闭包闭包的简化推导相当于匿名函数与 lambda.  接下来从普通函数的写法开始简化:\n\n普通函数:\nfunc changeSign(op: Double) -&gt; Double &#123;    return -op&#125;var operation: (Double) -&gt; Doubleoperation = changeSignlet result = operation(4.0) // result = -4.0\n将函数的定义下移:\nvar operation: (Double) -&gt; Doubleoperation = (op:Double) -&gt; Double &#123; return -op&#125;let result  = operation(4.0)\n将 ｛ 提前，并在原来的位置添加 in\nvar operation:(Double) -&gt; Doubleoperation = &#123;(op: Double) -&gt; Double  in return -op&#125;...\n系统可以推断类型, 所以根据输入的类型简化返回值的类型定义\nvar operation:(Double) -&gt; Doubleoperation = &#123;(op: Double)   in return -op&#125;...\n可以进一步省略传入的类型\nvar operation:(Double) -&gt; Doubleoperation = &#123; (op) in return -op&#125;...\n省略返回的标记 return:\nvar operation:(Double) -&gt; Doubleoperation = &#123; (op) in  -op&#125;...\n\n最后, 我们可以直接用 $0等替代传入的参数, 也就是省略了参数的名称!\nvar operation:(Double) -&gt; Doubleoperation = &#123; -$0 &#125;...\n\n闭包的常见使用e.g.\n\nTrailing Closure当闭包是函数的最后一个参数时，\nlet result = applyTwice(3, operation: &#123; $0 * 2 &#125;)\n\n可以改写成:\nlet result = applyTwice(3) &#123; $0 * 2 &#125; // result = 12\n\n慕课学习杂记something\n去官网学习新出现的技术\n\ncodeML\n\n\n函数也可以赋值给变量\n\n\n省略外部参数名\n外部参数名: 在函数调用的时候使用, 提高可读性;\n内部参数名: 在函数体的内部使用\n\n如果如此定义:\nfunc greet(person name: String)&#123;  print(&quot;Hello , \\(name)&quot;)&#125;\n\n那么在调用的时候必须显示声明外部参数名:\ngreet( person: &quot;Alice&quot;)\n\n如果我们希望省略外部参数名, 就可以在定义函数的时候用 _来代替:\nfunc greet(_ name: String)&#123;  ...&#125;\n\n高阶函数我们可以让函数作为另一个函数的输入参数:\nfunc addTwoInts( _ a: Int, _ b: Int) -&gt; Int&#123;  return a+b&#125;var mathFunction = addTwoInts// 高阶函数func printMathResults（_ mathFunction: (Int, Int）-&gt; Int, _ a: Int, _ b: Int)&#123;  var result = mathFunction(a,b)  print(result)&#125;// 调用printMathResults（addTwoInts， 3,5）\n\n\n注意函数作为参数的时候, 类型的定义就是输入类型和返回类型, 也是用 , 来分隔不同的参数.\n\n\n内置的库AVFoudation: 音频播放\n\n\n枚举内部也可以设置方法;\n\n结构体本身不需要构造函数(因为swift存在对于结构体的默认构造) , 但是如果结构体内部的属性存在这样的属性:\n\n它可能是枚举内部的方法, 跟枚举的属性有关, 可能使用了 switch来根据枚举属性赋值.\n\nenum Type&#123;  case Cike  case ...  func blood()-&gt; Double&#123;    switch self&#123;      case .Cike: return 10      case .Fashi: return ...      ...    &#125;  &#125;&#125;struct Card &#123;  var country: Country  vat type: Type  var blood: Double  init (country: Country, type: Type)&#123;    self.country = country    self.type = type;    blood = type.blood  &#125;&#125;\n结构体和枚举属于  值类型  , 如果赋值的时候进行拷贝操作;\n\n如果结构体声明为 let, 即使属性是变量, 那么也无法修改内部的属性,\n\n\n类是引用类型, 赋值的时候使得左值指向了同样的内存区域, 也就是信息保持一致, 更改同步\n\n如果我们将类声明为常量, 相当于cpp的指针常量, 也就是说类内部的属性可以更改, 但是无法修改这个量指向的内存区域.\n\n\n\n计算属性访问的时候动态计算得到.\n下面通过一个矩形的例子来说明:\nstruct Point &#123;  var x = 0.0  var y = 0.0&#125;struct Size&#123;  var width = 0.0  var height = 0.0&#125;struct Rect&#123;  var origin = Point()  var size = Size()  var center: Point&#123;    get&#123;      let centerX = origin.x + (size.width / 2)      let centerY = orgin.y + (size.height /2 )      return Point(x: centerX, y: centerY)    &#125;    set(newCenter)&#123;      origin.x = newCenter.x - (size.width / 2)      origin.y = newCenter.y - (size.height / 2)    &#125;  &#125;&#125;\n\n上述完成了结构体的计算属性的定义, 其中 get部分也可以优化为:\nget&#123;\tPoint(x: origin.x + (size.width / 2),        y: orgin.y + (size.height /2 ) )&#125;\n\n\n这是因为, 如果 get 部分只存在一个表达式,  就会自动将其返回, 不需要显式声明 return关键字.\n\n然后可以如此应用:\nvar currCenter = rectElement.centerrectElement.center = Point(x:20, y:50)\n\nset提供了语法糖, 也就是可以直接访问oldValue 和  newValue, 因此我们可以如此改写:\nset&#123;  origin.x = newValue.x - (size.width / 2)  origin.y = newValue.y - (size.height / 2)&#125;\n\n\n[!NOTE]\n对于只读的计算属性, 由于不存在 set, 我们可以直接在花括号内定义返回内容.\n\n\n\n声明 static , 表示这个属性或者方法属于整个类型而非某个实例. 此时相应的, 我们使用 &lt;tyepName&gt;.&lt;strtic attribute&gt;的方式来访问.\n子面量本身是不可修改的, 下面的拓展中, 如果写作  var someInt = 3.square()就会报错\n\nextension Int&#123;    mutating func square()&#123;        self = self * self    &#125;&#125;var someInt = 3someInt.square()\n\n\n控制器存在5种状态:\n\n未加载\n将要出现\n出现\n将要消失\n已经消失\n\nAPP的状态:\n\n\nUiSceneDelegate用于响应基于 scene 的生命周期事件.\n可以使用属性的 didset来便捷地检测变化并快速修改:\nvar score = 0&#123;  didSet&#123;    self.gameScoreLabel.text = &quot;Score: \\(score)&quot;  &#125;&#125;\n\n\nviewController是新的页面;\nview是视图, 可以叠加在页面上.\nUIAlertController组件相当于警示的弹窗组件\n\n作图和绘画CG\nCGFloat用于二维坐标系中的坐标数据:\n\nlet coor_x = CGFloat(10.5)\n\n\nCGPoint(x: .. , y:...)\n\nCGSize 包含width和height属性的结构体;\n\nCGRect包含点和尺寸的矩形\nstruct CGRect&#123;  var origin: CGPoint  var size: CGSize&#125;\n\n\n其他属性\n\ne.g.\nvar minX: CGPointvar midY: CGPointintersects(CGRect) -&gt; Bool // 判断是否存在交集contains(CGPoint) -&gt; Bool // 是否包含点.\n\n\n\n最小单元是 Point而非像素点.\nbound表示视图内部允许绘制的区域:\nvar bounds: CGRect // 也就是一个矩形\n\nframe\t视图在父视图中的位置:\nvar frame: CGRect\n\n自定义视图绘制自定义视图通常通过创建一个自定义的 UIView 子类，并重写 draw(_:) 方法来实现.\nplayGround中的实例:\nimport UIKitimport PlaygroundSupportclass CustomView: UIView &#123;    override init(frame: CGRect) &#123;        super.init(frame: frame)        self.backgroundColor = .white // 设置背景颜色    &#125;    required init?(coder: NSCoder) &#123;        fatalError(&quot;init(coder:) has not been implemented&quot;)    &#125;    override func draw(_ rect: CGRect) &#123;        guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;        // 绘制一个圆形        context.setFillColor(UIColor.blue.cgColor) // 设置填充颜色        context.fillEllipse(in: rect) // 绘制填充的圆        // 绘制一个矩形        context.setStrokeColor(UIColor.black.withAlphaComponent(0.6).cgColor) // 设置能见度        context.setLineWidth(5)        context.stroke(rect.insetBy(dx: 10, dy: 10)) // 绘制矩形边框，留出间距    &#125;&#125;// 创建自定义视图实例let customView = CustomView(frame: CGRect(x: 0, y: 0, width: 200, height: 200))// 显示在 Playground 的 live viewPlaygroundPage.current.liveView = customView\n\n\ntouchesBegan–WWDC\nSCNVector3是三维向量\nDispathchQueue表示创建一个异步的进程\n\n传感器\n加速度的方向伴随手机的头部旋转保持不变;\n以 g 为描述单位;\n面向使用者的方向是 z 轴.\n\n\n陀螺仪\n记录对应用三个轴\nroll, pitch, yaw\n\n\n\n动画结绳记事\n操作演示.\n\n按住 ctrl将视图中的组件拖放到代码中.\n\n右下角的几个功能:\n\n约束;\n选择视图\n\n\nctrl + option + cmd + enter 快速显示代码区域\n\n组件使用\n\n50:00 左右介绍了两种类型和交互\n\n\n按住 optional然后 hover 在类上, 可以显示对应的基础操作.\n\n可选值的本质是枚举类型!\nenum Optional&lt;T&gt;&#123;  case none  case some(&lt;T&gt;)&#125;\n画图和动画\n\ncoreML\n\n在项目中显示Md格式:\n/*:...*/\n选择在运行时隐藏实际存在的代码:\n//#-hidden-codeimport PlaygroundSupport...//#-end-hidden-code\n\nSwift UI\n慕课的链接\nby now\nSixD: 开箱即用的UI设计等.\n术语表\n\nAR\nhelpful links\n官方文档\n\n动画缩放变换NavigationLink&#123;  BraceletEditor(bracelet)  .navigationTransitionStyle(  .zoom(  \tsourceID:bracelet.id,  \tin:braceletList  \t)  )&#125;label:&#123;  BraceletPreview(bracelet)&#125;.matchedTansitionSource(\tid:bracelet.id,  in:braceletList)\n\nSymbol 6动画\n使用 晃动 在复杂的UI中提示可交互性.\n旋转动画来表示正在进行的进程\n\n基本语法磨砂效果VStack &#123;&#125;.frame(width: 200, height: 200).background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20, style: .continuous))\n\n搜索栏\n状态管理:\n// 存储搜索文本@State private var searchText = &quot;&quot;// 可选：跟踪搜索是否处于活动状态@State private var isSearching = false\n数据过滤模式\n// 基本过滤计算属性模板var filteredItems: [ItemType] &#123;    if searchText.isEmpty &#123;        return originalItems    &#125; else &#123;        return originalItems.filter &#123; item in            // 根据需要自定义过滤条件            item.name.localizedCaseInsensitiveContains(searchText) ||            item.description.localizedCaseInsensitiveContains(searchText)        &#125;    &#125;&#125;// 处理嵌套数据结构的过滤模板var filteredNestedItems: [ParentType] &#123;    if searchText.isEmpty &#123;        return originalParentItems    &#125; else &#123;        return originalParentItems.compactMap &#123; parent in            let matchedChildren = parent.children.filter &#123; child in                child.name.localizedCaseInsensitiveContains(searchText)            &#125;            if matchedChildren.isEmpty &#123;                return nil            &#125; else &#123;                // 创建包含匹配子项的新父项                return ParentType(id: parent.id, name: parent.name, children: matchedChildren)            &#125;        &#125;    &#125;&#125;\n搜索UI中的实现:\nNavigationStack &#123;    List &#123;        // 使用过滤后的数据源        ForEach(filteredItems) &#123; item in            // 列表项视图        &#125;    &#125;    .navigationTitle(&quot;标题&quot;)    .searchable(text: $searchText, prompt: &quot;搜索提示文字&quot;)    // 可选：添加搜索建议    .searchSuggestions &#123;        ForEach(suggestions, id: \\.self) &#123; suggestion in            Text(suggestion).searchCompletion(suggestion)        &#125;    &#125;&#125;\n\n左右适应的外边距通过 HStack与  space实现卡片的自适应扩展, 同时利用 .frame(maxwidth:...)来设置一个最大的卡片宽度\nHStack&#123;    Spacer(minLength: 10)      Text(item.description)        .padding()        .background(Color(.systemGray6))        .overlay(            RoundedRectangle(cornerRadius: 10) // 10为圆角半径，可调整                .stroke(Color.gray, lineWidth: 1) // 边框颜色和宽度        )        .clipShape(RoundedRectangle(cornerRadius: 10))    // 保证背景和边框都圆角    .frame(maxWidth: 400) // 最大宽度限制    Spacer(minLength: 10)&#125;\n\nSpacer(minLength: 10) 表示保证自己不会小于 minLength.\n上述的 Spacer会压缩卡片的内容, 如果希望直接设置卡片在父容器中的左右外边距, 应该在卡片的内部使用 padding:\nText(item.description)    .padding(.horizontal, 24) // 卡片内容内边距    .padding(.vertical, 12)    .background(Color(.systemGray6))    .overlay(        RoundedRectangle(cornerRadius: 10)            .stroke(Color.gray, lineWidth: 2)    )    .clipShape(RoundedRectangle(cornerRadius: 10))    .padding(.horizontal, 20) // 整个卡片距离父视图左右20pt\n\n全局统一样式@mainstruct MyApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()                .buttonStyle(ShadowButtonStyle(radius: 10))        &#125;    &#125;&#125;\n\n参数标签和参数名\n参数标签用于函数调用时;\n参数名用于函数内部的参数名称.\n\ne.g.:\nfunc greet(person atName: String) &#123;    print(&quot;Hello, \\(atName)!&quot;)&#125;greet(person: &quot;Alice&quot;) // 输出：Hello, Alice!\n\n也可以使用 _来省略调用时的参数标签:\nfunc greet(_ name: String) &#123;    print(&quot;Hello, \\(name)!&quot;)&#125;greet(&quot;Alice&quot;) // 输出：Hello, Alice!\n\nAlertswift UI中的弹窗提示同样通过本地的 @State变量来实现:\n@State private var showingPaymentAlert = false....alert(&quot;Order confirmed&quot;, isPresented: $showingPaymentAlert) &#123;    // add buttons here&#125; message: &#123;    Text(&quot;Your total was \\(totalPrice) – thank you!&quot;)&#125;\n\n设置按钮来改变可见的状态:\nButton(&quot;Confirm order&quot;) &#123;    showingPaymentAlert.toggle()&#125;\n\n自定义绑定我们也可以使用 Binding 类型手动创建绑定，该类型可以提供自定义 get 和 set 闭包，以便在读取或写入值时运行。\nForeachForEach(item.restrictions) &#123; restriction in    Text(restriction)&#125;\n\n此时, 要求 item.restrictions 具有可唯一标识的 id 字段.\n\n如果内容本身就是唯一标识, 比如说遍历的内容是字符串数组, 那么可以如此声明:\nForEach(item.restrictions, id: \\.self) &#123; restriction in    Text(restriction)&#125;\n\nSpacer()用于填充剩余的空间\n\n使用 offset(x:.., y:...)来调节位置, 左上角是原点.\n\n环境变量\n作用: 用于存储独立于视图的、长期存在的数据;\n\ne.g.\n// App.swift@StateObject var order = Order()\n@StateObject 属性包装器负责在应用程序的整个生命周期中保持对象处于活动状态。\n\n需要在创建视图结构体的时候传递:\nWindowGroup &#123;    ContentView()        .environmentObject(order)&#125;\n为了让swift知道什么时候更新视图, 常用的是声明 @Published属性包装器——足以让它更新任何正在监视更改的 SwiftUI 视图.\n\n同时声明对应的对象遵循可观测协议: ObservableObject.\n使用 @ObservedObject 或者 @StateObject 来订阅上述的对象, 不同的是:前者引用外部的对象, 后者将直接创建一个新的对象, 且生命周期和视图绑定\n\n\n\n我们可以使用 @EnvironmentObject来访问环境中的共享数据, 也就是传递上一步已经在父视图中创建和管理的对象.\ne.g.\nclass UserData: ObservableObject &#123;    @Published var name: String = &quot;John&quot;&#125;struct ContentView: View &#123;    @StateObject private var userData = UserData()    var body: some View &#123;        ChildView().environmentObject(userData)    &#125;&#125;struct ChildView: View &#123;    @EnvironmentObject var userData: UserData    var body: some View &#123;        Text(userData.name)    &#125;&#125;\n\n使用 @State来声明简单的本地值——比如整数和字符串.\n\n建议将其声明为 private, e.g.\n@State private var paymentType = &quot;Cash&quot;\n\n菜单视图为了将菜单视图存放在一个选项卡当中, 我们需要新建一个视图, 用来作为容器:\nstruct MainView: View &#123;    var body: some View &#123;        TabView &#123;            ContentView()                .tabItem &#123;                    Label(&quot;Menu&quot;, systemImage: &quot;list.dash&quot;)                &#125;            OrderView()                .tabItem &#123;                    Label(&quot;Order&quot;, systemImage: &quot;square.and.pencil&quot;)                &#125;        &#125;    &#125;&#125;\n\n\n页面级别的切换.\n\n使用枚举与子页面的内容分区:\nimport SwiftUIstruct ContentView: View &#123;    enum Section &#123;        case cats        case dogs    &#125;    @State private var selectedTab = Section.cats    var body: some View &#123;        TabView(selection: $selectedTab) &#123;            Tab(&quot;Cats&quot;, systemImage: &quot;cat&quot;, value: .cats) &#123;                Button(&quot;Go to Dogs&quot;) &#123;                    selectedTab = .dogs                &#125;            &#125;                      Tab(&quot;Dogs&quot;, systemImage: &quot;dog&quot;, value: .dogs) &#123;                Button(&quot;Go to Cats&quot;) &#123;                    selectedTab = .cats                &#125;            &#125;        &#125;    &#125;&#125;\n\n合适的修饰符\n图像自动调节尺寸:\nImage(item.mainImage)    .resizable()    .scaledToFit()\n\n设置阴影.shadow(color: .black.opacity(0.2),         radius: 15, x: 0, y: 10)\n\n为按钮设置动画struct ContentView: View &#123;    @State private var showingWelcome = false    var body: some View &#123;        VStack &#123;            Toggle(&quot;Toggle label&quot;, isOn: $showingWelcome.animation())            if showingWelcome &#123;                Text(&quot;Hello World&quot;)            &#125;        &#125;    &#125;&#125;\n\n可以进一步设置, 比如弹簧的渐入渐出:\nToggle(&quot;Toggle label&quot;, isOn: $showingWelcome.animation(.spring()))\n\n基本操作快捷键\nctrl按住后点击  VStack可以快速地将其添加到 ZStack当中\n颜色的设置需要通过 ZStack来实现.\n\n\noption可以显示当前类的介绍\n\n\n推荐资源：\n\nRaywenderlich 的 SwiftUI 教程： Raywenderlich - SwiftUI Apprentice\nBig Mountain Studio 的免费电子书： SwiftUI Views Quick Start\n\n","categories":["学习笔记"],"tags":["swift","编程语言"]},{"title":"密码学复习","url":"/2025/06/25/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%A4%8D%E4%B9%A0/","content":"\n任课老师：白洪欢\n\n前期知识数学基础gcd相关定理设a,b为整数且至少有一个不为0, 令d = gcd(a,b), 则一定存在整数x, y 有:\n\n\n特别的,当a,b互素时一定存在整数x，y使得 上述的右式为1成立\n\n扩展欧几里得法对于一个整数a来说，如果它存在模n的乘法逆元 , 那么这一充分必要条件是， a与n是互素的\n\n\n素数相关的定理任意大于0的整数  都能唯一分解成素数的乘积：\n\n古典密码\n频率分析表可以对付单表密码\n仿射密码\n以加密为例：\n\n\n\nVigenereVigenere是一种多表简单加法密码.\n\n明文为 m1,m2…mp; 密钥为 k1,k2…kq\n当q小于p时, 重复使用密钥;\n加密: \n解密: \n\nEnigma流程图：\n\n\nHash函数MD5使用～加密的过程也被称作生成摘要的过程，相当于有损压缩\n\n报文的长度固定为128位\n\nmd5是一种单向函数，意味着可能有多个输入对应相同的输出\n\n如果不同的报文计算得到的摘要相同，就称为发生了碰撞 collision\n\n分块与填充\n如果最后一块的大小正好是64字节，还需要额外填充一块\n1字节的 0x80以及8字节的 count 是一定要填充的\n按照最后一块的大小，分为小于56与介于56和63字节之间2种情况\n\n源代码分析结构体\ntypedef struct _MD5_CTX{   ulong32  state[4]; /* 128位摘要 */   ulong32  count[2]; /* 已处理的报文的二进制位数,最大值=2^64-1 */   unsigned char  data[64]; /* 64字节message块 */} MD5_CTX;\n\n\n此处的count计数的是比特位而不是字节！因此通过下面的方式计算字节数：\nbytes_left = (MD5_ctx-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;\n\n&amp;0x3F 等价于 %64 也就是 和 n-bit的1进行与计算，相当于 mod \n\nUpdate\n每次不断向其中添加新数据，添加前需要补充的字节数如果小于buf_len，说明可以补齐为1个block来处理，否则进入else分支直接赋值\nFinalint Final_MD5(MD5_CTX *MD5_ctx){   ulong32 bytes_left, pad_len;   unsigned char total_bits[8];   // unsigned char * 进行强制类型转换, 使得8“位”实际上得到的是64bits, 也就是计数的全部内容.      memcpy(total_bits, (unsigned char *)MD5_ctx-&gt;count, 8); // total_bits=                                                           // 已处理的报文的二进制位数                                                           // (含data中剩余的字节)                                                           // 后面补充的pad_stuff及                                                           // total_bits本身不计在内   bytes_left = (MD5_ctx-&gt;count[0] &gt;&gt; 3) &amp; 0x3F;   pad_len = (bytes_left &lt; 56) ? (56 - bytes_left) :                (64 - bytes_left + 56); // bytes_left==56时, 要补8+56=64字节                                       // bytes_left==57时, 要补7+56=63字节   Update_MD5(MD5_ctx, pad_stuff, pad_len); // 把pad_stuff加到data中计算   Update_MD5(MD5_ctx, total_bits, 8); // 把total_bits加到data中计算   return 0;}\n\n\n注意 pad_len在此处就是填充值的字节数，按照最后一个块的字节数的56划分\ncount中，不包含填充值和本身，只是计数处理的字节数\n\n彩虹表破解MD5以4个大写字母的彩虹表为例:\n\n生成随机数 n  [0, ], 得到对应的字母 \n\n比如 AAAA 对应 0\n\n\n计算 \n\n每次将得到的 取模得到上述的 , 循环计算, 得到最后的一个 ;\n记录循环序列初始的 n与最后的 m.\n\n\n循环上述操作 k 次, 得到 k对的值存入数据库, 然后用报文  在数据库当中检索 m.\n\n如果立即找到, 说明是这对键值对的 , 使用 重新计算即可.\n\n如果在数据库中找不到  的值, 作以下的操作\n\n如果此时的  在数据库中存在, 那么说明此时的  就是那一对 n与m计算序列中的 所对应的  .\n\n如果继续找不到, 那么就循环上述的步骤.\n\n\n\nNOTICE：\n\n生成一个随机数的之后，计算其MD5值 , 然后将其赋值给 （注意需要取模处理），迭代计算， 直至索引为100， 因此最后一个随机数计算得到的链上有101个MD5值\n数据库中只存储一开始的随机数（为了开始计算），以及链尾的MD5值（为了查询比较）\n如果初始的100个md5的值中存在对应的，就认为明文是对应的 (然后转换为字母组合)；\n如果一开始查询不到，就按照下面的说法继续计算：\n\n\n\n\n注意，是向前迭代，也就是说存储的都是0和100，比较的都是idx=100的md5值\n\nSHA\nsha-1得到的hash值是160位 = 20 字节\n使用5个32位寄存器\n\n\n～也是分块计算，每块64字节，不足64字节时按照与md5相同的方法填充\n\n结构体typedef struct _SHA1_CTX {   ulong state[5];    // 5个32位寄存器，对应A,B,C,D,E   struct {ulong hi, lo;} length;  // 64位消息长度计数器   uchar data[64];    // 512位的消息块} SHA1_CTX;\n\nROL\n循环左移\n\nstatic ulong ROL(ulong x, int number) /* left circular shift number bits */{   return (x &lt;&lt; number) | (x &gt;&gt; (32 - number));}\n\n\n在低位进行或运算，补充之前移出的位\n\n\nBigEndian 将buf中的long转换成大端的存储格式\nfinal中：BigEndian(digest, 20); /*[%] 注意SHA1的hash值共5个state, 每个state为ulong类型,       输出的时候,不可以把5个state当作连续的20个字节并以      字节为单位按从左到右顺序输出, 而应该以ulong为单位      分5次输出. 这是因为在Little-Endian的机器中, ulong      是按低字节在前高字节在后的顺序存放在内存中的 , 若      以字节为单位输出ulong , 则从左到右输出的4个字节与      直接输出ulong所得的4字节顺序刚好是反的.      这里为了达到以字节为单位按从左到右顺序输出的目的,      特地调用BigEndian()这个函数对每个ulong所包含的4个      字节颠倒顺序, 这样一来,  digest中包含的20字节摘要      就可以按从左到右顺序输出了.*/#endif\n\n分组密码工作与流密码分组密码ECB\n电子密码簿\n\n将明文分块, 分别用一个 key进行加密.\n\n优点:  加密和解密都可以并行进行.\n缺点: 块内依旧存在可能相同的密文块.\n\n\n\nCBC\nCipher Block Chaining 密文块链接模式\n\n当前块的密文与前一块的密文有关:\n\n\n加密过程只能串行处理：\n\n解密过程可以并行处理：\n\nCFB\nCipher feedback 密文反馈模式\n\n\n\n加密流程：\n\n每次加密一个字节\n取X的高8位用E加密，然后与明文8位异或\n\n\n然后每字节加密结束之后, 将 x 左移一个字节, 然后用 c[0]填充右侧;\n循环上述, 注意每次都是用 x[0] 进行异或操作.\n\n\n解密流程：\n\n优点：\n\n可以从密文传输的错误中恢复\n\n\n\nRC4是一种对称加密算算法，使用相同的密钥来加密和解密\n结构体typedef struct rc4_key{     unsigned char state[256];  // 256字节的状态表     unsigned char x;          // 状态表索引x     unsigned char y;          // 状态表索引y} rc4_key;\n\n密钥初始化void prepare_key(unsigned char *key_data_ptr, int key_data_len, rc4_key *key){   // 初始化状态表   for(counter = 0; counter &lt; 256; counter++)      state[counter] = counter;      // 使用密钥打乱状态表   for(counter = 0; counter &lt; 256; counter++)   {       index2 = (key_data_ptr[index1] + state[counter] + index2) % 256;       swap_byte(&amp;state[counter], &amp;state[index2]);       index1 = (index1 + 1) % key_data_len;   }}\n\n\nkey_data_ptr 为种子密钥；使用循环打乱state\n\n加密/解密函数void rc4(unsigned char *buffer_ptr, int buffer_len, rc4_key *key){   for(counter = 0; counter &lt; buffer_len; counter ++)   {      x = (x + 1) % 256;      y = (state[x] + y) % 256;      swap_byte(&amp;state[x], &amp;state[y]);      xorIndex = (state[x] + state[y]) % 256;      buffer_ptr[counter] ^= state[xorIndex];   }   key-&gt;x = x; /* 保存x及y这两个state的下标, 使得下次rc4()调用与本次调用可以衔接 */   key-&gt;y = y;}\n\n示例main(){   rc4_key k;   char seed_key[] = \"This is RC4 seed key.\";   char plaintext[100] = \"A quick brown fox jumps over the lazy dog.\";      // 初始化密钥   prepare_key(seed_key, strlen(seed_key), &amp;k);      // 加密   rc4(buf, n, &amp;k);      // 解密（重新初始化密钥后再次加密）   prepare_key(seed_key, strlen(seed_key), &amp;k);   rc4(buf, n, &amp;k);}\n\n重要算法DES基本介绍全称: Data Encryption Standard\n流程示意图：\n\n\n\n\n明文的L/R中交替加密，每轮没有改变的部分与K参与计算，将结果用于改变另一部分\n64位的key去除8位（经过打乱）后变为56位的Key，然后将左右两侧分别循环左移，16次循环迭代中分别得到一组，然后利用56-48的表得到48位的值\n查询sbox得到32位的结果，与L异或\n\n\n步骤解析加密L[i] = L[i-1] ^ f(K[i], R[i-1]);R[i] = R[i-1]\n\n其中的 f为：\nlong f(K[i], D[i]){  K48 = shrink ( K[i]);  D48 = expand( D[i]);  return query_sbox(K48 ^ D48);}\n\n\nshrink表示从最低位开始, 交替取用1/2次 比如 0,0,1,2,2,3…\n为了将48位的数据展开成为数组, 我们将48位分为8组, 各组为 6bits 并且用 unsigned char来表示 —— unsigned char s[8].\ns[i]仅仅使用低六位.\nsbox恰好对应了8张表, 供 s进行查询, 且每次查询输入6位的输出是4位.\n因此, 8次查询的返回值一共是32位.\n\n\n\nsbox的查询由8个一维数组组成，分别对应48位分成的8组查询, 其中每个数组都是64位, 每行是0-15构成的不重复的16个数字, 共四行.\n\n\n对于每组中的8位，实际的数据存储在低6位中，我们：\n\n提取首尾的2-bit合成查询的行号；\n提取中间的4-bit合成查询的列号\n\ndisturb将输入的64位进行位重排 permutation\ntable中64字节是1～64的排序（因此内部的数值以1为基数）：\n\nip[0]=58  表示源数据中的第58位 ( 实际是第58-1=57位)要转化成目标数据中的第0+1=1 位\n\nvoid disturb(unsigned char table[64], unsigned char s[8], unsigned char t[8]){   int i;   byte_num, bit_num;   /* memset(t, 0, sizeof(t)); 错误 */   memset(t, 0, 8); /* 正确 */   for(i=0; i&lt;64; i++)   {      byte_num = (table[i]-1) / 8;      bit_num = (table[i]-1) % 8;// 如果对应的位是0，就直接进行下一轮的迭代，因为初始化t的各位都是0      if(s[byte_num] &amp; (0x80 &gt;&gt; bit_num)) /* 或 if(s[byte_num] &amp; (0x01 &lt;&lt; 7-bit_num)) */         t[i/8] |= 0x80 &gt;&gt; i%8;   }}\n\n\n每次循环取出table中的一个字节，并且通过 /8 与 %8的计算分别得到 byte_num, bit_num；\n一共需要迭代64次，因为一共有8x8位需要替换\n\n什么时候打乱？\n\n明文在加密之前——ip\n明文加密之后——fp\nsbox查询结果的32位数据）sbox_perm_table\n打乱之后再与“明文”异或\n\n\n64位的密钥转换位56位 TODO——key_perm_table\n56位的密钥循环左移之后取用48位 TODO\n\n密钥的合成56 2 48   for (j=0; j&lt;48; j++) /* select bits individually */   {                    /* [%] Select 48 bits from 56 bits.                               j is the target bit number, and                                key_56bit_to_48bit_table[j]-1 is                                the source bit number */      /* check bit that goes to kn[j] */      if (pcr[key_56bit_to_48bit_table[j]-1]) /* [%] pcr[key_56bit_to_48bit_table[j]-1] is SourceBit, j is TargetBit */      {         /* mask it in if it's there */         b = j % 6;                     /*  same as bytebit[b+2] */         kn[i][j/6] |= bytebit[b] &gt;&gt; 2; /* [%] remove the trailing 2 bits                                           j=0    1    2    3    4    5                                  bytebit[b]=0x80 0x40 0x20 0x10 0x08 0x04                               bytebit[b]&gt;&gt;2=0x20 0x10 0x08 0x04 0x02 0x01                                         */      }   } /* [%] for (j=0; j&lt;48; j++) */} /* [%] for (i=0; i&lt;16; i++) */\n\n此处的 bytebit为：\nstatic int bytebit[8] = {/* bit0  bit1  bit2  bit3  bit4  bit5  bit6  bit7 */   0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n\n也就是8bit中从最左侧为1开始，不断右移知道最右侧为1\n上述的 bytebit[b] &gt;&gt; 2 确保了1只可能只出现右侧的6位，因此实现了靠右对齐\n6个为一组，构成8x6，i表示16轮迭代中的层数\n操作汇总利用一维idx在二维数组中索引\n要求：给定1-64范围内的idx，在8x8 i.e. 8个字节中索引对应的1bit：\n分析：\n8x8分别用3bit去索引\n\n\n\ndisturb中的实现\nfor(i=0; i&lt;64; i++){    byte_num = (table[i]-1) / 8;    bit_num = (table[i]-1) % 8;    // 如果对应的位是0，就直接进行下一轮的迭代，因为初始化t的各位都是0    if(s[byte_num] &amp; (0x80 &gt;&gt; bit_num)) /* 或 if(s[byte_num] &amp; (0x01 &lt;&lt; 7-bit_num)) */        t[i/8] |= 0x80 &gt;&gt; i%8;}\n\n\n/ 8 等价于 &gt;&gt; 3 ； 同时 % 8等价于 &amp;7\n注意利用结果对二维的数组进行赋值（此处就是替换）：t[i/8] |= 0x80 &gt;&gt; i % 8\n\n下面的实现也是合理的：\nfor (j=0; j&lt;56; j++) /* convert key_perm_table to bits of key */{                    /* [%] j is the target bit number of key */   b = key_perm_table[j] - 1;   /* integer bit location */                                /* [%] b is the source bit number of key, base 0 */   m = b &amp; 7;        /* [%] m = b % 8; */ /* find bit */    pc1m[j]=(key[b&gt;&gt;3] &amp; bytebit[m]) ? 1 : 0; /* find which key byte b is in */                                             /* and which bit of that byte */                                             /* and store 1-bit result */}\n\n\n不同于第一个实现，此处的pclm就是一个一维的数组，因此可以直接赋值。\n\n构建反查表已知sbox打乱表，需要根据表格内容构建反查表\n\n先遍历取值范围\n然后遍历已知表的idx，直到idx在已知表中索引得到的值与外层的遍历值相同\n将外层的idx作为索引，用内层表的idx赋值给反查表\n\nfor(p=0; p&lt;32; p++) /* [%] p=SourceBit */{   for(i=0; i&lt;32; i++) /* [%] i=TargetBit */   {      if(sbox_perm_table[i]-1 == p) /* [%] sbox_perm_table[i] ranges within [1,32], so it is base 1, not base 0 */      {         sbox_perm_table_inverse[p] = i; /* [%] fill sbox_perm_table_inverse[p] with TargetBit=i */         break;      }   }}\n\n循环右移与补偿方法1：循环左移与右移：\n// 循环左移n位ulong ROL(ulong x, int n){  n = n % 32;\treturn (x &lt;&lt; n) | (x &gt;&gt; ( 32 - n));}// 循环右移ulong ROR(ulong x, int n){  n = n % 32;\treturn (x &gt;&gt; n) | (x &lt;&lt; (32 - n));}\n\n方法2：循环右移一位的写法\n// 循环右移，将r的最低位移到最高位，其他位向右移动一位//  r &amp; 1用于判断移位前的最低位是否为1，如果是，需要在循环右移的结果补偿rt = (r &gt;&gt; 1) | ((r &amp; 1) ? 0x80000000 : 0); /* [%] rt = ROR(rt, 1); */\n\n循环左移\n分别将左右两侧分为28bit进行循环左移；\n用 b表示移位的位数，将pclm中的位赋值给pcr数组\n注意在高28位中是 (j - 28 + xx) % 28  确保基数为1\n\nfor(j=0; j&lt;28; j++) /* [%] left half */{   b = (j+key_rol_steps[i]) % 28;   pcr[j] = pc1m[b];}for(j=28; j&lt;56; j++) /* [%] right half */{   b = 28 + (j-28+key_rol_steps[i]) % 28;   pcr[j] = pc1m[b];}\n\n转换为16进制for(i=0; i&lt;blocks*8; i++) // 转化成 16进制字符串{sprintf(hex+i*2, \"%02X\", bufout[i]); // 2表示最少2位，0表示不足填充0，X表示用大写的16进制输出}\n\n三重DES由于存在一种称为中途相遇攻击（meet-in-the-middle attack）的技术，对双重DES加密构成了威胁，因此一般不使用双重DES，而是三重DES来多重加密\n给定3个长度为56比特的密钥与明文 ，密文为：\n\n中间的密钥采取解密的形式加密，仅仅是为了可以利用三重DES对单重DES加密的数据进行解密\nAES整体流程\n\nbytesub 字节代替变换\nshiftrows 行移位变换\nmixcolumns 列混淆变换\n\nMixColumn\n\n\n每次加密明文的一列.\n3112为底,不断循环左移一位得到另一行.\n计算的时候是左列和右列诸位乘加. 和传统的矩阵乘法有所不同.\n\n\n乘数的低位在前, 高位在后.\n\nvoid MixColumn(unsigned char *p, unsigned char a[4], int do_mul){   unsigned char b[4];   unsigned char t[4][4];   int j;   for (j = 0; j &lt; 4; j++)   {      get_column(p, j, b);            /* 从p所指矩阵m中提取第j列, 保存到数组b中. */      if (do_mul)                     /* 在加密最后一轮以及解密第一轮的MixColumn步骤中不需要做乘法; */         aes_polynomial_mul(a, b, b); /* 其余轮都要做乘法: b = a*b mod (X^4+1); */      memcpy(t[j], b, 4);             /* 把乘法所得结果复制到t中第j行 */   }   memcpy(p, t, 4 * 4); /* 复制t中矩阵到p, 替换掉p中原有矩阵 */}\n\n对应的乘法：\n// 有限域GF(2^8)多项式乘法 mod X^4 + 1void aes_polynomial_mul(unsigned char x[4], unsigned char y[4], unsigned char z[4]){    unsigned char temp[8] = {0};    int i, j;    for (i = 0; i &lt; 4; i++)    {        for (j = 0; j &lt; 4; j++)        {            unsigned char product_coeff = aes_8bit_mul_mod_0x11B(x[3 - i], y[j]);            temp[i + j] ^= product_coeff;        }    }    z[0] = temp[0] ^ temp[4];    z[1] = temp[1] ^ temp[5];    z[2] = temp[2] ^ temp[6];    z[3] = temp[3] ^ temp[7];}\n\n\n由于原先矩阵中的低次系数均在前，我们希望计算0～3次之间相乘的结果，因此在两层的嵌套中，采取 3-i 与  j 并举的方式；\ni，j分别表示对应的阶数\n\n密钥生成流程概述：\n\n4i 形式比较特殊，一组（4x4字节）的key都在前者的基础上得到\n4i的计算流程：\n4i 由 4i-1 临时赋值\n循环左移1位\n带入sbox替换查询\n利用4i计算轮常数r\n首字节与r异或\n4i 与 4(i-1) 作异或得到最终的4I\n\n\n4i+1 =  4i ^ 4(i-1);\n4i+2 = 4i+1 ^ 4(i-1) + 1\n…\n\npk[0] = pk[-1];     rol_a_row(key + i * 4, 1);     ByteSub(key + i * 4, 4);     r = 1 &lt;&lt; ((i - step) / step);     // r较小的时候直接mod     if (r &lt;= 0x80)        r = aes_8bit_mul_mod_0x11B(r, 1);     else        // r较大，为了避免处理大数，等价变换来优化        r = aes_8bit_mul_mod_0x11B(r / 4, 4);     key[i * 4] ^= r;     pk[0] ^= pk[-step];     for (j = 1; j &lt; step; j++) /* i+j是密钥k的下标, 当(i+j)%step != 0时, */     {                          /* k[i+j]只需做简单的异或处理 */        if (...){}          else /* 当(i+j)%step != 0时, k[i+j]只需做以下异或处理 */           pk[j] = pk[j - step] ^ pk[j - 1];     }     pk += step;\n\n\n最后两组的轮常数因为 mod 0x11B的缘故与的值并不相等\n192和256位的密钥生成在上面的代码片段中被省略了\n\n操作汇总农夫算法核心思想：通过被乘数的左移和乘数的右移，同时提前求模来加速计算\nint p = 0 ;for(int i = 0; i &lt; 8 &amp;&amp; x &gt; 0 &amp;&amp; y &gt; 0; i++){  if(y &amp; 1){    p ^= x;  }  y &gt;&gt;= 1;  x &lt;&lt;= 1;    // 通过迭代实现除法效果.  if(x &gt;= 0x100){    x ^= 0x11B;  /* x = x % 0x11B */  }}\n\n\nGF2的减法就是加法，加法也就是异或；多次异或直至结果小于0x100\n\nRSA属于公钥加密体制（非对称加密）\n整体的流程：\n\n选择不等的素数 \n计算 \n选择与  互素的数 \n计算在模下的乘法逆元 \n公开公钥：\n保存私钥：\n\n加密与解密：\n\nEuler函数\n定义： ：小于n且与n互素的整数的个数\n\n对应的定理：\n\n特别的，如果是素数的话，有  =  ，推知 \n\n\n中国剩余定理对于同余方程组：\n\n其中  两两之间互素，并且令 ：\n\n此时， 模 M的唯一解为：\n\n\n其中逆元可以根据辗转相除法得到\n\ne.g.\n\n\n\n\nEuler函数的拓展性质\n乘法性质：\n$$n_1, n_2 互素 \\Longrightarrow \\phi(n_1n_2) = \\phi(n_1)\\phi(n_2)$$\n\n乘积公式：\n\n\n其中，且 为素数， 由对  的质因数分解得到\n\n\n\ne.g.\n\n\n签名加密：A将一封信发送给B\n\nA将信件内容用B的公钥进行RSA的加密\nB收到内容后使用自己的私钥解密，得到的结果就是A信件的内容\n\n签名：为了验证信件内容确实来自于A\n\nA对信件内容计算摘要，以MD5算法为例：M = MD5（L）\n然后用A的私钥对M加密： M’ = RSA（M， A的私钥）\nA将M’与L一起发送给B\nB利用A的公钥计算 M‘’ = RSA（M’，A的公钥），同时计算MD5（L）\n如果后者的结果 = M‘’， 说明验证正确\n\n\n\n\n注意A无法得到B的私钥，因此此处RSA加密解密涉及的都是A的密钥\n\nECC\n直接参考pdf文档\n\n常用ecc函数\n\n\n注意0表示计算得到的y是偶数\n\n补充AES算法的明文长度和密文长度都是16字节，密钥长度分为16、24、32字节三种\n请看调整后的表格，其中包含了ECC算法的特点：\n\n\n\n算法\n加密模式\n明文-密文长度\n密钥关系\n备注\n\n\n\nDES\nECB, CBC, CFB\n明文64位，密文64位\n64位密钥（实际56位用于加密，8位用于奇偶校验）\n三重DES是为了对抗中途相遇攻击，增加安全性\n\n\nAES\nECB, CBC, CFB (未在文中明确提及，但通常支持)\n明文16字节，密文16字节\n密钥长度可为16、24、32字节\n具有字节代替、行移位、列混淆等变换\n\n\nRSA\n不适用（非对称加密算法）\n明文长度需小于n，密文长度等于n\n公钥(e,n)，私钥(d,n)； e与ϕ(n)互素，d为e模ϕ(n)的乘法逆元\n基于大数分解的困难性；可用于加密和数字签名\n\n\nECC\n不适用（非对称加密算法）\n与所选椭圆曲线参数相关\n基于椭圆曲线离散对数难题\n相比RSA，在相同安全强度下密钥长度更短，计算效率更高\n\n\nxgcd/** * 扩展欧几里得算法实现 * 计算gcd(x,y)以及x mod y的乘法逆元 *  * @param x 第一个整数 * @param y 第二个整数 * @param pinverse 用于存储x mod y的乘法逆元的指针 * @return 返回gcd(x,y) *  * 示例: * xgcd(3, 20, &amp;inv)返回1，inv被赋值为7，因为3 * 7 ≡ 1 mod 20 */int xgcd(int x, int y, int *pinverse){   // 初始化扩展欧几里得算法所需的变量   // a1, b1用于跟踪第一个方程: x = a1*x + b1*y   // a2, b2用于跟踪第二个方程: y = a2*x + b2*y   int a1=1, b1=0, a2=0, b2=1;      // q是商，r是余数   int q, r, t;      // n和old_n用于跟踪当前的被除数和除数   int old_n;      // 确保x &lt;= y，如果不是则交换它们   if(x &gt; y)   {      t = x;      x = y;      y = t;   }      // 初始化n和r   // n初始为较大的数y，r初始为较小的数x   n = y;   r = x;      // 当余数r不为0时继续循环   while(r != 0)   {      // 计算商q = n / r      q = n / r;        // 更新a1和a2的值      // 这是扩展欧几里得算法的核心部分，同时计算系数      t = a1;      a1 = a2;      a2 = t - q*a2;        // 更新b1和b2的值      t = b1;      b1 = b2;      b2 = t - q*b2;        // 更新n和r的值，进行下一轮迭代      t = n;      n = r;      r = t % r;   }      // 此时n就是gcd(x,y)   // 但我们需要确保乘法逆元b1在模y下是正数   // 因为b1可能是负数，所以加上y再取模y确保它在[0, y-1]范围内   a1 = (a1+y) % y;  // 虽然a1是x的系数，但这里也确保它在模y下   b1 = (b1+y) % y;  // 确保乘法逆元b1是正数      // 将乘法逆元存入指针指向的变量   *pinverse = b1;      // 返回gcd(x,y)   return n;}\n","categories":["课程笔记"],"tags":["CS课程","信息安全"]},{"title":"CORS","url":"/2025/01/16/%E5%89%8D%E5%90%8E%E7%AB%AF/CORS/","content":"概述跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。\n技术背景同源策略基础同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：\n基准URL：http://example.com/page.html跨域场景：- http://api.example.com/data     // 子域名差异- https://example.com/data        // 协议差异- http://example.com:8080/data    // 端口差异\n\n配置方案环境变量驱动的CORS配置以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：\nimport osfrom flask import Flaskfrom flask_cors import CORSapp = Flask(__name__)# 从环境变量获取前端URL，如果没有设置则使用默认值FRONTEND_URL = os.environ.get(&#x27;FRONTEND_URL&#x27;, &#x27;http://localhost:3000&#x27;)# CORS配置实现CORS(app, resources=&#123;    r&quot;/api/*&quot;: &#123;        &quot;origins&quot;: FRONTEND_URL,        &quot;methods&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;, &quot;PUT&quot;, &quot;DELETE&quot;],        &quot;allow_headers&quot;: [&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Requested-With&quot;],        &quot;supports_credentials&quot;: True,        &quot;expose_headers&quot;: [&quot;Content-Disposition&quot;]    &#125;&#125;)\n\n配置详解让我们逐行分析这个配置：\n\n环境变量设置\n\nFRONTEND_URL = os.environ.get(&#x27;FRONTEND_URL&#x27;, &#x27;http://localhost:3000&#x27;)\n\n使用os.environ.get()获取环境变量\n提供默认值&#39;http://localhost:3000&#39;作为本地开发环境的配置\n可以通过环境变量轻松切换不同环境的配置\n\n\nCORS配置参数\n\n&quot;origins&quot;: FRONTEND_URL\n\n动态设置允许的源，基于环境变量\n避免了硬编码的问题\n支持不同部署环境的灵活配置\n\n\nHTTP方法配置\n\n&quot;methods&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;, &quot;PUT&quot;, &quot;DELETE&quot;]\n\n明确定义允许的HTTP方法\n包含了RESTful API所需的全部方法\nOPTIONS用于预检请求（preflight request）\n\n\n请求头配置\n\n&quot;allow_headers&quot;: [&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Requested-With&quot;]\n\nContent-Type：允许设置请求的内容类型\nAuthorization：支持身份验证令牌\nX-Requested-With：用于标识AJAX请求\n\n\n凭证支持\n\n&quot;supports_credentials&quot;: True\n\n允许跨域请求携带凭证（如Cookie）\n对需要身份验证的API至关重要\n\n\n响应头暴露\n\n&quot;expose_headers&quot;: [&quot;Content-Disposition&quot;]\n\n允许客户端访问Content-Disposition响应头\n通常用于文件下载功能\n\n环境变量配置示例# 开发环境export FRONTEND_URL=http://localhost:3000# 测试环境export FRONTEND_URL=http://test.example.com# 生产环境export FRONTEND_URL=https://www.example.com\n\n最佳实践环境变量管理建议\n开发环境\n\n\n使用.env文件管理本地开发环境变量\n将.env文件加入.gitignore\n\n\n生产环境\n\n\n使用容器化部署时通过环境变量注入\n使用配置管理系统统一管理环境变量\n\n安全性考虑\n避免过于宽松的配置\n\n# 不推荐&quot;origins&quot;: &quot;*&quot;  # 推荐&quot;origins&quot;: FRONTEND_URL\n\n\n合理设置凭证策略\n\n\n仅在必要时启用supports_credentials\n确保前端配置匹配（credentials: &#39;include&#39;）\n\n问题排查常见错误及解决方案\nCORS策略违规\n\nAccess to XMLHttpRequest at &#x27;http://api.example.com&#x27; from origin &#x27;http://example.com&#x27; has been blocked by CORS policy\n解决方案：\n\n检查环境变量是否正确设置\n验证前端请求URL与配置是否匹配\n确认所有必要的请求头都已配置\n\n参考文献\nW3C CORS Specification\nMDN Web Docs - Cross-Origin Resource Sharing\nFlask-CORS Official Documentation\n\n","categories":["学习笔记"],"tags":["前后端交互","网站开发"]},{"title":"响应式设计","url":"/2025/01/20/%E5%89%8D%E5%90%8E%E7%AB%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/","content":"所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:\n\n第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；\n另一个作用是当图片无法加载时，页面需要显示的替代文本。\n\n\n\n注意嵌套的形式.e.g\n&lt;p&gt;See more &lt;a href=&quot;https://freecatphotoapp.com&quot;&gt;cat photos&lt;/a&gt; in our gallery.&lt;/p&gt;\n\n\n\n\n要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。\n&lt;p&gt;See more &lt;a href=&quot;https://freecatphotoapp.com&quot; target = &quot;_blank&quot;&gt;cat photos&lt;/a&gt; in our gallery.&lt;/p&gt;\n\n\n\n锚元素除了能将文本转化为链接, 还可以将 图片 转换为链接:\n&lt;a hreg = &quot;https://freecatphotoapp.com&quot;&gt;    &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg&quot; alt=&quot;A cute orange cat lying on its back.&quot;&gt;&lt;/a&gt;\n\n\n\n\nsection 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。\n\n\n\n列表:\n\n无序列表: ul;\n有序列表:ol;\n列表项: li;\n\n\n\n\nfigure 元素代表自包含的内容，允许将图像与标题相关联;figcaption 元素用于添加标题以描述 figure 元素中包含的图像。\n&lt;figure&gt;  &lt;img src=&quot;image.jpg&quot; alt=&quot;A description of the image&quot;&gt;  &lt;figcaption&gt;A cute cat&lt;/figcaption&gt;&lt;/figure&gt;\n\n\n\n\n\n使用 em 使得文字为斜体;\nstrong 加深文字;\n\n\n\n\nform 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。\n\naction属性指定表单数据发送的位置;\n\n&lt;form action=&quot;/submit-url&quot;&gt;&lt;/form&gt;\n\n\ninput 允许通过多种方式从Web表单中收集数据:\n\n与img一样为空元素——不需要结束标签;\n使用 type 属性创建多种输入;\ntext : 文本;\nradio: 可以使用单选按钮;\ncheckbox: 表单使用 复选框;\n\n\n使用name属性使得区分提交的数据;\n令多个单选按钮具有 相同 的name, 使得在选中其中一个按钮时自动取消另外的单选按钮;\n形成name = value形式的属性对进行提交;\n\n\n\n&lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name = &quot;indoor-outdoor&quot;&gt; Indoor&lt;/label&gt;&lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name = &#x27;indoor-outdoor&#x27;&gt; Outdoor&lt;/label&gt;\n\nplaceholder 中为 占位符 文本, 用于提示输入框中输入的信息;\nrequired属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;\n\n&lt;input type=&quot;text&quot; name = &quot;catphotourl&quot;&gt;\n\n\n\n\nbutton 用于创建可点击的按钮:\n\n单击没有任何属性的表单按钮的默认行为会将表单提交到表单的 action 属性中指定的位置;\n由于input和button为 内联 元素, 即使相隔书写也会显示在同行:\ntype的submit明确了为 可提交按钮;\n\n&lt;button type = &quot;submit&quot;&gt;Submit&lt;/button&gt;\n\n\n\nlabel 元素用于帮助将 input 元素的文本与 input 元素本身关联起来\n&lt;label&gt;&lt;input type=&quot;radio&quot;&gt; cat&lt;/label&gt;&lt;!-- 点击单词 &quot;cat&quot; 也将选择 radio 按钮。 --&gt;\n\n\n\nid用于标识特定的HTML元素\n\n\nfieldset 元素用于在 Web 表单中将相关的输入和标签组合在一起:\n\n块级元素，这意味着它们出现在新的一行上。\nlegend 元素充当 fieldset 元素中内容的标题。\n\n&lt;fieldset&gt;        &lt;legend&gt; Is your cat an indoor or outdoor cat?&lt;/legend&gt;          &lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;indoor&quot;&gt; Indoor&lt;/label&gt;          &lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;outdoor&quot;&gt; Outdoor&lt;/label&gt;&lt;/fieldset&gt;\n\n\n\n还可以使用for属性将文本直接嵌套在label当中, 同时设置input的id与上述的for属性相同, 从而实现文本与元素相关联的效果:\n&lt;input id=&quot;loving&quot; type=&quot;checkbox&quot;&gt; &lt;label for = &quot;loving&quot;&gt; Loving &lt;/label&gt;\n\n\n\n默认选中的按钮: checked\n&lt;input checked type=&quot;radio&quot; name=&quot;meal&quot; value=&quot;breakfast&quot;&gt; Breakfast\n\nchecked属性无需额外赋值.\n\n\n\nfooter素用于定义文档或章节的页脚:\n\n脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.\n\n\n\nhead 相关\n\n存放 $\\underline{元数据}$ 不会实际显示在html中的数据;\ntitle 元素决定了浏览器在页面的标题栏或选项卡中显示的内容;\n&lt;link rel = &quot;stylesheet&quot; href = &quot;styles.css&quot;&gt; 将CSS文件链接到当前的HTML\n\nelse:\n\n&lt;!DOCTYPE html: 声明满足最新版本html相关设置的要求;\nmeta是空元素; &lt;meta charset = &quot;utf-8&quot;&gt;;\n\n\n\n选择器:\n\nid选择器\n\n#cat &#123;  width: 250px;&#125;\n\nclass选择器\n\n.class-name, .other-class &#123;  styles&#125;\n\nclass类中元素的选择\n\n.item p&#123;  /* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */  display: inline-block; &#125;\n\n伪元素\n\n/* 已访问链接后设置为灰色 */a:visited&#123;  color: grey;&#125;/* 悬浮时的变色 */a:hover &#123;  color: brown;&#125;/* 点击时的状态设置 */a:active&#123;  color: white;&#125;\n\n\nmargin-left : auto;margin-right: auto;\n\n使得普通元素在父级元素的空间内 水平居中\n\n\n\narticle是一个语义化标签:\n\n用于表示文档、页面或应用中的独立的、完整的内容单元;\n清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;\n内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.\n\n与其他类似标签的区别:\n\ndiv: 粹的容器，没有语义，常用于布局;\nsection: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;\narticle: 示一个可以独立存在的内容单元.\n\n\n\n/* 设置备用字体 */h1, h2 &#123;  font-family: Impact, serif;&#125;\n\n\n","categories":["学习笔记"],"tags":["杂记"]},{"title":"数据库系统复习","url":"/2025/06/21/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E4%B9%A0/","content":"\n任课老师：黄忠东\n\n知识点梳理DML\nselect得到的结果通过 distinct关键字来去重\nunion all可以保留并集中的重复元组\n注意 case与 update组合使用时，分段更新\n\n聚合函数&amp;NULL除了 count之外的聚合函数, 会忽略集合属性上有 null的元组, 而 count则会计算包括空值在内的元组个数.\nSpecial case: 如果所有的聚合属性都是空值:\n\ncount: 返回0;\n其他聚合函数: 返回 null.\n\nlateral外层的查询可以直接使用内部查询的关系名, 但是内部的子查询无法向外直接使用其重命名的关系名.\n然而, 如果在子查询的前面声明关键字 lateral则可以实现:\nSELECT name, salary, avg_salaryFROM instructor I1,     LATERAL (SELECT avg(salary) AS avg_salary              FROM instructor I2              WHERE I2.dept_name = I1.dept_name) AS AvgDeptSalary;\n\n嵌套查询顺序from ; where; group by ; having; select; distinct; order by\n映射基数约束采取 l...h的形式来表示复杂的约束关系：\n\n0..* 表示最少参与0次, 最多没有限制, 可见 ..对多的关系, 部分参与;\n1..1表示恰好参与1次, 表示一对..的关系, 完全参与\n\n比如下面的实际上是many-to-one的关系：\n\n\nER模型和范式从ER模型得到schema从ER模型得到schema的核心规则：\n\n关系类型：\n1:1 ：在参与关系的实体类型中，选择一个schema增加一个FK，指向另一个实体对应的schema的PK，不需要额外建模；\n1:N: 在多端对应的schema中，增加1端对应的PK作为FK。此时，关系也蕴含在这个外键的约束关系中，不需要额外建模；\nM:N: 此时，我们需要将关系建模为一个新的schema——将参与关系的实体类型的主键作为外键，然后加上关系本身的属性，组成为schema的属性\n\n\n弱实体类型：强实体的PK + 弱实体自身的分辨符 = 对应schema的主键，然后补充弱实体的剩余属性\n多值属性：需要为多值属性构建一个新的schema\n将对应的实体的PK和多值属性自身作为schema的PK\n\n\n\n属性集闭包注意，属性的闭包包括自身的属性集\n作用：\n\n判断是否为主键：如果闭包包含了关系中的所有属性，那么就是～\n验证函数依赖是否成立\n计算整个关系模式的闭包: 计算每一个属性的闭包\n\n正则覆盖\n目标：简化给出的函数依赖\n尝试化简属性A时，如果去除的是 中的：\n左侧：判断去除之后左侧剩余属性的闭包是否包含了右侧属性\n右侧：判断此时的左侧属性闭包中是否含有去除的属性\n\n\n我们可以进一步用公式来讲解上述的分析：\n判断中的属性A是否多余：\n计算是否包含了\n\n\n判断中的属性A是否多余：\n根据  的依赖关系，计算 \n如果对应的属性闭包包括了A，那么就可以去除\n\n\n\n\n\n\n\n一个简单的例子来说明如何推导：\n\n\nNOTICE：\n\n实际情况下，可能比较难推导，需要更多的经验和灵感）\n虽然我们要求左侧的属性唯一，但是在推导的过程中，可能尝试将类似于 先拆解为两条，然后判断其中的某条属性是否多余；最后将左侧属性合并\n\n范式的验证\nBCNF：\n如果F中没有违背BCNF原则的函数依赖，那么F的闭包中也没有\n\n\n3NF：\n注意，属性A可以来自不同的CK集合\n只需要对已有的FD进行判断\n\n\n\n存储结构\n似乎不是经常考，了解概念\n\n文件结构\n面向列的存储可以在现代CPU中实现向量处理\n\n定长与变长的记录\n如果是定长记录，为了避免删除记录时调整结构的较大时间成本，可以为维护一个空表，将删除之后的空间通过链表的方式连接，之后插入的时候，首先插入到空表中，如果没有空余的位置，再插入到文件的末尾\n\n如果记录是变长的，在定长和变长之间存在一个空位图：\n\n位数 = 变长记录的个数\n\n某个记录为空时 ==&gt; 对应的bit为 1\n\n定长的信息包含：\n\n变长属性的定长属性信息（开始的偏移量+长度）\n定长属性的值\n\n\n\n\n\nB+树相关索引的block大小假设指针和search-key的大小分别是a，b 那么block的扇出n ( fan-out rate )就是：\n\n\n注意最左侧存在一个单独的指针，然后是一系列的键值对；\n扇出也就是B+树的阶数\n\nchildren的关系\n\n\n此处的 n就是之前计算得到的扇出；\n对于内部节点，最小值的估计是孩子而非关键字的个数！关键字key的个数是孩子数（指针）- 1\n注意叶子节点根据索引值指向对应物理地址的记录，所以是n-1个孩子\n叶子节点的最右侧的指针用于串联叶子节点的链表\n\n非叶子节点类似于多级、稀疏索引。\n高度的估计\n\n\n高度最大估计如上所示；当叶子节点都满时，有最小高度 .\n\n操作相关删除：\n\n\n计算高度\n\n\n根节点最少有2个子节点\n\n\nB+树的范围查找：\n\n如果是查找 &lt;= x, 直接从第一个叶子节点开始按照链表遍历；\n反之，从根节点开始寻找第一个满足条件的叶子节点，然后遍历到底\n\n\n\n如果B+树的索引是字符串等变长的，可以采取前缀的方式来压缩索引项的大小，从而增大扇出n\n\n\nbottom-up\n如果记录已经存在，可以从叶子节点开始自底向上构造（首先排序）\n\n\n\n\n这种技术也用在了LSM的的构建上–当底层的L满了的时候，将其融合并自底向上构建\n\n\n如果要批量插入，也可以先排序然后一起插入，可以有效减少访问的block数量\n\nTODO：分析成本的估计\n\n\n其他结构LSM\n将对数据的修改增量保存在内存中，达到一定的限制后批量写入磁盘，提升了写性能；\n但是因此降低了一定的读性能\n\nBuffer Tree为节点增加内部的缓冲区:\n\n\n\n插入: 如果缓冲区有空闲, 优先插入缓冲区中;\n如果发生了节点的分裂, 注意同时管理缓冲区的转移;\n缓冲区内部也是有序的.\n\n\n查询: 需要在缓冲区中进一步查找\n\nBitmap将Record标号, 然后为每个属性都建立一个 bitmap, 0表示对应的位置不是当前的属性, 1 表示符合当前属性.\n\nbitmap使得两个属性通过 and 操作就找到对应的record.\n\n\n\nIndex\n顺序索引分为了稠密和稀疏两类，后者只能用于顺序文件，因为只有部分的search-key存在索引\n如果搜索键没有重复的，那么稠密的顺序索引就包含了所有的搜索键的index；否则对于每一个搜索键，我们只需要一个开始的index，然后可以线性搜索得到\n\n\n\n\n\n辅助索引\ni.e. secondary key， 与primary-key（顺序）有所区别\n\n当数据文件中的记录顺序和索引文件中的索引项的顺序不一致时：\n\n\n\n可以看到，辅助索引首先指向了一个bucket，bucket中存在二级索引\n\n散列索引选择索引，利用哈希函数计算K到B的映射，哈希值相同的索引项放在了一个bucket中\n\noverflow chaining：如果某个bucket内部的项太多了，系统将分配一个～，用于存储额外的索引项（bucket本身也是一个链表）\n\n为了减少上述桶溢出发生的概率，我们可以如此设置桶的数量：\n\n\n其中，分子和分母分别表示记录总数和每个桶的记录数量；d称为fudge factor，通常设置为0.2\n\n\n\nQuery Processing\n整体思想: 先选择、再投影、最后连接和输出\n\n成本估计：\n\n\nJoin-cost嵌套循环\n\n\njoin方式\n块传输次数\n寻道次数\n备注\n\n\n\nNested-Loop\n\n\n\n\n\nBlock Nested-Loop\n\n\ns的block顺序存储，对于每个寻道s的block起点，然后顺序读取\n\n\nIndex Nested-Loop\nTODO\n\n条件：inner在连接属性上具有index\n\n\n\n在最好的情况下，嵌套和块嵌套的循环，内存可以装下两个关系，因此块传输次数为block的个数，寻道次数均为2\n\n由于上述的计算是基于每次都读取外层关系1个block，我们可以继续改进上述的方法，让其每次读取M-2个block，留下2个block分别用于读取s的block和输出所用的空间\n\n其中  为内存大小的block块数；每次读取r中一连串的block之后，读取s的block，并将s的record逐个与前者的记录比较\n\n此时，块嵌套的块传输次数和寻道次数分别为：\n与\nmerge join\n要求关系按照连接属性有序排列，否则优先sort\n\n\nHash join\n利用哈希函数，将连接属性具有相同哈希值的元组放在一个集合/划分\n对两个关系分别计算哈希值并划分后，我们只需要考虑对应划分对,\n之后，我们在上述的每个划分对，使用索引嵌套循环连接：\n为inner关系build一个哈希索引，从outer关系中probe查找对应的元组\n分别称r，s为探测输入和构建输入\n构建哈希索引的哈希函数必须和第一步的哈希函数不同\n\n\n如果构建关系包含个块，每个划分的大小不超过，则划分的数量至少为\n\n实际进行划分之后，我们需要将较小的关系作为 build 所用的关系;\n哈希函数的值域决定了分区n的大小, 为了使得si均能存放在mem中,要求 :\n\n\n其中的  被称为修正系数, 一般设置为 1. 2\n\n递归划分\nRecursive partitioning  required if number of partitions n is greater than number of pages M of memory.\n\n不需要递归划分的条件:\n近似于\n成本分析\n\n\n为输入和输出分配缓冲块个数的提示：\ntwo buffer pages are available for each partition during the hash partitioning phase.\n此时的 = 2\n\n外排序cost分析:\n\n块传输\n\n\n\n\nseek\n\n\n\n物化与流水线\n物化：按照顺序对表达式求值，将中间的计算结果物化为临时关系，并且需要将临时关系表写入disk\n\n\n\n\n流水线：同时对多个表达时求值，将表达式的运算结果立即传入需要的表达式，无需将中间结果写入disk\n生产驱动型流水线.\n从下往上主动生成元组.\n\n\n需求驱动型流水线.\n从最上层的输出, 递归调用下层的函数 next(), 直到最底层为 close()\n向流水线顶端的操作请求元组\n\n\n\n\n\nQuery Optimization主要参考ppt的习题\n并发控制\n可串行化调度\n前驱图（优先图）\n注意绘制需要根据给出的schedule，从上往下看是否存在冲突\n将事务作为节点, 存在冲突的事务之间建立边,  表示冲突之中，前者的操作先发生，后者的操作后发生；\n\n\nrecoverable schedule 可恢复调度\n依赖于T1写入的数据的T2，需要在前者commit之后，后者才能commit\n\n\nCascadeless Schedules 无级联调度\n每一对存在冲突的事务, 前者事务的提交先于后者数据对的读取\n无级联调度都是可恢复的.\n\n\n等待图\n边  表示事务i正在等待后者释放有关数据的锁； 当后者释放这个锁时，将这条边删除\n当且仅当等待图中存在环时，系统中就出现了死锁\n\n\n\n两阶段锁协议\n无法保证解决死锁的问题\n但是按照排序关系来获得锁可以避免产生死锁\nTwo phase locking can not avoid deadlock.To acquire locks in partial order of the data can avoid deadlock.\n\n\nstrict two-phase locking\n每个事务保持exclusive锁直到结束；\n可以解决级联回滚和不可恢复的问题\n\n\n根据～得到的调度一定是冲突可序列化的，这意味着如果前驱图存在环，一定不是由～得到的调度\n按照所有事务的lock point （当前事务得到最后一个lock的时间点）排序，即可得到串行化顺序\n\n\n\n避免死锁发生冲突的锁请求之间：\n\nwait-die： 如果后者的时间戳更小，i.e. 更早开始 begin, 那么后者可以等待，否则回滚后者的操作；\nwound-wait:反之，后者 begin开始得较晚时，可以等待，否则回滚 &lt;u&gt;前者 &lt;/u&gt;（前者被后者击伤）\n\n\n\n错误恢复普通恢复简单流程\nredo：\n正向遍历，重做；\n如果碰到了新的事务就将其加入undo-list\n如果碰到了事务的commit/abort，就将其从undo-list中移除\n\n\nundo：\n从末尾开始逆向遍历\nundo的时候产生undo日志（注意区分逻辑操作）\n碰到了undo-list中的事务才undo，并且碰到了对应的start写入对应的abort日志\n所有的undo事务都写入了abort后结束\n\n\n\ncheckpoint\n普通的checkpoint：在写入checkpoint的log之前，此前的活跃事务停止更新，直到将buffer里的修改全部flush到disk，才写入checkpoint的log表示更新完毕，然后继续执行\n这样可以确保，在checkpoint之前commit的事务，其更新一定反应到了disk当中；\n\n\nfuzzy-checkpoint：\n为了避免上述的阻塞而设计，允许写入checkpoint的log之后，可以继续执行日志，同时将先前的修改写到disk\n但是这样伴随了一个问题，可能有的修改正在写入就发生了crash，我们需要一个机制确保处理这种情况；\n\n\nlast-checkpoint：将最后一个完成的检查点记录在日志中的位置存储在硬盘上的一个固定位置，即最后检查点。系统在写入检查点记录时不会更新此信息。相反，在写入检查点记录之前，它创建一个包含所有已修改缓存块的列表。只有当列表中的所有缓冲区块都已输出到磁盘后，才会更新最后检查点信息。\n\nundo产生的日志在逻辑操作中，如果逻辑操作已经完成和逻辑操作未完成，面临回滚时的日志类型不同：\n\n\n\n为什么需要operation-abort的信号？\n让operation-abort的信号在undo阶段被发现时，直接跳到对应的begin，避免已经在redo期间执行的操作被再次执行\n\nAries恢复\n使用LSN标注日志\n使用dirty page table避免不必要的redo\nRecLSN：第一次变成脏页对应的LSN\n\n流程\n相比之前的恢复算法，多了第一步的分析阶段：\n分析dirty table，取RecLSN的最小值作为Redo的起点（如果不存在就取checkpoint的LSN）\n分析阶段本身是从检查点开始正向遍历的\n分析阶段同样需要更新dirty table和活跃事务表\n分析的时候，只会分析log，但是不会读取数据文件page，也就是不会读取page\n\n\nredo的阶段与普通恢复整体相同：\n发现更新记录的时候，如果不在脏页表中的page之列，or  更新记录的LSN小于页面的RecLSN，就忽略；\n否则，我们需要读取page，然后再比较pageLSN与log LSN；\n如果log LSN 大于 页面的pageLSN就redo\n\n\n\n\nundo阶段\n为了撤销undo-list中的事务，利用分析阶段得到的lastLSN(选择最大值作为起点)，开始反向遍历重做\n重做的时候也会生成仅重做日志的CLR，但是不同之处在于：\nARIES算法的CLR还会在字段UndoNextLSN中记录该事务当前LSN的prevLSN\n这是为了应对undo过程中crash情景：可以利用CLR知道下一条undo的LSN后，继续undo\n\n\n实际上做题的时候，往往不会呈现上述的 xxLSN,而是类似于普通恢复的仅重做日志，类似于：&lt;T4, 102.1, 62&gt;&lt;T4, abort&gt;\n符合下列条件的记录可以跳过：\nTODO\n\n\n\n\n\n简单的例子演示了xxLSN的作用：\n\n\n\nTODO：教材中声明了脏页表储存了pageLSN，如果DirtyPageTable已经包含了pageLSN，为什么还要从disk中读取page再比较pageLSN和当前log LSN？\n因此在redo阶段，需要首先比较当前LSN与RecLSN，如果可能需要修改，就读取对应page，然后比较其pageLSN与当前LSN的大小\n\n课本的例子演示了算法的具体流程：\n\n\nCLR不需要写abort\n在事务commit的时候，不一定需要将数据都flush到内存中\n\n事务总是可以写log\nflush的时候，先将日志flush到内存中，然后将数据flush到内存中\n\nundo产生日志的时候，也是一条一条产生仅重做日志的，不会从末端沿着prevLSN直接回溯到最开始）比如：\n&lt;T3, 8002.1, 66&gt;&lt;T3, 8002.1, 55&gt;&lt;T3, abort&gt;\n\n习题SQL练习\n使用聚合函数时不一定需要 group by；\n注意符号：不等于 &lt;&gt;\n\n练习1\n\n主要关注第四题：\nselect title from movieexceptselect title from moviewhere exists(select *\tfrom comment A, comment B\twhere A.title = movie.title and A.user_name = B.user_name\tand B.titel = 'the avenger'\tand A.grade &lt;= B.grade)\n\n\n\n题目的意思是：找出给xx打分的都比给 the avenger打分高的xx（电影title）\n考虑使用 except，涉及到单表之间的比较，因此将2个comment作笛卡尔积\n利用title确保与外表相连接；利用user_name确保2个内表讨论的是同一个用户的打分\n\n\n练习2题目：\n\n\n第一问：将给出的SQL查询转换为不包含嵌套子查询的版本\nSELECT DISTINCT C.cno, C.name -- 使用 DISTINCT 是为了避免同一张 CS 卡因有多笔交易符合条件而被多次列出FROM card AS CJOIN detail AS D1 ON C.cno = D1.cno -- 将 card 与其消费记录 D1 连接JOIN detail AS D2 ON D1.cdate = D2.cdate AND D1.pno = D2.pno -- 将 D1 的消费记录与 D2 的消费记录连接，条件是时间和地点相同WHERE C.depart = 'CS' -- 过滤 CS 部门的卡  AND D2.cno = 'c0002'; -- 过滤 D2，使其只包含卡 'c0002' 的消费记录\n\n第二问：转换为代数表达式：\n\n\n第三问：编写SQL语句，找出2018年仅在一个校园中使用的卡片\nselect cnofrom detail natural join poswhere year(detail.cdate) = 2018group by cnohaving count(distinct campus) = 1;\n\n\n注意 detail中就有cno的信息，因此不需要和card表join\n\n第四问：写一个SQL语句，找出2018年“紫金港”校园中具有最大卡消费总量的pos。\n\n使用 having子句的版本\nselect pnofrom detail natural join poswhere pos.campus=’紫金港’ and year（detail.cdate）=2018group by pnohaving sum(amount) &gt;= all ( -- 注意这里的比较    select sum(amount)    from detail natural join pos    where pos.campus='紫金港' and year(detail.cdate) = 2018    group by pno)\n也可以搭配 order和 limit 1直接筛选：\nselect pnofrom detail natural join poswhere pos.campus=’紫金港’ and year（detail.cdate）=2018group by pnoorder by sum(amount) desc -- 注意这里是 sum(amount)limit 1\n\n\n这种操作带来的差异是，如果存在多个相同的最大值，还是只会选择一个，所以比起使用嵌套子查询还是有劣势\n\n\n\n第五问：编写一系列SQL语句来完成以下事务：卡片“c0002”在pos“p001”处消费20，时间为2018-07-02 08:08:08\nupdate card set balance = balance - 20where cno = 'c0002';insert into detail(cno,pno,cdate,ctime,amount)\tvalues('c0002','p001','2018-07-02','08:08:08',20);commit;\n\n\n注意需要同步更新card；\n需要commit\n\n范式相关无损分解\n课本的定义：\n\n\n\n\n具体的验证，可以采取计算属性闭包的方式来推导\n\n\n一个简单的例子：\n\n\n\n\n如果分解的结果不是两个，而是多个关系，并且给出了分解的过程（可能是自己推的），那么可以每次对中间结果判断一下是否满足无损分解，如果都满足就认为整体是无损分解的；\n\ndependency-preserving回顾课本的定义：\n\nthe set  of all functional dependencies in  that include only attributes of Ri\n也即是将R进行分解为Ri之后, Fi是F的闭包中存在于Ri相关属性的部分.\n因此, Fi不一定是F的部分.\n\n我们定义 上述的  的并集为 F’, 如果满足:\n\n也就是, 如果F’的闭包等于F的闭包, 则称上述的R的分解为 dependency-preserving decomposition\n\n由此可见，我们判断一个分解是否为依赖保留的分解时，只需要计算对应的并集的闭包，然后判断是否与原本的F的闭包相等即可。\n\n一个简单的例子：判断上述的分解是否为～\n\n\n\n\n上述的F1还包含了 BC -&gt; A （根据F条件下的属性闭包计算得到）\n\nBCNF分解根据无损分解的定义，满足BCNF范式的分解就满足了无损分解的要求。（但是不一定满足依赖保留）\n\n一个简单的例子：将上述的例子转换为无损分解的BCNF分解\n\n\n\n注意，判断是否满足BCNF的时候 ,   也来自于 中，参考下面的具体说明：\n\n\n满足3NF的分解3NF在BCNF的基础上多了一条，也就是右侧的属性是候选键的部分。因此，我们需要先借助FD来推导候选键有哪些。\n标准的分析流程：\n\n计算F的一个最小覆盖 F_min。满足三个条件：\n\nF_min 与 F 是等价的（即它们逻辑蕴含相同的 FD 集合）。\nF_min 中没有任何冗余的 FD（移除任何一条 FD 都会改变 F_min 的闭包）。\nF_min 中每个 FD X -&gt; Y 的右边 Y 是单属性的，且没有任何冗余的属性\n\n\n根据 F_min 构建关系模式：\n\n对于 F_min 中的每一个 FD X -&gt; Y，创建一个关系模式 Ri，其属性集为 X ∪ {Y}。\n\n\n检查是否包含原始关系模式的候选码。检查是否存在某个 Ri 的属性包含了候选键\n\n如果存在这样的 Ri，则步骤 2 生成的关系模式集合 {R1, R2, …, Rm} 就是最终的分解结果。\n如果不存在这样的 Ri，则需要额外创建一个关系模式 R_{m+1}，其属性集就是 K。将这个 R_{m+1} 加入到分解结果中。\n\n\n\n一个简单的例子：将上述的分解转换为满足3NF、无损和依赖保留的分解\n\n\n\n此处的题目给出的F已经是最小覆盖的Fc，因此可以直接用于分解\n\nER模型练习根据描述绘制ER图\n题干将会给出主要的实体集，我们需要根据描述推导蕴含的关系\n同时需要注意其中的数据类型，比如多值和复合等的格式\n\n一个简单的例子：\n\n\n第一问：绘制对应的ER图\n\n\n\n此处的多值属性（电话）由 {}包裹。\n\n由ER图得到schema\n\n对应的schema：\n\n\n\n注意：此处的关系中，1对N的belong没有新建schema\n修正： player中的属性应该增加 team_name作为team的外键\n\nB+树练习计算B+树的高度\n通过计算不同高度的最值，来得出最终的高度：\n\n\n\n此处计算block并没有作用，实际上是比较索引项 \n\n关键是记住：\n\n叶子节点的key范围是  ~ \n内部节点的～是  ~  ， 并且根节点的最小值是2\n\n\n\n我们也可以通过扇出n以及索引项来直接利用对数计算进行估计\n\n\n关键是理解左右两侧的含义：\n\n计算最小高度时，我们自底向上地构建全满的B+树，先将k个value按照n-1的规模打包，然后每层n个，因此是\n\n\n\n其中左侧是迭代的次数，因此需要+1补充底层的层数；\n\n\n计算最大高度时，我们自顶向下地构建半满的B+树，并且在一开始将根节点特殊处理——只分配两个child，所以我们从第二层开始计算，需要迭代的次数为 （）, 同理需要+1得到从第二层到叶子层的高度数，最后+1加入根节点的高度：\n\n\n\n\n对于上述的推导，我们可以结合第一种方法来给出第二个证明：\n\n取左侧计算得到：\n\n\n为了满足不等式的条件，应当向下取整\n\n取右侧计算得到：\n\n\n直接利用给定的高度h计算size：\nmax:\n\nmin:\n\n然后利用题目给出的索引项个数建立不等式\n\n实际上，我们在估算的时候可以忽略常数的影响，比如：\n\n根据索引项估计节点数量关键：利用扇出n估计最后一层的节点数量，然后倒推\n\n估计最少值时，由计算得到叶子节点的数量N，然后逐步倒推 ,直到加数为1到达根节点（过程中的计算结果向上取整，因为小数部分的节点数无法再纳入其他节点）\n估计最大值时，将上述的除数都换成对应的最小值  与 ，但是注意将每次的计算结果向下取整！因为小数部分的节点数表示无法满足最少个数的要求，无法独立构成节点\n\n\n\n\n注意取整方向的差异：估计最少向上取整；估计最大向下取整\n上面的例题中，max估计的63应为62\n\n计算块传输的次数题目可能给出一个现有的B+树结构以及一系列的访问操作，结合一定的replacer策略，让我们计算块传输的次数，需要注意的是：\n\n如果题目明确说了是 blocks transferred to buffer  那么我们就不需要考虑将block写回到disk的次数\n\n一个简单的例子：\n\n\n\n注意此处内部节点的指针数和key数量\n\n删除操作一般来说，分裂时默认左侧的节点元素不少于右侧节点包含的元素个数，可能题目会具体说明右侧不少于左侧。\n\n\n\n重组 合并 发现需要分裂\n\nLSM的成本估计问题：\n\n\n（3）对应的B+树：\n\n\nans：\n\n\n\nTODO：（2）是什么意思？\n\n\n题目说maximize size  = 13， 根据 1 + 3 + 9 = 13， 推知最多有3层高\n\n查找某个index，可能的范围分别是主存以及disk中的两棵树，分别计算对应的成本，然后加权求和：\n\n根据上一步计算得到的B+树的高度，如果在主存中，块传输和寻道的成本都是0；如果在第一棵树就是3+3， 在第二棵树就是前面成本的两倍\n因此整体是 (0 + 3 + 6) / 3 = 3（块传输和seek）\n\n\n为什么不需要计算从叶子节点到disk的额外寻道和块传输？\n\n因为题目声明了：look up an index entry ….\n这意味着，我们只需要检查某个index是否在叶子节点中包含，所以只需要查找到叶子节点层，不需要根据叶子节点中的指针访问disk中的数据页\n\n\n\n查询处理练习join的成本估计\n这里什么都没有哦～\n\n查询优化练习如果题目只是给出了两个关系，让我们计算对应的join成本，我们应该先计算关系各自的block数量，然后选择块较少的作为外层关系\n\n这是因为此时对应的块传输次数和寻道次数分别为：与\n\n如果给出了缓存区的buffer大小，应该考虑使用上述的计算方法，否则认为M = 3带入公式\n习题1\n\n\n具体解答参考：\n\n\n\nwhere中包含了join的条件, 因此此处的join属性实际上是 pno 和 cdate, 计算对应的V.\n\n实际上是一组复合的属性, post有100个, cdate有365个可能的取值. 因此估计对应的值域空间是100*365.\n/4对应了where中最后一个时间的约束, 是整体的1/4.\n\n\n1个block的尺寸是4096bytes, 除以每条记录的尺寸, 得到每个block对应的记录数量. 然后据此计算table对应的block数量.\n\ncno的bytes是5, 根据题意==&gt; pointer的大小是4bytes, 那么每一对键值对是5+4=9bytes.\n\n计算 fan-out-rate n = 455，然后根据公式算出高度为2（注意是建立在cno的索引，不同的cno有10000 = K个，据此计算！）\n\n根据detail的记录数量, 估算每个card对应的记录数量. 然后根据detail的block的容量, 计算每个card对应的记录的block数量.\n\n根据 V(name,card) = 5000 我们可以知道, 因为card中一共有10k条记录, 所以每个名字平均对应2个card.\n参考\n\n\n\n\n习题2\n\n（2）：\n\n\n\n优化的分配是：1块给输出，1块给内关系，剩下都分配给外关系\n\n（3）：TODO\n\n\n\nSOLUTION：\nK = 5000， n = 60，计算得到高度为 3（答案中max的估计公式有问题，并且应该是向下取整）\n注意此处题目说了为root准备了一个buffer，在每次的遍历中原本的h+1 = 4的成本 减去1次，只需要在一开始存入（最后+1）\n公式  中的需要除以500，因为确定了director（一共有500位不同的～），或者我们可以从成本估计的角度解释：\n\n\n归并排序练习\n\n\n此处的buffer容量是针对于run的, 也就是output存在2个block; 可以计算得到 (10-2) /2  = 4 ,每次将4个run归并\n\nSOLUTION: 如何计算seek?\n分析:\n\n此处为每个input row 提供了  2 buffer block意味着我们每次seek之后可以直接读取2个blcok而非1个(优化), 从而减少了seek的次数;\n利用每次归并4个runs, 得到总共的pass数量\n注意题目说最终需要写回到disk\n\n解答: (ljm同学的珍贵手稿)\n\n\n\n可以直接运用公式， 此处的 = 2,  = 10,   = 160:\n\n其中加红的，表示需要写回disk的额外成本，如果题目没有明确声明，就不需要加入计算\n\n并发控制练习绘制前驱图可以根据数据项分组，从当前向下查看：\n习题和解答：\n\n\n\n判断是否为无级联回滚的调度也很简单，只需要保证读取在提交之后即可，比如：\nT1           | T2           | T3-------------|--------------|-------------Read(A)      |              |Read(B)      |              |Write(B)     |              |Commit       |              |             | Read(B)      |             | Read(A)      |             | Write(A)     |             | Commit       |                          | Read(A)\n\n两阶段锁协议无法解决死锁的问题\n\n等待图与死锁\n\n\n注意题目说了，此时还没有事务释放锁；T3没有指向T1的边，因为此时T1没有对B成功加锁\n\n错误恢复练习脏页表的更新\n\n\nPageID\nPageLSN\nRecLSN\n\n\n\n\n如果有新的页面被更新了，加入脏页表，同时设置对应的PageLSN, RecLSN等于当前的log LSN\n只有flush的时候才会清除脏页表中的page entry（我们无法知道什么时候flush到disk，因此一般只增不减）\n\n\n\n补充不同的范式第一范式  表中的每个字段都是不可再分的最小数据单位，即字段具有原子性；\n\n如果存在多值属性，需要将其分割位多个单独的\n\n第二范式 消除非PK属性对于key的部分函数依赖\n\nA-&gt;B : B 依赖于A\n如果主键是复合的，确保所有非PK属性完全依赖于整个主键，而不是主键的一部分\n\n第三范式 消除非PK对于key的传递函数依赖\n\n确保所有非PK属性都直接依赖于PK\n\nBCNF范式 消除PK对于key的部分与传递函数依赖\n\nTODO：补充与理解\nSOLUTION：书上没有啊？\n\nColumnar Representation列式存储在数据查询方面表现更好，但是在事务处理方面表现较差\n\n\n\nhybrid row/column store： 支持行列两种存储方式的数据库\n根据drawback, Reduced cost of tuple deletion and update的说法是错误的\n\n线性搜索与index我们根据比较运算符来判断是否需要使用index：\n\n\n冲突可序列化与2PL\n遵循2PL的事务调度一定是冲突可序列化的；\n所有在树协议下合法的调度也是冲突可序列化的\n\n\n但是满足冲突可序列化的事务调度不一定遵循两阶段锁协议\n\n\n\n范围查找\n\nredo-list\n\n\nabort的事务也应该被排除在redo-list之外\n\n小贴士\n计算B+树的扇出时，键的大小是按照search-key，也就是PK的大小来计算的，不要将关系中的所有属性相加😇\n绘制B+树的示意图时，记得在叶子层补充链表结构\n进行结果集大小估计时，发生在候选键上的等值查找，结果集大小应当为0或1\n给出记录数量、每条记录的size以及block的大小时，应该先计算每个block所包含的记录数量（向下取整），然后计算所需的block数量（向上取整）\n直接利用总数量计算总容量然后计算block数量有误，因为这样导致了不同block之间可能存储了同一条记录（的部分）\n\n\nACID：\n原子性 (atomicity)\n恢复系统\n\n\n一致性 (consistency）\n由ADI和合适的约束条件（触发器等）实现\n\n\n隔离性 (isolation)\n并发控制\n\n\n持久性 (durability)\n恢复系统\n\n\n\n\nrelation：行， relationship：表\nAccess time： The time it takes from when a read or write request is issued to when data transfer begins\n= seek + rotation time\n\n\nsteal策略：checkpoint之前的修改都已经反应到了disk（无论对应的事务是否commit）\n无法确定checkpoint之后发生的修改是否flush到了disk\n\n\n不能对辅助索引使用稀疏的策略！\n辅助索引对应的search-key一般不是文件排列的顺序；\n如果只是对部分的记录建立辅助索引，那么无法通过相邻的辅助索引来index得到没有建立索引的记录\n只能对primary/clustering key使用稀疏索引\n\n\n因此我们有两个结论：\n稀疏索引只能用于顺序文件\n辅助索引只能用于密集索引\n\n\n\nPPT回顾\nSimple checkpoint stops all active transactions, write out all the updated pages, and restart transactions after completing\n\n导论与基础数据库系统的目的直接建立在文件系统上的数据库应用导致：\n\nData redundancy（数据冗余）and inconsistency（不一致）\nData isolation（数据孤立，数据孤岛）— multiple files and formats\nDifficulty in accessing data（存取数据困难）\nIntegrity problems（完整性问题）\nAtomicity problems（原子性问题）\nConcurrent access anomalies（并发访问异常）\nSecurity problems（安全性问题）\n\n数据库的特征data persistence（数据持久性）convenience in accessing data（数据访问便利性）data integrity（数据完整性）concurrency control for multiple users（多用户并发控制）failure recovery（故障恢复）security control（安全控制）\nview of data分为了视图、逻辑和物理模式：\n\n视图模式：隐藏了数据类型的细节，也可能出于安全性的考虑而隐藏数据的信息等\n逻辑模式：描述数据和关系\n物理模式：描述记录如何被存储\n\n\n不同模式之间存在对应的映射 mapping\n\nDDL数据字典：DDL compiler generates a set of table templates stored in a data dictionary\n数据字典包含了元数据：\n\nschema\n完整性约束\n主键\n参照完整性\n权限\n\nDML两种数据操作语言：\n\n过程式 procedural：描述如何获得信息\n陈述式 declaretive：只声明需要的数据，但是不说明如何获取\n\n\nSQL是流行的、陈述式的语言\n\n正因如此，SQL不支持直接通过network来交互，相关的计算和交互需要写在宿主语言 host language 中实现\n应用可以通过API或者嵌套的SQL语句来访问数据库（需要宿主语言的支持）\n\n\nDBA\n数据库管理员\n\nDBA的指责：范式的定义、权限的管理、日常的维护（根据表现进行微调、定期将数据备份、确保充分的disk空间）\n数据库系统的历史NoSQL\nnot only SQL\n\n提供了一种存储和检索数据的机制，这些数据使用比传统关系数据库更松散的一致性模型，以实现横向扩展和更高的可用性。\n当数据的性质不需要关系模型时，NoSQL数据库系统在处理大量数据（尤其是大数据）时很有用。\n常用的NoSQL DBMs：MongoDB，Cassandra, HBase\nNewSQL寻求为OLTP工作负载提供与NoSQL系统相同的可扩展性能，同时仍然保持传统数据库系统NewSQL的ACID保证：\n关系模型参照完整性：要求参照表中的外键属性一定在被参照表中的至少一个元组中存在\nUnion要求：\n\n两个关系的属性个数 arity相同；\n对应列的属性的domain / type 一致\n\n\nTODO：属性个数一致？\n\n连接\n\nSemijoin半连接：只会将满足连接条件的元组，保留来自指定关系的属性，也就是在theta join的结果取projection\n\n比如左半连接，将会得到左侧关系的匹配元组\n\nnull 表示值处于unknown状态 或者 不存在\nOuter join外连接：在自然连接的基础上，保留特定关系不匹配的元组\n\n\n使用joins组合外连接\n\nnumeric（3,1）  总共3位，且小数点后1位\n\nnumeric 是 fixed point number， 与浮点数相区分\n\nfloat（n） 表示至少有n位\nprimary key declaration on an attribute automatically ensures not null\n\n主键自动具有非空的约束条件\n\nunique使用 unique来测试子查询是否含有多个元组\n\n当子查询返回的元组个数是0或者1时，\n\n简单的例子：\n\n\nwith简单的例子：\n\n\n\n关键词：with 和  as\n\nuser-defined typestype和 domain都是用于自定义的数据类型, 二者十分相似. 区别在于: 后者可以声明约束 constraints.\nType\n语法\ncreate type type_nameas data_type[ (precision, scale) ][ not null ][ final | instantiable | abstract ];\n\n\nfinal | instantiable | abstract:\n用于指定类型的继承属性。\n\nfinal：表示该类型不能被继承。\ninstantiable：表示可以创建该类型的实例。\nabstract：表示该类型是抽象的，不能创建实例。\n\n\n\ne.g.\ncreate type dollarsas numeric(12, 2)final;create table department (    dept_name varchar(20),    building varchar(15),    budget dollars);\n\nDomain当某些列需要限制其取值范围, 也就是具有一定的约束条件时, 如果每次创建类似的列都重复书写, 工作量较大.\ndomain可以理解为对数据类型的扩展定义，它允许我们创建自定义的数据类型，并且可以为其指定约束条件。使用 domain 可以确保数据的一致性，\n\n基本语法\n\nCREATE DOMAIN 域名 数据类型[DEFAULT 默认值][CONSTRAINT 约束名称][CHECK (约束条件)];\n\n\ne.g.\n\n-- 创建一个表示年龄的域CREATE DOMAIN age_type INTEGERCONSTRAINT valid_ageCHECK (VALUE &gt;= 0 AND VALUE &lt;= 150);\n\nLarge-Object TypesMySQL BLOB datatypes:\n\nTinyBlob : 0 ~ 255 bytes.\nBlob: 0 ~ 64K bytes.\nMediumBlob : 0 ~ 16M bytes.\nLargeBlob : 0 ~ 4G bytes.\n\n\n上限以的规模递增\n\n候选键CK可以为null，但是主键PK不能为空\n\n因此，unique构成组成的属性集合可以称为构成了一组超键，但是不能称为CK，因为CK可以为空\n\nassertione.g.\ncreate assertion credits_constaint check (    not exists(        select *        from student S        where total_cred &lt;&gt; (            select sum(credits)            from takes natural join course            where takes.ID = S.ID                 and grade is not null                 and grade &lt;&gt; 'F'        )    ))\n\n使用下面的命令来阻止数据库对SQL的隐式commit：\nset autocommit = 0...commit;\n\n授权四种权限：增删改查\n\ninsert不允许修改现有的数据；\nupdate不允许删除现有的数据\n\n五种修改数据库范式的权限：\n\n\n\n范式的创建、修改、删除，以及index和view相关的操作\n\nAuthorization\n授予权限：\n\ngrant &lt;privilege_list&gt; on &lt;relation_name or view_name&gt; to &lt;user_list&gt;\n\n这里的 &lt;user_list&gt;既可以是具体的用户名，也可以是关键字 PUBLIC（表示授权给所有用户）。\n特别地，当我们需要允许用户具有转授权的能力时，可以在授权语句末尾添加 WITH GRANT OPTION子句。\n\n\n\n权限回收：\n\nrevoke &lt;privilege_list&gt; on &lt;relation_name&gt; from &lt;user_list&gt; [restrict|cascade]\n\n\n\n其中 RESTRICT表示仅回收直接授予的权限，而 CASCADE则会同时回收该用户转授给其他用户的权限(级\n\n\n可以在权限列表中声明 all 表示回收所有的特权;\n可以在用户列表声明 public表示回收的范围是正常访问的普通成员, 但是不会回收指定的成员的特权\n\n\n\n如果同一个用户被不同的授权者先后授予了2次相同的权限, 那么一次的回收权限之后, ta的权限可能依旧存在.\n权限的依赖性: 如果回收的权限会导致具有依赖关系的权限的失效, 那么涉及的权限也会被回收:\n\n创建外键约束的权限\ngrant reference (dept_name) on department to Mariano;\n\n数据库设计的流程\nrequirement specification\nconceptual-design： E-R diagram\nlogical-design：logical schema\nphysical-design： physical schema\n\n设计范式的时候，主要避免两个问题：\n\nredundancy\nincompleteness\n\nentity： an object that exists and is distinguishable from other objects\n三元关系与箭头\n\nArmstrong’s\n\n以及对应的推论：\n\n\n按照BCNF分解：\n\n一定是无损分解\n但不一定是满足依赖保留的\n\n\n按照3NF分解，可以同时满足上面两条\n\nMVD定义\n\n相关定理与4NF\n任何函数依赖一定也是多值依赖\nD的闭包D+是逻辑上由D隐含的所有功能和多值依赖项的集合；\n如果一个关系范式满足下面的要求，就称为满足4NF，对于函数和多值依赖D，如果其D+中的所有多值依赖都只存在下面两种情况之一；\n平凡的（右侧包含在左侧属性，或者二者的并集是R）\n左侧属性是R的超键\n\n\n\n\n4NF类似于普通关系的BCNF\n\n物理存储系统存储级别\n\n访问时间 = 寻道时间 + 旋转延迟\ndisk-block访问的优化：\n\nbuffering\nprefetch\ndisk-arm-scheduling：使用算法重排block的请求\n非易失性写缓存\nnon-volatile RAM: battery backed up RAM or flash memory\n\n\nlog disk 日志磁盘\n\nFlash storageNAND flash\n\npage-at-a-time read\n在erased之前 一个page只能被write一次\n\nSSD：splid state disk\n通过flash translation table将逻辑页地址转换成物理页地址\n在分槽页中，记录指针不是直接指向记录，而是指向对应entry的header\n文件中记录的组织形式：\n\nheap：记录可以存放在文件的任意位置；\nsequential：根据search-key线性存储记录\nhashing：利用哈希函数计算search-key，然后存储到对应的block中\nmultitable clustering file organization：将不同关系的记录存放在同一个文件中\n可以为同一个关系的记录之间增加指针，形成pointer chains 指针链\n\n\ntable partitioning：将一个关系中的记录分成更小的关系，分别存储\n相当于上一种形式的对立\n\n\ndata dictionary storage\n也称为system catalog\n存储metadata\n\n\n\n\n\nBuffer-Replacement Policies\nLRU\nToss-immediate strategy：只要一个block的最后一个元组的数据被处理结束，就释放这个block\nMRU：刚处理结束的block是最可能被替换的对象\nclock：\n\n\n\nColumn-Oriented Storage\n也被称为 columnar representation\n\n\n\n\n列：决策支持；\n行：事务处理\n\nORC 优化行列存储\n\nApache ORC 和 Apache Parquet\n流行处理big-data的应用\n\n索引顺序文件：根据主索引排序的有序文件\n稠密索引——对建立索引的属性，每一个值都有自己的指针；\n\n稀疏索引：只有部分search-key的索引，因此要求记录必须按照搜索键来排序\n\n如果主索引无法存储在memory中，需要将disk上的主索引看成线性文件，建立外层的稀疏索引\nB+复杂度与占用率\n\n针对写密集型的B+树的策略：\n\nLSM tree\nbuffer tree\n更少的查询开销\n\n\n\n\n\nbitmap indices：\n\n取属性的值域的大小作为行数\n有记录的个数那么多列，如果对应位置的属性匹配，bit就是1\n\nindex on flash\ntodo：ch14-51\n\n\nppt的A4‘有问题，参考书本的定义\n\n如果查询的比较条件是 &lt;= ，就不要使用index，直接使用线性查找\n\n\nmerge成本最小化\n\n混合的归并合并\n使用前提：\n第一个关系是有序的；\n第二个关系在连接属性上具有B+树的index，方便根据属性查找\n\n\n流程概述：\n顺序扫描第一个关系；\n对于第一个关系中的每一个元组，利用连接属性在第二个属性中使用索引查找得到对应的叶子节点，然后将第一个关系的元组合并到叶子节点中\n此时第二个关系的B+树叶子节点具有实际物理地址和第一个关系的元组，将其按照自身的物理地址排序\n然后，我们得到按照地址排序的叶子节点，可以顺序扫描，然后构造合并结果（用第二个关系的元组来替代物理地址）\n\n\n上述流程的关键就在于，通过先根据物理地址排序，然后顺序扫描，降低了随机访问导致的大量的寻道时间\n\n\n\n估计交集的成本时：\n\n如果连接属性是其中的外键-主键关系，成本是确定的——引用关系的元组数；\n如果是平凡的关系，那么就利用V计算，取最后估计结果较小（V较大的）\n\n\n\n外连接的成本估计 = 自然连接的结果+对应属性的元组个数\ncost-based optimizer为每个操作选择cheapest的算法（贪心）可能不会产生最优的整体效果，比如：\n\n合并连接可能比哈希连接成本更高，但是有序的输出可能为外层的算法提供便利；\n嵌套循环可以为流水线提供机会\n\nn个关系连接时，具有 种不同的连接顺序\n\n我们不需要一次性对所有的关系采取套用上述的公式，可以采取动态规划的思想：\n从较小的子集开始取用，计算小规模的不同关系的所有连接成本，存储在数组中，在较大规模的计算中直接取用即可\n\nbest join tree\n\n\n复杂度：\n\n\n\n方法\n时间复杂度\n空间复杂度\n\n\n\n动态规划\n\n\n\n\nonly left-deep trees\n\n\n\n\n启发式优化策略\n\nPerform selection early(reduces the number of tuples)\nPerform projection early(reduces the number of attributes)\nPerform most restrictive selection and join operations (i.e. with smallest result size) before other similar operations.\nPerform left-deep join order\n\n物化视图的增量更新对于选择, join可以直接在原来的结果上:\n\ninsert ==&gt; 并集;\ndelete ==&gt; 差\n对于avg, max, min等统计属性, 采取之前的中间结果来辅助实现增量更新.\n方差也可以用增量更新来维护.\n\n\n因此, 只需要维护各个元素的和, 平方和 以及计数 n, 就可以实现快速的增量更新.\n并发控制2PL\n两阶段锁协议 2PL 可以保证冲突可序列化\n\n将事务的执行顺序按照lock points排序\n但是冲突可序列化的调度不一定满足2PL协议，也就是说2PL不是冲突可序列化的必要条件\n不保证排除死锁\n\n\n严格2PL：事务必须保持自身的exclusive locks直到其commits / aborts\n\n确保可恢复性\n避免了级联回滚\n\n\n强2PL（rigorous）：事务必须保持自身的所有lock，直到其commits / aborts\n\n可以按照事务提交的顺序来构建序列\n\n\n\nLock Conversions\n\nLock table\nusually implemented as an in-memory hash table indexed on the name of the data item being locked\n\n\n新的请求添加到队列的末尾，并且检查是否与先前的lock相同，如果相同就grant\n请求删除的时候同时unlock 对应的requests，并检查pending的lock是否可以被granted\n\n\n\n\n\nTree Protocol是图协议的一种，适用于对数据访问的次序具有偏序结构理解的情况\n\n中译中：了解访问特定的数据项之前必须经过的中间节点\n\n\n\n特点：\n\n树协议可以保证冲突可序列化并排除死锁 (deadlock-free)\n避免了回滚\n\n\n缺点：\n不能保证无级联和可恢复性\n可能 lock more data items than needed， 从而降低了并行性，同时提高了额外的等待时间\n\n\n\nSchedules not possible under two-phase locking are possible under tree protocol, and vice versa.\nGranularity Hierarchy从高到低，以整个数据库系统为根节点，分别划分为不同大小的区域，直到叶子节点包含单个记录的信息\n为了在高层级快速判断底层节点是否被加了 S / X锁引入 intention locks：\n\n\n\n如果直接加X-lock，表示可以直接修改内部的节点\n\n对应的相容矩阵：\n\n\n\nX与任意锁都不相容；除了IS和X，都只跟自己相容；IS与X之外的锁相容\n\n对于插入和删除记录，如果只是在对应的记录上加锁，可能导致幽灵现象和死锁问题\n\n可以直接在表层级加锁，但是降低了并行性\n可以引入谓词锁，来准确判断影响的记录范围，但是在实现上比较困难\n另一种更好的解决方法是：Index Locking Protocol\n\nIndex Locking Protocol\n\n\n可以避免幽灵现象的发生\n\n一个例子：\n\n\n\n注意范围查询，导致10所在的叶子节点也具有了S-lock\n\n上述的策略会将entire leaf给lock，为了提高并行性，我们可以针对某个key来lock，同时为了确保可以发现潜在的幽灵现象，需要引入一定的限制条件，这就是：Next-Key Locking\nNext-Key Locking\n\nTODOB+-height\n\nSOLUTION：\n此处的height确实是从1开始的，比如计算max时前面的4个4是n, 最后一个是叶子层的叶子块内部的n-1，所以高度为h, 计算size时存在的因数个数也是h\n","categories":["课程笔记"],"tags":["CS课程","sql"]},{"title":"跨组件渲染","url":"/2025/02/16/%E5%89%8D%E5%90%8E%E7%AB%AF/%E8%B7%A8%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93/","content":"为什么需要跨组件实时渲染？在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：\n\n用户在一个组件中编辑内容，其他组件需要立即看到更新\n多个组件需要共享同一份数据\n需要避免通过层层组件传递 props（即所谓的 prop drilling）\n\n这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。\n最小实现示例以下是实现跨组件实时渲染的最简代码结构：\n// 1. 定义 Context 类型interface SharedContextType &#123;  data: any;  updateData: (newData: any) =&gt; void;&#125;// 2. 创建 Contextconst SharedContext = createContext&lt;SharedContextType | undefined&gt;(undefined);// 3. 创建 Provider 组件export function SharedProvider(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;  const [data, setData] = useState&lt;any&gt;(null);  const updateData = useCallback((newData: any) =&gt; &#123;    setData(newData);  &#125;, []);  return (    &lt;SharedContext.Provider value=&#123;&#123; data, updateData &#125;&#125;&gt;      &#123;children&#125;    &lt;/SharedContext.Provider&gt;  );&#125;// 4. 创建自定义 Hookexport function useShared() &#123;  const context = useContext(SharedContext);  if (!context) &#123;    throw new Error(&#x27;useShared must be used within SharedProvider&#x27;);  &#125;  return context;&#125;\n\n实际应用分析让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：\n// 1. 定义具体的数据结构interface HistoryItem &#123;  id: string;  content: string;  mermaidCode: string;  timestamp: number;&#125;// 2. 实现带有持久化的 Context Providerexport function HistoryProvider(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;  const [selectedHistory, setSelectedHistory] = useState&lt;HistoryItem | null&gt;(null);  const [historyList, setHistoryList] = useState&lt;HistoryItem[]&gt;([]);  // 数据持久化  useEffect(() =&gt; &#123;    if (selectedHistory) &#123;      localStorage.setItem(&#x27;selectedHistory&#x27;, JSON.stringify(selectedHistory));    &#125;  &#125;, [selectedHistory]);  // 实时更新方法  const addHistory = async (content: string, mermaidCode: string) =&gt; &#123;    const historyItem: HistoryItem = &#123;      id: Date.now().toString(),      content,      mermaidCode,      timestamp: Date.now()    &#125;;    setHistoryList(prev =&gt; [historyItem, ...prev]);  &#125;;  return (    &lt;HistoryContext.Provider      value=&#123;&#123;        selectedHistory,        setSelectedHistory,        addHistory,        historyList      &#125;&#125;    &gt;      &#123;children&#125;    &lt;/HistoryContext.Provider&gt;  );&#125;\n\n在这个实际例子中，我们可以看到几个关键点：\n\n状态定义：使用 TypeScript 接口明确定义了数据结构，确保类型安全\n状态持久化：通过 useEffect 监听状态变化并保存到 localStorage\n实时更新：通过 setHistoryList 确保状态更新后所有使用该 Context 的组件都能即时获得更新\n\n当组件需要使用这些共享状态时，只需：\nfunction HistoryViewer() &#123;  const &#123; selectedHistory &#125; = useHistory();    return (    &lt;div&gt;      &#123;selectedHistory &amp;&amp; (        &lt;div&gt;&#123;selectedHistory.content&#125;&lt;/div&gt;      )&#125;    &lt;/div&gt;  );&#125;\n\n这种模式的优势在于：\n\n避免了 props 的层层传递\n实现了组件间的解耦\n确保了状态更新的实时性\n提供了类型安全的数据访问\n\n参考资料\nReact Context Documentation\nTypeScript Handbook\nReact Hooks API Reference\n\n","tags":["前端"]},{"title":"我们能够在梦境窥探真实的本我吗","url":"/2025/06/29/%E9%9A%8F%E7%AC%94/%E6%A2%A6%E5%A2%83%E4%B8%8E%E6%BD%9C%E6%84%8F%E8%AF%86/","content":"\n\n  b8b5ab35f1ad034c1820e574536071ac19a50b5e21d0a897237fa3e1427ac2eaa294e37f5f4b1cee98ebde9c75388976796d30f42fb5b9985ed468696d50ffbf750481b709c18e901bf71f1acb93e8dafa7c49cae9aa02ab4bbe2e22782e674d608b6dbd9b40684023d6dfe0055f9822c99a9ee09e9f4647c9e261779e16e67cfc514700153da434145c77be7d3659167f675a0ee20d5da9775aeff72ebbbd3f36b5c0cd9dcd7f794a521d8536600cd996d32dd751117b962ef19c7ccc2b2e482fadac8646a59c2535e4387a189b9aabcf3b02f7cc7c39d8503c3b91510d0b12147e0336533a4ad7b5c83a48a45003c2664d0d366441aaaa76d79b6b323cf31d540c4b06a06a6d58545e33544118c146f93d3e2f601b8d4392808f032696c97d41b6dbfb637fda9b9dfaf51a97f7e1f5d0375f9edfa489b7314c485e01778c11c02c2eae9ca098206e59ddfd76b0cc9bee8ad9bd1280f4b7e663ccc39bfd1b824372e481df9685278df7f20297e5a737735d068c155c56b3f9e82bd51a96e57a1a611b1d9d50e44f693d44d30bf73c40956dd97267b0fc64890787fc91a4d22f267c062ea3b8c2410ca3edf07a4a9474de112801ccea69e03c9a407b4ef1a1e5d6fe085806cc17f605b044c31e15dd758cae85e1f90e7a73df5600c25c07d4b5b3eed34f696ac52d8fc20f3e9e921c39a0c4e1ad39d7f7e82ef3c07a650bc19880843a5af2e1ca5aee007e8bfcb13cc87482c14b75c2b59a18a1db232382f53ef15b122514059e161c30cb3af4b640795eb475c6490814d19d401a8563b870c545e2a55ddd3a809636c09abb4192e135b2ea18b66fa55ba3cfaa856c2ab4359b08463693ddcdbe743f1d7c7fd4dcbf922500070189eab508e967226d3ae39b7633a0da8cd845348ec4a78a9a00b6747e40d26409d05c570bab30875a2cf96c9a64d691ef59a78046becea821f0d4932c421362bc3c23c2b409d12abb163ce97589077aa24ce4bcaa46af78f3e36a396cf454e66490701d7891c2c1b40467f1541881c432225fd595bda4d2ed56a44ad2eb4a3236a2b31118e0b5e3ebd4551e8bb9ee3629a55c60c585a3a43f19d3aba8b6cd16cadadfd0e53874730999cf8cd555e0ac6d8a4e11d6b9398b24190f2ac311d7ce2073e0443a81f796dd5bf7fade08fb20bbacbd099e0960fe1556d1dd8e124f49470c9ca4393a35946e4b221dc0751d7a0a2f4f9515faac644d0f277bc5836bd32a3cacc4909a37755b88d49f3e6e6d5dcf8adb88d82513e25f9f815b5c218ad1a08dfd5413200064d753d0828b9a6817bbdb82f8a67116cb30d8df181f8cbd1ccf589d050d0dc8385f26e55510b0febce09d97f98e2d4bd98a766a63fafc913abb222b1593430675c1f3a5c5ccbef497c9948540c9c5de84171dacd154ac00d94245664a8c9715beeb666ff5ae0287ea522bb04472d29296e3789ccf131e212fb2c37406480f23a1180cbf50dbdba176de5d59097f935c5ac867c77f1375b9309553e07348cfded36d880cc7977f8d9e871777e621b1fc172e859aa6932801fa2298d6bddd6b61f620864ef48f602bf98781382b2d2a47c9c2eaed23b2fba74e32dca3defa5eeb164ae50a0f98c08c8bf49748682820481fbdde4c86fe267b6f9ddbc41ff8e4402f2e8e34b7712fbc68b194becd019dd764b0f6d330255e2c28aaec027cbe452e2f24b2c758e89f1a7b0d1f34758f5dfab3c6da9feeaf3e43c2725d6d04ae7831c129aabf5fad441ccae85d002dfd2a12c2f3fd417d8ae7a2028967a7c2cbb728a0d1e9e3884e913b68cc8b0005a1c5bd0dbc8e511f2cd1f32c502c20bfe11614aa0ed4d3f20a86a234c2a4f203db38ea5e7914d2a638e60ad2a30106022dfa0e085460b78b5e44ba9cfbaddba82d9a1efd8076242ce497064eb7dd7f29fc3af5520844c27a7f7b000f5b8fc8201d8aaba4106d9b06bcd1ea6f54ecf4dd347ffd4958eca5608b5914d0f7840a3b2b0d41ee1c9b43fe859858f04b7eb758763e8194f942a755aadfd9a57c27c9547ab149b312325b9c9eb5534ab6e1b8225eb60f926368628b917ee692f68594007d6dffebe5749544ceb0f3f4162a883f622b5d63e84ca40f7d9abfe9ccd929f7aa68efd773884855e6da99a58584371c5c511927696a19ade4e1f39527008514431b9f22a47ae990cf690b97ab051e516615cc21e5c39e5598428851c1f1342af3f1abea7d5bb8dcbf09ec346a35c3c5a3b46228d09076a6d0a3e95319e3d9a97c9a28e62911803e8335b93dd9ef6dbcabc8d9fcf06396349c55d53b1e21e49309129b84f0292a096cf0c0048ac34ef6cd398f8a965b8a9f0c788718e5e6dab3c63b4e793279cda44750929294f0ca14aace41b7d9f3b5fd77be8161b693bdfbbaad889b95dee9fc67b9a0249594afcadaa37b908de91a42acf13cfaa77553f024429f2c9cd78134d53c8736ccfffddf95de0ae82e901bd0cb2b25d3ad19a266bdc0b3587e26aabff9a4680b1051674447cd5c671beaf9c2496b1ca21e94848d03b18e631d56bcb5288e7077621b9f9dc3dc42b5abd5986c6cef92276108a6612f047c3a6050977692e24de7e653879830ba35c97aa500b620a176a351140c4574ca1920bc8a5cd9b06acec228a181b9775be9a3f46f8bbd7213bf2dede35f0d69e65e4e1512d0dece7d550d8ab7cd133ce08ba0aa512e1f0a5730c85d6612f623dd92b7effbea8b62f206518361d804165f5f34b9566953de4cd262823246e9d6625a1b537cf6e3038f2ee1fef0327863ef28037fd9bbc91c975075a2109fff26e2765c97e9fa18659a39328b4e49aa4cfb708bde489bb1630223cf703ca68071baf3d815fe21bd8afdb457ea99e0889ee09eaa9ed396f7c20d330b99bb0a18f19b6acad98460986eee949a9342726eed9afbdf86f98a9b2920c1ab4ed05f767d44094717ccc758746f4187fa11502ae9bbdbe2975e98bf7e6892eaf2c4677cd5a3ee63510ec6aa02e0ea573774f9ec5a84645381b45a642203ab2ff9a024b4857de1d76b693189118512bba41a1c302376fb5d292e10cd66b4aeb00df6f12dc24997b9152c53e13b32ff0c810cd92703cc47b3d9ffb78daee598fcac2d1c5c4f9e31cc1dce8258579e625efbcd09c13de14b1903d483a70567f678a4fd6acac84427410843cfbe8648ac65b77aa9543d19781e4dc774e5a9dd739c779f7088758d54f71d3903da38c0eea3130d380197e00524373ec328c2e8a0e77f75ada61c147206688cad7273eccf3df7f19e947205216260b302932bb1af6d1c12ac47d4b225287131450e780d5568555b84652624e4cddae9c578293a7463760f353e30797e18fbba80892701043d67767bdd76a29dca65cf9d8af13b24d377d243c5ea112e6d607fdd4d81f1d3287af0d0ac78aee42c87f995aff3bf357c0e026ebab29ea6892a434c2b21c6e4dc55ff1d11e6f13eb7bc04f1bd8005bd18a79ef0355e5ec9e526cbee194d42a456e501d2941575ce23892ea8ffedd12a5d7d83897710cbaadb8ec87dad76ba009e7dcd5eca6824f58c7a2eda87c4b46b89e726ea694523f387015ac0f17a83b1d2bac37e4aa8cac364de44f5e853c390d09a309461ceb959842809ef5ed5e367077b8ea4b9c9f35f6d75259b013ba578654338feb3bf3658dc6febe11e08c55d70ffa7b446e059f185071a46f54019064cd554e46f37c7c337fb795b6a554d1e731548e890dafaf6eb7a9084da200fee710b2c0b95a893263faf28aab0906bf4c536a688787e7724370ef9ca0e6092de29713b0ca53793d90b26ecf14de1d5f8e592cef5ec844540b36421ac2b6a237156cfd1c4a9692d69dafb833d1b3e2cc3edefc585f6f2e118e3241a4302760c5a00b44d87375b4ef94950b5bfac06b47f551e72057b5953dea15c5246c99699e070e423c83b86656f928a6aac0fbf6bbcd82c5e7d9b48bd94c797a8f879985ffed20ea1c60f3ce90d5f153e1128c47b5475af9b2901dbc8ce83e2ea71fc176a7637472fef46d8a4907cd886cefb0418d392f8bf06e617064af9174678bd74bc1533abe1c30b79a3d6253a7231b6a07c967adc896f1c35ef69cf9db9f3e9ef55cfc8ff0436a7c078116cd38f221abdb9e6c3c483747ed3b30cea57a4821b2a33e9d2d4a5c2b63ba5e54975cfc5189a7cc1e02856fdc0a85d7ddbbc1ff3867c7c2646c6ec72bd3f741d74aada8b43fa66893099aaa9a5ae2c864cc016b078b83f65b2ed22cc0f1619f85505cf4bbdfad8ed4038997ce6c6cd237f04ba6aba03cafd4e24e64df6e86b472389b8a80097422c708ea3d75691ddf7f4de564adac1ef0ed0d320b311a3fa0b116ec66e14dff9f1798ee081a906c9b63042c4c42c6b58b897ebabf9531c2d64d8f1fc8b6726a63c716a8d77cb9de3a1d2177723a079462a55525425c2d6e88b05b6faf6a426d1b15a5e64477e77976f302a98ba3af7e04429a27bdf4325c3ef514edfa7a77f511a468680df228bce4c9386354c4ad092361387c68a0aa73ff2b61c600438973e735ecc94f3ee81daa2ca69169f0a98f93bf2f730a754f528e16fed77a8710fd9f54e1a222ae3a3483b09098a512443ed80b97a581276dae376f2e940844962f4e492f2979ddd0f9879b129aa375ea7c0a07069267e32e0790e14bcd1780419188afc646e481b84e6479f26cb70c147443e62cf78dd6b807037c46154a0c9076c2da73fa43eba75c56ca486e1ae971ddeb22c97b487cb1324ef54324ea3c51b80cb3fa64712f07e3d51cd38a356a9bf1bd1a0d0e7e38fdc6b8cd92254096438aad4f27633da213ebe7a7c49e7cda79be91938742acf45ce709535798ad47a7d0aa768a0fe975c1af980a64dff605823face738d9f115fc563379fb82e48d3faf7d3e5c2ea8da2b13dde0da97130d7f12c28971be9ef7bdc595f0582605bcb03cfc58b00f52a001fc7327e67a60f53eb322700aa72b68fc43e736ccff89619caa66828d47b454864b7385db6496898a181811f8aaaadd98554b8b51b0aafac071ee8e61858091b84cbd7f7f62cedc8545061b50ba2bef28fd38f447aa9ae9e11b63748acbc774efe1a622c6841e57ace8427379c9c8813f32e90bc933a23a04d5aa3faf294f42a3d3c06c529f375e75854c7a62776b29d23c774b575d75a7ca1eb46c82cc20920827c8b1e7f558722e7f7fc775bf467bc76d6a3ec062c892d5d9a38f54a34e45b678fe69cf91a3d33117bb4ea2182f87b5fbade462f39ce353d42367d13e1d5e176df7fe2656c5e1ffa643348b185b719df1e49703e7fe7f775b1e4c3d5764d9739cd8538d9bf900f5d4ada71a956051e8128a49cc31beb3bf316492feafb85dd265625f24b7b26e269f4e45c38ebdd410da2356d4a21f4323a55448a6ae2ec2e7254a02e8d782144ad11be8d33f059b373504a27fd851355ca9a282ef60d0599c0022b5ae3f2a474cadba5b94dfcac86b83cfbe3bc5b2fdf59bacf2fa8185d3d169127e772f7f0a488557ff494a07aa1d7d4149fa7d487807bd3dced229fb252eea793f1ed7137e916ba4f041612854e3156c932e14c3a21519beaed79a289720f62c10e181d11d307ff3e87d5f2469ce241dc22af16c57ce779c5a8a861ad1df455ecae571adef9f0369ac17cc2825d18f5f82272f8680a1a93ce30371449c2f8543a2e170e3f1b1ad63a95216e81e52284bad004867d03e6e4f3e9d7f788fc58ab41bb054937e944b43f1430dd2aa291f9a2f46144064f57cd70a36e044085b4ea79296db86bfc3bb29c5a998e61a9f3c28213704315edfca186a8e905b76063082a890e1da36b1c01e3ace91bdc5a207e22b353afc4563111c5d5dd5658513fad8275b015f8b104520f72d30f0b6fc1ed3b44f0f3560cc0c277f36489357cd0a817b78010a5102bda100d80130a3ae4bc56c73a45cc4cd067022df7386719c2b6b1661858937bf08519c1b7c47edaeccdee8b57ef840492be70a9449062c84a9c701371c8641f5e7758f670f084bd12653b736f5dea00a3fb868c9fa82d07a48f651897c238a9fb0c09dc620b30e6b54cdd3a8b6db9b6285c202b2f54c211439c9a8c0682a28e3063b8b850ad938d0bfa0b6f99bb49e685463c09894c4adaf41aaced417c8b16856cacfbb8e5d1c49dbbb8e3ad7869e811e3f509f180270f89cc4d65f43ff0b96de29282ced16eba193ee882da54fef7100f2c91c0644f4efd79c956e6002db756ad57b8491a3a26a05c8b7d2fc94c9c2280d228a32a9442127f315f98c71a927a18c07753d12af79941f404dbeaa84a764acd94dd2b9d3a1734ba745b910822ca786f02ca7c3c48148f1710cedeb359d93bf1f35fa2df871ce9ba7a23cde8cfdd98bddf59cb87ef32f15914caf5e77ca12b14285cd8691d32ea4dc2eb63b215c3375b2588724ab6872523b4f5a9353eec238869f9951e00e15a6ece371dda2bbb1a90a2d0ee0833c8a6bfdaaa775d2a41945d9c12fc5082022b11806e884d172336fee03736df3747b057a94d32598a9b3adb4a5a86ef12e58df4bd057469c620b1f290198ed4d6183f480a48eda5b0ca094dbe62ba244f3eb31f04a00df252f6d3545cf0a9e30fafa600d05c1f1969a95a49b4a394ad286ebe7d714d4d9fc49c410879b8b56b9f1d8e797fe3b7d4571a7c054299a78163b87f3686b61a782e45b756c560f95d1af76829ff92f928c9ee62dbcd9027bfce4c0acf70ce6f285736cae54c74127977c5a3b82a571ca2ab251d2269ed79db9febd10432cbc73d6986b212f6b0b5520b00f7fe46e32c1896de24af0a553521897839badcb750e6aa2ff59fbc8b201c2c3f1c8c68250900e888bd3bc5e882a3764427bedf7ab2bd9979218260ccfb7b46018a1069cd32f082bbeb8bf6c916c4d522997159bbe321141809f84d2c730390af7c5fb051a8b85010e8c29cfdc6de1b4413951d2436bd67c395762e5b31dbc1986227fc88648a7065b7b5ff73c4ac9d3bc9006e706f1093f8f39c244374455563cf95b16e599adca4d67356516d62681a2d595b2dd1c7ed2276f80bea91ae679761a20a3aff90265fdcc15048ec2fa68404ca81db84bec9fda88e752c57d64463753dbe0be0cdd9e5a7a87c5997159ecf40034aaa1584a8f5df4739c8d5aa4f049ab669192b82bb334570856b6620cf1bc59b92cf3ff0ad7fe6e11eb18ca15e518521dd7d5a0e8d81b73979aca8f5b8b3b444b3b6149babc6c229043304df4de3465c27908102807bdd8196d52bbab377debeb5dab3902a56768a2f0d810925e8eb41a5a2f545727b6182fdbca817e3ec004a3176a582f3be38ebf8733cd4ccc2aac046482c68ad1c798958e26ca9a20451c66e3c55fb02fc1255c62f9b649bf2a10dc5f31d1a8c3814973685ac56071c65df8a80e285cfed09af8492f12d94ee5406747172b4159a262b43282c3a4aea6b5eb11ca360c713f8207ebc8e15f332ee00aa043672806a93eb0bfaf8760cda3c73730dde88fa67e5966341864cd8ea32bf30fc103fcc88986cb1511bd82968b1ffdc997d5cba28bd54675ebf75031b5bef23ce4058169d242231ec90de0b18b09e848b9f08b501ce9614a97af80cbdbca521323c86a9d540af5e0364820ae37edfdc2d0f95433f085f1a361f48fe27b0ea2b115de6c12b65fb995c5260757d06d3b1c89c3b5abf2db2084d54ee011196ea1e486e1be5647a565c5f157ad5b966d5dfc3b72cde7f1b446cbd5b3311b9e38075a6889d1a462579e466311270171e52b3e98eec3c56ef5af64b41aae67f33b8e86e0cf89619b1b0701b8d7bc147db7731ab7f9763f995ce55772c8d808814a5a97d3f35c06408e7844475120cfa6ce228b5148b54b0e20d6f3a4cf59a615f1c95a896411e6fe287ec14b011f007c03484c3097a9e634783c33b4dab27b673e6cd071e60fd0167794f6cbf10d520aa708c36a02b3e07999fc042159a2c5a84734f8398799aee8c478189979f8be6d673e54466caa91440b763efe235409e2f857f49cf1c61e5120c2afabeaa4cdfabae046504dbdd70f82648a436e1a19a57c008e9455c70c1918795db208802a74bd62348c8bc7ae2baf0176d915234570c162d9771455cef568e5059fb4e3768c406ddd52b82aefbcec92c925d3d89c646df844de14368f21943b75b3871e8dad574509d3e6bbddd3f6a148e0c0d07112529906a046f9270bb48dfb3c1ed6fbe77e8628a078f805001c7570fca0be2b7136c1df931a97f259e35edd5042bc86e6a3198a4a27335998bb7fce5eb415689e992a8ec378560787c3cd0ca74e2d13496a3d55b8b7382bce3c793fb71afbf286b3a9362c8ad5610f7e125ef37f647e972418611965c032b89e8f94d91ddd742810139128bdad52696287efab46d8e427683fbe5629259d3d2c7909f8b07c28498ddf320feffb50db2698605cc028a4276929fc10ebaa80a7d8e507d65adb6148107f405dacd5f07f4ca30f4ab1a878092b14c4ef231b4c628e883880e88651878d87275ccc03af4cc2f6354489d729d8719c83472ef8d5c32d2979fffc8154d9520f319ec44df85618c21c8ec34510fa8409b83d92df80abe3f24fad3157dbe737a3dcdef0e91c4d0de54dedfd9cb99fcda8ed57f3f77547ea2514f73ef61a4303f91a6685c1bbc1ffd3d2a7d2599b331d34f0dc232e1d07a7e36000c12305f0647247f3d1ca1619ce598617b45437f73097bb7e54c9adbdb66762d9153fe04b1c69bf54ba1cec4ba04a2c01bb278e0643da581a73dc5f03db381d6eb743d9955179c71d029ef86ce7d122624ed319564def48c5309dae07a76cb613197b4ca716a548feb63652d3915ef4cde80783272610f80d6100ce9c9627ce861627bc4ce61d01377644c22c639b640366c2b2b003bbe90d00e038ce2495e788ac933d19f7a424d3c3394f5fc35cf42a4341dbd26623f03bb66447c985f05a25930d2ba2894593426904d5c3a0ce2ad18d66b9372c81375feda1537f9f11eab00c22446e3c457d42608fa43f5dffbf01be6961126343644b0c72f7c3a28c47d034b502c6b415bd744817dd5158a325e91fcf918b9e6bf8124f544e11e6fda24ec0d8e0f6cf6661697787479509dd9d3f5a0cf53f216f3a0c6558284344350eb4a47609845531cc2b3f7fbe891e73531cacdd709501368f38f0a4e126411ca933d89104022ea5b6c042c72798af4fb4260401f899b8e5a3398db431049937811bdfc3a3f1d27fc51673f7b021cd72e8630ded1f1fd44c67750c7896712032824599fc11f60ecae501cf431aab980f6e88797845163ffec065223f63130e4d5aac73391ae37a79657ca6eca79b93725f082babe11dd8f60f01e17b6c61be568fe43ef9a7cc1ea4d5abee501e686429c10d48455cc396f9b79c8614155f8416f53ce358d06cbc02799935fadb7b8ebf42ec9bc94c8b97b0e54285b466c7d51a6b1fdac33b7d46439e8bd6c38baead999e1a42d96b7486b21d2ce1f21686835b21c7f756dd00ca2cbdb14292c705f58498ccb3861ea9909ff3d8ca96216bf77b8dc0d0f72dc117f1da4fb345a4b9553e5cbba7446f10425f48af03e39caa83424000cb5c5f6465e8842eb3d3cbb528530e5abca6872bcffffd9820410ef02925b3e332cd25fdec7253b41a152f897ebc3da757d560918e352c00da43d68be72c243477aabf26f8efccb4e49b30437a86ad898c39cd72303cb10c2b04248149a4fdaa9e10ca0aaea5bcbd275f354f9746e90090f85a6ff99b476a6326dc151cde756bcd77217bf689e6e03f70c762fedade424fc1d7eebeb62ef9b8a9d21c2525a03e0a91f04c1ddc2af5b9d5cf7234f6fde136691fab91c7bd4e9a714b69c6cbf19335f47d54abed32ee4d12a2c94f3aa6e091ffb55d61f3c68f0939868950675bcdffe1eb6fa5e0f43049d8eaca951fce47bfbdd621da3eefa07c2a42fe9d592019a47948f4a45c03b007c34ab1b169d0ef1d8e26c0cec5513fa1c79f6b001cd5fecc926c38656f12ab3cc2afca4dca5aac09698d63a9ea659c3046d45ab8946c5800c67fd84108d7f3d2e7668fd95fd8b4f0866f2ef8f4528237d198c2e665566e4810f5c72dc79121428738e933cd7641d8ee76e2e95337d3b84a2adf300e799f9dee80dfa3b7e8022dd876d45280773c320068e1dd207e21cc9aff42b517cad13d198527252aaca2241d78dad990ce74dd82a92c6c4abe77a98e3894a9a1031cc3bc3c3f63a52dc73942270274970e7d1fa195bfdc2ed6d171ba0debe433698b8f74a5071fd77834dae8df274c1a3475d4838b585590014f35cc393b6fd6651ba48457bcb2052382462de7cfa29807234619477f5616e27ad2d964cd777eb33a7a62af99794a3ce805a99b3dee35409441e00cd08220f1f12a1d087c443b352c7ea5bec3a563ddc7ed2a97ddac0c891d200de7baa178f98f40f50f04d485129c83d3f53708c2bdbae4c549c1c37c9e07061d15c583330ebace9c64c459b17d33be69999b365bd1bf48d8ce28cc70a992e518f6fbde4e0000801707f45d67d1829bf0fc924b5308bad97dcbc5fec2435cae253a870db661e7887ff601937138c4a32b389800e1cc46f508707f3821d89bf335c9de5053a719c4bbaba1bac4328f13e963adb479bd9df9ac49d00f66763bbc9c39de65d11a9bae45f6132dcf7816ad43a1aba66765d66b82089c6a34c277bcf9d77da2ad982e5991a784d45238d86b1c2d76780501f6b5ff1499ae73ab2b2c8b7b5d58cb1a9f15e4458a3a853132233b31fe1780451ded18c50c05f5aaa90f6eb3ab2837bec841bebe344e14021fb0adec1eb5d49e7e7fd2fdafc3101fbd43d92fb8d222a36832bab2f8c619b5fcfcc2d11037b7550d83bf0949c4d1b521405e4fa7d6339e720c217c5565a4a86dca463ea4144475a3c47769c18ad67bd20d8e1f6aca2b6b5d3a933c928f551a1220dd7a45703f3419514767d9d6349fd95a021aa728c8cad879d457bfaea71a9cc9a4a54ff44d860c3050c8e1e92cf148e41c4da57f7bd63be9d5c4145c676581dbc111d2755c5fb1b76e2ad3a7b10fafc37ad5f85f536c859af840631baa6e3fe03d944293672a4b87441a74e1713abf3c38f07580243c8f8acf15aa6c1523a26e76a006e63d92578ff2fe57cf17edb78c701331680ecab241b335117c0af78887341d3d7dc12d729a33b303f6e84da800f6845104868ed3b1dff8451beb173ab792fc5f6a718f22ef84be71e725339d44d9a3163719ebea204d14a6e96237845182e2af98a2b6b1d0f7764fb1d2de7cbb80536c8a7b0c90335ab22b5d20cd1e06fae0dd9560a504981790b3a0ac42cee055e30d05ac25152aba684bfa79d72e4d1089518334bb8ea1ec8cce00f80638c2a04aa6e5037848ad5f383173ee0d4785d99470b60dcdbc2f39c9c04f8dc47058bfa71dbf2a717c2465fb310e11168d3a45771fb450a2acedde151f931e582a7fbfd11d670b4d9ece321198d64b121d49253b77fb2b76399a2a20141868ef68bd6677309ad0646937e4e4187590e1a85469eec8927aa64f7b19bcc0a240b90f30d5182b610d75a2dcc1675d7cb9ad52ee101aaa63b28d6e0bf49e55ea3d07c3715d3567cfc4b714dae5503a3538d97904cbe1894d5ead6870ccf3460e97450f5b187fd633a222941bfbcb18dba083002d3459d8a432052470aa807f9f579462d20572c330afe3a8b6b56425dc094dfe550dcb331bcf94196edd43ac404488b815d2adffac6ce18dd9ad8b17fbc0f5682435685392db5fc51e041f104843dd9ae159027f9748c65fb35ca887eab0e8dd79a076f42b611d5c9ce82d9df0d1cf4bbf381a29f29e79a19335137cb85e84fd934465cac622457c87c40b96d1e20ebbd44c1b82dab66709b3c5b172c6d01c5dde31c3593774969eceabd52fa66617fedefd5cc7f92cdb39b0f17f5ab5f63d012ff3f07b231d7818d3cbbf162e903b274a7a8b44a554bffea7e4b5e9d71af63bfa6eb04f6e13d3a0b1170589f7763c85989dc7b99ee53deef80dd945b67f094e6bf466e3ef1e3cacb5e45bef388c0ee0abd15d06cee12c3554db0850ba60844ba7eb0fe01ecedd22d13f31c87f6ce2911408eac529939a9b9decbd8784923602e54725c3cc0d37ff72a7b97eac654cf42b29f6a0169c178e79815a42e29d106f04cf835e1a717af9f21185799a32e83a2ad51b70c80ace864c7ae26ff41338da3d26cda8cef8c1c1fc514c6057802b2cb9955bf640d2b373e70b67209c46394ca6ce795103a1a1dde6796da90cef01ee96e18f4dbbb9fea2a9f3428e1f706d48cec9dcf52fcc81c7ccb8f3591edaf5f3f89b0638b82515b03b6217798dded5c75cfa1651b2837328ce10b989c629a28a3c96dd18d9e2ad9988afd7795eaa88670b63c4a697a7c928e692c3870a43de556839aff1ccd7a4ec25e1c8237edec8c4240b9a0eb7ebd47bf4035fdbf2d2b2f8c089becf5d3b84a6c241637a8c5e5655d1a693c17d420303b5529da6698671798e8fe3b0d738326c0726d2957c18877af78df9af5a1852127309e446ddeeccc68af04f072da36a1887748610f81e88956ffc599c322386cc0e2cbca50679260add6f74250288d642b357cdc947c270fc55a7f12df74a634fe92aa8dec0023e871ba5ec427bf8d40af500d3b622af91e160771ac412a2e7e04a40f9ce6e52b47face7a2f5ce450e7b4cfaef0c73efe5b0ed945bd975005fb43914483172ad3bc23c3bcf1d90664e286cd2ae98bfe2657a8c17213de923c6918a669fa381068663ed8fdec98cc294d4ac4ddaa2b541801d2da43f586eed28db245412276fc908e069272fbee11f9d838fdb944f45855fc0e91540168e86bb5997e13edbf2e1edfc1079efdd4cf96aa1a3e928397781a55e04b321491d7290c991ef236326a4772338eb760094463e55af5d72fbfb352da3c6b365a565a6b59c78c87d47742a58915919e3d569b944896dbb5ffbb3d333d2cbecdfcd32b452792724c8f00f49a4d01d657845999e5728877dd4397449f2daa95d7b4d8c9028ce40e3869a91611d5161836d841975768a35fda52cd591a1b3e51d45d88cc151c0da7a11e1321244fd2674e16f5cbe57e4e9f19668f2a98b47222e6f2b4721376980fe1a126a6493d4ab8d1711cc73dad162c037f77092fb775e6f394d70332a9ec2df5c82d39c18645d09acdcbe4ba1cbf481bbcca9a0947b834a6919678a2e015f5967f6fd066ab68588a36fe844f9764e2e0bfc4590a35b360745de937378ee8de457e8c8bd40074513d62a20af1f52387ec2f4da2a87eda502deaa3032ef7db9738517ab72ad608bdf143592c1a4008583ef00542c5ae454463f565847c6e2e9adf75599cc18b87cfc12ea137ec111e8501282b2429f2770feaf185555b9137441912acea709cb533248d9f848ef1db0630e8c76381ca97071ccc938de8e9ad01f83b60c7f8b2fd04baf1cd973b8a0dc2017964156dfac2db4ed8fe476a07f1e9dfda02e7e3a3ff06bc13d8450cff08164c3f88c5712c9c39e44acacdc2cca5ab6b45e4705e9d18e53a7a84e195b33af69f91624486a1605b7faad65dbc3e39092068620d8a32efe270680abb16ba7f3734d7353b4c17a4973b4b1ec6437aca9f2377ba2f3b3b3cad47d34ce334287e95eb21ff352e02b1921e53ecf3dd8e961c67bd6af85aa4c02ebf908bd40dd7094a1f38a38c528a4e77ab3cf3ac5cfdad0c192bb7fa2c3e0dc167f78f1acb672b85ec6870cf24e6537f1b39d36a15a60498f5d9\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n\n\nimport {initHBE} from \"/js/plugins/hbe.js\";\n  console.log(\"hexo-blog-encrypt: loaded.\");\n    initHBE();\n\n","categories":["随笔"],"tags":["心理学","神经科学","潜意识"]},{"title":"协议切换与认证配置","url":"/2025/01/18/%E6%9C%8D%E5%8A%A1%E5%99%A8/%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE/","content":"背景介绍在使用 Git 进行版本控制时，我们经常需要在 SSH 和 HTTPS 两种协议之间进行切换。本文将详细介绍这两种认证方式的特点、转换方法以及相关的常见问题解决方案。\n认证机制解析双层认证架构\n服务器层认证\n\n用于验证用户对服务器的访问权限\n通常通过 SSH 密钥或密码完成\n\n\n仓库层认证\n\n验证用户对特定 Git 仓库的操作权限\n独立于服务器认证系统\n确保代码安全性和提交者身份\n\n\n\nSSH vs HTTPS\nSSH 协议\n\n优势：\n更安全，使用密钥对进行加密\n配置一次可永久使用\n可以避免每次输入密码\n\n\n劣势：\n可能被防火墙阻止（22端口）\n在某些企业网络中可能无法使用\n配置相对复杂\n\n\n\n\nHTTPS 协议\n\n优势：\n几乎总是可用（443端口）\n穿透防火墙能力强\n配置简单\n\n\n劣势：\n需要管理凭证\n可能需要频繁输入认证信息\n\n\n\n\n\n连接问题分析SSH 超时问题解析SSH 连接可能出现超时的原因：\n\n网络限制\n\n企业防火墙可能会阻止或限制 SSH 连接\n某些网络环境会定期切断长时间的 SSH 连接\n\n\n代理影响\n\nSSH 不会自动使用系统代理\n需要额外配置 SSH 的代理设置\n\n\n防火墙策略\n\n22 端口经常被封锁\n某些地区可能限制 SSH 协议\n\n\n\nHTTPS 连接优势\n标准 Web 端口\n\n使用 443 端口，几乎总是开放的\n与普通网页浏览使用相同的端口\n\n\n代理兼容\n\n自动使用系统代理设置\n更好的网络兼容性\n\n\n连接特性\n\n非持久连接，每次请求独立\n不受长连接限制影响\n\n\n\n协议转换实践在尝试直接git push时显示:通过执行命令git remote -v查看当前远程仓库的地址:\n\ngit@的前缀格式说明是通过ssh的方式, 我们尝试修改为https的协议来解决超时问题.\n\n更新仓库的URL:\ngit remote set-url origin https://github.com/用户名/仓库名.git\ne.g.:\n\n在更新之后执行get remote -v, 检查发现已经转换为HTTPS.\n\n配置凭证管理此时依旧无法直接git push, 因为仓库层认证的密码验证方式已经不受github支持, 如果尝试通过用户名-密码的方式验证, 将会失败:\n因此我们需要通过 个人访问令牌(PAT) 的方式来鉴权.\n\n配置凭证管理:\n\n# 永久存储凭证git config --global credential.helper store# 或临时缓存（如15分钟）git config --global credential.helper &#x27;cache --timeout=900&#x27;\n\n如果不希望影响其他仓库, 去除--global即可.\n\n\n获取PAT:\n访问 GitHub Settings;\n下滑到底部,进入 Developer settings;\n选择 Personal access tokens → Tokens (classic);\n在右上角选择生成新的access token;\n生成新令牌并设置适当的权限范围 (至少勾选repo).\n在生成PAT之后立即复制并保存.\n\n\n\n\n\n通过PAT鉴权此时, 我们可以git push然后利用PAT来鉴权:\ngit pushUsername: &lt;GitHub用户名&gt;Password: &lt;个人访问令牌&gt;\ne.g.\n安全相关建议凭证管理\n凭证存储位置\n\nLinux&#x2F;Mac: ~/.git-credentials\nWindows: %USERPROFILE%\\.git-credentials\n\n\n安全建议\n\n定期更新访问令牌\n在共享环境使用临时缓存\n及时清理凭证缓存\n\n\n\n故障排除# 删除全局凭证配置git config --global --unset credential.helper# 删除凭证文件rm ~/.git-credentials  # Linux/Macdel &quot;%USERPROFILE%\\.git-credentials&quot;  # Windows\n","categories":["通用技能"],"tags":["服务器","PAT"]}]