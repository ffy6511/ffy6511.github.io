[{"title":"Prisma","url":"/2025/04/28/Prisma/","content":"Prisma 命令行相关数据库迁移\n创建并应用新的迁移：\nnpx prisma migrate dev --name add_timestamps\n\n根据 schema.prisma 的更改生成迁移文件，并应用到数据库。\n--name 指定迁移的名称。\n\n\n重置并重新应用所有迁移：\nnpx prisma migrate reset\n\n重置数据库并重新应用所有迁移，适用于开发环境。\n\n\n生成迁移文件但不应用：\nnpx prisma migrate dev --create-only\n\n生成迁移文件但不应用到数据库，可以手动修改迁移文件后再应用。\n\n\n应用未应用的迁移：\nnpx prisma migrate deploy\n\n将未应用的迁移应用到生产环境。\n\n\n查看迁移状态：\nnpx prisma migrate status\n\n查看当前数据库的迁移状态。\n\n\n回滚迁移状体;\nnpx prisma migrate resolve --rolled-back &lt;migration_name&gt;\n\n\n数据库操作\n生成 Prisma 客户端：\nnpx prisma generate\n\n根据 schema.prisma 生成 Prisma 客户端代码。\n\n\n推送 schema 到数据库（不生成迁移）：\nnpx prisma db push\n\n将 schema.prisma 的更改直接应用到数据库，不生成迁移文件。\n\n\n查看数据库数据：\nnpx prisma studio\n\n启动 Prisma Studio，一个可视化工具，用于查看和操作数据库数据。\n\n\n\n\n数据操作\n执行种子脚本：\nnpx prisma db seed\n\n运行 prisma/seed.ts 或 prisma/seed.js 脚本，用于填充数据库初始数据。\n\n\n运行自定义脚本：\nnpx prisma execute --file ./scripts/my-script.ts\n\n执行自定义的 TypeScript 或 JavaScript 脚本。\n\n\n\n\n其他常用命令\n初始化 Prisma：\nnpx prisma init\n\n初始化 Prisma，生成 prisma/schema.prisma 和 .env 文件。\n\n\n格式化 schema.prisma：\nnpx prisma format\n\n格式化 schema.prisma 文件，使其更易读。\n\n\n检查 Prisma 版本：\nnpx prisma --version\n\n查看当前安装的 Prisma 版本。\n\n\n清理未使用的迁移文件：\nnpx prisma migrate resolve --applied &quot;20231010123456_add_timestamps&quot;\n\n标记迁移文件为已应用，用于修复迁移状态不一致的问题。\n\n\n\n\n语言特性Prisma 中的关系定义需要双向声明\n\n在引用表中进行外键的声明\nmodel BorrowRecord &#123;\tbookId string \tbook       Book       @relation(fields: [bookId], references: [id])&#125;\n\n\n表示当前表中的 bookId字段是被应用表 Book 的属性 id的外键.\n\n\n同时在被引用表中定义:\nmodel Book&#123;  id             String         @id  borrowRecords  BorrowRecord[] // 添加反向关系&#125;\n\n\n使用TS交互客户端Prisma Client 是一个类型安全的数据库查询工具，它根据 schema.prisma 文件生成 TypeScript 类型定义和数据库操作 API。\n以下是其主要功能及代码示例。\n\n1. 初始化 Prisma Client在使用 Prisma Client 之前，需要初始化一个 PrismaClient 实例。\nimport &#123; PrismaClient &#125; from &#x27;@prisma/client&#x27;;const prisma = new PrismaClient();\n\n\n2. 查询数据\n查询所有记录\n\n使用 findMany 方法查询表中的所有记录。\nasync function getAllUsers() &#123;  const users = await prisma.user.findMany();  console.log(&#x27;All users:&#x27;, users);&#125;getAllUsers();\n\n\n查询单条记录\n\n使用 findUnique 方法根据唯一条件查询单条记录。\nasync function getUserById(id: number) &#123;  const user = await prisma.user.findUnique(&#123;    where: &#123; id &#125;,  &#125;);  console.log(&#x27;User:&#x27;, user);&#125;getUserById(1);\n\n\n条件查询\n\n使用 where 条件过滤查询结果。\nasync function getUsersByName(name: string) &#123;  const users = await prisma.user.findMany(&#123;    where: &#123; name &#125;,  &#125;);  console.log(&#x27;Users with name:&#x27;, name, users);&#125;getUsersByName(&#x27;Alice&#x27;);\n\n\n3. 创建数据使用 create 方法插入新数据:\nasync function createUser(name: string, email: string) &#123;  const newUser = await prisma.user.create(&#123;    data: &#123;      name,      email,    &#125;,  &#125;);  console.log(&#x27;Created new user:&#x27;, newUser);&#125;createUser(&#x27;Bob&#x27;, &#x27;bob@example.com&#x27;);\n\n\n4. 更新数据使用 update 方法修改现有数据。\nasync function updateUserEmail(id: number, newEmail: string) &#123;  const updatedUser = await prisma.user.update(&#123;    where: &#123; id &#125;,    data: &#123; email: newEmail &#125;,  &#125;);  console.log(&#x27;Updated user:&#x27;, updatedUser);&#125;updateUserEmail(1, &#x27;alice_new@example.com&#x27;);\n\n\n5. 删除数据使用 delete 方法删除数据。\nasync function deleteUser(id: number) &#123;  const deletedUser = await prisma.user.delete(&#123;    where: &#123; id &#125;,  &#125;);  console.log(&#x27;Deleted user:&#x27;, deletedUser);&#125;deleteUser(1);\n\n\n6. 关系查询\n查询关联数据\n\n使用 include 查询关联的模型数据。\nasync function getUserWithPosts(userId: number) &#123;  const userWithPosts = await prisma.user.findUnique(&#123;    where: &#123; id: userId &#125;,    include: &#123; posts: true &#125;, // 假设 User 模型与 Post 模型有关联  &#125;);  console.log(&#x27;User with posts:&#x27;, userWithPosts);&#125;getUserWithPosts(1);\n\n\n嵌套查询\n\n支持嵌套查询关联数据。\nasync function getPostWithAuthor(postId: number) &#123;  const postWithAuthor = await prisma.post.findUnique(&#123;    where: &#123; id: postId &#125;,    include: &#123; author: true &#125;, // 假设 Post 模型与 User 模型有关联  &#125;);  console.log(&#x27;Post with author:&#x27;, postWithAuthor);&#125;getPostWithAuthor(1);\n\n\n7. 分页查询使用 skip 和 take 实现分页查询。\nasync function getUsersPaginated(page: number, pageSize: number) &#123;  const users = await prisma.user.findMany(&#123;    skip: (page - 1) * pageSize,    take: pageSize,  &#125;);  console.log(&#x27;Paginated users:&#x27;, users);&#125;getUsersPaginated(1, 10); // 查询第 1 页，每页 10 条记录\n\n\n8. 排序查询使用 orderBy 对查询结果排序。\nasync function getUsersSortedByName() &#123;  const users = await prisma.user.findMany(&#123;    orderBy: &#123; name: &#x27;asc&#x27; &#125;, // 按 name 字段升序排序  &#125;);  console.log(&#x27;Sorted users:&#x27;, users);&#125;getUsersSortedByName();\n\n\n9. 聚合查询使用 count、sum、avg 等聚合函数。\n\n统计记录数\n\nasync function countUsers() &#123;  const userCount = await prisma.user.count();  console.log(&#x27;Total users:&#x27;, userCount);&#125;countUsers();\n\n\n计算字段平均值\n\nasync function averageUserAge() &#123;  const avgAge = await prisma.user.aggregate(&#123;    _avg: &#123; age: true &#125;, // 假设 User 模型有 age 字段  &#125;);  console.log(&#x27;Average user age:&#x27;, avgAge._avg.age);&#125;averageUserAge();\n\n\n10. 事务操作使用 $transaction 执行事务操作。\nasync function transferBalance(fromId: number, toId: number, amount: number) &#123;  await prisma.$transaction([    prisma.user.update(&#123;      where: &#123; id: fromId &#125;,      data: &#123; balance: &#123; decrement: amount &#125; &#125;, // 假设 User 模型有 balance 字段    &#125;),    prisma.user.update(&#123;      where: &#123; id: toId &#125;,      data: &#123; balance: &#123; increment: amount &#125; &#125;,    &#125;),  ]);  console.log(&#x27;Balance transfer completed&#x27;);&#125;transferBalance(1, 2, 100);\n\n\n11. 关闭 Prisma Client在程序结束时，关闭 Prisma Client 以释放数据库连接。\nasync function main() &#123;  // 数据库操作代码&#125;main()  .catch(e =&gt; &#123;    console.error(e);  &#125;)  .finally(async () =&gt; &#123;    await prisma.$disconnect();  &#125;);\n\n\n","categories":["前后端开发"],"tags":["数据库"]},{"title":"𝐜𝐡𝐚𝐭𝐒𝐐𝐋","url":"/2025/05/08/chatSQL/","content":"\n  Website\n  Github Repo\n\n\n  \n\n\n什么是chatSQL:\nchatSQL 是一个交互式 SQL 学习平台，通过人工智能技术生成个性化的 SQL 练习题，帮助用户从入门到精通 SQL 查询语言。平台结合了直观的数据库可视化工具、智能代码编辑器和即时反馈系统，为用户提供沉浸式学习体验。无论您是 SQL 初学者还是希望提升查询技能的开发者，chatSQL 都能根据您的水平定制适合的学习内容，让 SQL 学习变得更加高效和有趣。\n产生背景在初学sql的时候, 总觉得在纸上谈兵的感觉不太切实, 总是不知道自己胡乱写的sql语句是否正确. 偶然的机会看到了一个在线的自学sql网站, 提供了数据库结构,元组信息以及sql编辑平台, 供用户实时查询:\n\n然而该网站的习题内容对免费用户十分有限, 不足以sql学习者反复的练习. 于是我想到, 为什么不自己做一个呢? \nsql题目的生成gemini免费的api + dify上免费的工作流 &#x3D; 无穷无尽的sql题目~\n由于有过dify平台上搭建工作流的经验, 我还是选择用dify来针对用户的需求生成不同难度和类型的sql题目. \nschema的可视化在写数据库作业的时候, 意外发现了chartDB这个网站, 其中的数据库结构的可视化十分优雅.经过对其源码的”探测”, 我挖掘到了xyflow这个组件库.\n同时, 我决定直接用MUI组件库中的表格作为数据库元组的展示, 让元组的信息更加直观.\nsql语句的执行这部分可谓是项目中最难实现的任务了.\n其实一开始并没有立刻开始做chatSQL, 就是因为我没有现成的在虚拟&#x2F;实际数据库中执行sql语句的方法. \n然而, 某天浏览数据库教材的时候, 意外发现了官网上存在一个前端执行sql语句查询的demo! 发现叫做sql.js的库似乎就可扮演在前端的sql引擎角色. 因此, 我觉得万事俱备了! 开始设计前后端的字段, 布局排版, 然后实现基础的UI…\n然而然而, 当我准备开始做sql引擎的时候, 发现sql.js竟然与react高版本框架和一些依赖不兼容! 然而我只剩下sql引擎的执行部分了… 也不好就此放弃. 那么就借助augment的力量自己写一个吧~\n\n首先, 从monaco editor入手, 建立一个类似于vscode风格的代码编辑区;\n然后, 利用node-sql-parser库, 我们将标准的sql语句传入给解析组件, 获得ast语法树;\n最后, 我们编写自己的sql执行引擎, 利用ast语法树执行sql语句.\n\n\n下面基本是项目仓库中README的部分.\n\n✨ 特性\n🤖 AI 生成练习：提供两种方式的习题来源\n\n通过预设的教程, 循序渐进地练习select, join, 聚合操作与嵌套子查询等知识点.\n与dify工作流交互, 输入难度,标签与描述自动生成 SQL 练习题.\n\n\n📊 数据库结构可视化：直观展示表关系和字段信息, 外检约束等信息一目了然;\n\n⌨️ Monaco编辑器与schema的补全整合：\n\n支持sql语法高亮和悬浮的语法提示\n针对当前schema信息提供tab的自动补全\n\n\n📝 即时结果验证：实时验证查询结果\n\n由构建于前端的sql引擎0延迟地处理sql查询结果.\n支持将查询结果与期望结果进行比较, 评价查询结果是否正确.\n\n\n\n🖥 界面预览初始化界面\n\n点击侧边栏中的“初始化教程”, 可以同预设的数据库表结构进行交互;\n点击侧边栏中的“帮助”, 可以查看基本的操作演示.\n\n数据库结构可视化\n\n默认显示数据库结构的可视化视图;\n可在左下角切换元组视图.\n\nSQL 编辑器演示\n\n对应快捷键:\n\ncommand+enter : 执行查询\ncommand+j: 检测查询结果是否匹配;\ncommand+k: 搜索历史记录.\n\n🛠 技术栈\n  \n  \n  \n  \n  \n  \n  \n\n\n\n框架: Next.js 15.3.0\nUI 组件:\nAnt Design 5.24.6\nMaterial-UI 7.0.2\n\n\n编辑器: Monaco Editor\n流程图:\nXY Flow (@xyflow&#x2F;react)\n用于数据库表关系可视化\n支持自定义节点和边的样式\n提供图表交互操作\n基于 D3.js 的缩放和拖拽功能\n\n\nAI 集成: Dify.ai\n类型检查: TypeScript\n\n🚀 快速开始\n得益于预制课教程系列的完善, 您可以直接clone仓库后, 通过npm install安装依赖, npm run dev启动前端即可进行基本教程的学习, 而无需配置dify工作流. 😌\n\n前置要求\nNode.js 18.0 或更高版本\nnpm 包管理器\nDify.ai 账号和 API 密钥\n\n安装步骤\n克隆仓库\n\ngit clone https://github.com/ffy6511/chatSQL.gitcd chatSQL/chat-sql\n\n\n安装依赖\n\nnpm install\n\n\n配置环境变量\n\ntouch .env\n\n编辑 .env 文件并添加你的 Dify API 密钥：\nNEXT_PUBLIC_DIFY_API_KEY=your_api_key_here\n\n\n启动开发服务器\n\nnpm run dev\n\n\n更新git日志: 如果您希望更新自己的”更新日志”界面, 请执行\n\nnpm run generate-git\nDify 工作流配置\n在 Dify 平台 创建新应用（选择工作流）\n导入工作流配置：\n从项目中下载 public/chatSQL.yml 文件\n在 Dify 平台中导入该配置文件\n\n\n\n获取 API 密钥并在个人设置中配置（工作流默认使用 Gemini，可根据需要修改）\n\n🤝 贡献欢迎提交 Pull Request 和 Issue！\n","categories":["前后端开发"],"tags":["奇思妙想"]},{"title":"晚霞","url":"/2025/01/09/poets/%E6%99%9A%E9%9C%9E/","content":"\n\n白昼飞红了她的脸颊 \n以隐匿于远山之后的凝望  \n默默期待着  \n月色的降临  \n\n","categories":["随机掉落的文字碎片"],"tags":["短诗","自然"]},{"title":"倦鸟","url":"/2025/01/08/poets/bird/","content":"\n\n我盘旋的目光是漂泊不息的倦鸟\n\n越过人海 坠入你乌黑瞳仁中的夜\n\n\n\n\n下附最初的三节诗, 以及灵感来源.\n\n\n 完整三节诗\n\n我盘旋的目光是漂泊不息的倦鸟 \n越过人海终于落入你乌黑瞳仁中的夜\n\n你澄澈的眼眸映照着闪烁明灭的晨星\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记\n\n我们的目光还是悄然相遇了\n你温和的凝视又让我想起黎明的微光\n我漆黑的羽翼微微颤动 随后灼灼燃烧\n于是 我的目光载着余烬 再度飞远了\n\n\n\n\n 「灵感」Tagore's\n\n\nMy heart, the bird of the wilderness, \nhas found its sky in your eyes.\n\n(出自泰戈尔的园丁集)\n\n\n\n","categories":["随机掉落的文字碎片"],"tags":["短诗"]},{"title":"CORS","url":"/2025/01/16/%E5%89%8D%E5%90%8E%E7%AB%AF/CORS/","content":"跨域资源共享（CORS）技术指南目录\n概述\n技术背景\n配置方案\n最佳实践\n问题排查\n参考文献\n\n概述跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。\n技术背景同源策略基础同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：\n基准URL：http://example.com/page.html跨域场景：- http://api.example.com/data     // 子域名差异- https://example.com/data        // 协议差异- http://example.com:8080/data    // 端口差异\n\n配置方案环境变量驱动的CORS配置以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：\nimport osfrom flask import Flaskfrom flask_cors import CORSapp = Flask(__name__)# 从环境变量获取前端URL，如果没有设置则使用默认值FRONTEND_URL = os.environ.get(&#x27;FRONTEND_URL&#x27;, &#x27;http://localhost:3000&#x27;)# CORS配置实现CORS(app, resources=&#123;    r&quot;/api/*&quot;: &#123;        &quot;origins&quot;: FRONTEND_URL,        &quot;methods&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;, &quot;PUT&quot;, &quot;DELETE&quot;],        &quot;allow_headers&quot;: [&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Requested-With&quot;],        &quot;supports_credentials&quot;: True,        &quot;expose_headers&quot;: [&quot;Content-Disposition&quot;]    &#125;&#125;)\n\n配置详解让我们逐行分析这个配置：\n\n环境变量设置\n\nFRONTEND_URL = os.environ.get(&#x27;FRONTEND_URL&#x27;, &#x27;http://localhost:3000&#x27;)\n\n使用os.environ.get()获取环境变量\n提供默认值&#39;http://localhost:3000&#39;作为本地开发环境的配置\n可以通过环境变量轻松切换不同环境的配置\n\n\nCORS配置参数\n\n&quot;origins&quot;: FRONTEND_URL\n\n动态设置允许的源，基于环境变量\n避免了硬编码的问题\n支持不同部署环境的灵活配置\n\n\nHTTP方法配置\n\n&quot;methods&quot;: [&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;, &quot;PUT&quot;, &quot;DELETE&quot;]\n\n明确定义允许的HTTP方法\n包含了RESTful API所需的全部方法\nOPTIONS用于预检请求（preflight request）\n\n\n请求头配置\n\n&quot;allow_headers&quot;: [&quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Requested-With&quot;]\n\nContent-Type：允许设置请求的内容类型\nAuthorization：支持身份验证令牌\nX-Requested-With：用于标识AJAX请求\n\n\n凭证支持\n\n&quot;supports_credentials&quot;: True\n\n允许跨域请求携带凭证（如Cookie）\n对需要身份验证的API至关重要\n\n\n响应头暴露\n\n&quot;expose_headers&quot;: [&quot;Content-Disposition&quot;]\n\n允许客户端访问Content-Disposition响应头\n通常用于文件下载功能\n\n环境变量配置示例# 开发环境export FRONTEND_URL=http://localhost:3000# 测试环境export FRONTEND_URL=http://test.example.com# 生产环境export FRONTEND_URL=https://www.example.com\n\n最佳实践环境变量管理建议\n开发环境\n\n\n使用.env文件管理本地开发环境变量\n将.env文件加入.gitignore\n\n\n生产环境\n\n\n使用容器化部署时通过环境变量注入\n使用配置管理系统统一管理环境变量\n\n安全性考虑\n避免过于宽松的配置\n\n# 不推荐&quot;origins&quot;: &quot;*&quot;  # 推荐&quot;origins&quot;: FRONTEND_URL\n\n\n合理设置凭证策略\n\n\n仅在必要时启用supports_credentials\n确保前端配置匹配（credentials: &#39;include&#39;）\n\n问题排查常见错误及解决方案\nCORS策略违规\n\nAccess to XMLHttpRequest at &#x27;http://api.example.com&#x27; from origin &#x27;http://example.com&#x27; has been blocked by CORS policy\n解决方案：\n\n检查环境变量是否正确设置\n验证前端请求URL与配置是否匹配\n确认所有必要的请求头都已配置\n\n参考文献\nW3C CORS Specification\nMDN Web Docs - Cross-Origin Resource Sharing\nFlask-CORS Official Documentation\n\n","categories":["学习笔记"],"tags":["前后端交互","网站开发"]},{"title":"Swift学习摘记","url":"/2025/04/17/swift/","content":"初见默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用 _ 表示不使用参数标签:\nfunc greet(_ person: String, on day: String) -&gt; String &#123;    return &quot;Hello \\(person), today is \\(day).&quot;&#125;greet(&quot;John&quot;, on: &quot;Wednesday&quot;)\n\n\n参数标签指的是调用时候的名称, 参数名指的是函数内部.\n\n函数是第一等类型，这意味着函数可以作为另一个函数的返回值。\nfunc makeIncrementer() -&gt; ((Int) -&gt; Int) &#123;    func addOne(number: Int) -&gt; Int &#123;        return 1 + number    &#125;    return addOne&#125;var increment = makeIncrementer()increment(7)\n\n\n\n函数也可以作为另一个函数的输入参数:\nfunc hasAnyMatches(list: [Int], condition: (Int) -&gt; Bool) -&gt; Bool &#123;    for item in list &#123;        if condition(item) &#123;            return true        &#125;    &#125;    return false&#125;func lessThanTen(number: Int) -&gt; Bool &#123;    return number &lt; 10&#125;var numbers = [20, 19, 7, 12]hasAnyMatches(list: numbers, condition: lessThanTen)\n\n\n\n可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。\nlet sortedNumbers = numbers.sorted &#123; $0 &gt; $1 &#125;print(sortedNumbers)\n\n\n\n\n\nactor与 class类似, 但是可以序列化访问, 保护共享、可变的数据.\n对象和类构造与析构使用 self.替代 this-&gt;, 使用  init 和  deinit分别声明构造和析构函数:\nclass NamedShape &#123;    var numberOfSides: Int = 0    var name: String    init(name: String) &#123;        self.name = name    &#125;    func simpleDescription() -&gt; String &#123;        return &quot;A shape with \\(numberOfSides) sides.&quot;    &#125;&#125;\n\n\n\n子类如果要重写父类的方法的话，需要用 override 标记:\nclass Square: NamedShape &#123;    var sideLength: Double    init(sideLength: Double, name: String) &#123;        self.sideLength = sideLength        super.init(name: name)        numberOfSides = 4    &#125;    func area() -&gt;  Double &#123;        return sideLength * sideLength    &#125;    override func simpleDescription() -&gt; String &#123;        return &quot;A square with sides of length \\(sideLength).&quot;    &#125;&#125;let test = Square(sideLength: 5.2, name: &quot;my test square&quot;)test.area()test.simpleDescription()\n\n\n\n使用 :className的方法声明父类.\nsuper.init 是用来调用父类（超类）的初始化方法的。当创建一个子类的实例时，子类可能需要初始化一些自己的属性，同时还需要确保父类的属性也被正确初始化。这时就需要使用 super.init 来调用父类的初始化方法，完成父类的初始化过程\n严格的顺序要求: 子类必须先初始化自己的属性，然后调用 super.init，最后才能访问或修改继承来的属性。\n\n\n计算属性普通的计算属性在属性内部使用 &#123;&#125;并加上 return, 可以让访问这个属性的时候, 返回值由结构体的其他属性计算得到.\nstruct Temperature &#123;  var celsius: Double  var fahrenheit: Double&#123;    return celsius *1.8 + 32  &#125;    init(celsius: Double)&#123;    self.celsius = celsius  &#125;&#125;\n\n\n\n此时实例化一个结构体就只需要给出一个属性的值.\nself在上述的Swift代码中是不可或缺的, 因为形参和内部属性的名称相同.\n\n\n使用 getter 和 setter 的计算属性:class EquilateralTriangle: NamedShape &#123;    var sideLength: Double = 0.0    init(sideLength: Double, name: String) &#123;        self.sideLength = sideLength        super.init(name: name)        numberOfSides = 3    &#125;    var perimeter: Double &#123;      // 根据存储属性进行计算        get &#123;            return 3.0 * sideLength        &#125;      // 设置属性        set &#123;            sideLength = newValue / 3.0        &#125;    &#125;    override func simpleDescription() -&gt; String &#123;        return &quot;An equilateral triangle with sides of length \\(sideLength).&quot;    &#125;&#125;var triangle = EquilateralTriangle(sideLength: 3.1, name: &quot;a triangle&quot;)print(triangle.perimeter)triangle.perimeter = 9.9print(triangle.sideLength)\n\n计算属性同样是一个属性, 但是根据调用方式的不同, 有返回和设置两种方式.\ntriangle.perimeter = 9.9print(triangle.perimeter)\n\n\n\nMutating默认情况下, 结构体中的方法不能直接修改结构体的属性. 需要显式声明为 mutating:\nstruct User&#123;  let username:String  var isVisible:Bool = true  var friends: [string] = []    mutating func addFriend(username: String)&#123;    friends.append(username)  &#125;&#125;\n\n\n\n属性监视器使用 willSet 和 didSet。写入的代码会在属性值发生改变时调用，但不包含构造器中发生值改变的情况:\n\n分别可以使用 newValue与 oldValue来表示属性将要改变的值以及改变之前的值.\n\ne.g. 确保三角形的边长总是和正方形的边长相同。\nclass TriangleAndSquare &#123;    var triangle: EquilateralTriangle &#123;        willSet &#123;            square.sideLength = newValue.sideLength        &#125;    &#125;    var square: Square &#123;        willSet &#123;            triangle.sideLength = newValue.sideLength        &#125;    &#125;    init(size: Double, name: String) &#123;        square = Square(sideLength: size, name: name)        triangle = EquilateralTriangle(sideLength: size, name: name)    &#125;&#125;var triangleAndSquare = TriangleAndSquare(size: 10, name: &quot;another test shape&quot;)print(triangleAndSquare.square.sideLength)print(triangleAndSquare.triangle.sideLength)triangleAndSquare.square = Square(sideLength: 50, name: &quot;larger square&quot;)print(triangleAndSquare.triangle.sideLength)\n\n\n\n枚举enum Rank: Int &#123;    case ace = 1    case two, three, four, five, six, seven, eight, nine, ten    case jack, queen, king    func simpleDescription() -&gt; String &#123;        switch self &#123;        case .ace:            return &quot;ace&quot;        case .jack:            return &quot;jack&quot;        case .queen:            return &quot;queen&quot;        case .king:            return &quot;king&quot;        default:            return String(self.rawValue)        &#125;    &#125;&#125;let ace = Rank.acelet aceRawValue = ace.rawValue\n\n\n如果没有设置第一个成员的初始值, 默认从 0 开始;\n缺省值按照递增处理;\ncase之外可以设置方法.\n\n使用 init?(rawValue:) 初始化构造器来从原始值创建一个枚举实例:\nif let convertedRank = Rank（rawValue:3）｛\tlet threeDescription = convertedRank.simpleDescription（）｝\n\n\n\nif let表示可选绑定, 安全地解包可选值\n\n\n解包\nif let解包\n\nif let A = B &#123;  ...&#125;\n\n如果 B不是 nil, 就将其赋值给A, 然后执行 &#123;&#125;内部的语句. \n\n??\n\nvar score : Int ?  = nilprint(score ?? default_score)// 成绩score不是nil, 就将其打印, 否则输出默认的成绩\n\n\n\n对字典进行索引:\n// scores是一个Int数组for ( major, scores) in all_scores &#123;  for score in scores&#123;    ...  &#125;&#125;// 如果key没有使用, 可以直接忽略for( _, socres) in all_scores&#123;  ...&#125;\n\n\n\nswift支持对字典进行更新或者移除的时候, 返回并使用就值:\nif let oldValue = scores.updateValue(100, forKey:&quot;fad&quot;)&#123;  print(..)&#125;else&#123;  ...&#125;if let oldValue = scores.removeValue(forKey: &quot;fad&quot;)&#123;  print(&quot;fad&#x27;s old value was \\(oldValue)&quot;)&#125;\n\n\n@IBAction表示组件交互和代码相绑定(允许在交互的时候执行外部定义的函数);\n@IBOutlet表示允许代码的响应改变组件本身的状态(字体、大小等).\n\n\n\n\n\n\n\n\n\n概念闭包闭包指的是可以在特定位置运行的、不需要名称的函数.\nscene.setOnStartHandler｛ // 闭包的主体｝\n\n\n\n\ntoggle()可以自动切换变量的布尔值.\nButton(&quot;Press Me&quot;) &#123;    isOn.toggle()&#125;\n\n状态属性\n使用 @State在视图之外定义;\n\n当状态属性的值发生改变时, 会自动更新视图中相关的部分.\n\n对于状态对象, 使用 @StateObject来声明.\n\n\n绑定由 @Binding声明将属性连接到其他地方, 允许子视图对属性的修改并同步.\n在属性的前面增加 $，表明会同步修改可信源.\n字符串插值在较长字符串中使用常量、变量或代码表达式，使它们替换为其当前值以求出字符串的值。\n例如，在字符串”Katy ate a \\（fruit）.”中，如果fruit 是带有值 “peach”的变量，那么在求字符串的值时，\\（fruit）由”peach”替换，变为 “Katy ate a peach.”。\n其他自动的动画效果当状态属性发生改变时, 我们希望对应控制的视图元素的变化具有动画效果, 那么可以指定: e.g.\nCircle()    .frame(maxHeight: 200)    .foregroundColor( isOn ? .purple : .mint     .shadow(color:isOn ? .indigo : .orange , radius: 20)    .scaleEffect(isOn ? 1: 0.75)    .animation( .default, value: isOn)\n\n\n其中的 value： isOn表示追踪的状态属性.\n\n在一个视图中创建状态对象,  然后在 app中声明为环境变量并在子视图中使用.\n设计原则principle \n\n需要长按进行交互的组件, 在轻触时ICON放大或者缩小\n\n官方手册学习记录基础知识\nSwift 使用字符串插值将常量或变量的名称作为占位符包含在较长的字符串中，并提示 Swift 将其替换为该常量或变量的当前值。将名称包在括号中，并在左括号前用反斜杠进行转义：\nprint(&quot;The current value of friendlyWelcome is \\(friendlyWelcome)&quot;)// 打印 &quot;The current value of friendlyWelcome is Bonjour！&quot;\n\n不必使用 ;, 但是如果想在一行中编写多个独立语句，则必须使用分号：\nlet cat = &quot;🐱&quot;; print(cat)// 打印 &quot;🐱&quot;\n\n整数边界: 使用 min, max进行访问\nlet minValue = UInt8.min  // minValue 等于 0，类型为 UInt8let maxValue = UInt8.max  // maxValue 等于 255，类型为 UInt8\n\n类型别名: typealias\ntypealias AudioSample = UInt16var maxAmplitudeFound = AudioSample.min// maxAmplitudeFound 现在为 0\n\n元组\n作用: 多个值组合成一个复合值\n\nlet http404Error = (404, &quot;Not Found&quot;)// http404Error 的类型为（Int，String），且等于（404，&quot;Not Found&quot;）\n\n如果只需要元组的部分值，则在分解元组时使用下划线 (_) 忽略不需要的部分\n\n分解元组\nlet (statusCode, statusMessage) = http404Errorprint(&quot;The status code is \\(statusCode)&quot;)// 打印 &quot;The status code is 404&quot;print(&quot;The status message is \\(statusMessage)&quot;)// 打印 &quot;The status message is Not Found&quot;\n\n可以在定义元组时为元组中的各个元素命名：\nlet http200Status = (statusCode: 200, description: &quot;OK&quot;)\n\n然后可以使用元素名访问:\nprint(&quot;The status code is \\(http200Status.statusCode)&quot;)// 打印 &quot;The status code is 200&quot;print(&quot;The status message is \\(http200Status.description)&quot;)// 打印 &quot;The status message is OK&quot;\n\n\n\n也可以直接使用从零开始的索引来访问, e.g. http200Status.0\n\n\n\n\n可选: 存储这种类型的值或者 nil.\n\n提供后备值: ??\nlet name: String? = nillet greeting = &quot;Hello, &quot; + (name ?? &quot;friend&quot;) + &quot;!&quot;print(greeting)// 打印 &quot;Hello, friend!&quot;\n\n\n如果 ?? 之前的值不是 nil, 就会正常解包, 否则选择后备值;\n使用 () 包裹.\n\n\n隐式解包可选: 安全假定一直都有值时使用\nlet possibleString: String? = &quot;An optional string.&quot;let forcedString: String = possibleString! // 需要显式解包let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedString // 隐式解包\n\n\n错误处理函数在声明中包含 throws 关键字，表示它可以抛出错误。调用可以抛出错误的函数时，要在表达式前加上 try 关键字.\nSwift 会自动将错误传播到当前作用域之外，直到它们被 catch 子句处理为止。\ndo &#123;    try canThrowAnError()    // 无错误的情况&#125; catch &#123;    // 抛出错误的情况&#125;\n\n\n细节部分在后面补充\n\n断言和先决条件使用断言进行调试let age = -3assert(age &gt;= 0, &quot;A person&#x27;s age can&#x27;t be less than zero.&quot;)// 该断言失败的原因是 -3 并不 &gt;= 0。\n\n断言的第一个参数是预期的、正确的结果, 如果不满足条件就会显示报错. 但是不会阻止程序继续运行.\n强制执行先决条件当条件有可能为假，但必须为真才能继续执行代码时，请使用先决条件.\n向该函数传递一个计算结果为 true 或 false 的表达式，以及一条在条件结果为 false 时显示的信息:\n// 在下标的实现中...precondition(index &gt; 0, &quot;Index must be greater than zero.&quot;)\n\n\n运算符基本运算符\n与 C 和 Objective-C 中的赋值运算符不同，Swift 中的赋值运算符本身不返回值。以下语句无效：\nif x = y &#123; // 这是无效的，因为 x = y 不返回值。&#125;\n\n\n可以防止不小心使用赋值运算符（&#x3D;） 而非等于运算符（&#x3D;&#x3D;）.\n\n\n基本的四则运算不允许值的溢出.\n\n\n\n[!NOTE]\n在 Swift 中对负数的处理与模运算符有所不同:\n为了确定 a % b 的答案，% 运算符计算以下等式并返回 余数 作为输出：\na` = (`b` x `某个乘数`) + `余数\n\n其中 某个乘数 是 b 在 a 中能容纳的最大倍数。\n9 % 4    // 等于 1-9 % 4   // 等于 -1\n\n数值的正负号可以使用前缀 - 切换，称为一元负号运算符.\n\n中间没有任何空格.\nlet three = 3let minusThree = -three       // minusThree 等于 -3\n\n\n\n元组的计算\n前提: 如果两个元组具有相同的类型和相同数量的值，则可以比较它们.\n规则: \n元组是从左到右逐个值进行比较的，直到比较发现两个不相等的值为止。\n这两个值将进行比较，并且该比较的结果决定了整个元组比较的结果。\n如果所有元素都相等，那么这两个元组本身就相等。\n\n\n\n\n[!NOTE]\n只有当给定的运算符可以应用于各自元组中的每个值时，元组才能与该运算符进行比较.\n\n(&quot;blue&quot;, false) &lt; (&quot;purple&quot;, true)  // 错误，因为 &lt; 不能比较布尔值\n\n\n\n空合并运算符a ?? b的结果与下面的运算相同:\na != nil ? a! : b\n\n\n\n区间运算\n闭区间运算符（a...b）定义了一个从 a 到 b 的范围，包括 a 和 b 的值。a 的值不能大于 b;\n\n在需要使用所有值的情况下很有用\n\ne.g.\nfor index in 1...5 &#123;    print(&quot;\\(index) 乘以 5 等于 \\(index * 5)&quot;) &#125;\n\n\n半开区间运算符（a..&lt;b）定义了一个从 a 到 b 但不包括 b 的范围.\n\n对于处理从基数 0 开始的列表（如数组）时特别有用，因为它可以计数到列表长度（但不包括列表长度）.\n\ne.g.\nlet names = [&quot;Anna&quot;, &quot;Alex&quot;, &quot;Brian&quot;, &quot;Jack&quot;] let count = names.countfor i in 0..&lt;count &#123;    print(&quot;第 \\(i + 1) 个人叫 \\(names[i])&quot;)&#125;\n\n\n闭区间运算符有一种替代形式，用于一直延伸到尽可能远的区间 —— 例如，一个包含从索引 2 到数组末尾所有元素的区间。\nfor name in names[2...] &#123; print(name) &#125;// Brian// Jack\n\n半开区间运算符也有一种只写最后一个值的单侧形式\nfor name in names[..&lt;2] &#123; print(name) &#125;// Anna// Alex\n\n逻辑运算\n[!NOTE]\nSwift 逻辑运算符 &amp;&amp; 和 || 遵循从左到右的结合顺序，这意味着带有多个逻辑运算符的复合表达式会首先评估最左边的子表达式.\n\n控制流协议\n如果类需要继承, 需要将父类写在所有的协议之前\n不能在协议定义中为方法参数指定默认值。\n协议也可以要求遵循协议的类型 实现指定的构造器, 和协议内部的方法一样, 不需要写花括号和构造期的实体\n如果是类, 必须在构造函数的开头加上 required修饰符. 这是为了确保所有继承的子类也提供这个构造函数的实现, 从而确保遵守协议;\n但是如果一个类被声明为了 final, 也就是无法被继承, 那么就不需要 required的声明\n\n\n\n协议的基本用法协议可以规定属性类型以及属性被操作的权限, 通常和类、结构体和枚举进行绑定, 作为一种强制的约束.\nprotocol Tax&#123;  var national: Double &#123; get &#125;   var individual: Double&#123; set get&#125;&#125;\n\n同样可以在协议中使用 mutating 来声明一个改变自身属性的方法:\nprotocol Tax&#123;  var national: Double &#123; get &#125;   var individual: Double&#123; set get&#125;    mutating func changeTax(newValue: Double)&#125;\n\n\n需要注意的是, 结构体内部的方法如果要修改自身属性, 也需要声明 mutating, 但是类则不需要额外的声明.\nstruct Taxas: Tax&#123;   var national: Double  var individual: Double    mutating func changeTax(newValue: Double)&#123;    national = newValue  &#125;&#125;\n\n补充协议\n使用 , 连接不同的协议\n\nextension可以为协议的函数设置默认方法, 就不需要继续在每一个类、结构体或枚举中重新定义\n\n同样可以补充数据类型\nextension Int &#123;  var abs: Int &#123;    get &#123;      if self &gt;= 0 &#123;        return self      &#125;else&#123;        return -self      &#125;    &#125;  &#125;&#125;print((-3).abs);// 3\n\n\n\n有条件地遵循协议让 Array 类型只要在存储遵循 TextRepresentable 协议的元素时，就遵循 TextRepresentable 协议:\nextension Array: TextRepresentable where Element: TextRepresentable &#123;    var textualDescription: String &#123;        let itemsAsText = self.map &#123; $0.textualDescription &#125;        return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot;    &#125;&#125;let myDice = [d6, d12]print(myDice.textualDescription)// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;\n\n\n\n扩展里声明协议遵循当一个类型已经遵循了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空的扩展来让它遵循该协议:\nstruct Hamster &#123;    var name: String    var textualDescription: String &#123;        return &quot;A hamster named \\(name)&quot;    &#125;&#125;extension Hamster: TextRepresentable &#123;&#125;\n\n\n\nError handling系统提供了 Error协议用于错误处理, 主动给予错误的捕捉情况.\n使用方法:\n\n定义遵循相关协议的枚举类型, 作为错误的类型;\n定义可能抛出错误的函数;\n使用 do...catch块来结构化地处理错误.\n\ne.g.\n// 定义一个错误类型，遵循 Error 协议enum PasswordError: Error &#123;    case tooShort    case tooWeak&#125;// 一个函数，可能抛出错误func validate(password: String) throws &#123;    if password.count &lt; 6 &#123;        throw PasswordError.tooShort    &#125;    if password == &quot;123456&quot; &#123;        throw PasswordError.tooWeak    &#125;&#125;// 使用 do-catch 捕捉错误do &#123;    try validate(password: &quot;123456&quot;)    print(&quot;密码验证通过 ✅&quot;)&#125; catch PasswordError.tooShort &#123;    print(&quot;❌ 密码太短，请至少使用 6 个字符&quot;)&#125; catch PasswordError.tooWeak &#123;    print(&quot;❌ 密码太弱，不能使用简单的序列&quot;)&#125; catch &#123;    print(&quot;❌ 发生未知错误：\\(error)&quot;)&#125;\n\n\n\nthrows：在函数声明中标注该函数会抛出错误;\ntry：在调用可能抛出错误的函数时使用.\n\n\n其他的协议CaseIterable用于获取枚举的属性个数, 从而进行遍历.\nenum Status:CaseIterable&#123;    case low,middle,high            mutating func change()&#123;        switch self&#123;        case .high:            self = .low        case .low:            self = .middle        case .middle:            self = .high        &#125;    &#125;        func ptr()&#123;        print(&quot;Current Status is \\(self)&quot;)    &#125;&#125;var status = Status.lowfor _ in 0..&lt;Status.allCases.count&#123;    status.ptr()    status.change()&#125;\n\n\nfor _ in 0..&lt; 当中的 _表示忽略遍历时候的循环变量的值.\n\n闭包闭包的简化推导相当于匿名函数与 lambda.  接下来从普通函数的写法开始简化:\n\n普通函数: \nfunc changeSign(op: Double) -&gt; Double &#123;    return -op&#125;var operation: (Double) -&gt; Doubleoperation = changeSignlet result = operation(4.0) // result = -4.0\n\n将函数的定义下移:\nvar operation: (Double) -&gt; Doubleoperation = (op:Double) -&gt; Double &#123; return -op&#125;let result  = operation(4.0)\n\n将｛ 提前，并在原来的位置添加 in\nvar operation:(Double) -&gt; Doubleoperation = &#123;(op: Double) -&gt; Double  in return -op&#125;...\n\n系统可以推断类型, 所以根据输入的类型简化返回值的类型定义\nvar operation:(Double) -&gt; Doubleoperation = &#123;(op: Double)   in return -op&#125;...\n\n可以进一步省略传入的类型\nvar operation:(Double) -&gt; Doubleoperation = &#123; (op) in return -op&#125;...\n\n省略返回的标记 return:\nvar operation:(Double) -&gt; Doubleoperation = &#123; (op) in  -op&#125;...\n\n最后, 我们可以直接用 $0等替代传入的参数, 也就是省略了参数的名称!\nvar operation:(Double) -&gt; Doubleoperation = &#123; -$0 &#125;...\n\n\n\n闭包的常见使用e.g. \n\nTrailing Closure当闭包是函数的最后一个参数时，\nlet result = applyTwice(3, operation: &#123; $0 * 2 &#125;)\n\n可以改写成:\nlet result = applyTwice(3) &#123; $0 * 2 &#125; // result = 12\n\n\n\n慕课学习杂记something\n去官网学习新出现的技术\n\ncodeML\n张克俊老师?\n\n\n函数也可以赋值给变量\n\n\n省略外部参数名\n外部参数名: 在函数调用的时候使用, 提高可读性;\n内部参数名: 在函数体的内部使用\n\n如果如此定义:\nfunc greet(person name: String)&#123;  print(&quot;Hello , \\(name)&quot;)&#125;\n\n那么在调用的时候必须显示声明外部参数名:\ngreet( person: &quot;Alice&quot;)\n\n\n\n如果我们希望省略外部参数名, 就可以在定义函数的时候用 _来代替:\nfunc greet(_ name: String)&#123;  ...&#125;\n\n\n\n高阶函数我们可以让函数作为另一个函数的输入参数:\nfunc addTwoInts( _ a: Int, _ b: Int) -&gt; Int&#123;  return a+b&#125;var mathFunction = addTwoInts// 高阶函数func printMathResults（_ mathFunction: (Int, Int）-&gt; Int, _ a: Int, _ b: Int)&#123;  var result = mathFunction(a,b)  print(result)&#125;// 调用printMathResults（addTwoInts， 3,5）\n\n\n注意函数作为参数的时候, 类型的定义就是输入类型和返回类型, 也是用 , 来分隔不同的参数.\n\n\n内置的库AVFoudation: 音频播放 \n\n\n枚举内部也可以设置方法; \n\n结构体本身不需要构造函数(因为swift存在对于结构体的默认构造) , 但是如果结构体内部的属性存在这样的属性:\n\n它可能是枚举内部的方法, 跟枚举的属性有关, 可能使用了 switch来根据枚举属性赋值.\n\nenum Type&#123;  case Cike  case ...    func blood()-&gt; Double&#123;    switch self&#123;      case .Cike: return 10      case .Fashi: return ...      ...    &#125;  &#125;  &#125;struct Card &#123;  var country: Country  vat type: Type  var blood: Double    init (country: Country, type: Type)&#123;    self.country = country    self.type = type;    blood = type.blood  &#125;&#125;\n\n\n\n结构体和枚举属于 值类型, 如果赋值的时候进行拷贝操作;\n\n如果结构体声明为 let, 即使属性是变量, 那么也无法修改内部的属性,\n\n\n类是引用类型, 赋值的时候使得左值指向了同样的内存区域, 也就是信息保持一致, 更改同步\n\n如果我们将类声明为常量, 相当于cpp的指针常量, 也就是说类内部的属性可以更改, 但是无法修改这个量指向的内存区域.\n\n\n\n计算属性访问的时候动态计算得到.\n下面通过一个矩形的例子来说明:\nstruct Point &#123;  var x = 0.0  var y = 0.0&#125;struct Size&#123;  var width = 0.0  var height = 0.0&#125;struct Rect&#123;  var origin = Point()  var size = Size()  var center: Point&#123;    get&#123;      let centerX = origin.x + (size.width / 2)      let centerY = orgin.y + (size.height /2 )      return Point(x: centerX, y: centerY)    &#125;    set(newCenter)&#123;      origin.x = newCenter.x - (size.width / 2)      origin.y = newCenter.y - (size.height / 2)    &#125;  &#125;&#125;\n\n上述完成了结构体的计算属性的定义, 其中 get部分也可以优化为:\nget&#123;\tPoint(x: origin.x + (size.width / 2),        y: orgin.y + (size.height /2 ) )&#125;\n\n\n这是因为, 如果 get 部分只存在一个表达式,  就会自动将其返回, 不需要显式声明 return关键字.\n\n然后可以如此应用:\nvar currCenter = rectElement.centerrectElement.center = Point(x:20, y:50)\n\n\n\nset提供了语法糖, 也就是可以直接访问oldValue 和  newValue, 因此我们可以如此改写:\nset&#123;  origin.x = newValue.x - (size.width / 2)  origin.y = newValue.y - (size.height / 2)&#125;\n\n\n\n\n[!NOTE]\n对于只读的计算属性, 由于不存在 set, 我们可以直接在花括号内定义返回内容.\n\n\n\n声明 static , 表示这个属性或者方法属于整个类型而非某个实例. 此时相应的, 我们使用 &lt;tyepName&gt;.&lt;strtic attribute&gt;的方式来访问.\n\n子面量本身是不可修改的, 下面的拓展中, 如果写作  var someInt = 3.square()就会报错\n\n\nextension Int&#123;    mutating func square()&#123;        self = self * self    &#125;&#125;var someInt = 3someInt.square()\n\n\n\n\n控制器存在5种状态:\n\n未加载\n将要出现\n出现\n将要消失\n已经消失\n\nAPP的状态:\n\n\nUiSceneDelegate用于响应基于 scene 的生命周期事件.\n可以使用属性的 didset来便捷地检测变化并快速修改:\nvar score = 0&#123;  didSet&#123;    self.gameScoreLabel.text = &quot;Score: \\(score)&quot;  &#125;&#125;\n\n\n\n\nviewController是新的页面;\nview是视图, 可以叠加在页面上.\nUIAlertController组件相当于警示的弹窗组件\n\n作图和绘画CG\nCGFloat用于二维坐标系中的坐标数据:\n\nlet coor_x = CGFloat(10.5)\n\n\nCGPoint(x: .. , y:...)\n\nCGSize 包含width和height属性的结构体;\n\nCGRect包含点和尺寸的矩形\nstruct CGRect&#123;  var origin: CGPoint  var size: CGSize&#125;\n\n\n其他属性\n\ne.g.\nvar minX: CGPointvar midY: CGPointintersects(CGRect) -&gt; Bool // 判断是否存在交集contains(CGPoint) -&gt; Bool // 是否包含点.\n\n\n\n最小单元是 Point而非像素点.\nbound表示视图内部允许绘制的区域:\nvar bounds: CGRect // 也就是一个矩形\n\nframe\t视图在父视图中的位置:\nvar frame: CGRect\n\n\n\n自定义视图绘制自定义视图通常通过创建一个自定义的 UIView 子类，并重写 draw(_:) 方法来实现.\nplayGround中的实例:\nimport UIKitimport PlaygroundSupportclass CustomView: UIView &#123;    override init(frame: CGRect) &#123;        super.init(frame: frame)        self.backgroundColor = .white // 设置背景颜色    &#125;    required init?(coder: NSCoder) &#123;        fatalError(&quot;init(coder:) has not been implemented&quot;)    &#125;    override func draw(_ rect: CGRect) &#123;        guard let context = UIGraphicsGetCurrentContext() else &#123; return &#125;        // 绘制一个圆形        context.setFillColor(UIColor.blue.cgColor) // 设置填充颜色        context.fillEllipse(in: rect) // 绘制填充的圆        // 绘制一个矩形        context.setStrokeColor(UIColor.black.withAlphaComponent(0.6).cgColor) // 设置能见度        context.setLineWidth(5)        context.stroke(rect.insetBy(dx: 10, dy: 10)) // 绘制矩形边框，留出间距    &#125;&#125;// 创建自定义视图实例let customView = CustomView(frame: CGRect(x: 0, y: 0, width: 200, height: 200))// 显示在 Playground 的 live viewPlaygroundPage.current.liveView = customView\n\n\n\n\ntouchesBegan–WWDC\nSCNVector3是三维向量\nDispathchQueue表示创建一个异步的进程\n\n传感器\n加速度的方向伴随手机的头部旋转保持不变;\n以 g 为描述单位;\n面向使用者的方向是 z 轴.\n\n\n陀螺仪\n记录对应用三个轴\nroll, pitch, yaw\n\n\n\n动画结绳记事\n操作演示.\n\n按住 ctrl将视图中的组件拖放到代码中.\n\n右下角的几个功能:\n\n约束;\n选择视图\n\n\nctrl + option + cmd + enter 快速显示代码区域\n\n组件使用\n\n50:00 左右介绍了两种类型和交互\n\n\n按住optional然后 hover 在类上, 可以显示对应的基础操作.\n\n可选值的本质是枚举类型!\nenum Optional&lt;T&gt;&#123;  case none  case some(&lt;T&gt;)&#125;\n\n画图和动画\n\ncoreML\n\n在项目中显示Md格式:\n/*:...*/\n\n选择在运行时隐藏实际存在的代码:\n//#-hidden-codeimport PlaygroundSupport...//#-end-hidden-code\n\nSwift UI\n慕课的链接\nby now\nSixD: 开箱即用的UI设计等.\n术语表\n\nAR\nhelpful links\n官方文档\n\n动画缩放变换NavigationLink&#123;  BraceletEditor(bracelet)  .navigationTransitionStyle(  .zoom(  \tsourceID:bracelet.id,  \tin:braceletList  \t)  )&#125;label:&#123;  BraceletPreview(bracelet)&#125;.matchedTansitionSource(\tid:bracelet.id,  in:braceletList)\n\n\n\n\n\nSymbol 6动画\n使用 晃动 在复杂的UI中提示可交互性.\n旋转动画来表示正在进行的进程\n\n基本语法磨砂效果VStack &#123;&#125;.frame(width: 200, height: 200).background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20, style: .continuous))\n\n\n\n搜索栏\n状态管理:\n// 存储搜索文本@State private var searchText = &quot;&quot;// 可选：跟踪搜索是否处于活动状态@State private var isSearching = false\n\n数据过滤模式\n// 基本过滤计算属性模板var filteredItems: [ItemType] &#123;    if searchText.isEmpty &#123;        return originalItems    &#125; else &#123;        return originalItems.filter &#123; item in            // 根据需要自定义过滤条件            item.name.localizedCaseInsensitiveContains(searchText) ||            item.description.localizedCaseInsensitiveContains(searchText)        &#125;    &#125;&#125;// 处理嵌套数据结构的过滤模板var filteredNestedItems: [ParentType] &#123;    if searchText.isEmpty &#123;        return originalParentItems    &#125; else &#123;        return originalParentItems.compactMap &#123; parent in            let matchedChildren = parent.children.filter &#123; child in                child.name.localizedCaseInsensitiveContains(searchText)            &#125;                        if matchedChildren.isEmpty &#123;                return nil            &#125; else &#123;                // 创建包含匹配子项的新父项                return ParentType(id: parent.id, name: parent.name, children: matchedChildren)            &#125;        &#125;    &#125;&#125;\n\n搜索UI中的实现:\nNavigationStack &#123;    List &#123;        // 使用过滤后的数据源        ForEach(filteredItems) &#123; item in            // 列表项视图        &#125;    &#125;    .navigationTitle(&quot;标题&quot;)    .searchable(text: $searchText, prompt: &quot;搜索提示文字&quot;)    // 可选：添加搜索建议    .searchSuggestions &#123;        ForEach(suggestions, id: \\.self) &#123; suggestion in            Text(suggestion).searchCompletion(suggestion)        &#125;    &#125;&#125;\n\n左右适应的外边距通过 HStack与  space实现卡片的自适应扩展, 同时利用 .frame(maxwidth:...)来设置一个最大的卡片宽度\nHStack&#123;    Spacer(minLength: 10)      Text(item.description)        .padding()        .background(Color(.systemGray6))        .overlay(            RoundedRectangle(cornerRadius: 10) // 10为圆角半径，可调整                .stroke(Color.gray, lineWidth: 1) // 边框颜色和宽度        )        .clipShape(RoundedRectangle(cornerRadius: 10))    // 保证背景和边框都圆角    .frame(maxWidth: 400) // 最大宽度限制    Spacer(minLength: 10)&#125;\n\nSpacer(minLength: 10) 表示保证自己不会小于 minLength. \n上述的 Spacer会压缩卡片的内容, 如果希望直接设置卡片在父容器中的左右外边距, 应该在卡片的内部使用 padding:\nText(item.description)    .padding(.horizontal, 24) // 卡片内容内边距    .padding(.vertical, 12)    .background(Color(.systemGray6))    .overlay(        RoundedRectangle(cornerRadius: 10)            .stroke(Color.gray, lineWidth: 2)    )    .clipShape(RoundedRectangle(cornerRadius: 10))    .padding(.horizontal, 20) // 整个卡片距离父视图左右20pt\n\n\n\n全局统一样式@mainstruct MyApp: App &#123;    var body: some Scene &#123;        WindowGroup &#123;            ContentView()                .buttonStyle(ShadowButtonStyle(radius: 10))        &#125;    &#125;&#125;\n\n\n\n参数标签和参数名\n参数标签用于函数调用时;\n参数名用于函数内部的参数名称.\n\ne.g.:\nfunc greet(person atName: String) &#123;    print(&quot;Hello, \\(atName)!&quot;)&#125;greet(person: &quot;Alice&quot;) // 输出：Hello, Alice!\n\n\n\n也可以使用 _来省略调用时的参数标签:\nfunc greet(_ name: String) &#123;    print(&quot;Hello, \\(name)!&quot;)&#125;greet(&quot;Alice&quot;) // 输出：Hello, Alice!\n\n\n\n\n\nAlertswift UI中的弹窗提示同样通过本地的 @State变量来实现:\n@State private var showingPaymentAlert = false....alert(&quot;Order confirmed&quot;, isPresented: $showingPaymentAlert) &#123;    // add buttons here&#125; message: &#123;    Text(&quot;Your total was \\(totalPrice) – thank you!&quot;)&#125;\n\n设置按钮来改变可见的状态:\nButton(&quot;Confirm order&quot;) &#123;    showingPaymentAlert.toggle()&#125;\n\n\n\n自定义绑定我们也可以使用 Binding 类型手动创建绑定，该类型可以提供自定义 get 和 set 闭包，以便在读取或写入值时运行。\nForeachForEach(item.restrictions) &#123; restriction in    Text(restriction)&#125;\n\n此时, 要求 item.restrictions 具有可唯一标识的 id 字段.\n\n如果内容本身就是唯一标识, 比如说遍历的内容是字符串数组, 那么可以如此声明:\nForEach(item.restrictions, id: \\.self) &#123; restriction in    Text(restriction)&#125;\n\nSpacer()用于填充剩余的空间\n\n使用 offset(x:.., y:...)来调节位置, 左上角是原点.\n\n环境变量\n作用: 用于存储独立于视图的、长期存在的数据;\n\ne.g.\n// App.swift@StateObject var order = Order()\n\n@StateObject 属性包装器负责在应用程序的整个生命周期中保持对象处于活动状态。\n\n需要在创建视图结构体的时候传递:\nWindowGroup &#123;    ContentView()        .environmentObject(order)&#125;\n\n为了让swift知道什么时候更新视图, 常用的是声明 @Published属性包装器——足以让它更新任何正在监视更改的 SwiftUI 视图.\n\n同时声明对应的对象遵循可观测协议: ObservableObject.\n\n\n我们可以使用 @EnvironmentObject来访问环境中的共享数据, 也就是传递上一步已经在父视图中创建和管理的对象.\ne.g.\nclass UserData: ObservableObject &#123;    @Published var name: String = &quot;John&quot;&#125;struct ContentView: View &#123;    @StateObject private var userData = UserData()    var body: some View &#123;        ChildView().environmentObject(userData)    &#125;&#125;struct ChildView: View &#123;    @EnvironmentObject var userData: UserData    var body: some View &#123;        Text(userData.name)    &#125;&#125;\n\n\n\n使用 @State来声明简单的本地值——比如整数和字符串.\n\n建议将其声明为 private, e.g.\n@State private var paymentType = &quot;Cash&quot;\n\n菜单视图为了将菜单视图存放在一个选项卡当中, 我们需要新建一个视图, 用来作为容器:\nstruct MainView: View &#123;    var body: some View &#123;        TabView &#123;            ContentView()                .tabItem &#123;                    Label(&quot;Menu&quot;, systemImage: &quot;list.dash&quot;)                &#125;            OrderView()                .tabItem &#123;                    Label(&quot;Order&quot;, systemImage: &quot;square.and.pencil&quot;)                &#125;        &#125;    &#125;&#125;\n\n\n页面级别的切换.\n\n使用枚举与子页面的内容分区:\nimport SwiftUIstruct ContentView: View &#123;    enum Section &#123;        case cats        case dogs    &#125;    @State private var selectedTab = Section.cats    var body: some View &#123;        TabView(selection: $selectedTab) &#123;            Tab(&quot;Cats&quot;, systemImage: &quot;cat&quot;, value: .cats) &#123;                Button(&quot;Go to Dogs&quot;) &#123;                    selectedTab = .dogs                &#125;            &#125;                        Tab(&quot;Dogs&quot;, systemImage: &quot;dog&quot;, value: .dogs) &#123;                Button(&quot;Go to Cats&quot;) &#123;                    selectedTab = .cats                &#125;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n合适的修饰符\n图像自动调节尺寸:\nImage(item.mainImage)    .resizable()    .scaledToFit()\n\n设置阴影.shadow(color: .black.opacity(0.2),         radius: 15, x: 0, y: 10)\n\n\n\n为按钮设置动画struct ContentView: View &#123;    @State private var showingWelcome = false    var body: some View &#123;        VStack &#123;            Toggle(&quot;Toggle label&quot;, isOn: $showingWelcome.animation())            if showingWelcome &#123;                Text(&quot;Hello World&quot;)            &#125;        &#125;    &#125;&#125;\n\n可以进一步设置, 比如弹簧的渐入渐出:\nToggle(&quot;Toggle label&quot;, isOn: $showingWelcome.animation(.spring()))\n\n\n\n基本操作快捷键\nctrl按住后点击  VStack可以快速地将其添加到 ZStack当中\n颜色的设置需要通过 ZStack来实现.\n\n\noption可以显示当前类的介绍\n\n\n学习路线:\n\n学习 Swift 基础语法\n上手 SwiftUI 基础控件（Text、Button、Image、List、NavigationStack 等）\n学会使用 @State、@Binding 等状态管理属性\n尝试做一个简单的 App（比如 ToDo List、小笔记本）\n慢慢接触更复杂的功能，比如动画、数据持久化（CoreData）、网络请求（URLSession）\n\n第二周：SwiftUI 基础入门目标：\n\n理解 SwiftUI 的基本概念和架构。\n掌握常用的 SwiftUI 视图和修饰符。\n\n\nSwiftUI 概述：\n声明式语法与传统 UIKit 的区别\nSwiftUI 的视图层次结构\n\n\n常用视图组件：\nText、Image、Button 等基本控件的使用\n视图修饰符的应用，如 .font()、.foregroundColor()、.padding() 等\n\n\n布局系统：\n使用 HStack、VStack 和 ZStack 进行视图布局\nSpacer 和 Divider 的使用\n\n\n\n推荐资源：\n\nHacking with Swift 的 100 天 SwiftUI： 100 Days of SwiftUI\nAppCoda 的 SwiftUI 教程： AppCoda - Mastering SwiftUI\n\n第三周：状态管理与数据绑定目标：\n\n理解并应用 SwiftUI 的状态管理机制。\n掌握数据绑定和视图更新的原理。\n\n学习内容：\n\n状态管理：\n使用 @State 管理视图内部状态\n使用 @Binding 在父子视图之间传递状态\n使用 @ObservedObject 和 @EnvironmentObject 管理复杂数据模型\n\n\n数据绑定：\n双向绑定的实现\n数据变化如何驱动视图更新\n\n\n\n推荐资源：\n\nSwiftUI 官方文档： SwiftUI Documentation\nDesign+Code 的 SwiftUI 教程： Design+Code - SwiftUI for iOS 17\n\n第四周：导航、列表与高级交互目标：\n\n掌握 SwiftUI 中的导航和列表视图。\n实现复杂的用户交互和动画效果\n\n学习内容：\n\n导航与路由：\n使用 NavigationView 和 NavigationLink 实现页面导航\n传递数据到下一个视图\n\n\n列表视图：\n使用 List 展示数据集合\n自定义列表行和支持删除、移动操作\n\n\n动画与手势：\n添加基本动画效果\n处理手势交互，如拖拽、缩放等\n\n\n\n推荐资源：\n\nRaywenderlich 的 SwiftUI 教程： Raywenderlich - SwiftUI Apprentice\nBig Mountain Studio 的免费电子书： SwiftUI Views Quick Start\n\n","categories":["编程语言"]},{"title":"跨组件渲染","url":"/2025/02/16/%E5%89%8D%E5%90%8E%E7%AB%AF/%E8%B7%A8%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93/","content":"React Context 实现跨组件实时渲染的实践分析为什么需要跨组件实时渲染？在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：\n\n用户在一个组件中编辑内容，其他组件需要立即看到更新\n多个组件需要共享同一份数据\n需要避免通过层层组件传递 props（即所谓的 prop drilling）\n\n这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。\n最小实现示例以下是实现跨组件实时渲染的最简代码结构：\n// 1. 定义 Context 类型interface SharedContextType &#123;  data: any;  updateData: (newData: any) =&gt; void;&#125;// 2. 创建 Contextconst SharedContext = createContext&lt;SharedContextType | undefined&gt;(undefined);// 3. 创建 Provider 组件export function SharedProvider(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;  const [data, setData] = useState&lt;any&gt;(null);  const updateData = useCallback((newData: any) =&gt; &#123;    setData(newData);  &#125;, []);  return (    &lt;SharedContext.Provider value=&#123;&#123; data, updateData &#125;&#125;&gt;      &#123;children&#125;    &lt;/SharedContext.Provider&gt;  );&#125;// 4. 创建自定义 Hookexport function useShared() &#123;  const context = useContext(SharedContext);  if (!context) &#123;    throw new Error(&#x27;useShared must be used within SharedProvider&#x27;);  &#125;  return context;&#125;\n\n实际应用分析让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：\n// 1. 定义具体的数据结构interface HistoryItem &#123;  id: string;  content: string;  mermaidCode: string;  timestamp: number;&#125;// 2. 实现带有持久化的 Context Providerexport function HistoryProvider(&#123; children &#125;: &#123; children: React.ReactNode &#125;) &#123;  const [selectedHistory, setSelectedHistory] = useState&lt;HistoryItem | null&gt;(null);  const [historyList, setHistoryList] = useState&lt;HistoryItem[]&gt;([]);  // 数据持久化  useEffect(() =&gt; &#123;    if (selectedHistory) &#123;      localStorage.setItem(&#x27;selectedHistory&#x27;, JSON.stringify(selectedHistory));    &#125;  &#125;, [selectedHistory]);  // 实时更新方法  const addHistory = async (content: string, mermaidCode: string) =&gt; &#123;    const historyItem: HistoryItem = &#123;      id: Date.now().toString(),      content,      mermaidCode,      timestamp: Date.now()    &#125;;    setHistoryList(prev =&gt; [historyItem, ...prev]);  &#125;;  return (    &lt;HistoryContext.Provider      value=&#123;&#123;        selectedHistory,        setSelectedHistory,        addHistory,        historyList      &#125;&#125;    &gt;      &#123;children&#125;    &lt;/HistoryContext.Provider&gt;  );&#125;\n\n在这个实际例子中，我们可以看到几个关键点：\n\n状态定义：使用 TypeScript 接口明确定义了数据结构，确保类型安全\n状态持久化：通过 useEffect 监听状态变化并保存到 localStorage\n实时更新：通过 setHistoryList 确保状态更新后所有使用该 Context 的组件都能即时获得更新\n\n当组件需要使用这些共享状态时，只需：\nfunction HistoryViewer() &#123;  const &#123; selectedHistory &#125; = useHistory();    return (    &lt;div&gt;      &#123;selectedHistory &amp;&amp; (        &lt;div&gt;&#123;selectedHistory.content&#125;&lt;/div&gt;      )&#125;    &lt;/div&gt;  );&#125;\n\n这种模式的优势在于：\n\n避免了 props 的层层传递\n实现了组件间的解耦\n确保了状态更新的实时性\n提供了类型安全的数据访问\n\n参考资料\nReact Context Documentation\nTypeScript Handbook\nReact Hooks API Reference\n\n","tags":["前端"]},{"title":"响应式设计","url":"/2025/01/20/%E5%89%8D%E5%90%8E%E7%AB%AF/%E5%93%8D%E5%BA%94%E5%BC%8F%E8%AE%BE%E8%AE%A1/","content":"所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:\n\n第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；\n另一个作用是当图片无法加载时，页面需要显示的替代文本。\n\n\n\n注意嵌套的形式.e.g\n&lt;p&gt;See more &lt;a href=&quot;https://freecatphotoapp.com&quot;&gt;cat photos&lt;/a&gt; in our gallery.&lt;/p&gt;\n\n\n\n\n要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。\n&lt;p&gt;See more &lt;a href=&quot;https://freecatphotoapp.com&quot; target = &quot;_blank&quot;&gt;cat photos&lt;/a&gt; in our gallery.&lt;/p&gt;\n\n\n\n锚元素除了能将文本转化为链接, 还可以将 图片 转换为链接:\n&lt;a hreg = &quot;https://freecatphotoapp.com&quot;&gt;    &lt;img src=&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg&quot; alt=&quot;A cute orange cat lying on its back.&quot;&gt;&lt;/a&gt;\n\n\n\n\nsection 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。\n\n\n\n列表:\n\n无序列表: ul;\n有序列表:ol;\n列表项: li;\n\n\n\n\nfigure 元素代表自包含的内容，允许将图像与标题相关联;figcaption 元素用于添加标题以描述 figure 元素中包含的图像。\n&lt;figure&gt;  &lt;img src=&quot;image.jpg&quot; alt=&quot;A description of the image&quot;&gt;  &lt;figcaption&gt;A cute cat&lt;/figcaption&gt;&lt;/figure&gt;\n\n\n\n\n\n使用 em 使得文字为斜体;\nstrong 加深文字;\n\n\n\n\nform 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。\n\naction属性指定表单数据发送的位置;\n\n&lt;form action=&quot;/submit-url&quot;&gt;&lt;/form&gt;\n\n\ninput 允许通过多种方式从Web表单中收集数据:\n\n与img一样为空元素——不需要结束标签;\n使用 type 属性创建多种输入;\ntext : 文本;\nradio: 可以使用单选按钮;\ncheckbox: 表单使用 复选框;\n\n\n使用name属性使得区分提交的数据;\n令多个单选按钮具有 相同 的name, 使得在选中其中一个按钮时自动取消另外的单选按钮;\n形成name = value形式的属性对进行提交;\n\n\n\n&lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name = &quot;indoor-outdoor&quot;&gt; Indoor&lt;/label&gt;&lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name = &#x27;indoor-outdoor&#x27;&gt; Outdoor&lt;/label&gt;\n\nplaceholder 中为 占位符 文本, 用于提示输入框中输入的信息;\nrequired属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;\n\n&lt;input type=&quot;text&quot; name = &quot;catphotourl&quot;&gt;\n\n\n\n\nbutton 用于创建可点击的按钮:\n\n单击没有任何属性的表单按钮的默认行为会将表单提交到表单的 action 属性中指定的位置;\n由于input和button为 内联 元素, 即使相隔书写也会显示在同行:\ntype的submit明确了为 可提交按钮;\n\n&lt;button type = &quot;submit&quot;&gt;Submit&lt;/button&gt;\n\n\n\nlabel 元素用于帮助将 input 元素的文本与 input 元素本身关联起来\n&lt;label&gt;&lt;input type=&quot;radio&quot;&gt; cat&lt;/label&gt;&lt;!-- 点击单词 &quot;cat&quot; 也将选择 radio 按钮。 --&gt;\n\n\n\nid用于标识特定的HTML元素\n\n\nfieldset 元素用于在 Web 表单中将相关的输入和标签组合在一起:\n\n块级元素，这意味着它们出现在新的一行上。\nlegend 元素充当 fieldset 元素中内容的标题。\n\n&lt;fieldset&gt;        &lt;legend&gt; Is your cat an indoor or outdoor cat?&lt;/legend&gt;          &lt;label&gt;&lt;input id=&quot;indoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;indoor&quot;&gt; Indoor&lt;/label&gt;          &lt;label&gt;&lt;input id=&quot;outdoor&quot; type=&quot;radio&quot; name=&quot;indoor-outdoor&quot; value=&quot;outdoor&quot;&gt; Outdoor&lt;/label&gt;&lt;/fieldset&gt;\n\n\n\n还可以使用for属性将文本直接嵌套在label当中, 同时设置input的id与上述的for属性相同, 从而实现文本与元素相关联的效果:\n&lt;input id=&quot;loving&quot; type=&quot;checkbox&quot;&gt; &lt;label for = &quot;loving&quot;&gt; Loving &lt;/label&gt;\n\n\n\n默认选中的按钮: checked\n&lt;input checked type=&quot;radio&quot; name=&quot;meal&quot; value=&quot;breakfast&quot;&gt; Breakfast\n\nchecked属性无需额外赋值.\n\n\n\nfooter素用于定义文档或章节的页脚:\n\n脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.\n\n\n\nhead 相关\n\n存放 $\\underline{元数据}$ 不会实际显示在html中的数据;\ntitle 元素决定了浏览器在页面的标题栏或选项卡中显示的内容;\n&lt;link rel = &quot;stylesheet&quot; href = &quot;styles.css&quot;&gt; 将CSS文件链接到当前的HTML\n\nelse:\n\n&lt;!DOCTYPE html: 声明满足最新版本html相关设置的要求;\nmeta是空元素; &lt;meta charset = &quot;utf-8&quot;&gt;;\n\n\n\n选择器:\n\nid选择器\n\n#cat &#123;  width: 250px;&#125;\n\nclass选择器\n\n.class-name, .other-class &#123;  styles&#125;\n\nclass类中元素的选择\n\n.item p&#123;  /* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */  display: inline-block; &#125;\n\n伪元素\n\n/* 已访问链接后设置为灰色 */a:visited&#123;  color: grey;&#125;/* 悬浮时的变色 */a:hover &#123;  color: brown;&#125;/* 点击时的状态设置 */a:active&#123;  color: white;&#125;\n\n\nmargin-left : auto;margin-right: auto;\n\n使得普通元素在父级元素的空间内 水平居中\n\n\n\narticle是一个语义化标签:\n\n用于表示文档、页面或应用中的独立的、完整的内容单元;\n清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;\n内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.\n\n与其他类似标签的区别:\n\ndiv: 粹的容器，没有语义，常用于布局;\nsection: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;\narticle: 示一个可以独立存在的内容单元.\n\n\n\n/* 设置备用字体 */h1, h2 &#123;  font-family: Impact, serif;&#125;\n\n\n","categories":["学习笔记"],"tags":["杂记"]},{"title":"JavaScript","url":"/2025/01/09/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/","content":"\nJavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「料理的加护」下, 尽可能将JS处理得更加可口一些)\n\n创建JS代码块变量var or let?var先于let的产生, 后者是现代版本的JS中新的关键字.\n使用var, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是let并不适用.\nmyName = \"Chris\";function logName() {  console.log(myName);}logName(); //输出\"Chris\"var myName = \"Aniya\";logName(); //输出\"Aniya\"\n\n除此之外, 可以使用var前后声明相同的变量, 这并不会报错:\nvar myName = \"Chris\";var myName = \"Bob\";\n\n而let只能声明一次:\nlet myName = \"Chris\";myName = \"Bob\";\n\n因此, 在代码编写中应尽量多使用let而非var, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.\n变量命名的规则与C语言类似, 建议以 字母、数字、下划线 组成的标识符来命名变量.\n\n不可用_开头, 因为可能被JS设计为特殊的含义;\n不可用数字开头, 否则引发错误;\n大小写敏感;\n建议采用 小写驼峰命名法 ,即小写整个命名的第一个字母然后大写剩下单词的首字符;\n避免使用保留字, 比如var,let,for等.\n\n变量类型let myAge = 20 ;// 数字let dolphinGoodbye = \"So long and thanks for all the fish\"; // 字符串let test = 6 &lt; 3; //boolean//数组类型let myNameArray = [\"Chris\", \"Bob\", \"Jim\"];let myNumberArray = [10, 15, 40];//对象类型let dog = { name: \"Spot\", breed: \"Dalmatian\" };\n\n对象类型的访问与结构体相似, dog.name;\n\n在上面的几种变量类型中, 我们都采用let关键字声明变量, 这体现了JS是一种 动态类型语言 ,即无需指定变量包含的数据类型.\n同时, 这也意味着我们可以像python一样对同一个变量先后赋值不同类型的值:\nlet myNumber = \"500\";typeof myNumber;// 输出 'string'myNumber = 500; typeof myNumber;//输出'number'\n\n\n函数\n提升 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.\n\nexampleFunction();function exampleFunction() {  console.log(\"函数内\");  console.log(x);}\n\n由于 提升 的存在, 上述的函数调用不会出错.\n\n默认参数在编写函数时, 可以通过在参数名称后添加=, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。\nfunction greeding(name = \"my friend\") {    console.log(`Hello, ${name}!`);}hello(); //Hello, my friend!hello(\"world\"); //Hello, world!\n\n\n\n事件处理函数的默认接受值是event:\n&lt;button&gt;onclick&lt;/button&gt;&lt;p&gt;nothing here&lt;/p&gt;&lt;script&gt;btn = document.querySelector(\"button\")para = document.querySelector(\"p\")btn.onclick = click;function click(string){  console.log(\"clicked!\")  para.textContent = string;}&lt;/script&gt;\n\n上述的btn在点击之后调用函数click, 该函数需要一个参数string, 由于btn.onclick = click;的绑定方式, 我们无法指定传参的值, 因此点击之后的para的内容显示为: [object PointerEvent];\ntextContent是属性而非方法, 因此采用赋值实现;\n\nbtn.onclick = function click(string) {  console.log(\"clicked!\")  para.textContent = \"You have clicked the button!\";}\n\n将上述的绑定方式如此改写, 可以在btn外对string进行赋值, 然后点击按钮可以传入指定参数供后续处理.\n\n箭头函数在了解箭头函数的作用之前, 需要先介绍 匿名函数:\nfunction myFunction() {  alert(\"你好\");}// 匿名函数(function () {  alert(\"你好\");});\n\n正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.\n\n如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:\nfunction logKey(event) {  console.log(`You pressed \"${event.key}\".`);}textBox.addEventListener(\"keydown\", logKey);\n这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:\ntextBox.addEventListener(\"keydown\", function (event) {  console.log(`You pressed \"${event.key}\".`);});\n\n只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.\n\n而箭头函数则是在此情况下更简洁的函数定义方式:\ntextBox.addEventListener(\"keydown\", (event) =&gt; {  console.log(`You pressed \"${event.key}\".`);});//如果函数只接受一个参数, 也可以省略参数周围的括号textBox.addEventListener(\"keydown\", event =&gt; {  console.log(`You pressed \"${event.key}\".`);});\n\n如果只包含一行的return,则可以忽略{}和return关键字:\nconst originals = [1, 2, 3];const doubled = originals.map(item =&gt; item * 2);console.log(doubled); // [2, 4, 6]\n\nitem =&gt; item * 2等价于:\n\nfunction doubleItem(item) {  return item * 2;}\n\n一个实例&lt;input id=\"textBox\" type=\"text\" /&gt;&lt;div id=\"output\"&gt;&lt;/div&gt;\nconst textBox = document.querySelector(\"#textBox\");const output = document.querySelector(\"#output\");textBox.addEventListener(\"keydown\", (event) =&gt; {  output.textContent = `You pressed \"${event.key}\".`;});\n通过监听输入框的keydown事件, 输出按下的键盘按键.\n函数作用域和冲突作用域 指当前的执行上下文, 在其中的值和表达式可以被访问. \n\n全局作用域: 脚本模式运行所有代码的默认作用域;\n模块作用域: 模块模式中运行代码的作用域;\n函数作用域: 由函数创建的作用域\n\n和C语言相似, 在函数外部let定义的变量, 以及const定义的常量可以在函数内部访问.\n如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:\n&lt;!-- Excerpt from my HTML --&gt;&lt;script src=\"first.js\"&gt;&lt;/script&gt;&lt;script src=\"second.js\"&gt;&lt;/script&gt;&lt;script&gt;  greeting();&lt;/script&gt;\n\n如果两个JS文件都定义了greeting函数, 则只有第一个文件中的函数才会被调用.\n\n数据类型数字和操作符大部分与C语言相同, 概括需要注意的差异:\n\nJS当中只有一种数字类型 – number, 对于整型或者浮点数的初始化得到的量, 由typeof均得到number;\n算术运算符: 求幂为**;\n常量无法使用自增或自减,好像也是C语言的 忘了\n===表示严格等于, !==表示不等于;\n同时存在==和!=来判断是否相等, 但是它们只是测试 值 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用===和!==来避免类型不一致的错误.\n\n\n\n字符串创建字符串\nlet myString = \"A string\";const constString = myString;console.log(constString);//A string\n可以使用单引号,双引号和反引号来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:\nconst single = '单引号';const double = \"双引号\";const backtick = `反引号`;\n\n反引号包裹的字符串称为模板字符串, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:\n\n可以嵌入 JavaScript;\n可以声明多行的模板字面量.\n\n字符串的拼接字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 串联法:\nconst name = \"克里斯\";const greeting = `你好，${name}`;console.log(greeting); // \"你好，克里斯\"\n\n在模板字面量中用${}包装JS的变量或者表达式.\n\nconst one = \"你好，\";const two = \"请问最近如何？\";const joined = `${one}${two}`;console.log(joined); // \"你好，请问最近如何？\"\n\n连接2个变量.\n\nconst song = \"青花瓷\";const score = 9;const highestScore = 10;const output = `我喜欢歌曲《${song}》。我给它打了 ${  (score / highestScore) * 100} 分。`;console.log(output); // \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"\n\n在模板字面量的${}内部包含表达式.\n\n\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\nconst greeting = \"你好\";const name = \"克里斯\";console.log(greeting + \"，\" + name); // \"你好，克里斯\"\n\n多行字符串模板字符串会保留源代码中的换行符，因此可以编写跨越多行的字符串:\nconst newline = `终于有一天，你知道了必须做的事情，而且开始……`;console.log(newline);/*终于有一天，你知道了必须做的事情，而且开始……*/\n\n如果希望用普通的字符串得到等效的输出, 必须在字符串中包含\\n,而非直接跨行:\nconst newline = \"终于有一天，\\n你知道了必须做的事情，而且开始……\";console.log(newline);/*终于有一天，你知道了必须做的事情，而且开始……*/\n\n显示引号\n转义  通过在符号前加上反斜杠\\, 可以转义字符串中的特殊字符,包括字符串中的引号:\n\nconst bigmouth = 'I\\'ve got no right to take my place…';\n\n换用其他字符: 在字面量内用不同于包裹字符串的引号:\n\nconst goodQuotes1 = 'She said \"I think so!\"';const goodQuotes2 = `She said \"I'm not going in there!\"`;\n\n\n常用方法对于字符串对象实例,其常用的方法:\n\n.length: 获取字符串的长度;\n[]: 返回字符串中对应索引的字符, 索引同样从0开始;\n.indexOf(\"\"): 查找子字符串\ninput: 希望查找的子字符串;\noutput: 子字符串开始的下标(如果不存在则返回-1);\n\n\n.slice(indedxStart, indexEnd): 截取字符串\ninput: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;\noutput: 截取的子字符串;\n\n\n\n更多的slice知识:\n\n标准化负值 如果索引是个负数, 取index+str.length进行标准化;\n如果indexStart大于str.length, 返回空字符串;\n如果标准化负值之后, indexStart大于indexEnd, 也返回空字符串;\n\n\n.toLowerCase() &amp; .toUpperCase(): 转换字符串中的所有字符为小写或大写;\n.replace(original, new): 替换字符串中original子字符串为new;\n此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.\n\n\n\nCases利用 indexOf 和 slice 方法, 获取新字符串:\n\ninput: \"str3\"三位长字符串+\"...\"(无关字符串)+\";\"+strLast(剩余字符串);\noutput: \"str3\"+\";\"+strLast\n\nvar stations = ['MAN675847583748sjt567654;Manchester Piccadilly',                'GNF576746573fhdg4737dh4;Greenfield',                'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street',                'SYB4f65hf75f736463;Stalybridge',                'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'];for(var i = 0; i &lt; stations.length; i++){    var input = stations[i];    var str3 = input.slice(0,3);    var strLast = input.slice(input.indexOf(\";\")+1); //indexOf获取;位置    var output = str3 + \";\" + strLast;}\n\n\n通过 indexOf 根据子字符串筛选字符串数组:\n\ninput: 可能包含 Christmas 的字符串数组;\noutput: 包含 Christmas 的字符串数组;\n\nvar list = document.querySelector('.output ul');list.innerHTML = '';var greetings = ['Happy Birthday!',                 'Merry Christmas my love',                 'A happy Christmas to all the family',                 'You\\'re all I want for Christmas',                 'Get well soon'];for(var i = 0; i &lt; greetings.length; i++) {  var input = greetings[i];  if(greetings[i].indexOf('Christmas') !== -1) {    var result = input;    var listItem = document.createElement('li');    listItem.textContent = result;    list.appendChild(listItem);  }}\n\n数字与字符串相互转换非常神奇, 在JS当中, 数字和字符串可以直接通过函数Number()和String()进行转换, 与C语言不同.\nconst myString = \"123\";const myNum = Number(myString);console.log(typeof myNum);// numberconsole.log(myNum);// 123\n\nconst myNum2 = 123;const myString2 = String(myNum2);console.log(typeof myString2);// stringconsole.log(myString2);// \"123\"\n\n对于浮点数同样成立.\n\n前后拼接使用+将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:\nconst name = \"Front \";const number = 242;const combine = name + number;console.log(combine); //Front 242console.log(typeof(combine));  //string\n\n数组\n存储任意类型元素–字符串，数字，对象，变量，另一个数组;\n可以 混合 元素类型:\n\nlet random = [\"tree\", 795, [0, 1, 2]];\n\n像访问字符串一样, 利用索引访问数组元素;\n多维数组 包含数组的数组结构称为~\n\nsplit()\n作用: 将一个字符串根据给定的字符分隔为字符串数组;\n\nlet myData = \"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\";let myArray = myData.split(\",\");console.log(myArray); // [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]\n\njoin()split的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:\nlet myNewString = myArray.join(\",\");myNewString;\n\ntoString()与join方法相似, 但是无法自定义分隔符, 默认为,:\nlet dogNames = [\"Rocket\", \"Flash\", \"Bella\", \"Slugger\"];dogNames.toString(); //Rocket,Flash,Bella,Slugger\n\npush &amp; poppush()方法可以将1或多个元素添加到数组的 末尾:\n\n将会直接改写原来的数组,不需要重新赋值;\n该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);\n\nlet myArray = [1, 2, 3];let newLength = myArray.push(4, 5,\"string\");console.log(myArray); // [1, 2, 3, 4, 5, \"string\"]console.log(newLength); // 6\n\n使用.pop()从数组中删除最后一个元素:\nmyArray.pop(); //\"string\"console.log(myArray); // [1, 2, 3, 4, 5]\n\n方法调用返回值就是删除的元素本身;\n直接对原始数组操作并赋值, 不需要另外的赋值操作;\n\n\nshift &amp; unshift:在功能上分别与push和pop相同, 但是作用于数组的开始位置.\n\n条件语句JS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:\n天气预报&lt;label for=\"weather\"&gt;选择今天的天气：&lt;/label&gt;&lt;select id=\"weather\"&gt;  &lt;option value=\"\"&gt;--作出选择--&lt;/option&gt;  &lt;option value=\"sunny\"&gt;晴天&lt;/option&gt;  &lt;option value=\"rainy\"&gt;雨天&lt;/option&gt;  &lt;option value=\"snowing\"&gt;雪天&lt;/option&gt;  &lt;option value=\"overcast\"&gt;阴天&lt;/option&gt;&lt;/select&gt;&lt;p&gt;&lt;/p&gt;\n\nlable当中的for标签与select标签的id属性对应, 用于关联两个标签.\n\nconst select = document.querySelector(\"select\");const para = document.querySelector(\"p\");select.addEventListener(\"change\", setWeather);function setWeather() {  const choice = select.value;  switch (choice) {    case \"sunny\":      para.textContent = \"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\";      break;    case \"rainy\":      para.textContent = \"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\";      break;    case \"snowing\":      para.textContent =        \"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\";      break;    case \"overcast\":      para.textContent =        \"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\";      break;    default:      para.textContent = \"\";  }}\n\n\n通过querySelector方法获取select和p标签;\n然后为select标签添加事件监听器, 当内容改变时触发 change 事件, 同时调用setWeather函数;\n进而通过 switch 语句处理不同天气的情况, 并设置相应的文字内容;在线网页示例:simple-switch\n\n\n事件介绍什么是事件? \n\n用户选择、点击或者光标悬停在某一元素;\n用户在键盘中按下某个按键;\n网页结束加载;\n…\n\n事件处理器 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.\n处理点击事件以点击事件为例, 介绍html与js如何进行事件处理的交互:\n&lt;button&gt; 改变颜色 &lt;/button&gt;\nconst btn = document.querySelector(\"button\");function random(number){  return Math.floor(Math.random()*(number+1));  }btn.addEventListener(\"click\", ()=&gt;{  const rndCol = `rgb(${random(255)},${random(255)},${random(255)})`;  document.body.style.backgroundColor = rndCol;})\n\nMath.random()方法生成一个介于[0,1)之间的随机数;\n*(number+1)之后利用向下取整的方法Math.floor()将其转换为整数, 范围为[0,number];\n假如输入的number为4, 则random(4)的结果可能为0, 1, 2, 3, 4中的一个;假设输入的number为3.6, 则输出的结果还是0~4中的整数.\n\n\nrndCol = `rgb(${random(255)},${random(255)},${random(255)}) 采用的是在模板字符串内部使用${}调用函数变量的方法.\n\naddEventListener()adEventListener方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.\n通过EventTarget.adddEventListener()的方法, 将指定的监听器注册到对象上, 具体的语法如下:\naddEventListener(type, listener);addEventListener(type, listener, options);addEventListener(type, listener, useCapture);\n\ntype: 事件类型, 如click, mouseover, mouseout, keydown, keyup等;\nlistener: 事件处理函数, 该函数将在事件发生时被调用;\n包括 回调函数 以及 实现了 EventListener 接口的对象;\n\n\noptions: 可选参数, 用于配置事件监听器的行为;\n可以为单个事件添加多个事件监听器.\n\n\n\nlistener回调函数 简单来说, ~指的是当某个事件发生时被调用的一段代码.\n\n是一个函数, 但是只有等到特定的事件发生时才会执行.\n\n实现了 EventListener 接口的对象:\n\n特点: 以对象作为listener, 对象中具有名为handleEvent()的方法;\n作用: \n将事件处理封装到一个对象当中, 可以更好地组织代码;\n便于在对象中保存更多的状态信息;\n\n\n\nconst listenerObject = {    count: 0,    handleEvent(event) {        this.count++;        console.log(`事件类型是：${event.type}，已触发 ${this.count} 次`);    }};const button = document.querySelector('button');button.addEventListener('click', listenerObject);\n\noptions一个指定有关 listener 属性的可选参数对象.\nCapture\n含义:\n\n一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;\n默认为false, 表示只有在冒泡阶段才触发.\n\n\n区别:\n\ncapture和useCapture实际上指的都是 监听器是否在捕获阶段触发 的布尔值.\n捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.\n\n\n后来DOM的规范更新时引入了options参数, 此后capture取代了useCapture的作用.\n如果addEventListener的第三个参数不指定对象, 只有布尔值, 那么默认是在设置useCapture\n\n\n\n\n可以先查看事件传播的阶段来辅助理解不同的阶段.\n\nOnce\n含义:\n一个布尔值，表示 listener 在添加之后最多只调用一次;\n默认为false, 表示可以多次调用.\n\n\ne.g.\n\nchild.addEventListener('click', () =&gt; {    console.log('子元素 - 目标阶段');},{once: true});\n\nonce属性被设置为true, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.\n\nPassive\n含义:\n\n一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();\n\n\n作用:\n\n明确不会在listener中不会调用preventDefault()方法, 即不会阻止浏览器的默认行为;\n此时, 浏览器可以直接渲染默认行为的结果, 无需等待listener的执行与默认行为的检查, 从而提高了性能.\n\n\nNotice:\n\n如果设置passive为true, 则listener当中不可出现preventDefault()方法, 否则会报错.\n\n\n\ne.g.\ndocument.addEventListener('wheel',()=&gt;{\tevent.preventDefault();  console.log(\"scrolling\");},{passive: false});\n\nwheel事件的默认行为是滚动页面;\nevent.preventDefault();表示会阻止鼠标滚动带来的页面滚动;\n\ndocument.addEventListener('wheel',()=&gt;{  console.log(\"scrolling\");},{passive: true});\n\n明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.\n\ndocument.addEventListener('wheel',()=&gt;{  event.preventDefault();  console.log(\"scrolling\");},{passive: true});\n\npassive的设置与listener内部矛盾, 将会报错.\n\nSignal用于有条件地移除事件监听器, 具体使用参见可被移除的监听器.\n事件传播的阶段\n捕获阶段 : 事件从根节点开始向目标节点传播;\ne.g. 点击事件从document开始传播, 经过html,body直到目标元素.\n\n\n目标阶段阶段 : 事件到达目标元素;\n冒泡阶段 : 事件从目标元素开始沿着DOM树向上传播.\n\nCase&lt;div id=\"parent\"&gt;  parent  &lt;div id=\"child\"&gt;child&lt;/div&gt;&lt;/div&gt;\nconst parent = document.querySelector('#parent');const child = document.querySelector('#child');parent.addEventListener('click', () =&gt; {    console.log('父元素 - 冒泡阶段');});parent.addEventListener('click', () =&gt; {    console.log('父元素 - 捕获阶段');}, { capture: true });child.addEventListener('click', () =&gt; {    console.log('子元素 - 目标阶段');});\n上述的child被包裹在parent内部.\n\n当点击parent时将会显示:\n\n\"父元素 - 捕获阶段\"\"父元素 - 冒泡阶段\"\n\n由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;\n\n\n当点击child时将会显示:\n\n\"父元素 - 捕获阶段\"\"子元素 - 目标阶段\"\"父元素 - 冒泡阶段\"\n\nchild是整个事件流的目标元素, 所以触发时机介于二者之间.\n\nNotice\n如果将div换成button, 则点击child时可能只会显示 目标 阶段的输出.\n\n这是因为, 不同浏览器对于button元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段\n\n\nevent.stopPropagation();加入该咒语代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:\n\n\nparent.addEventListener('click', () =&gt; {    console.log('父元素 - 捕获阶段');    event.stopPropagation();}, { capture: true });\n\n此时, 点击parent时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.\n\n可被移除的监听器&lt;table id=\"outside\"&gt;  &lt;tr&gt;    &lt;td id=\"t1\"&gt;one&lt;/td&gt;  &lt;/tr&gt;  &lt;tr&gt;    &lt;td id=\"t2\"&gt;two&lt;/td&gt;  &lt;/tr&gt;&lt;/table&gt;\n// 为 table 添加可被移除的事件监听器const controller = new AbortController();const el = document.getElementById(\"outside\");el.addEventListener(\"click\", modifyText, { signal: controller.signal });// 改变 t2 内容的函数function modifyText() {  const t2 = document.getElementById(\"t2\");  if (t2.firstChild.nodeValue === \"three\") {    t2.firstChild.nodeValue = \"two\";  } else {    t2.firstChild.nodeValue = \"three\";    controller.abort(); // 当值变为 \"three\" 后，移除监听器  }}\n\n\nAbortController是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;\nsignal属性是一个AbortSignal对象, 用于控制监听器的移除;\ncontroller.abort()方法用于移除监听器;\n当t2的内容变为”three”时, 移除监听器, 使得modifyText函数不再执行. 此后, 点击t2不会触发modifyText函数.\n\n\n具体的构造步骤:\n\n创建一个AbortController实例: const controller = new AbortController();\n在事件监听器内的参数中添加signal: controller.signal选项;\n在需要移除监听器的地方调用controller.abort()方法;\n\n\n我们也可以直接使用removeEventListener()方法来移除事件监听器:\nremoveEventListener(type, listener);removeEventListener(type, listener, options);removeEventListener(type, listener, useCapture);\n\n\n\nNotices:\n如果同一个对象上存在2个事件监听器, 且仅在useCapture参数存在差异, 那么需要先后2次调用removeEventListener()方法才能完全移除其事件监听器;\n如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;\ntype,listener参数必须完全匹配才能移除事件监听器;\n对于options参数:\n字段相同: 一定可以移除;\n字段不同: 需要与默认值false匹配才可以移除.\n\n\n\n\n\nelement.addEventListener(\"mousedown\", handleMouseDown, { passive: true });element.removeEventListener(\"mousedown\", handleMouseDown, { passive: true }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, { capture: false }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, { capture: true }); // 失败element.removeEventListener(\"mousedown\", handleMouseDown, { passive: false }); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, false); // 成功element.removeEventListener(\"mousedown\", handleMouseDown, true); // 失败\n\n\n添加与移除的结合使用:\nconst body = document.querySelector(\"body\");const clickTarget = document.getElementById(\"click-target\");const mouseOverTarget = document.getElementById(\"mouse-over-target\");let toggle = false;function makeBackgroundYellow() {  body.style.backgroundColor = toggle ? \"white\" : \"yellow\";  toggle = !toggle;}clickTarget.addEventListener(\"click\", makeBackgroundYellow, false);mouseOverTarget.addEventListener(\"mouseover\", () =&gt; {  clickTarget.removeEventListener(\"click\", makeBackgroundYellow, false);});\n\n\n使用匿名函数在上述html例子下:\n// 改变 t2 内容的函数function modifyText(new_text) {  const t2 = document.getElementById(\"t2\");  t2.firstChild.nodeValue = new_text;}// 用匿名函数为 table 添加事件监听器const el = document.getElementById(\"outside\");el.addEventListener(  \"click\",  function () {    modifyText(\"four\");  },  false,);\n通过匿名函数封装代码, 将参数传入函数modifyText, 使得函数可以被调用.\n使用箭头函数// 改变 t2 内容的函数function modifyText(new_text) {  var t2 = document.getElementById(\"t2\");  t2.firstChild.nodeValue = new_text;}// 用箭头函数为 table 添加事件监听器const el = document.getElementById(\"outside\");el.addEventListener(  \"click\",  () =&gt; {    modifyText(\"four\");  },  false,);\n通过=&gt;{}形式的箭头函数简化代码书写.\n\n比较匿名与箭头匿名函数与箭头函数在此处的应用基本相同, 但是在this的指向上有所不同:\n\n匿名函数与其他普通的JS函数:this指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为undefined);\n\nfunction sayHello() {  console.log(this); // 在非严格模式下，this 指向 window}sayHello();\n\n\n箭头函数的this继承自外部作用域, 即调用该方法的对象.\n\nconst obj = {  name: \"ZJU\",  greet: function () {    console.log(this.name); // this 指向 obj  },};obj.greet(); // 输出：ZJU\n\n\ne.g.\n\nconst obj = {  name: \"ZJU\",  getNameWithAnonymous: function () {    return function () {      console.log(this.name);    };  },  getNameWithArrow: function () {    return () =&gt; {      console.log(this.name);    };  },};const anonymousFn = obj.getNameWithAnonymous();anonymousFn(); // 输出：undefinedconst arrowFn = obj.getNameWithArrow();arrowFn(); // 输出：ZJU\n\n进一步完善.\n\n事件对象事件对象 在事件处理函数的内部, 以固定指定名称出现的参数, 例如event,e,evt. 它被自动传递给事件处理函数，以提供额外的功能和信息。\ne.target始终是对 事件刚刚发生的元素 的引用\n表达式和运算符new() 用来创建对象实例的一个关键字. \n\n作用: 调用 一个 构造函数, 并返回一个由该构造函数创建的对象实例.\n\n语法new constructornew constructor()new constructor(arg1)new constructor(arg1, arg2)new constructor(arg1, arg2, /* …, */ argN)\n\n如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即new foo 等价于 new foo();\n构造函数内部的this将被绑定到新建的对象实例上;\n\n\ne.g.\n\nfunction Car(color, brand) {  this.color = color;   // 将 color 赋值给新对象  this.brand = brand;   // 将 brand 赋值给新对象}const myCar = new Car(\"red\", \"Toyota\");console.log(myCar.color); // 输出 \"red\"console.log(myCar.brand); // 输出 \"Toyota\"\n\n使用new()的步骤:\n\n定义构造函数;\n使用new()并传入构造函数的参数;\n将返回的对象实例赋值给一个变量;\n\n新增属性\n为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:\n\ncar1.color = \"black\" //为car1新增color属性\n\n\n\n添加共享属性到构造函数中的prototype:\n\nfunction Car() {}car1 = new Car();car2 = new Car();console.log(car1.color); // undefinedCar.prototype.color = \"原色\";console.log(car1.color); // '原色'car1.color = \"黑色\";console.log(car1.color); // '黑色'console.log(Object.getPrototypeOf(car1).color); // '原色'console.log(Object.getPrototypeOf(car2).color); // '原色'console.log(car1.color); // '黑色'console.log(car2.color); // '原色'\n\n\n此处的构造函数名为Car, 因此通过Car.prototype可以访问到构造函数的原型对象;\ngetPrototypeOf 表示获取对象的原型对象, 因此此处均为最初定义的 原色.\n\n\nnew.target函数通过new.target属性可以判断是否通过new关键字调用, 即构造.\n\n如果函数是正常调用, 则返回undefined;\n\n如果函数是通过new调用, 返回被调用的构造函数.\n\ne.g.\n\n\nfunction Car(color) {  if (!new.target) {    // 以函数的形式被调用。    return `${color}车`;  }  // 通过 new 被调用。  this.color = color;}const a = Car(\"红\"); // a 是“红车”const b = new Car(\"红\"); // b 是 `Car { color: \"红\" }`\n\n对象类型与实例对象类型 通过构造函数可以创建一个对象类型:\nfunction Car(make, model, year) {  this.make = make;  this.model = model;  this.year = year;}\n\n对象实例 通过使用new()方法, 由对象类型构造一个对象实例:\nconst myCar = new Car(\"鹰牌\", \"Talon TSi\", 1993);\n\n类与new在JS当中, 类 必须 通过new调用.\n\n可以优先阅读类相关的知识\n\n\ne.g.\n\nclass Animal {  //构造函数  constructor(name) {    this.name = name;  }  //实例方法  greet() {    console.log(`你好，我的名字是${this.name}`);  }}\n对于上述的类, 必须使用如下的调用方式:\nconst animal = new Animal(\"Dog\"); // 正常\n而下面这样类似于普通函数的调用方式会抛出错误:\nAnimal(\"Cat\"); // TypeError:  Class constructor Animal cannot be invoked without 'new'\n\n\n在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:\nanimal.greet(); // 输出 \"你好，我的名字是Dog\"\n\n\n下面给出与普通函数的区别:\nfunction Car(model) {  this.model = model;}const car = new Car(\"Toyota\"); // 正常Car(\"Honda\"); // 不抛出错误，但 this 会指向全局对象.const anotherCar = Car(\"cat\"); //此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.\n总结:\n\n以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;\n如果以new方法构造得到对象实例, 依旧正常.\n\n\n补充默认行为默认行为 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.\n\n比如存在以下的默认行为:\n滚动事件：触摸屏上滑动手指，页面会滚动;\n拖拽文件到浏览器：浏览器会尝试加载文件;\n点击链接 (&lt;a href=\"...\"&gt;)：跳转到指定的 URL;\n\n\n\n阻止默认行为 使用 event.preventDefault() 方法可以阻止事件的默认行为.\n\ne.g: 阻止链接跳转\n\ndocument.querySelector('a').addEventListener('click', function(event) {    event.preventDefault(); // 阻止点击链接时的默认行为    console.log('链接被点击，但没有跳转');});\n\n\n作用:\n通过阻止默认行为, 可以实现自定义逻辑.\n\n\n\nthis\nthis可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;\nthis 指向的是当前函数的调用者，而不是函数内部定义的变量.\n\n\n\n\ne.g.\n\nconst obj = {    a: \"a in the obj\",    b: \"b in the obj\",    f: function() {        const b = \"b in the function\"; // 函数作用域        console.log(this.b); // 访问 this.b    }};const b = \"b outside of the func\";obj.f();\n\n此处的f\n\n函数上下文中的this\nthis参数的值取决于函数如何被调用, 而不是函数如何被定义.\n\n// 对象可以作为第一个参数传递给 'call' 或 'apply'，// 并且 'this' 将被绑定到它。const obj = { a: \"Custom\" };// 使用 var 声明的变量成为 'globalThis' 的属性。var a = \"Global\";function whatsThis() {  return this.a; // 'this' 取决于函数如何被调用}whatsThis(); // 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'obj.whatsThis = whatsThis;obj.whatsThis(); // 'Custom'; 'this' 参数被绑定到 obj\n\n同样是调用函数whatsThis(), 但是this参数被绑定到不同的对象上, 导致返回值不同;\n在非严格模式下, this参数默认指向globalThis, 即全局对象;\n对于典型函数, this指向函数访问的对象;\n\n\ne.g.\n\nconst obj = {    b: \"b in the obj\",    f: function() {        const b = \"b in the function\"; // 函数作用域        console.log(this.b); // 访问 this.b    }};const b = \"b outside of the func\";obj.f();\n\n此处f作为obj对象的方法被调用, 因此普通函数的this指向obj.\n\n\ne.g. 直接调用的普通函数this指向全局:\n\nconst obj = {    a: \"a in the obj\",    f: function() {        const funcA = function () { return this.a }; // 普通函数，this 由调用方式决定        console.log(funcA()); // 访问 this.a    }};var a = \"a in the global\";obj.f(); // \"a in the global\"\n\n\n此处的funcA并没有类似于作为对象的属性调用(obj.funcA()), 因此其this指向全局作用域(window), 输出undefined, 而是直接调用的形式, 因此其this指向全局作用域.\n\n\n对this传值使用call()以及apply()方法可以将this绑定到其他对象上.\ncall()\n形式: func.call(thisArg, arg1, arg2, ...)\ne.g:\n\nfunction add(c, d) {  return this.a + this.b + c + d;}const o = { a: 1, b: 3 };// 第一个参数被绑定到隐式的 'this' 参数；// 剩余的参数被绑定到命名参数。add.call(o, 5, 7); // 16\n\napply()\n形式: func.apply(thisArg, [argsArray])\ne.g:\n\nfunction add(c, d) {  return this.a + this.b + c + d;}const o = { a: 1, b: 3 };// 第一个参数被绑定到隐式的 'this' 参数；// 第二个参数是一个数组，其成员被绑定到命名参数。add.apply(o, [10, 20]); // 34\n\nbind()\n形式: f.bind(someObject);\n作用: \n创建一个新的函数(需要重新赋值), 具有与f相同的函数体和作用域;\n新函数的this被 永久地 绑定到someObject, 不随调用方式的变化而变化.\n\n\n限制: \nbind无法多次生效. 即对函数fbind得到的g, 无法继续用bind得到期望的h;\n\n\ne.g. 多次bind:\n\nfunction f() {  return this.a;}const g = f.bind({ b: \"azerty\" });console.log(g()); // undefinedconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！console.log(h()); // undefinedconst o = { a: 37, f, g, h };console.log(o.a, o.f(), o.g(), o.h()); // 37 37 undefined undefined\n\n\n由于bind只能对一个原始函数作用, 因此由f得到的g无法继续由bind绑定this得到期望的h, 此处h的this依旧是{b: \"azerty\"}, 因此在输出对象a时显示undefined;\no.f()的调用是普通函数的调用, 因此其this继承自对象o, 输出37;\n\n\n\ne.g. 对象\n\nfunction f() {  return this.a + \" \" + this.c;}const g = f.bind({ b: \"azerty\" , c:\"ccc\"});console.log(g()); // \"undefined ccc\"const h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！console.log(h()); // \"undefined ccc\"const o = { a: 37, f, g, h };console.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty\n\n\nbind绑定的this是永久覆盖, 而非简单叠加;\n由于bind绑定的this不随者调用方式的变化而变化, 因此即使处于对象o当中, g,h依旧不会输出o中的a.\n\n\n箭头函数中的this使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。\n普通函数:\nconst a = \"a in the global\";const foo = function () {return this.a};const obj = { a: \"a in the obj\", f: foo};console.log(obj.f()); // \"a in the obj\"\n\ncall()、 apply()、 bind() 无法改变箭头函数的this(但是call与apply的其他参数可以正常传递:\nconst foo = ()=&gt; this.a;const obj = { a: \"a in the obj\", f: foo.bind({a:\"a in the bind\"}) // 显式绑定 this 到 obj, 但是无法生效};console.log(obj.f()); // undefined\n\n换成普通函数则输出a in the obj.\n\n\n全局作用域\n\nvar a = \"a in the global\";const foo1 = () =&gt; this.a;const obj = {\ta: \"a in the obj\",\tf: ()=&gt; a};console.log(obj.f());\n\n作用域作用域 指当前的执行上下文, 在其中的值和表达式可以被访问. \n\n全局作用域: 脚本模式运行所有代码的默认作用域;\n模块作用域: 模块模式中运行代码的作用域;\n函数作用域: 由函数创建的作用域\n块级作用域: 由let或const声明的变量的作用域.(对于var无效);\n\n{  var x = 1;}console.log(x); // 1{  const x = 1;}console.log(x); // undefined\n\nNotices:\n\n对象本身并不会创建作用域, 只是一个键值对的集合;\n箭头函数也不会创建自己的作用域, 而是 继承 外层作用域中的this;\n\n变量与作用域\nvar在全局作用域中声明时会成为 全局对象 (window或global)的属性;\nlet和const即使在全局作用域中声明, 也不会成为全局对象的属性;\n\nvar a = \"1\";let b = \"2\";window.a; // \"1\"window.b; // undefined\n\n因此, 建议在全局作用域中不要使用var声明变量, 而使用let或const声明变量. 从而避免导致意外的覆盖和冲突.\n\n函数与作用域普通函数普通函数和匿名函数的作用域继承自其定义时的作用域.\nconst obj = {    a: \"a in the obj\",    insideObj: {        g: function() {            return this.a; // 普通函数，this 动态绑定到 insideObj        }    },    f: function() {        return this.a; // 普通函数，this 动态绑定到 obj    }};console.log(obj.f());        // \"a in the obj\"console.log(obj.insideObj.g()); // undefined，因为 insideObj 中没有 a\n\n箭头函数e.g. 箭头函数继承外层作用域:\nvar a = \"a in the global\";const obj = {    a: \"a in the obj\",    insideObj: {        g: () =&gt; this.a    },    f: () =&gt; this.a};console.log(obj.f());        // \"a in the global\"console.log(obj.insideObj.g()); //\"a in the global\"\n由于对象不会创建作用域, 因此此处的箭头函数的this继承了外层作用域(window)的this, 且var创建的变量存在于全局作用域中.\n语法糖语法糖 一种让代码更简洁、更易读的语法形式.\n\n本质上没有增加语言的功能, 而是对已有功能的 包装 或者优化;\n可读性提升: 让代码更填 使得代码更加容易理解和书写;\n底层实现: 实质上依旧用基础的语法实现.\n\n类类 class 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承prototype的封装.\n使用class的写法:\nclass Person {  constructor(name) {    this.name = name;  }  greet() {    console.log(`Hello, my name is ${this.name}`);  }}const person = new Person(\"Alice\");person.greet(); // 输出：Hello, my name is Alice\n\n等价的原型写法:\nfunction Person(name) {  this.name = name;}Person.prototype.greet = function() {  console.log(`Hello, my name is ${this.name}`);};const person = new Person(\"Alice\");person.greet(); // 输出：Hello, my name is Alice\n\n箭头函数箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.\n\ne.g.\n\n// 使用箭头函数const add = (a, b) =&gt; a + b;// 等价的普通函数const add = function add(a, b) {  return a + b;}\n\n结构赋值结构赋值 手动提取对象属性的语法糖.\n\n使用结构赋值:\n\nconst person = {name:\"Zhuo\", gender:\"male\"};const {name, gender} = person;\n\n\n等价的原型写法:\n\nconst person = {name:\"Zhuo\", gender:\"male\"};const name = person.name;const gender = person.gender;\n\n赋值规则结构赋值时, 基于 属性名匹配 而非顺序.因此, 对象结构的{}内部属性必须和 对象的属性名 相对应.\n错误的示例:\nconst person = { name: \"Alice\", age: 25 };const { a, b } = person;console.log(a); // 输出：undefinedconsole.log(b); // 输出：undefined\n\n重命名属性的写法:\nconst person = { name: \"Alice\", age: 25 };const { name: a, age: b } = person;console.log(a); // 输出：Aliceconsole.log(b); // 输出：25\n\n手动赋值: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:\nconst person = { name: \"Alice\" };const { name, age = 30 } = person;console.log(name); // 输出：Aliceconsole.log(age);  // 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）\n数组的结构赋值上述讨论的结构赋值都是对 对象 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— 基于顺序赋值:\nconst arr = [\"Alice\", 25];const [a, b] = arr;console.log(a); // 输出：Aliceconsole.log(b); // 输出：25\n","categories":["学习笔记"],"tags":["前端","JS"]},{"title":"css笔记","url":"/2025/01/08/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/css%E7%AC%94%E8%AE%B0/","content":"\n在线编辑平台\n\n伪元素使用伪元素before和after可以为元素添加内容.\n&lt;div class=&quot;author&quot;&gt;待抉&lt;/div&gt;&lt;style&gt;.author:before &#123;  content: &quot;Author: &quot;;  font-weight: bold; /* 加粗字体 */  color: blue; /* 文本颜色为蓝色 */&#125;.author:after &#123;  content: &quot; ✍️&quot;;  font-size: 1.2em; /* 调整图标大小 */  margin-left: 5px; /* 添加左边距 */&#125;&lt;/style&gt;\n\n\n:nth-child可用于对序列中不同的元素进行有序的样式设计:\n&lt;div class=&quot;index-card&quot;&gt;内容1&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容2&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容3&lt;/div&gt;&lt;div class=&quot;index-card&quot;&gt;内容4&lt;/div&gt;&lt;style&gt;.index-card:nth-child(odd) &#123;  flex-direction: row-reverse;&#125;&lt;/style&gt;\n\n选择所有类名为 “index-card” 的元素;\nrow-reverse 会让 flex 容器中的项目从右到左排列;\n同理, even选择偶数位置的元素; 3n+1等函数表达式也可以起作用.\n\n\n\n基本的元素属性布局属性\nmargin: 控制元素的外边距;\npadding: 控制元素的内边距;\n\n文本属性\nfont-size: 控制字体大小;\nfont-weight: 控制字体粗细;\ntext-align: 控制文本的对齐方式;\ntext-decoration: 控制文本的装饰;\nline-height: 控制行高;\nletter-spacing: 控制字符间距;\ntext-transform: 控制文本的大小写;\n\n边框属性\nborder: e.g. border: 1px solid red; 简写属性;\nborder-radius: 控制元素的圆角;\nborder-style: solid, dashed, dotted…\n\n其他\noverflow: visible, hidden, scroll, auto;\nopacity: 控制元素的透明度;\ncursor: pointer, default, move, not-allowed…\n\n动感魔法hover效果通过为class设置:hover伪类，可以为元素添加鼠标悬停时的效果。\n.my-element:hover &#123;  background-color: green;  color: red;  transform: scale(1.1);  font-size:20px;&#125;\n\n空格将不会被忽略, 需要确保类名与:hover之间不存在空格;\n\n其他的一些常用的伪类:\na:hover &#123;      color: red;    &#125;    button:active &#123;      background-color: green;    &#125;    input:focus &#123;      border-color: blue;    &#125;    a:visited &#123;      color: purple;    &#125;    p:first-child &#123;      font-weight: bold;    &#125;    p:last-child &#123;      font-style: italic;    &#125;    li:nth-child(2) &#123;      color: red;    &#125;    p:only-child &#123;      color: green;    &#125;    div:empty &#123;      background-color: yellow;    &#125;\n\nFlex&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;  &lt;meta charset=&quot;UTF-8&quot;&gt;  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;  &lt;style&gt;    /* 定义Flex容器 */    .container &#123;      display: flex; /* 将容器设置为Flexbox容器 */            /* flex-direction: 定义主轴方向 */      /* row: 水平从左到右（默认） */      /* row-reverse: 水平从右到左 */      /* column: 垂直从上到下 */      /* column-reverse: 垂直从下到上 */      flex-direction: row; /* 可以改为row-reverse, column, column-reverse */      /* flex-wrap: 定义是否换行 */      /* nowrap: 不换行（默认） */      /* wrap: 换行 */      /* wrap-reverse: 反向换行 */      flex-wrap: wrap; /* 可以改为nowrap, wrap-reverse */      /* flex-flow: flex-direction 和 flex-wrap 的简写 */      /* flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; */      flex-flow: row wrap; /* 可以改为column nowrap等组合 */      /* justify-content: 定义在主轴上的对齐方式 */      /* flex-start: 起始对齐（默认） */      /* flex-end: 末端对齐 */      /* center: 居中对齐 */      /* space-between: 两端对齐，项目之间间隔相等 */      /* space-around: 项目之间间隔相等，项目两边有半个间隔 */      /* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */      justify-content: space-between; /* 可以改为flex-start, flex-end, center, space-around, space-evenly */      /* align-items: 定义在交叉轴上的对齐方式 */      /* stretch: 拉伸适应容器（默认） */      /* flex-start: 交叉轴起始对齐 */      /* flex-end: 交叉轴末端对齐 */      /* center: 交叉轴居中对齐 */      /* baseline: 项目基线对齐 */      align-items: center; /* 可以改为flex-start, flex-end, stretch, baseline */      /* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */      /* stretch: 拉伸适应容器（默认） */      /* flex-start: 交叉轴起始对齐 */      /* flex-end: 交叉轴末端对齐 */      /* center: 交叉轴居中对齐 */      /* space-between: 多行两端对齐，行之间间隔相等 */      /* space-around: 多行之间间隔相等，行两边有半个间隔 */      align-content: space-between; /* 可以改为flex-start, flex-end, center, space-around */            height: 100vh; /* 设置容器高度 */      background-color: #f0f0f0; /* 设置容器背景颜色 */    &#125;        /* 定义Flex项目 */    .item &#123;      flex: 1; /* 设置项目的flex属性，项目平分空间 */      padding: 20px; /* 设置项目内边距 */      background-color: lightblue; /* 设置项目背景颜色 */      margin: 10px; /* 设置项目外边距 */      text-align: center; /* 设置项目文本居中 */      flex-grow: 1;/*尝试向flex容器扩展空间*/    &#125;  &lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;item&quot;&gt;Item 1&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;Item 2&lt;/div&gt;    &lt;div class=&quot;item&quot;&gt;Item 3&lt;/div&gt;  &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;\n\n","categories":["学习笔记"],"tags":["前端","CSS"]},{"title":"SSH隧道","url":"/2025/01/17/%E5%85%B6%E4%BB%96/SSH%E9%9A%A7%E9%81%93/","content":"在进行服务器运维时，经常会遇到需要代理来访问某些资源的情况。本文将介绍如何通过 SSH 隧道，让远程服务器共享使用本地电脑的代理，实现优雅的科学上网解决方案。\n背景通常我们在本地电脑上都配置了代理软件（如 Clash），但远程服务器往往没有代理。如何让远程服务器也能使用上我们本地的代理呢？这就需要用到 SSH 的端口转发功能。\n原理解释SSH 隧道技术允许我们将本地端口转发到远程服务器。通过建立一个加密的通道，远程服务器可以通过这个通道访问本地电脑的代理服务。\n[远程服务器] &lt;--- SSH隧道 ---&gt; [本地电脑] &lt;--- 代理 ---&gt; [互联网]\n\n具体步骤1. 前提条件\n本地电脑已安装并运行代理软件（如 Clash，默认端口 7890）\n能够通过 SSH 连接到远程服务器\n确保本地代理软件正常工作\n\n2. 建立 SSH 隧道在本地电脑的终端中执行：\nssh -R 7890:127.0.0.1:7890 -o ServerAliveInterval=60 -o ServerAliveCountMax=3 用户名@服务器IP\n\n参数说明：\n\n-R 7890:127.0.0.1:7890：将远程服务器的 7890 端口转发到本地的 7890 端口\n-o ServerAliveInterval=60：每 60 秒发送一次心跳包\n-o ServerAliveCountMax=3：最多允许丢失 3 次心跳包\n\n\n\n然后根据提示输入服务器用户的密码:\n3. 配置服务器代理在服务器终端中执行：\nexport https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890\n\n4. 验证代理是否生效在服务器上执行：\ncurl -v https://github.com\n\n如果能够正常访问，说明代理配置成功。\n持久化配置如果想让代理设置持久生效，可以将代理配置命令添加到 Shell 的配置文件中：\n# 编辑 ~/.bashrc 或 ~/.zshrcecho &#x27;export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890&#x27; &gt;&gt; ~/.bashrc# 重新加载配置source ~/.bashrc\n\n注意事项\n安全性考虑：SSH 隧道是加密的，相对安全\n连接维护：保持 SSH 连接不断开，否则代理会失效\n带宽限制：代理流量会经过你的本地电脑，注意带宽占用\n临时使用：这种方法适合临时使用，长期使用建议直接在服务器上配置代理\n\n常见问题排查\n隧道无法建立\n\n检查本地代理是否正常运行\n确认端口号是否正确\n检查服务器防火墙设置\n\n\n代理失效\n\nSSH 连接是否断开\n本地代理软件是否正常运行\n环境变量是否正确设置\n\n\n\nClash设置在默认的代理设置基础上进行了如下修改, 但是不确保这是正常访问的必须操作:以mac的ClashX Pro为例, 在更多设置中\n结论通过 SSH 隧道共享本地代理是一个简单而优雅的解决方案，特别适合临时需要代理访问的场景。它不需要在服务器上安装额外的软件，配置简单，安全可靠。\n","categories":["通用技能"],"tags":["ssh","服务器"]},{"title":"Tmux","url":"/2025/01/17/%E5%85%B6%E4%BB%96/Tmux/","content":"\n在利用SSH连接远端服务器并需要长期运行程序?  使用Tmux赋予进程以「不死鸟的加护」—— 退出终端窗口后依旧在后台运行~\n\n什么是 Tmux？Tmux（Terminal Multiplexer）是一个终端复用器，它允许用户在单个终端窗口中运行和管理多个终端会话。作为一个强大的命令行工具，tmux 特别适合需要长时间运行程序或需要同时管理多个终端窗口的场景。\n为什么需要 Tmux？在以下场景中，tmux 特别有用：\n\n远程服务器管理\n\nSSH 连接意外断开时，tmux 会话仍然保持运行\n可以随时重新连接到之前的工作环境\n\n\n多任务管理\n\n在同一个终端窗口中同时运行多个程序\n方便地在不同任务之间切换\n\n\n结对编程\n\n多人可以同时连接到同一个 tmux 会话\n实时查看和协作编辑\n\n\n\n基本概念tmux 采用三层架构：\n\n会话（Session）：最顶层的概念，包含多个窗口\n窗口（Window）：类似于浏览器的标签页\n窗格（Pane）：窗口内的分割区域\n\n常用操作指南1. 安装不同系统的安装命令：\n# MacOSbrew install tmux# Ubuntu/Debiansudo apt install tmux# CentOS/RHELsudo yum install tmux\n\n2. 会话管理启动新会话# 创建默认会话tmux# 创建命名会话tmux new -s session_name\n\n会话操作# 断开当前会话Ctrl+b d# 列出所有会话tmux ls# 连接到指定会话tmux attach -t session_name# 关闭指定会话tmux kill-session -t session_name\n\n3. 窗口管理所有命令都需要先按前缀键 Ctrl+b：\n\nc: 创建新窗口\n&amp;: 关闭当前窗口\np: 切换到上一个窗口\nn: 切换到下一个窗口\n数字键: 切换到指定编号的窗口\n\n4. 窗格操作同样需要先按前缀键 Ctrl+b：\n\n%: 垂直分割窗格\n&quot;: 水平分割窗格\n方向键: 在窗格之间移动\nx: 关闭当前窗格\nz: 最大化&#x2F;还原当前窗格\n\n进阶技巧1. 自定义配置创建 ~/.tmux.conf 文件来自定义 tmux 配置：\n# 修改前缀键为 Ctrl+aset -g prefix C-aunbind C-bbind C-a send-prefix# 开启鼠标支持set -g mouse on# 设置窗口编号从 1 开始set -g base-index 1\n\n2. 复制模式\n按 Ctrl+b [ 进入复制模式\n使用方向键移动光标\n按 Space 开始选择\n按 Enter 复制选中内容\n按 Ctrl+b ] 粘贴\n\n最佳实践\n使用有意义的会话名：便于识别和管理\n合理使用窗格：避免过度分割\n保持配置文件的整洁：注释清晰，逻辑分明\n定期保存重要会话：使用插件或脚本自动保存\n\n常见问题解决\n无法创建会话\n\n检查 tmux 是否正确安装\n确认用户权限\n\n\n快捷键不响应\n\n确认是否正确按下前缀键\n检查配置文件是否有冲突\n\n\n会话丢失\n\n使用 tmux ls 检查会话状态\n查看系统日志寻找错误信息\n\n\n\n结语tmux 是一个强大的终端管理工具，掌握它可以显著提高命令行工作效率。从基本的会话管理到高级的自定义配置，tmux 都提供了灵活而强大的功能。随着使用经验的积累，你会发现它是开发工作中不可或缺的工具之一。\n参考资源\nTmux 官方文档\nTmux 速查表\nAwesome Tmux\n\n","categories":["通用技能"],"tags":["服务器","多会话管理"]},{"title":"pip-tools","url":"/2025/01/15/%E5%85%B6%E4%BB%96/pip-tools/","content":"Python依赖管理利器：pip-tools完全指南\n 本文由 Claude 3.5 Sonnet 协助生成.\n\n\n在 Python 项目开发中，依赖管理是一个常见但棘手的问题。特别是在团队协作时，不同成员的环境可能存在细微差异，导致”在我这里能运行”的经典问题。针对上述问题, 本文将详细介绍如何使用 pip-tools，实现精确的依赖版本控制。\n目录\n为什么需要 pip-tools？\n环境准备\npip-tools 的安装与使用\n最佳实践\n常见问题解决\n高级用法\n\n为什么需要 pip-tools？传统的依赖管理方式存在以下问题：\n\nrequirements.txt 手动维护容易出错\n间接依赖版本难以控制\n团队成员环境不一致\n依赖更新流程繁琐\n\npip-tools 通过以下特性解决这些问题：\n\n自动生成完整的依赖关系\n锁定所有依赖的具体版本\n支持开发环境和生产环境分离\n提供简单的依赖更新机制\n\n环境准备1. 创建虚拟环境首先，我们需要创建一个独立的 Python 虚拟环境：\n# 安装 virtualenv（如果还没有安装）pip install virtualenv# 创建虚拟环境virtualenv venv# 激活虚拟环境# Linux/macOS:source venv/bin/activate# Windows:.\\venv\\Scripts\\activate\n\n2. 项目结构推荐的项目结构如下：\nmy_project/├── venv/├── requirements.in├── requirements.txt├── requirements-dev.in   # 可选：开发环境依赖├── requirements-dev.txt  # 可选：开发环境依赖锁定文件└── src/\n\npip-tools 的安装与使用1. 安装 pip-toolspip install pip-tools\n\n2. 创建依赖文件创建 requirements.in 文件，列出直接依赖：\n# requirements.inflaskpython-dotenvopenaimarkdown-it-pyfairy-doc[cpu]\n\n注意, 此处不同的依赖包必须分行呈现.\n\n3. 生成锁定文件# 生成 requirements.txtpip-compile requirements.in# 如果有开发依赖pip-compile requirements-dev.in\n\n生成的 requirements.txt 示例：\n## This file is autogenerated by pip-compile# To update, run:##    pip-compile requirements.in#flask==2.3.3  --hash=sha256:...python-dotenv==1.0.0  --hash=sha256:...openai==0.27.8  --hash=sha256:...markdown-it-py==3.0.0  --hash=sha256:...fairy-doc[cpu]==1.2.0  --hash=sha256:...\n\n4. 安装依赖# 安装所有依赖pip-sync requirements.txt# 如果同时需要开发依赖pip-sync requirements.txt requirements-dev.txt\n\n最佳实践1. 版本控制# requirements.inflask&gt;=2.0.0,&lt;3.0.0  # 指定版本范围python-dotenv~=1.0.0  # 允许补丁版本更新openai==0.27.8       # 锁定具体版本\n\n2. 依赖分组# requirements-dev.in-r requirements.in    # 包含基础依赖pytest               # 测试框架black                # 代码格式化flake8               # 代码检查\n\n3. 更新依赖# 更新单个包pip-compile --upgrade-package flask requirements.in# 更新所有包pip-compile --upgrade requirements.in\n\n常见问题解决1. 依赖冲突如果遇到依赖冲突，可以：\n\n检查 requirements.in 中的版本约束\n使用 pip-compile --verbose 查看详细信息\n考虑降级某些包的版本\n\n2. Hash 不匹配如果出现 hash 不匹配：\npip-compile --generate-hashes requirements.in\n\n3. 环境不一致确保团队成员：\n\n使用相同的 Python 版本\n严格执行 pip-sync\n不要手动 pip install\n\n高级用法1. 自定义输出格式# 生成带注释的依赖文件pip-compile --annotate requirements.in# 生成带 hashes 的依赖文件pip-compile --generate-hashes requirements.in\n\n2. 多环境配置# 开发环境pip-compile requirements-dev.in# 生产环境pip-compile requirements.in --output-file requirements-prod.txt\n\n3. 依赖更新策略# 只更新安全相关的包pip-compile --upgrade-package flask --upgrade-package &quot;requests&gt;=2.31.0&quot;# 保持现有版本pip-compile --no-upgrade requirements.in\n\n结语通过使用 pip-tools，我们可以：\n\n实现精确的依赖版本控制\n简化依赖管理流程\n确保团队环境一致性\n提高项目的可维护性\n\n希望这篇指南能帮助你更好地管理 Python 项目的依赖！\n参考资料\npip-tools 官方文档\nPython Packaging User Guide\nPEP 508 – Dependency specification for Python Software Packages\n\n","categories":["通用技能"],"tags":["python","环境配置"]},{"title":"React 主题切换","url":"/2025/01/23/%E5%85%B6%E4%BB%96/themechange/","content":"$\\underline{主题切换}$  即通过点击某个组件来切换背景与文字的颜色等 CSS 属性。这要求我们的组件能够控制某个”环境变量”, 且index.css中的 CSS 应随这个”环境变量”而改变。\n要实现这个需求,我们需要解决以下几个问题：\n\n如何定义和管理这个”环境变量”？\n组件如何控制这个变量？\nCSS 如何响应变量的变化？\n\n这些问题的解决方案涉及到几个重要的基础概念,让我们逐一了解。\n基础知识Context 的创建和使用Context 提供了一种在组件树中共享数据的方式,无需手动在每一层传递 props。\n// 创建 Contextconst ThemeContext = createContext&lt;ThemeType | undefined&gt;(undefined);// 提供 Contextconst ThemeProvider = (&#123; children &#125;) =&gt; &#123;  const [theme, setTheme] = useState(&#x27;light&#x27;);    return (    &lt;ThemeContext.Provider value=&#123;&#123; theme, setTheme &#125;&#125;&gt;      &#123;children&#125;    &lt;/ThemeContext.Provider&gt;  );&#125;;// 使用 Contextconst ChildComponent = () =&gt; &#123;  const &#123; theme &#125; = useContext(ThemeContext);  return &lt;div&gt;Current theme: &#123;theme&#125;&lt;/div&gt;;&#125;;\n因此, 我们可以在src/context/目录下创建一个ThemeContext来定义和管理相关上下文.\n\n在其中利用useState定义主题反转的函数;\n在点击按钮组件中使用上述的函数,\n\nCSS 变量CSS 变量(也称为自定义属性)允许我们定义可重用的值：\n/* 定义变量 */:root &#123;  --primary-color: #007bff;&#125;/* 使用变量 */.button &#123;  background-color: var(--primary-color);&#125;\n\n为了区分CSS的变量与常量, --xx-y的命名格式是CSS变量的规范;\n通过var(&lt;c--xx-y&gt;)的形式使用CSS变量.\n\nHTML data-* 属性document.documentElement.setAttribute(&#39;data-theme&#39;, theme) 的作用是在 HTML 根元素上设置一个自定义数据属性：\n// JavaScript 设置document.documentElement.setAttribute(&#x27;data-theme&#x27;, &#x27;dark&#x27;);// 结果的 HTML&lt;html data-theme=&quot;dark&quot;&gt;  ...&lt;/html&gt;// 对应的 CSS[data-theme=&#x27;dark&#x27;] &#123;  --bg-color: #141414;&#125;\n\n主题切换实现主题变量设计首先设计主题相关的 CSS 变量：\n:root &#123;  /* Light theme variables */  --bg-color: #ffffff;  --text-color: #000000;  --sidebar-bg: #f0f2f5;  --border-color: #e5e2e2;  --shadow-color: rgba(0, 0, 0, 0.1);&#125;[data-theme=&#x27;dark&#x27;] &#123;  --bg-color: #141414;  --text-color: #ffffff;  --sidebar-bg: #1f1f1f;  --border-color: #434343;  --shadow-color: rgba(0, 0, 0, 0.3);&#125;\n\n可根据实际需要增减CSS变量.\n\n主题状态管理创建主题 Context 进行状态管理：\nimport React, &#123; createContext, useState, useContext, useEffect &#125; from &#x27;react&#x27;;type Theme = &#x27;light&#x27; | &#x27;dark&#x27;;interface ThemeContextType &#123;  theme: Theme;  toggleTheme: () =&gt; void;&#125;const ThemeContext = createContext&lt;ThemeContextType | undefined&gt;(undefined);export const ThemeProvider: React.FC&lt;&#123; children: React.ReactNode &#125;&gt; = (&#123; children &#125;) =&gt; &#123;  const [theme, setTheme] = useState&lt;Theme&gt;(() =&gt; &#123;    const savedTheme = localStorage.getItem(&#x27;theme&#x27;);    return (savedTheme as Theme) || &#x27;light&#x27;;  &#125;);  useEffect(() =&gt; &#123;    document.documentElement.setAttribute(&#x27;data-theme&#x27;, theme);    localStorage.setItem(&#x27;theme&#x27;, theme);  &#125;, [theme]);  const toggleTheme = () =&gt; &#123;    setTheme(prev =&gt; prev === &#x27;light&#x27; ? &#x27;dark&#x27; : &#x27;light&#x27;);  &#125;;  return (    &lt;ThemeContext.Provider value=&#123;&#123; theme, toggleTheme &#125;&#125;&gt;      &#123;children&#125;    &lt;/ThemeContext.Provider&gt;  );&#125;;export const useTheme = () =&gt; &#123;  const context = useContext(ThemeContext);  if (context === undefined) &#123;    throw new Error(&#x27;useTheme must be used within a ThemeProvider&#x27;);  &#125;  return context;&#125;;\n\n\n\n在设置上下文组件之后, 我们需要明确其作用的范围. 我们希望主题变色需要在全局范围内生效, 以react框架为例:\n&lt;!-- App.tsx --&gt;import &#123; ThemeProvider &#125; from &#x27;./context/ThemeContext&#x27;;function App()&#123;    ...    return (        &lt;ThemeProvider&gt;            &lt;div className = &quot;App&quot;&gt;                ...            &lt;/div&gt;        &lt;/ThemeProvider&gt;    )&#125;\n主题切换组件实现主题切换按钮：\nimport React from &#x27;react&#x27;;import &#123; Tooltip &#125; from &#x27;antd&#x27;;import &#123; useTheme &#125; from &#x27;../context/ThemeContext&#x27;;import &#123; BsSun, BsMoonStars &#125; from &#x27;react-icons/bs&#x27;;import styles from &#x27;./ThemeToggle.module.css&#x27;;const ThemeToggle: React.FC = () =&gt; &#123;  const &#123; theme, toggleTheme &#125; = useTheme();  return (    &lt;Tooltip title=&#123;theme === &#x27;light&#x27; ? &#x27;切换到暗色模式&#x27; : &#x27;切换到亮色模式&#x27;&#125; placement=&quot;right&quot;&gt;      &lt;button         className=&#123;styles.themeToggle&#125;         onClick=&#123;toggleTheme&#125;        aria-label=&quot;Toggle theme&quot;      &gt;        &#123;theme === &#x27;light&#x27; ? &lt;BsMoonStars /&gt; : &lt;BsSun /&gt;&#125;      &lt;/button&gt;    &lt;/Tooltip&gt;  );&#125;;export default ThemeToggle;\n\n此处使用antd的Tooltip, 用于在鼠标悬浮按钮组件时显示文字提示;\naria-label=&quot;Toggle theme&quot; 在&lt;button&gt;内设置这个属性不是必要的, 但是可以帮助屏幕阅读器读出 “Toggle theme“.\n\n组件样式应用在组件内部使用CSS变量的方式已经在 CSS变量 中介绍, 在此给出示例:\n.sidebar_container &#123;    background-color: var(--sidebar-bg);    color: var(--text-color);&#125;.icon_button &#123;    color: var(--text-color);    background-color: transparent;&#125;.icon_button:hover &#123;    background-color: var(--sidebar-hover-color);&#125;\n\n\n\n如果某个CSS不需要作为变量进行统一管理, 可以直接使用 属性选择器 进行单独设置:\n[data-theme=&#x27;dark&#x27;] .icon_example&#123;  --bg-color: #141414;&#125;\n\n总结与参考通过以上实现,我们构建了一个完整的主题切换系统。关键点包括：\n\n使用 CSS 变量管理主题样式\n通过 Context API 实现状态管理\n利用 data-theme 属性切换主题\n本地存储保持主题持久化\n\n参考 🔗\nReact Context API\nCSS Custom Properties\nHTML data-* Attributes\n\n"},{"title":"媒体查询","url":"/2025/01/08/%E5%85%B6%E4%BB%96/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2/","content":"\n媒体查询入门指南使用编程方法测试媒体查询\n\n媒体查询入门对于前端, 如果我们想实现响应式的设计, 那么媒体查询是必不可少的工具. 媒体查询可以帮助我们根据不同的设备和屏幕尺寸, 调整我们的网页的布局和样式.\n媒体查询的范式:\n@media media-type and (media-feature) &#123;    /*css rules*/&#125;\n\n\n媒体类型用于声明css文件被用作什么类型的媒体;\n媒体表达式用于指定媒体特征, 只有满足媒体特征的条件下, 才会应用css规则;\n通过测试且符合媒体类型的情况下应用内部的CSS样式.\n\n\nmedia-type: all, print, screen, speech.\n媒体特征屏幕尺寸使用min,max在一定的数值范围内启用当前的CSS样式.\n\n如果去掉前缀, 将仅在恰好为当前数值中启用.\n\n/* 启用宽度大于或等于600px的屏幕 */@media screen and (max-width: 600px)&#123;    ...&#125;/* 启用宽度小于或等于600px的屏幕 */@media screen and (min-width: 600px)&#123;    ...&#125;/* 窗口恰好等于600px时 */@media screen and (width: 600px) &#123;    ...&#125;\n\n朝向orientation可以检测设备的方向, 如竖屏或横屏.\n@media screen and (orientation: portrait) &#123;    /* 竖放时的CSS样式 */&#125;@media screen and (orientation: landscape) &#123;    /* 横屏时的CSS样式 */&#125;\n\n更复杂的媒体查询\nand实现与逻辑:\n\n@media screen and (min-width: 400px) and (orientation: landscape) &#123;  body &#123;    color: blue;  &#125;&#125;\n\n\n,实现或逻辑:\n\n@media (min-width: 768px) and (orientation: landscape), (max-width: 480px) &#123;  /*   (屏幕宽度大于等于 768px 且屏幕方向为横向) 或 (屏幕宽度小于等于 480px)  */&#125;\n\n与C中的&amp;和|类似, 与的优先级更高, 先将and的条件进行判断, 然后视作整体.\n\n\nnot实现非逻辑:\n\n@media not all and (orientation: landscape) &#123;/* 非全部屏幕且屏幕方向为横向 */&#125;\n\n\nnot实现 反转查询:\n与最近的and组合所绑定, 注意优先级\n\n\n\n@media not screen and (color), print and (color) &#123; ... &#125;\n,将媒体查询的表达式分为了前后两级, 因此上述的媒体查询等价于:\n@media (not (screen and (color))), print and (color) &#123; ... &#125;\n\n\n\n利用查询结果扩展设计上述在CSS中利用@media可以实现响应式的设计, 如果我们希望在js&#x2F;ts中使用媒体查询的结果呢? 利用媒体查询列表进行设计可以帮助我们实现更加自由的设计.\n\n使用window.matchMedia()方法存放媒体查询结果:\n\n// 检测设备的旋转方向是否为纵向var mediaQueryList = window.matchMedia(&quot;(orientation: portrait)&quot;);\n\n\n检查属性matches获取对应的查询结果:\n\nif (mediaQueryList.matches) &#123;  /* 设备的旋转方向为纵向 portrait */&#125; else &#123;  /* 设备的旋转方向不是纵向，也就是横向 landscape */&#125;\n\n\n通过addListener()方法注册监听器, 持续监听查询列表的结果\n\n// 定义媒体查询字符串const mediaQueryString: string = &quot;(orientation: portrait)&quot;;// 创建查询列表const mediaQueryList: MediaQueryList = window.matchMedia(mediaQueryString);// 定义回调函数，使用 MediaQueryListEvent 类型function handleOrientationChange(event: MediaQueryListEvent): void &#123;  if (event.matches) &#123;    // 媒体查询匹配（竖屏）    console.log(&quot;Orientation changed to portrait&quot;);    // 在这里执行竖屏时的逻辑  &#125; else &#123;    // 媒体查询不匹配（横屏）    console.log(&quot;Orientation changed to landscape&quot;);    // 在这里执行横屏时的逻辑  &#125;&#125;// 先运行一次回调函数，传入 MediaQueryList 对象handleOrientationChange(&#123;    matches: mediaQueryList.matches,    media: mediaQueryList.media,    type: &#x27;change&#x27;,&#125; as MediaQueryListEvent);// 为查询列表注册监听器，同时将回调函数传给监听器mediaQueryList.addEventListener(&#x27;change&#x27;, handleOrientationChange);// (可选) 在组件卸载时或不再需要监听时，移除事件监听器// mediaQueryList.removeEventListener(&#x27;change&#x27;, handleOrientationChange);\n\n","categories":["学习笔记"],"tags":["前端","CSS"]},{"title":"协议切换与认证配置","url":"/2025/01/18/%E5%85%B6%E4%BB%96/%E8%AE%A4%E8%AF%81%E9%85%8D%E7%BD%AE/","content":"背景介绍在使用 Git 进行版本控制时，我们经常需要在 SSH 和 HTTPS 两种协议之间进行切换。本文将详细介绍这两种认证方式的特点、转换方法以及相关的常见问题解决方案。\n认证机制解析双层认证架构\n服务器层认证\n\n用于验证用户对服务器的访问权限\n通常通过 SSH 密钥或密码完成\n\n\n仓库层认证\n\n验证用户对特定 Git 仓库的操作权限\n独立于服务器认证系统\n确保代码安全性和提交者身份\n\n\n\nSSH vs HTTPS\nSSH 协议\n\n优势：\n更安全，使用密钥对进行加密\n配置一次可永久使用\n可以避免每次输入密码\n\n\n劣势：\n可能被防火墙阻止（22端口）\n在某些企业网络中可能无法使用\n配置相对复杂\n\n\n\n\nHTTPS 协议\n\n优势：\n几乎总是可用（443端口）\n穿透防火墙能力强\n配置简单\n\n\n劣势：\n需要管理凭证\n可能需要频繁输入认证信息\n\n\n\n\n\n连接问题分析SSH 超时问题解析SSH 连接可能出现超时的原因：\n\n网络限制\n\n企业防火墙可能会阻止或限制 SSH 连接\n某些网络环境会定期切断长时间的 SSH 连接\n\n\n代理影响\n\nSSH 不会自动使用系统代理\n需要额外配置 SSH 的代理设置\n\n\n防火墙策略\n\n22 端口经常被封锁\n某些地区可能限制 SSH 协议\n\n\n\nHTTPS 连接优势\n标准 Web 端口\n\n使用 443 端口，几乎总是开放的\n与普通网页浏览使用相同的端口\n\n\n代理兼容\n\n自动使用系统代理设置\n更好的网络兼容性\n\n\n连接特性\n\n非持久连接，每次请求独立\n不受长连接限制影响\n\n\n\n协议转换实践在尝试直接git push时显示:通过执行命令git remote -v查看当前远程仓库的地址:\n\ngit@的前缀格式说明是通过ssh的方式, 我们尝试修改为https的协议来解决超时问题.\n\n更新仓库的URL:\ngit remote set-url origin https://github.com/用户名/仓库名.git\ne.g.:\n\n在更新之后执行get remote -v, 检查发现已经转换为HTTPS.\n\n配置凭证管理此时依旧无法直接git push, 因为仓库层认证的密码验证方式已经不受github支持, 如果尝试通过用户名-密码的方式验证, 将会失败:\n因此我们需要通过 个人访问令牌(PAT) 的方式来鉴权.\n\n配置凭证管理:\n\n# 永久存储凭证git config --global credential.helper store# 或临时缓存（如15分钟）git config --global credential.helper &#x27;cache --timeout=900&#x27;\n\n如果不希望影响其他仓库, 去除--global即可.\n\n\n获取PAT:\n访问 GitHub Settings;\n下滑到底部,进入 Developer settings;\n选择 Personal access tokens → Tokens (classic);\n在右上角选择生成新的access token;\n生成新令牌并设置适当的权限范围 (至少勾选repo).\n在生成PAT之后立即复制并保存.\n\n\n\n\n\n通过PAT鉴权此时, 我们可以git push然后利用PAT来鉴权:\ngit pushUsername: &lt;GitHub用户名&gt;Password: &lt;个人访问令牌&gt;\ne.g.\n安全相关建议凭证管理\n凭证存储位置\n\nLinux&#x2F;Mac: ~/.git-credentials\nWindows: %USERPROFILE%\\.git-credentials\n\n\n安全建议\n\n定期更新访问令牌\n在共享环境使用临时缓存\n及时清理凭证缓存\n\n\n\n故障排除# 删除全局凭证配置git config --global --unset credential.helper# 删除凭证文件rm ~/.git-credentials  # Linux/Macdel &quot;%USERPROFILE%\\.git-credentials&quot;  # Windows\n","categories":["通用技能"],"tags":["服务器","PAT"]},{"title":"makefile","url":"/2025/02/12/%E5%85%B6%E4%BB%96/makefile/","content":"编译基本概念默认目标\nMakefile当中的第一个目标会成为默认目标;\n不指定参数的make命令会执行默认目标;\n通常使用all的伪目标作为默认目标.\n\n伪目标当我们需要执行清理工作、运行测试等操作时, 我们不希望与实际文件名发生冲突, 此时就需要用到 伪目标.\n语法\n.PHONY: 目标名目标名:    命令\n\n使用示例\n# 情景：需要清理编译产生的 .o 文件和可执行文件.PHONY: cleanclean:    rm -f *.o program# 情景：需要运行测试.PHONY: testtest:    ./run_tests.sh# 使用方法：# make clean  # 清理文件# make test   # 运行测试\n\n其中-f表示强制删除, 其他的参数如-r表示递归删除目录, -rf表示强制递归删除目录.\n\n多重构建我们还可以利用伪目标使得默认目标具有多个对象:\n.PHONY: all debug release clean# 默认目标包含常用的构建类型all: debug release# 调试版本debug: main.c    @echo &quot;构建调试版本...&quot;    gcc -g main.c -o debug-program# 发布版本release: main.c    @echo &quot;构建发布版本...&quot;    gcc -O2 main.c -o release-programclean:    rm -f debug-program release-program# 使用：# make          # 构建调试版和发布版# make debug    # 只构建调试版# make release  # 只构建发布版# make clean    # 清理\n\n多目标e.g: \nbigoutput littleoutput : text.g    generate text.g -$(subst output,,$@) &gt; $@\n\n解析bigoutput littleoutput : text.g    generate text.g -$(subst output,,$@) &gt; $@\n\n\nbigoutput littleoutput - 两个目标文件\ntext.g - 依赖文件\n$(subst output,,$@) -变量展开：\n$@ 是自动变量，表示当前目标名\nsubst 是替换函数，格式为 $(subst from,to,text)\n此处将目标名中的 “output” 替换为空\n\n\n\n当规则执行时：\n\n对于 bigoutput 目标：\n\n$@ 展开为 bigoutput\n$(subst output,,$@) 结果为 big\n最终命令变为：generate text.g -big &gt; bigoutput\n\n\n对于 littleoutput 目标：\n\n$@ 展开为 littleoutput\n$(subst output,,$@) 结果为 little\n最终命令变为：generate text.g -little &gt; littleoutput\n\n\n\n\n\n因此, 上述的多目标规则等价于:\nbigoutput : text.g    generate text.g -big &gt; bigoutputlittleoutput : text.g    generate text.g -little &gt; littleoutput\n\n规则语法多目标规则（Multiple Targets）是 Makefile 中的一个重要特性：\n\n基本语法：\ntarget1 target2 : prerequisites    commands\n\n特点：\n\n多个目标共享相同的依赖关系\n命令会对每个目标分别执行一次\n可以使用 $@ 引用当前正在构建的目标\n\n\n使用场景：\n\n生成相似但略有不同的文件\n多个目标需要类似的构建过程\n减少重复代码\n\n\n示例：\n# 生成不同大小的图片big.jpg small.jpg : original.jpg    convert original.jpg -resize $* &gt; $@# 生成不同格式的文档manual.pdf manual.html : manual.txt    pandoc manual.txt -o $@\n\n优势：\n\n代码更简洁\n易于维护\n避免重复规则\n更好的规则组织\n\n\n注意事项：\n\n命令对每个目标都会执行一次\n需要合理使用自动变量（如 $@）来区分不同目标\n确保命令对所有目标都适用\n\n\n\n静态模式好的，让我从这几个角度来介绍 Makefile 中的静态模式规则。\n1. 引入背景在 Makefile 中，当我们需要将多个源文件编译成对应的目标文件时，如果按照普通的规则写法，往往需要为每个文件都写一条规则：\nfoo.o : foo.c    $(CC) -c $(CFLAGS) foo.c -o foo.obar.o : bar.c    $(CC) -c $(CFLAGS) bar.c -o bar.otest.o : test.c    $(CC) -c $(CFLAGS) test.c -o test.o\n\n这种写法存在明显问题：\n\n规则重复，维护困难\n当新增源文件时需要手动添加规则\n代码冗长，不够优雅\n\n虽然可以使用多目标规则，但在处理源文件和目标文件的对应关系时仍然不够灵活。这就是引入静态模式规则的原因。\n2. 基本语法静态模式规则的基本语法如下：\ntargets ...: target-pattern: prereq-pattern    commands\n\n其中：\n\ntargets: 要生成的目标文件列表\ntarget-pattern: 目标的模式，通常包含 % 通配符\nprereq-pattern: 依赖的模式，通常也包含 % 通配符\ncommands: 构建命令\n\n% 在 target-pattern 中匹配的内容，会在 prereq-pattern 中作为相同的替换内容。\n3. 综合示例让我们通过几个逐渐复杂的例子来说明静态模式的使用：\n基础示例：编译 C 文件objects = foo.o bar.o test.o$(objects): %.o: %.c    $(CC) -c $(CFLAGS) $&lt; -o $@\n\n复杂示例：多种源文件处理# 定义源文件和目标文件cpp_sources := $(wildcard *.cpp)c_sources := $(wildcard *.c)cpp_objects := $(cpp_sources:.cpp=.o)c_objects := $(c_sources:.c=.o)all_objects := $(cpp_objects) $(c_objects)# C++ 源文件的编译规则$(cpp_objects): %.o: %.cpp    $(CXX) -c $(CXXFLAGS) $&lt; -o $@# C 源文件的编译规则$(c_objects): %.o: %.c    $(CC) -c $(CFLAGS) $&lt; -o $@# 生成可执行文件program: $(all_objects)    $(CXX) $^ -o $@\n\n$(cpp_sources:.cpp=.o)是一种模式替换, 会将cpp_sources中的所有.cpp文件替换为.o文件;\n即$(varname:pattern1=pattern2) 会将varname中的所有pattern1替换为pattern2;\n\n\n\n更复杂的示例：多目录处理# 目录结构SRCDIR = srcOBJDIR = obj# 源文件和目标文件SOURCES = $(wildcard $(SRCDIR)/*.c)OBJECTS = $(SOURCES:$(SRCDIR)/%.c=$(OBJDIR)/%.o)# 确保目标目录存在$(OBJDIR):    mkdir -p $@# 静态模式规则$(OBJECTS): $(OBJDIR)/%.o: $(SRCDIR)/%.c | $(OBJDIR)    $(CC) -c $(CFLAGS) $&lt; -o $@# 最终目标program: $(OBJECTS)    $(CC) $^ -o $@\n\ntodo\n\n这个复杂示例展现了 Makefile 在处理现代项目时的多个高级特性。在文件组织方面，示例实现了跨目录的文件处理能力，通过将源文件和目标文件分别组织在不同的目录（如 src 和 obj）中，体现了项目结构的清晰性和模块化。Makefile 能够智能地在这些目录间进行文件操作，保持项目的整洁有序。\n在目录管理方面，示例引入了自动创建目标目录的机制。通过使用条件依赖（用 | 分隔符标识），确保在编译过程开始前目标目录已经存在。这种方式优雅地解决了目录创建的时序问题，避免了因目录不存在而导致的编译失败。特别是当多个目标文件同时需要某个目录时，条件依赖能够确保目录创建操作只执行一次，提高了构建效率。\n在文件名处理方面，示例展示了复杂的文件名转换技巧。通过巧妙运用 Make 的模式替换功能，实现了从源文件到目标文件的路径和扩展名转换。例如，将 src/main.c 转换为 obj/main.o，这种转换不仅处理了文件扩展名的变化，还同时处理了目录路径的变化。这种灵活的文件名处理机制，使得 Makefile 能够适应更复杂的项目结构和构建需求，同时保持了规则的简洁性和可维护性。\n\n基本规则target ... : prerequisites ...    recipe    ...    ...\ntarget: 目标文件 | 可执行文件 | 标签;prerequisites: 依赖文件 | target;recipe: 对应target所需的命令(以Tap缩进开头).\n\n\n执行recipe命令的条件:\n\nprerequisites中存在文件的日期早于target的日期;\ntarget的文件不存在.\n\n使用变量# 定义变量: 类似于C的宏定义objects = main.o display.o# 使用变量edit: $(objects)    cc -o edit $(objects)\n\n必须使用Tab缩进;\n采取$(variable)的形式引用变量, 将会展开为变量的值;\ncc -o edit 声明采用C语言编译器同时指定输出文件名为edit.\n\nMake的自动推导自动推导规则\n文件关联：\n\n当make看到.o文件时，会自动将对应的.c文件加入依赖关系\n例如：发现whatever.o时，会自动关联whatever.c作为依赖文件\n\n\n命令推导：\n\n自动推导编译命令，如cc -c whatever.c\n无需在每个.o文件后都手动写编译命令\n\n\n\n示例结构\n依赖关系：\n\n# 自动推导之前main.o : main.c defs.h    cc -c main.c# 自动推导下的简化书写main.o : defs.h\n\n\n清理目标：\n\n.PHONY : cleanclean :    rm edit $(objects)\n\n\n.PHONY表示clean是伪目标文件;\n这种自动推导方式大大简化了Makefile的编写;\nclean总是放在文件的末尾.\n\nmake命令在默认情况下会在当前目录下依次寻找文件名为GNUmakefile,makefile,Makefile的文件.\n\n推荐使用Makefile作为文件名;\n也可以使用-f或者-file参数来指定特定的Makefile文件.\n\nmake -f Make.Linux\n\n\n\n\ninclude命令# 使用include命令可以将其他Makefile包含进来include &lt;file-name&gt;\n\ninclude命令前可以存在空字符, 但是不能为Tab缩进;\ninclude与文件之间可以存在多个空格.\n\n直接指定文件# 最基本的include用法是直接指定文件名include config.mkinclude ./build/rules.mk# 同时包含多个文件include config.mk rules.mk tests.mk\n\n使用通配符 *# * 匹配任意字符串include *.mk              # 包含当前目录下所有.mk文件include src/*.mk         # 包含src目录下的所有.mk文件include **/build/*.mk    # 包含任意子目录中build目录下的所有.mk文件\n\n我们同样可以在变量中使用通配符 *:\n# 使用时展开objects = *.o# 定义时展开(除非重新赋值, 否则保持定义时的展开状态)objects := $(wildcard *.o)\n\ne.g:\n$(patsubst %.c,%.o,$(wildcard *.c))\n\npatsubst是一个函数, 用于模式替换;\n语法为patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;;\n此处表示利用通配符, 将所有的.c文件名称替换为.o文件.\n\n使用单字符通配符# ? 匹配单个字符include test?.mk         # 匹配test1.mk, testA.mk等include rule_?.mk        # 匹配rule_1.mk, rule_2.mk等include config???.mk     # 匹配config后带三个字符的.mk文件\n\n使用目录路径# 可以指定不同的目录路径include ./configs/*.mk    # 当前目录下的configs子目录include ../shared/*.mk    # 上级目录的shared子目录include /usr/local/include/make/*.mk  # 绝对路径\n\n使用字符集[]# [] 用于匹配字符集中的任意一个字符include make[123].mk     # 匹配make1.mk, make2.mk, make3.mkinclude test[a-z].mk     # 匹配testa.mk到testz.mkinclude config[0-9].mk   # 匹配config0.mk到config9.mk\n\n错误处理# 默认情况下，如果include的文件不存在，make会报错# 使用-include或sinclude可以忽略文件不存在的错误-include optional.mk     # 如果文件不存在，继续执行不报错sinclude optional.mk     # 与-include完全相同# 多个可选文件-include config/*.mk     # 如果config目录下有任何.mk文件不存在，继续执行\n\n组合使用示例# 可以组合使用多种模式include config.mk \\        rules/*.mk \\        test[0-9].mk \\        ./build/**/*.mk# 使用变量INCLUDE_DIR = ./includesinclude $(INCLUDE_DIR)/*.mk# 条件包含ifdef CUSTOM_RULES    include $(CUSTOM_RULES)endif\n\nmake的工作方式\n读取所有的Makefile;\n读取include涉及的Makefile文件;\n初始化文件当中的变量;\n推导隐式规则并分析所有规则;\n为目标文件创建依赖关系链;\n根据依赖关系, 决定需要重新生成的文件;\n执行生成命令.\n\n文件搜寻VPATH默认情况下, make会在当前目录和所有子目录下寻找依赖文件和目标文件.为了能够在较大工程中扩大make的搜索范围, 我们可以通过特殊变量VPATH来指定搜索路径.\nVPATH = src:../headers\n\n不同的目录之间由:分隔, 上述定义指定了额外的src以及../headers目录;\n当前目录的优先级最高, 在当前目录下无法找到相关文件时将会从指定的目录中从左到右继续寻找.\n\nvpath上述的VPATH指定了全局文件的搜索路径, 而vpath允许为不同类型的文件指定不同的搜索路径.\n语法\n# 1. 为指定模式的文件设置搜索路径vpath pattern directory1:directory2# 2. 清除指定模式的搜索路径vpath pattern# 3. 清除所有已设置的 vpathvpath\n\n特点\n\n可以为不同类型的文件指定不同的搜索路径;\n支持使用 % 通配符匹配文件名;\n可以有多条 vpath 指令, 且针对相同模式的命令将会起到附加而非覆盖的作用.\n\ne.g.\n# 定义编译器CC = gccvpath %.h includevpath %.c srcvpath %.o buildvpath %.a libprogram: main.o utils.o    $(CC) -o program main.o utils.o -L. -lmylibmain.o: main.c project.h    $(CC) -c main.cutils.o: utils.c utils.h    $(CC) -c utils.c\n\n\nvpath的指令必须都写在Makefile当中, 在Make解析Makefile文件时被处理, 例如:\n# 如果需要清理 .o 文件的搜索路径并重新设置clean-paths:\t# 清除 .o 文件的搜索路径\tvpath %.o\t# 设置新的搜索路径\tvpath %.o new/build# 如果需要完全重置所有搜索路径reset-paths:\t# 清除所有 vpath 设置\tvpath\t# 重新设置所需的搜索路径\tvpath %.h include\tvpath %.c src\tvpath %.o build\n在终端中对应的指令:\n$ make              # 使用默认搜索路径编译$ make clean-paths  # 执行搜索路径清理和重设$ make reset-paths  # 重置所有搜索路径\n\n\n优先级: 当前目录 &gt; vpath &gt; VPATH. \n"},{"title":"cpp学习记录","url":"/2025/02/14/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/cpp%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","content":"导论编译时, 从c的gcc转变为了g++.\nOOP的三大特点:\n\n封装\n继承\n多态\n\n基本语法在C语言中,我们主要使用malloc()和free()来进行动态内存管理。但这种方式存在一些问题:\n\n它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;\n容易发生内存泄漏.\n\n为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了new和delete.\nnew的基本语法十分直观:\nType* pointer = new Type;           // 分配单个对象Type* pointer = new Type[size];     // 分配对象数组\n\n可以在创建时进行初始化:\nint* p1 = new int(5);              // 初始化为5string* p2 = new string(\"hello\");   // 初始化为\"hello\"\n\n也可以根据变量进行动态的内存分配:\nint size;cin &gt;&gt; size;int* arr = new int[size];  // 根据输入分配内存\n\n\n[!NOTE]\nUse delete ［］ if new ［］ was used to allocate an array.\n\n输入输出流通过包含头文件 – #include &lt;iostream&gt; 来使用输入输出流 cin 和 cout.\n#include &lt;iostream&gt;using namespace std;int main(){    int age;     cin &gt;&gt; age;    cout &lt;&lt; \"You are \" &lt;&lt; age &lt;&lt; \" years old\" &lt;&lt; endl;    // endl 是换行符    return 0;}\n\n\ncin读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:\n\nstring str=\"Hello world!\";ofstream fout(\"out.txt\");fout&lt;&lt;str&lt;&lt;endl;ifstream fin(\"out.txt\");string str1,str2;// 读取文件中的两个字符串fin&gt;&gt;str1&gt;&gt;str2; cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2 &lt;&lt; endl;// 输出:// Hello// world!return 0;\n\n\n文件流输入输出流基础\n头文件: #include &lt;fstream&gt;\n类: ifstream(输入流), ofstream(输出流)\n\n#include &lt;fstream&gt;  // 需要包含这个头文件using namespace std;// 文件输出（写入文件）ofstream outFile(\"output.txt\");outFile &lt;&lt; \"Hello World\" &lt;&lt; endl;outFile.close();// 文件输入（读取文件）ifstream inFile(\"input.txt\"); string line;getline(inFile, line);inFile.close();\n\n写入文件时, 如果没有文件, 会自动创建.\n\n常用操作示例\n写入文件\n\nofstream outFile;outFile.open(\"test.txt\");  // 打开文件if (outFile.is_open()) {   // 检查是否成功打开    outFile &lt;&lt; \"第一行\" &lt;&lt; endl;    outFile &lt;&lt; \"第二行\" &lt;&lt; endl;    outFile.close();       // 完成后关闭文件}\n\n\n**读取文件 **\n\nifstream inFile(\"test.txt\");string line;while (getline(inFile, line)) {  // 逐行读取    cout &lt;&lt; line &lt;&lt; endl;}inFile.close();\n\n\n以追加模式打开文件\n\nofstream outFile(\"test.txt\", ios::app);  // app 表示追加模式outFile &lt;&lt; \"这行会被添加到文件末尾\" &lt;&lt; endl;outFile.close();\n\n\n文件打开模式\nios::in - 读取模式\nios::out - 写入模式\nios::app - 追加模式\nios::ate - 打开文件后立即定位到文件末尾\nios::binary - 二进制模式\nios::trunc - 如果文件存在则截断文件\n如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.\n\n\n\n// 假设 test.txt 原本内容是:// Hello World// This is a test// 使用 trunc 模式打开ofstream outFile(\"test.txt\", ios::out | ios::trunc);  outFile &lt;&lt; \"新的内容\" &lt;&lt; endl;outFile.close();// 现在 test.txt 的内容只有:// 新的内容\n\n 或直接用 ios::out，因为out默认包含trunc\n\n\n使用位或运算符|来同时指定多个模式:\n\n// 组合使用打开模式ofstream outFile(\"test.txt\", ios::out | ios::app);\n\n错误处理ifstream inFile(\"nonexistent.txt\");if (!inFile) {    cerr &lt;&lt; \"无法打开文件！\" &lt;&lt; endl;    return 1;}// 或者使用is_open()if (!inFile.is_open()) {    cerr &lt;&lt; \"无法打开文件！\" &lt;&lt; endl;    return 1;}\n\n变量String需要先引入指定的头文件:\n#include &lt;string&gt;\n\n\n定义时可以使用等号或者用括号包裹字符串:\n\nstring name = \"John\"; // string name(\"John\");\n\n\nstringstreamstringstream 表示双向字符串流:\n\n需要导入头文件#include &lt;sstream&gt;;\nistringstream 表示输入字符串流\n作用: 将字符串转换成一个类似于输入流的对象;\n内部维护了一个字符串和一个位置指针;\n每次读取时, 位置指针向后移动, 且自动跳过空白字符.\n\n\nostringstream 表示输出字符串流.\n\n字符串分词自动以空白字符(空格、制表符\\t、换行符\\n等)分割字符串;\n#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;int main(){    string name ( \"Xiao Ming\");    // 使用括号包字符串    istringstream is (name);     string s;    while (is&gt;&gt;s){        cout &lt;&lt; s &lt;&lt; endl;    }}\n\n&gt;&gt; 表示从输入流中读取数据;\n注意字符串流也是一种类型, 作用的对象是字符串.\n\nOutput:\nXiao MingXiaoMing\n\n包含更多分词的字符串:\n#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;sstream&gt;using namespace std;int main(){    string words = \"hello \\n world! \\t I am \\n here!\";    stringstream is (words);        string word;    int count  = 1;    while(is &gt;&gt; word){        cout &lt;&lt; \"Word \" &lt;&lt; count &lt;&lt; \": \" &lt;&lt; word &lt;&lt; endl;        count++;    }}\nOutput:\nWord 1: helloWord 2: world!Word 3: IWord 4: amWord 5: here!\n\n字符串拼接#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() {    ostringstream oss;    string name = \"Alice\";    int age = 25;        oss &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age;    string result = oss.str();    cout &lt;&lt; result &lt;&lt; endl;}\nOutput:\nName: Alice, Age: 25\n\n通过.str()方法可以对象转换为字符串类型, 从而格式化输出.\n\n\n\n.str(\"\")方法可以清空字符串流:\n#include &lt;sstream&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;int main() {    ostringstream oss;    string name = \"Alice\";    int age = 25;        oss &lt;&lt; \"Name: \" &lt;&lt; name &lt;&lt; \", Age: \" &lt;&lt; age;    oss.str(\"\");    string result = oss.str();    cout &lt;&lt; result &lt;&lt; \"Nothing\" &lt;&lt; endl;}\nOutput:\nNothing\n\nGetline基本语法:\ngetline(istream&amp; is, string&amp; str, char delim = '\\n');\n\nis: 输入流（通常是cin;\nstr: 存储结果的字符串;\ndelim: 分隔符, 默认为换行符\\n.\n\nExample:\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string line;        cout &lt;&lt; \"请输入一行文本：\";    getline(cin, line);  // 读取整行，包括空格    cout &lt;&lt; \"你输入的是：\" &lt;&lt; line &lt;&lt; endl;        // 使用自定义分隔符    string data;    cout &lt;&lt; \"请输入内容（用,分隔）：\";    getline(cin, data, ',');  // 读取直到遇到逗号    cout &lt;&lt; \"读取到逗号前的内容：\" &lt;&lt; data &lt;&lt; endl;}\n\ncin特点:\n\n以空白字符（空格、制表符、换行符）为分隔符;\n忽略前导空白字符;\n遇到空白字符就停止读取.\n\n通常需要与getchar()方法配合来清除缓冲区当中的\\n字符:\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    int number;    string line;        cout &lt;&lt; \"输入一个数字：\";    cin &gt;&gt; number;        //清除输入缓冲区中的换行符    getchar(); // or cin.ignore();        cout &lt;&lt; \"输入一行文本：\";    getline(cin, line);  // 现在可以正确读取整行        cout &lt;&lt; \"数字：\" &lt;&lt; number &lt;&lt; endl;    cout &lt;&lt; \"文本：\" &lt;&lt; line &lt;&lt; endl;}\n\n如果输入8 \\n, 则getchar()读取空格, 文本为空.\n\nAlter Stringoutline : 常用的字符串方法(成员函数):\ninsert(size_t pos, const string&amp; s);erase (size_t pos = 0, size_tlen = npos);append (const string&amp; str);replace (size_t pos,size_t len,const string&amp; str);\n\n\n常用方法\ninsert(int pos, string str) 在指定位置插入字符串\n\nstring str = \"Hello World\";// 在位置5处插入字符串str.insert(5, \" Beautiful\");cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello Beautiful World\"// 在字符串末尾插入内容str.insert(str.length(), \"!\");cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello Beautiful World!\"// 插入单个字符（使用string构造）str.insert(0, \"&gt;\");cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"&gt;Hello Beautiful World!\"\n\n\n\nerase(int pos, int length) 删除从指定位置开始的若干个字符\n\nstring str = \"Hello Beautiful World!\";// 删除从下标6开始的9个字符str.erase(6, 9); cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello World!\"// 删除从某个位置开始到末尾的所有字符str.erase(5);cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello\"\n\nlength参数省略, 则删除从pos位置开始到字符串末尾的所有字符.\n\n\n\nreplace (int pos, int length, string) 替换指定位置的字符串\n\n// 从位置6开始，替换5个字符为\"C++\"string str = \"Hello World!\";str.replace(6, 5, \"C++\");cout &lt;&lt; str &lt;&lt; endl;  // 结果: \"Hello C++!\"\n\n\n\n\nappend (const string&amp; str);\n\n// 添加整个字符串string1.append(string2);// 添加指定位置的字符(索引从开始)string1.append(string2, start, length);// 重复字符的添加string1.append(count, char);\n\n除此之外, 还存在着使用迭代器的用法: \n\n类似于指针, 指向容器(如字符串、数组等)的特定位置.\n\n#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main() {    string source = \"World!\";    string target = \"Hello \";        // 添加source中的部分字符（从开始到结束）    target.append(source.begin(), source.end());    cout &lt;&lt; target &lt;&lt; endl;  // 输出: Hello World!        // 只添加部分字符    string target2 = \"Hello \";    target2.append(source.begin(), source.begin() + 5);  // 只添加\"World\"，不包含\"!\"    cout &lt;&lt; target2 &lt;&lt; endl;  // 输出: Hello World        return 0;}\n\nbegin()方法返回字符串的第一个字符的迭代器, end()方法返回字符串最后一个字符的下一个位置的迭代器;\n迭代器的范围是左闭右开.\n\n\n其他方法\nfind(string, int pos) 从指定的位置开始寻找字符串位置\n\nstring str = \"Hello World Hello\";// 从位置0开始查找\"Hello\"cout &lt;&lt; str.find(\"Hello\", 0) &lt;&lt; endl;     // 结果: 0// 从位置1开始查找\"Hello\"cout &lt;&lt; str.find(\"Hello\", 1) &lt;&lt; endl;     // 结果: 12// 查找不存在的字符串cout &lt;&lt; str.find(\"Python\") &lt;&lt; endl;       // 结果: string::npos\n\nstring::npos是size_t类型的最大值;\n可以使用str.find(\"Python\") == string::npos作为判断条件, 检查是否找到字符串.\n\n\n\ncompare(string) 字符串比较\n\nstring str1 = \"Hello\";string str2 = \"Hello\";string str3 = \"World\";cout &lt;&lt; str1.compare(str2) &lt;&lt; endl;  // 结果: 0  (相等)cout &lt;&lt; str1.compare(str3) &lt;&lt; endl;  // 结果: -15 (str1 &lt; str3) cout &lt;&lt; str3.compare(str1) &lt;&lt; endl;  // 结果: 15  (str3 &gt; str1)\n\n按照字典序比较得到结果\n\n\n\nto_string(int) 将数字转换成字符串\n\nint num = 123;string str = to_string(num);cout &lt;&lt; str &lt;&lt; endl;          // 结果: \"123\"cout &lt;&lt; str + \"456\" &lt;&lt; endl;  // 结果: \"123456\"\n\n字符串之间可以通过+直接拼接.\n\n\n\nstoi(string) 将字符串转换成整数\n\nstring str = \"123\";int num = stoi(str);cout &lt;&lt; num + 456 &lt;&lt; endl;    // 结果: 579// 注意：字符串必须是合法的数字格式// string str = \"abc\"; // int num = stoi(str);  // 这会抛出异常\n\n字符串必须是合法的数字格式;\n int num = stoi(\"abc\");  将会抛出异常\n\n\n构造函数Outline:\nstring(const char *cp, int len);string(const string&amp; s2, int pos);string(const string&amp; s2, int pos, int len);\n\n\n\nstring(const char *cp, int len) 字符数组创建字符串\n\nstring str1(\"Hello World\", 5);cout &lt;&lt; str1 &lt;&lt; endl;// 输出: Hello\n\n\nstring(const string&amp; s2, int pos) 从现有字符串创建新字符串，从指定位置到末尾\n\nstring s2 = \"Hello World\";string str2(s2, 6);cout &lt;&lt; str2 &lt;&lt; endl;// 输出: World\n\n\nstring(const string&amp; s2, int pos, int len) 从现有字符串创建新字符串，指定起始位置和长度\n\nstring s3 = \"Hello World\";string str3(s3, 6, 3);cout &lt;&lt; str3 &lt;&lt; endl;// 输出: Wor\n\n\nstring(int length, char c) 用指定长度的字符c初始化字符串\n\nstring str4(5, '*');cout &lt;&lt; str4 &lt;&lt; endl;// 输出: *****// 实际应用示例int num = 432;string str = to_string(num);cout &lt;&lt; string(5 - str.length(), '0') + str &lt;&lt; endl;// 输出: 00432\n\n\n成员函数// 提取子字符串substr(int pos, int len);string str = \"Hello World\";string sub = str.substr(6, 3);  // 结果: \"Wor\"\n\n// 字符串赋值assign();string str1 = \"Hello\";string str2;str2.assign(str1);  // str2现在是 \"Hello\"\n\n\n// 在指定位置插入字符串    string str1 = \"hello\";    string str2 = \"world\";    str1.insert(3, str2);    cout &lt;&lt; str1 &lt;&lt; endl;// 结果: helworldlo \n\n// 删除指定位置的指定长度的字符erase(int pos, int len);string str = \"Hello World\";str.erase(5, 6);  // 结果: \"Hello\"\n\nNotice：\n\n所有位置索引都是从0开始计数\n如果指定的长度超过字符串实际长度，会自动调整到实际可用长度\n使用这些函数时要注意检查参数的有效性，避免越界访问\n.assign(str, pos, len): 相比于直接赋值, assign还提供了精确控制赋值的方法, 也就是指定内容字符串的起始位置和长度.\n\n\nSubstr在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. substr()方法可以精确地获取字符串片段.\nsubstr即substring的缩写, 表示子字符串.\n基本语法\nstring substr(int pos, int len) ;\n参数分别表示截取的起始下标以及要截取的长度(如果省略len将截取到字符串的末尾).\ne.g.:\nstring email = \"user.name@example.com\";// 获取用户名的部分int atPos = email.find('@');string username = email.substr(0, atPos); // result: \"user.name\"// 获取域名部分string domain =  email.substr(atPos + 1); // result: \"example.com\"// 获取顶级域名(最后一个.之后的部分)int lastDotPos = email.rfind('.');string topLevelDomain = email.substr(lastDotPos + 1); // result: \"com\"\n\nrfind()方法: 会从字符串的末尾向前搜索，从而返回要查找的字符或子字符串此时第一次出现的位置。如果没有找到，则返回 string::npos.\n\n\nFunctionDefault arguments要点:\n\n默认值必须在函数原型中从右到左地给出, 否则在调用的时候无法分辨;\n\n默认值只能出现在函数原型 或者 将声明和定义放在一起, 下面的情况会报错:\nvoid f(int i, int j = 10);int main(){    ...}void f(int i, int j = 10){    ...}\n\nGroup选择的标准:\n\n一般情况  vector;\n程序需要对元素进行随机访问  vector or deque;\n程序需要在容器中间插入元素  list or forward_list;\n程序需要在容器的首尾插入元素  deque;\n容器中的元素相对较小但是数量较多  list nor forward_list.\n否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.\n\n\n\nPair基本介绍1. 基本概念pair 是 C++ 标准库提供的模板类，用于将两个不同类型的值组合成一个对象。它定义在 &lt;utility&gt; 头文件中。\n2. 创建与初始化// 默认构造std::pair&lt;std::string, int&gt; p1;// 直接初始化std::pair&lt;std::string, int&gt; p2(\"tag\", 10);// 使用make_pairauto p3 = std::make_pair(\"data\", 5);// 统一初始化std::pair&lt;std::string, int&gt; p4{\"value\", 8};\n\n3. 访问元素// 传统访问方式std::cout &lt;&lt; p2.first &lt;&lt; \": \" &lt;&lt; p2.second &lt;&lt; endl;// 结构化绑定(C++17)auto [key, val] = p3;std::cout &lt;&lt; key &lt;&lt; \": \" &lt;&lt; val &lt;&lt; endl;\n\n4. 常用操作// 比较操作if (p1 == p2) {...}if (p1 &lt; p2) {...}  // 先比较first，再比较second// 交换内容p1.swap(p2);std::swap(p1, p2);\n\n5. 实际应用示例// 作为函数返回值std::pair&lt;bool, string&gt; checkInput(const string&amp; input) {    if (input.empty()) {        return {false, \"输入不能为空\"};    }    return {true, \"\"};}// 在容器中使用vector&lt;pair&lt;string, int&gt;&gt; dataList = {    {\"item1\", 10},    {\"item2\", 20},    {\"item3\", 30}};// 与map配合使用map&lt;string, pair&lt;int, double&gt;&gt; complexData;\n\n6. 注意事项\npair 的元素可以是任意类型，包括自定义类型\n使用结构化绑定需要C++17或更高标准\npair 常用于需要返回多个值的函数\n在性能敏感场景要注意构造和拷贝开销\n\nSet集合: 用于存储一组不允许重复的元素, 且会自动排序.\n可以使用的方法包括:\n\n.insert( ): 插入元素;\n\n.erase(): 删除元素. 如果输入是元素值, 那么返回1/0表示是否成功删除; 如果输入是迭代器, 那么返回的是下一个元素的迭代器.\n\n.find( ): 寻找元素, 如果找到 返回对应的 迭代器. 否则返回 .end( );\n\n\nVector存储元素在连续的内存空间中, 支持随机访问.\n\n可以动态增长, 适合存储未知数量的元素;\n通过下标访问元素的时间复杂度为 O(1);\n在末尾插入和删除元素的时间复杂度为 O(1);\n在中间插入和删除元素的时间复杂度为 O(n);\n使用场景: 需要随机访问、排序、内存连续存储的场景.\n\n语法:\n\n使用 .end()返回一个指向容器末尾后一个位置的迭代器:\nauto it = find(vec.begin(), vec.end(), value);  // 查找 value  if (it != vec.end()) {         // 如果找到了（即没有返回 end()）      vec.erase(it);             // 则删除找到的元素  }\n使用 .push_back()在末尾插入元素, 或者使用.emplace_back()在末尾原位构造元素(更加高效);\nvec.push_back(10);vec.emplace_back(20); //更加高效\n\nemplace_back方法直接在容器的内存空间中构造对象, 相比于push_back而言更加高效.\n\n\n.erase()方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;\n  vec.erase(vec.begin() + 1);       // 删除第二个元素vec.erase(vec.begin(), vec.begin() + 3); // 删除前三个元素vec.clear();                      // 清空整个 vector\n\nvec.clear(); 将会清空整个vector.\n和insert需要的参数一样, 都需要迭代器而非索引来定位.\n\n\nvec[i]的形式访问, 使用vec.at(i)的方式可以在越界时抛出异常;\n\n.begin()和.end()获取迭代器, 使用范围for循环遍历元素;\n   cout &lt;&lt; \"Vector elements:\" &lt;&lt; endl; for (int num : vec) {    cout &lt;&lt; num &lt;&lt; \" \"; } cout &lt;&lt; endl;//使用迭代器遍历for (auto it = vec.begin(); it != vec.end(); ++it) {    cout &lt;&lt; *it &lt;&lt; \" \";}cout &lt;&lt; endl;\n.size()获取vector的大小, .empty()判断vector是否为空;\ncout &lt;&lt; \"Vector size: \" &lt;&lt; vec.size() &lt;&lt; endl;if (vec.empty()) {    cout &lt;&lt; \"Vector is empty.\" &lt;&lt; endl;}\n使用sort()对vector进行排序, 使用find()查找元素;\nsort(vec.begin(), vec.end());   // 排序auto it = find(vec.begin(), vec.end(), 5); // 查找 5\n\ninsert 插入的位置是指定的迭代器位置之前一个;\n\n\nReserve为了避免频繁地扩展内存, 可以通过reserve预先分配合适的空间, 同时通过.reszie()调整大小;\nvector&lt;string&gt; v2;v2.reserve(1000);  // 一次性分配 1000 个元素的空间v2.resize(v2.size() + v2.size()/2); // 调整大小为原来的 1.5 倍\n\nreserve只分配空间而不创建元素,resize将同时分配元素(默认值):\nvector&lt;string&gt; vec;// reserve: 只分配空间，不创建元素vec.reserve(10);  cout &lt;&lt; \"The capacity with reserve: \" &lt;&lt; vec.capacity() &lt;&lt; endl;cout &lt;&lt; \"The size with reserve: \" &lt;&lt; vec.size() &lt;&lt; endl;    // resize: 分配空间并创建元素vec.resize(10);   cout &lt;&lt; \"The capacity with resize: \" &lt;&lt; vec.capacity() &lt;&lt; endl;cout &lt;&lt; \"The size with resize: \" &lt;&lt; vec.size() &lt;&lt; endl;   \n\nOutput:\nThe capacity with reserve: 10The size with reserve: 0The capacity with resize: 10The size with resize: 10\n\n[!important]\n.push_back()的实际作用是在容器索引的size处插入元素.\n 而reserve不会影响容器的size,  初始化和resize会影响并且填充默认值:\n\ne.g.  验证:\nint main() {    vector&lt;int&gt; vec(10);        // 打印初始状态    cout &lt;&lt; \"初始状态：\\n\";    cout &lt;&lt; \"size: \" &lt;&lt; vec.size() &lt;&lt; \", capacity: \" &lt;&lt; vec.capacity() &lt;&lt; \"\\n\\n\";        // 预留5个空间    vec.reserve(15);    cout &lt;&lt; \"reserve(15) 后：\\n\";    cout &lt;&lt; \"size: \" &lt;&lt; vec.size() &lt;&lt; \", capacity: \" &lt;&lt; vec.capacity() &lt;&lt; \"\\n\\n\";        vec[20] =20;    // 添加元素并观察    cout &lt;&lt; \"添加元素过程：\\n\";    for(int i = 1; i &lt;= 6; i++) {        vec.push_back(i);        cout &lt;&lt; \"添加 \" &lt;&lt; i &lt;&lt; \" 后 - \";        cout &lt;&lt; \"size: \" &lt;&lt; vec.size()              &lt;&lt; \", capacity: \" &lt;&lt; vec.capacity()             &lt;&lt; \", 元素: \";        for(int x : vec) cout &lt;&lt; x &lt;&lt; \" \";        cout &lt;&lt; \"\\n\";    }        return 0;}\n\nOutput:\n初始状态：size: 10, capacity: 10reserve(15) 后：size: 10, capacity: 15添加元素过程：添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 \n\n\n此处的 vector&lt;int&gt; vec(10);初始化了10个默认值的int类型的元素;\nvec[20] = 20;没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;\n如果换成vec.at(20) = 20将会在编译时报错;\n\n\n可以发现, reserve的作用就是避免了多次自动扩容.\n\n\nreserve的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素copy到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.\n\nResize用法的枚举:\n\nresize(n): 将vector的大小调整为n, 如果大于当前值, 则在末尾添加具有默认值的新元素;\n\nresize(n, val): 同样调整大小, 但是指定了默认值为新的 val;\n\n对于二维向量的内存分配也是类似的:\nvector&lt;vector&lt;int&gt;&gt; m;  //二维码向量; ... m.resize(r,vector&lt;int&gt;(c,0)); //初始化为一个r行c列且初始值为0的矩阵.\n\nList\n在list容器当中, 迭代器是双向迭代器;\n双向迭代器不支持大小的比较, 只支持 ==,!=,++,--;因此, 注意实际的使用:\n\n\n\nlist&lt;int&gt; lst1;list&lt;int&gt;::iterator iter1 = lst1.begin();list&lt;int&gt;::iterator iter2 = lst1.end();// 正确的写法while (iter1 != iter2) {    // 处理当前元素    ++iter1;}// 错误的比较// while(iter1 &lt; iter2)     \n\n有序链表#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;string&gt;using namespace std;int main() {    list&lt;string&gt; s;    string str;    list&lt;string&gt; :: iterator p;    int count ;    cout &lt;&lt; \"enter the number of the strings:\" &lt;&lt; endl;    cin &gt;&gt; count;     for(int i = 0; i &lt; count; i++){        cout &lt;&lt; \"enter a string:\" ;        cin &gt;&gt;str;                p = s.begin();        while(p != s.end() &amp;&amp; *p &lt;str)            p++;        s.insert(p,str);    }    for(p = s.begin(); p!=s.end(); p++)        cout &lt;&lt; *p &lt;&lt; endl;    cout &lt;&lt; endl;    return 0;}\n\n分析:\n\nwhile(p != s.end() &amp;&amp; *p &lt;str) 每次输入str时, 令迭代器从list的开头开始, 进行字典序的比较;\n\n\n[!important]\n找到插入的位置, 利用insert()方法插入到给出迭代器的前面!.\n\nDequedeque即 double-ended queue, 双端队列.\n支持:\n\n在两端快速的插入或删除;\n随机访问;\n\n语法:\n#include &lt;deque&gt;deque&lt;int&gt; dq;// 1. 插入操作dq.push_back(1);    // 在末尾插入dq.push_front(2);   // 在开头插入dq.insert(pos, val);// 在指定位置插入// 2. 删除操作dq.pop_back();      // 删除末尾元素dq.pop_front();     // 删除首部元素dq.erase(pos);      // 删除指定位置元素// 3. 访问操作dq[0];              // 随机访问dq.at(1);           // 带边界检查的访问dq.front();         // 访问第一个元素dq.back();          // 访问最后一个元素\n\n示例:\n#include &lt;deque&gt;#include &lt;iostream&gt;using namespace std;int main() {    deque&lt;int&gt; dq;        // 在两端插入元素    dq.push_back(3);    dq.push_front(1);    dq.push_back(4);    dq.push_front(8);        // dq ：{8, 1, 3, 4}        // 使用随机访问    for(size_t i = 0; i &lt; dq.size(); ++i) {        cout &lt;&lt; dq[i] &lt;&lt; \" \";    }}\n\nForward_listforward_list即 单项链表.\n\n只能向前遍历, 即对应的迭代器不支持--而支持++.\n同时不支持下标访问以及随机访问.\n单项链表的设计, 使得内部的每个节点只需要一个指针来指向下一个节点, 从而比list双向链表更加节省内存.\n\n语法:\n#include &lt;forward_list&gt;forward_list&lt;int&gt; fl;// 1. 插入操作fl.push_front(1);           // 在开头插入fl.insert_after(pos, val);  // 在指定位置之后插入// 2. 删除操作fl.pop_front();            // 删除第一个元素fl.erase_after(pos);       // 删除指定位置之后的元素// 3. 访问操作fl.front();               // 访问第一个元素// 4. 特殊操作fl.before_begin();        // 返回第一个元素之前的迭代器fl.begin();               // 返回第一个元素的迭代器\n\n示例:\n#include &lt;forward_list&gt;#include &lt;iostream&gt;using namespace std;int main() {    forward_list&lt;int&gt; fl;        // 插入元素    fl.push_front(3);    fl.push_front(2);    fl.push_front(1);        // 在特定位置后插入    auto it = fl.begin(); // 指向第一个元素    fl.insert_after(it, 4); // 在第一个元素后插入4        // 遍历打印    for(const auto&amp; val : fl) {        cout &lt;&lt; val &lt;&lt; \" \";    }    // 输出：1 4 2 3}\n\n访问前一个元素由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合before_begin()方法.\n// 如果需要访问某个元素的前一个元素，必须从头开始遍历auto prev = fl.before_begin();auto curr = fl.begin();while(curr != fl.end() &amp;&amp; *curr != target) {    ++prev;    ++curr;}\n\nMap作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键自动排序\n\n如果插入重复的key, 将会覆盖原有的value;\n通过键查找元素、插入和删除的时间复杂度均为O(log n);\n使用场景: 字典、索引、统计等.\n\n语法:\n\n使用 .end()返回一个指向容器末尾后一个位置的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于map当中;\nauto it = ages.find(\"Charlie\");  // 查找 \"Charlie\"  if (it != ages.end()) {         // 如果找到了（即没有返回 end()）      ages.erase(it);             // 则删除找到的元素  }\n使用下标(键)直接插入,或者通过键值对插入\nages[\"Alice\"] = 25;ages.insert({\"Bob\", 30});ages.emplace(\"Charlie\", 28); // 使用 emplace 插入 (更高效)\n\nemplace方法指直接在容器的内存空间中构造对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于insert而言更加高效.\n\n\n.erase()方法删除指定key的元素, 也可以通过.find()找到key对应的迭代器it, 然后erase(it).\n  ages.erase(\"Bob\");           // 删除键为 \"Bob\" 的元素auto it = ages.find(\"Charlie\");if (it != ages.end()) {    ages.erase(it);         // 删除迭代器指向的元素}\n\nages.clear(); 将会清空整个map.\n\n\nmap[key]的形式访问, 使用map.at(key)的方式可以在key不存在时抛出异常;\n\n.find(key)查找对应键的元素( 返回迭代器 ), .count(key)返回对应键的元素个数(0 or 1)\n\n.size()获取map的大小.\n\n迭代器的-&gt;first和-&gt;second可以分别访问键和值.\n  cout &lt;&lt; \"Map elements:\" &lt;&lt; endl;for (auto mapIt = ages.begin(); mapIt != ages.end(); ++mapIt) {   cout &lt;&lt; mapIt-&gt;first &lt;&lt; \": \" &lt;&lt; mapIt-&gt;second &lt;&lt; endl; // 访问键和值}\n\nIterator迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.\n\n标记位置: .begin()和.end() 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;\n\n迭代器的分类:\n\n输入迭代器: 支持读取和递增操作;\nistream_iterator: 用于从输入流读取数据;\n\n\n输出迭代器: 支持写入和递增操作;\nostream_iterator: 用于向输出流写入数据;\n\n\n前向迭代器: 具有输入、输出迭代器的所有功能, 并且可以多次遍历同一个序列;\n比如forwarf_list的迭代器:auto it = flist.begin() or forward_list&lt;int&gt;::iterator it = flist.begin();\n\n\n双向迭代器: 在前向迭代器的原有功能上, 同时支持递减操作;\n比如双向链表list的迭代器.#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() {    list&lt;int&gt; myList = {10, 20, 30, 40, 50};    // 使用双向迭代器正向遍历    cout &lt;&lt; \"Forward traversal: \";    for ( list&lt;int&gt;::iterator it = myList.begin(); it != myList.end(); ++it) {        cout &lt;&lt; *it &lt;&lt; \" \";    }    cout &lt;&lt;  endl;    // 使用双向迭代器逆向遍历    cout &lt;&lt; \"Reverse traversal: \";    for ( list&lt;int&gt;::reverse_iterator rit = myList.rbegin(); rit != myList.rend(); ++rit) {        cout &lt;&lt; *rit &lt;&lt; \" \";    }    cout &lt;&lt;  endl;    return 0;    // Forward traversal: 10 20 30 40 50     // Reverse traversal: 50 40 30 20 10 }\n\n\nreverse_iterator用于声明逆向遍历的迭代器, 也可以使用auto直接声明.\nrbegin()和rend()分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的++相当于正向遍历时的--操作.\n\n\n\n\n\n随机访问迭代器: 具有双向迭代器的所有功能, 同时支持随机访问, 如it+n,it[n].\n比如vector的迭代器.\n\nvector&lt;int&gt; vec = {10, 20, 30, 40, 50};cout &lt;&lt; \"Vector elements (random access): \";for (int i = 0; i &lt; vec.size(); ++i) {    cout &lt;&lt; vec[i] &lt;&lt; \" \"; // 使用下标随机访问}cout &lt;&lt; endl;\n\n另外, 还有一种迭代器称为插入迭代器, 比如back_inserter\nvector&lt;int&gt; vec = {10, 20, 30, 40, 50};//结合copy将容器的元素直接插入到另一个容器中vector&lt;int&gt; dest = {60,70};copy(vec.begin(), vec.end(), back_inserter(dest)); // 在 dest 末尾插入元素cout &lt;&lt; \"Copied vector: \";for (int num : dest) {    cout &lt;&lt; num &lt;&lt; \" \";}cout &lt;&lt; endl;// Copied vector: 60 70 10 20 30 40 50 \n\nfor-eachfor-each 循环的语法：\nfor (range_declaration : range_expression) {    loop_statement;}\n\nrange_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 auto 关键字让编译器自动推导类型;\nrange_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或字符串;\nloop_statement： 循环体，包含要对每个元素执行的语句.\n\ne.g:\n#include &lt;iostream&gt;#include &lt;vector&gt;int main() {    std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5};    // 使用 for-each 循环遍历 vector    for (int num : numbers) {        std::cout &lt;&lt; num &lt;&lt; \" \"; // 输出每个元素    }    std::cout &lt;&lt; std::endl;    // 使用 auto 关键字自动推导类型    for (auto num : numbers) {        std::cout &lt;&lt; num &lt;&lt; \" \";    }    std::cout &lt;&lt; std::endl;    // 修改容器中的元素（需要使用引用）    for (int &amp;num : numbers) {        num *= 2; // 将每个元素乘以 2    }    // 输出修改后的元素    for (auto num : numbers) {        std::cout &lt;&lt; num &lt;&lt; \" \";    }    std::cout &lt;&lt; std::endl;    return 0;}\n\nfor (int &amp;num : numbers)：使用引用 &amp;，可以直接修改容器中的元素.\n\nMap的循环当range_expression是map时, 可以使用auto自动推导range_declaration的类型.需要注意是:\n\n用迭代器的方式访问map中的键值对的形式是 it-&gt;first与it-&gt;second;\n在for-each循环当中, range_declaration是一个值, 因此使用.first与.second来访问键和值.  #include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main(){    map&lt;string, string&gt; m = {{\"one\", \"1\"}, {\"two\", \"2\"}, {\"three\", \"3\"}};    vector&lt;string&gt; vec;    for(auto&amp; entry : m){        vec.push_back(entry.first + \":\" + entry.second );    }    copy(vec.begin(), vec.end(), ostream_iterator&lt;string&gt;(cout, \" \"));}\n  Output:  one:1 three:3 two:2\n\n此处由于map自动按照键的字典序进行排序, 因此输出时three的元素在two前;\n\n\n\n在上述的示例中, 也可以使用下面的方式进行vec的输出:\nfor(const auto&amp; s : vec) {    cout &lt;&lt; s &lt;&lt; \" \";}\n此时auto会自动推导为string类型, 且&amp;对数组的元素进行了引用, 使得输出更加高效.\nPro&amp;Confor-each循环的优点:\n\n消除了访问数组等越界的风险;\n不需要事先初始化迭代器;\n\nfor-each循环的缺点:\n\n无法获取元素的索引;\n只能顺序地遍历.\n\ntypedef我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.\n而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.\ntypedef old_type new_type;\n\nNotices\n直接对数组、字符串和vector进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;\n\n对于vector, 可以通过.at() = 的方式进行安全访问, 编译器会进行边界检查. 或者通过.push_back() or .emplace_back的方式在末尾赋值. 同时注意用.reserve()预先分配充分的内存空间.\n\n避免不经意地向map当中插入元素:\n\n错误的示范:\n\n if(foo[\"bob\"] == 1){...}// 设置默认的零值\n\n使用.count()方法正确检查元素是否存在:\n\n if( foo.count(\"bob\") ){...}\n\n也可以使用find()方法检查元素是否存在:\n\nauto it = m.find(\"four\");   if(it  != m.end()){    cout &lt;&lt; it-&gt;second &lt;&lt; endl;}else{    cout &lt;&lt; \"Not found\" &lt;&lt; endl;}\n使用.empty()方法来检查容器整体是否为空, 而非.count() == 0的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.\n\nerase() 方法会返回指向被删除元素的下一个元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:\n //Initialize a listlist&lt;int&gt; L;list&lt;int&gt;::iterator li = L.begin();// Wrong:L.erase(li);    // 删除元素后，li 变成了无效迭代器++li;           // 错误, 不能对无效迭代器进行操作// Correct:li = L.erase(li);  // 删除元素后，li 被更新为指向被删除元素的下一个元素\n\n指针\nPointers to Objects\n\nstring str = \"hello\";string *p = &amp;str;\n\n\nOprators with Pointers\n&amp;: 取地址;\n*: 解引用;\n-&gt;: 用于访问对象的成员.\n\n\n\n(*p).length();// 等价于p-&gt;length();\n\nlength()即为string类的成员函数, 因此可以用-&gt;来访问.\n\n常量指针\n以char为例.\n\n\n指向常量的指针 const char *p\n可以改变指针的地址.\n无法通过指针改变对象的值\n\n\n常量指针 char * const p\n指针指向的地址无法改变;\n但是可以通过指针改变对象的值如果需要同时保证地址和值都无法改变, 则需要使用const char * const p.\n\n\n\n如果sp是指向字符串的指针, 那么这两种的写法是等价的, 注意.的优先级高于*, 因此括号不可忽略.\nsp-&gt;length();(*sp).length();\n\n\n\nClass:::: resolver: 作用域解析运算符\n\n作用: \n\n访问全局的作用域当局部变量和全局变量同名时, 可以使用 :: 来访问全局变量\nint value = 10; // 全局变量void function() {    int value = 20; // 局部变量    cout &lt;&lt; value;    // 输出 20（局部变量）    cout &lt;&lt; ::value;  // 输出 10（全局变量）}\n\n访问命名空间中的成员\nnamespace Math {    const double PI = 3.14159;}double circumference = 2 * Math::PI * radius; // 使用命名空间中的常量\n\n\n语法:\n\n&lt;class_name&gt; :: &lt;function_name&gt;\n::&lt;function_name&gt;  全局作用域\n\n\n\ne.g. \nvoid S::f() {    ::f();  // Would be recursive otherwise!    ::a++;  // Select the global a    a--;    // The a at class scope}\n\n\nS::f(): 定义了属于类S的成员函数f;\n::f():表示调用全局作用域中的函数 f(), 默认为递归调用当前的成员函数;\n::a++表示将全局作用域的 a 自增, a--则访问并递减类作用域中的成员变量 a.\n\nthisthis指针是成员函数的隐藏参数. 指向当前对象的实例.\nvoid Point::move(int dx, int dy);//等价于void Point::move(Point *this, int dx, int dy);\n\n当调用成员函数时, 对象的地址会自动作为 this参数传递.\n在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 this:\ne.g\nclass Point {private:    int x, y;    public:    // 移动点的位置    void move(int dx, int dy) {        x += dx;        y += dy;    }        // 打印点的坐标    void print() {        std::cout &lt;&lt; \"Point at (\" &lt;&lt; x &lt;&lt; \", \" &lt;&lt; y &lt;&lt; \")\" &lt;&lt; std::endl;    }        // 组合以上两个功能的函数    void move_and_print(int dx, int dy) {        move(dx, dy);  // 等同于 this-&gt;move(dx, dy)        print();       // 等同于 this-&gt;print()    }};\n\n\n但是也可以显式指定 this-&gt;move, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.\n\n封装特性在OOP中, Object = Attributes + Services, 即数据和操作被封装在一起, 构成一个完整的对象.\n声明与定义我们应当在头文件中声明对象的成员及其 public,private和 protected等属性, 并且在 cpp文件中给出具体的定义:\n\n最好为每个类都建立如此对应的头文件和源文件 cpp.\n\ne.g. \n// Student.h - 类的声明#ifndef STUDENT_H#define STUDENT_H#include &lt;string&gt;using namespace std;  // 在头文件中使用class Student {private:    // 数据成员    string name;         int id;    float gpa;    public:    // 构造函数原型    Student(const string&amp; name, int id);        // 成员函数原型    void setName(const string&amp; newName);    string getName() const;    void calculateGPA();    bool isEligibleForScholarship() const;};#endif // STUDENT_H\n\n// Student.cpp - 成员函数的定义#include \"Student.h\"using namespace std;  // 在源文件中使用// 构造函数实现Student::Student(const string&amp; name, int id) {    this-&gt;name = name;    this-&gt;id = id;    this-&gt;gpa = 0.0;}// 成员函数实现void Student::setName(const string&amp; newName) {    name = newName;}string Student::getName() const {    return name;}void Student::calculateGPA() {    // 实现GPA计算逻辑    // ...}bool Student::isEligibleForScholarship() const {    return gpa &gt;= 3.5;}\n\n\nStudent::getName()指的就是类 Student中的成员函数 getName().\n\n具体来说, .h头文件当中应该有:\n\n外部变量的声明e.g. extern int globalCounter;  // 仅声明，不定义\n\n函数原型e.g. int calculateSum(int a, int b);  // 函数声明，不包含实现\n\n类/结构体的声明e.g.\nclass Student;  // 前向声明// 或完整类声明（不含成员函数定义）class Rectangle {private:    double width;    double height;public:    Rectangle(double w, double h);    double getArea() const;};\n\n回顾 #include: 将被引用的文件插入 .cpp 文件当中\n\n#include \"xx.h\": 首先在当前目录下寻找;\n\n#include &lt;xx.h&gt;: 直接在指定的目录中寻找\n\n等价于 #include &lt;xx&gt;.\n\n\n\n为了避免在多个 .cpp 文件中重复引用相同的头文件, 可以通过 #ifndef等标记来判断是否需要引用当前的头文件:\n#ifndef HEADER_FLAG#define HEADER_FLAG#endif \n\n\nHEADER_FLAG一般使用完全大写来方便标识, 但是也可以大小写混合.\n\ne.g. \n// 文件: vector.h#ifndef VECTOR_H#define VECTOR_H// ...#endif // VECTOR_H\n\n生命周期管理当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.\n为了确保这些工作不被遗忘, cpp的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.\n构造函数构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.\n\n语法:\n\nclass ClassName {public:    // 默认构造函数    ClassName();        // 带参数的构造函数    ClassName(参数列表);        // 拷贝构造函数    ClassName(const ClassName&amp; other);    };\n\n\n\n默认构造函数：不带参数或所有参数都有默认值;\n带参数的构造函数：接受一个或多个参数;\n拷贝构造函数：从同类型的另一个对象创建新对象.\n\n\n\n构造函数初始化列表\nPoint::Point(int xx, int yy) :x(xx), y(yy) {  ...}\n\n\n构造函数时, 传递参数并直接赋值给内部的成员变量 x , y.\n\n\n结构体中的构造函数:\nstruct Y {     float f;     // 浮点型成员变量    int i;       // 整型成员变量    Y(int a);    // 声明了一个接受int参数的构造函数};\n\n\n\n此处只是声明了构造函数需要 int a作为参数, 但是没有给出具体的实现;\n声明结构体对象(数组)  e.g. Y y1[] = { Y(1), Y(2), Y(3) };\n\n\n\n\n默认构造auto default constructor: (自动) 默认构造函数. 当且仅当不存在任何构造函数时, 程序会自动生成默认构造函数, 不作任何的操作.\n默认构造函数： 在没有参数的情况下可以调用的构造函数， 称为默认构造函数. 其来源除了上述的程序构造以外, 还包括:\n\n显示定义的无参构造函数;\n定义的所有参数都具有默认值的构造函数.\n\n\n对于成员变量: 不进行初始化;\n\n析构函数析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 ~. 当对象超出作用域或被显式删除时，析构函数会自动被调用.\nclass ClassName {public:    ~ClassName();};\n\n\n类似于栈, 优先创建的后析构.\n\n运用的示例:\n#include &lt;iostream&gt;#include &lt;cstring&gt;class MyString {private:    char* data;public:    // 默认构造函数    MyString() : data(nullptr) {        std::cout &lt;&lt; \"默认构造函数调用\" &lt;&lt; std::endl;    }    // 带参数的构造函数    MyString(const char* str) {        if (str) {            data = new char[strlen(str) + 1];            strcpy(data, str);        } else {            data = nullptr;        }        std::cout &lt;&lt; \"参数构造函数调用\" &lt;&lt; std::endl;    }    // 拷贝构造函数    MyString(const MyString&amp; other) {        if (other.data) {            data = new char[strlen(other.data) + 1];            strcpy(data, other.data);        } else {            data = nullptr;        }        std::cout &lt;&lt; \"拷贝构造函数调用\" &lt;&lt; std::endl;    }    // 析构函数    ~MyString() {        delete[] data;        std::cout &lt;&lt; \"析构函数调用\" &lt;&lt; std::endl;    }    // 打印字符串    void print() const {        std::cout &lt;&lt; (data ? data : \"空字符串\") &lt;&lt; std::endl;    }};int main() {    // 测试各种构造函数    MyString s1;                  // 默认构造函数    MyString s2(\"Hello\");         // 带参数的构造函数    MyString s3 = s2;             // 拷贝构造函数        s1.print();    s2.print();    s3.print();        return 0;  // 所有对象在这里被销毁，调用析构函数}\n\n\n\n本地对象: \nField(字段)指的是在类中定义的变量(成员变量):\n\n可以直接被类中的所有方法访问;\n生命周期和类的对象保持一致;\n\n其他类型数据的生命周期:\n\n参数: 函数执行期间;\n局部变量: 声明的代码块内部.\n\n\n全局对象:\n\n[!NOTE]\n如果在类或对象的方法内部定义了一个和成员变量同名的变量, 那么将默认访问这个变量, 只有用 this-&gt;xxx才能显式访问成员变量. e.g. int MyClass::count .\nclass MyClass {public:    int value = 10; // 字段    void printValue() {        int value = 20; // 局部变量        std::cout &lt;&lt; \"Local value: \" &lt;&lt; value &lt;&lt; std::endl; // 输出局部变量        std::cout &lt;&lt; \"Field value: \" &lt;&lt; this-&gt;value &lt;&lt; std::endl;//使用this指针访问字段    }};\nAccess Controlclass的默认为 private, 而 struct的默认权限是 public.\n访问限制符:\nfriend在 class内部声明友元, 可以使得对应的函数访问自身的成员变量(包括私有和受保护, 也即是所有的变量).\nstruct X {private:    int i;public:    void initialize();    friend void g(X*, int i);    friend void Y::y();}\n\n\n\n\n[!NOTE]\n友元关系不具有传递性 !\n\nprotected该声明内的成员可以被以下的范围访问:\n\n该类自身的成员函数;\n该类的派生类的成员函数;\n\ne.g.\nclass Base {protected:    int protectedVar;public:    Base(int val) : protectedVar(val) {}};class Derived : public Base {public:    Derived(int val) : Base(val) {}    void accessProtectedVar() {        protectedVar = 10; // 派生类可以访问 protectedVar    }    int getProtectedVar(){        return protectedVar;    }};\n\n\n此处的 base就是一个基类, class Derived : public Base表明 Derived 是 base的一个派生类.\n因此,  派生类可以通过自己的成员函数, 访问基类的 protected内的成员变量.\n\nStatic对于本地变量和全局变量的作用不同, 前者是生命周期, 后者是访问空间.\n静态的对象的生命周期是全局, 但是不会跟全局变量一样(一开始就创建), 而是在第一次调用的时候才构造, 且只构造一次.\n\n静态成员变量由所有的实例共享, 初始化的时候不能再添加 static标签(否则无法被外文件访问), 必须在类的外部进行初始化, 且需要声明所属于的类;\n\n但是也可以被普通的成员函数所访问.\n\n\n静态成员函数属于类本身, 因此可以通过类名直接调用, 但是只能访问类的静态成员变量, 因为不存在属于实例的this指针. 静态成员函数可以在类的内部就定义, 如果在类的外部定义, 也不需要额外的static标签;\nclass MyClass {public:    static int count; // 静态成员变量    int id;    MyClass(int i) : id(i) {        count++; // 每次创建对象，count加1    }    ~MyClass() {        count--;    }    static int getCount() { // 静态成员函数        return count;    }};int MyClass::count = 0; // 静态成员变量的初始化int main() {    std::cout &lt;&lt; \"Count: \" &lt;&lt; MyClass::getCount() &lt;&lt; std::endl; // 通过类名调用静态成员函数    MyClass obj1(1);    MyClass obj2(2);    std::cout &lt;&lt; \"Count: \" &lt;&lt; MyClass::getCount() &lt;&lt; std::endl; // 通过类名调用静态成员函数    return 0;}\n\nOutput:\nCount: 0Count: 2\n\n\n\n函数内部的静态变量只会在调用的时候初始化一次, 直到程序结束.e.g. 计数函数的调用次数:\nvoid f(){  static int num_calls = 0;  ...  num_calls += 1;}\n\nextern关键字用于声明变量或函数在其他文件中定义. 告诉编译器从而允许跨文件的访问.\n\n但是这种跨文件访问只能作用于非静态的全局变量, i.e. 全局变量加上static声明之后, 将其作用域限制在了当前文件的内部.\n\n\n函数内部的静态对象, 其构造函数只会在定义的时候调用一次. 并且析构函数当退出程序时调用. 即使采取条件构造, 也只会在第一次条件满足的时候构造.\n\n静态成员的使用:\n\n通过类名: &lt;class_name&gt;::&lt;static member\n\n通过实例名: &lt;ob variable&gt;.&lt;static member&gt;\n\n让人误以为是类的对象变量, 不建议这样使用.\n\n\n\n\n\nReference引用（Reference）是一个非常重要的特性。它的引入是为了解决一些特定场景下的问题：\n\n避免不必要的拷贝：在某些情况下，传递大型对象或结构体给函数时，如果直接传递拷贝会导致性能下降。引用允许我们传递对象的别名，而不需要拷贝整个对象。\n简化代码：引用可以使代码更简洁，特别是在函数返回值和参数传递时。例如，通过引用返回一个对象可以避免构造临时对象。\n指针的安全替代：引用提供了指针的功能，但避免了指针容易导致的错误，如空指针解引用或野指针。\n\n基本语法: \n引用是一个变量的别名，它在声明时必须被初始化，并且一旦初始化后就**不能再指向其他**对象.\nint a = 10;int&amp; ref = a;  // ref 是 a 的引用\n\n\nint&amp; 表示引用类型，ref 是 a 的引用。\n引用必须在声明时初始化，并且不能重新引用到另一个对象。\n无法对引用进行引用;\n不允许存在 以引用为元素的数组\n\ne.g.\n#include &lt;iostream&gt;int main() {    int a = 10;    int&amp; ref = a;  // ref 是 a 的引用    std::cout &lt;&lt; \"Original value of a: \" &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; \"Value of ref: \" &lt;&lt; ref &lt;&lt; std::endl;    ref = 20;  // 修改引用会影响原变量    std::cout &lt;&lt; \"After modifying ref, value of a: \" &lt;&lt; a &lt;&lt; std::endl;    std::cout &lt;&lt; \"Value of ref: \" &lt;&lt; ref &lt;&lt; std::endl;    return 0;}\n\n在这个例子中：\n\nref 是 a 的引用，修改 ref 的值会影响 a 的值。\n通过引用，我们可以访问和修改原始变量 a 的值，而不需要直接操作 a。\n\n引用可以作为函数的形参, 此时函数内部的形参作为实参的引用可以改变实参的值.\n引用的绑定必须是一个具有明确地址的左值 ,而不能是临时产生的右值:\nvoid func(int &amp;);func (i * 3); // Warning or error!\n\n\n\n指针与引用\n限制:\n\n无法获得指针的引用;\nint &amp;*p;// illegal\n\n但是可以获得指向引用的指针\nvoid f(int *&amp;p);\n\n\n\n 可以如此理解, 引用实际上是对象的别名. 用于修改对象的值. 但是为了修改指针, 可以直接使用指针的指针 **.\n此外, 引用并非独立的对象, 而是直接 绑定. 因此 int&amp; ref = a;  &amp;ref就是 a的地址.\n右值引用左值是指具有明确地址的变量或者引用, 右值是计算过程中的中间结果或者字面量 (e.g.10).等不可寻址的值;\n\n涉及到计算的基本都是右值, 但是这四种的计算结果依旧是左值: *,.,[]和 -&gt;.\n\n右值一般在计算结束后就消失了, 如果我们希望延长其生命周期, 就可以使用 右值引用.\n\n格式: &lt;tyep&gt; &amp;&amp; &lt;ref_name&gt; = &lt;right_value&gt;\nint x=20; // left-value int&amp;&amp; rx = x * 2:\n\nTIps:\n\n右值引用在初始化之后就可以正常赋值;\n右值引用无法使用左值进行赋值.\n\n\n\n引用参数与函数重载#include &lt;iostream&gt;using namespace std;void fun(int&amp; lref){   cout &lt;&lt; \"lref = \" &lt;&lt; lref &lt;&lt; endl;}void fun(int&amp;&amp; rref){   cout &lt;&lt; \"rref = \" &lt;&lt; rref &lt;&lt; endl;}int main(){   int x = 10;   fun(x);   fun(10);}\n\nOutput:\nlref = 10rref = 10\n\n\n\n字面量10作为右值, 可以通过右值引用作为函数的参数;\n具有明确地址的变量 x是左值;\nC++ 允许在同一个作用域内声明多个具有相同名称但参数列表不同的函数。这被称为函数重载。编译器通过检查函数调用时提供的参数类型和数量来决定调用哪个重载函数。\n\n\n另外, 加上const之后, &amp; 的形参也可以接受右值作为实参, 比如: void fun (const int&amp; clref) {...}\n\n但是如果已经存在右值实参作为形参的同名函数, 将会优先选择后者进行重载.\n\n这是因为普通引用对于右值的修改 make no sense, 而 const 引用保证不会修改引用的对象，因此即使是临时对象（右值）也可以安全地绑定到 const 引用.\nConstants使用 const声明常量, 常量的值不可修改.\nconst声明集合的时候, 其中的值在编译期间不可知, 因此无法在代码中, 使用常量集合内部的值进行操作.\nconst int i[] = {1,2,3};float f[i[2]]; // Illegal!\n\n\n\n使用const对指针类型进行操作的时候:\n\n忽略类似于 char之类的类型, 只关注 const与 *之间的位置关系;\n如果是 const *p 意思是指针指向的内容不可通过这个指针进行更改;\n如果是 * const p意思是指针指向的对象不可更改, 但是可以通过 *p 的方式改写对象的值\n\n\n关于字符指针与字符数组:\n\nchar  *p = \"hello\"; 实际上是 const char *p, 也就是说不允许修改 *p;\n而 char p[] = 'hello'; 则可以通过*p 修改.\n\n\n如果成员函数的名称后加了 const标记, 意味着:\n\n无法通过该成员函数改变成员变量的值.\n同时无法调用其他 非const的成员函数\n实际上, 将其的 this指针转换为 const A* this, 也就是指向常量的指针\n\n\n因此 const修饰的成员函数具有 this指针(可访问), 不要与 static修饰的静态成员函数混淆! 后者不具有 this指针.\n注意不要与 const  type f()混淆, 这是限制返回的结果无法修改; 而 type f() const限制成员函数本身的操作.\n\n重载: 允许根据成员函数是否被 const限制, 以及对象本身是否为 const来重载成员函数.\nclass A {public:    void f() const {        cout &lt;&lt; \"const version\" &lt;&lt; endl;    }    void f() {        cout &lt;&lt; \"non-const version\" &lt;&lt; endl;    }};int main() {    A a;    const A ca;    a.f();    // 输出: non-const version    ca.f();   // 输出: const version    return 0;}\n\n\n\n如果成员变量是 const, 那么:\n\n必须在对象构造时进行初始化 (无法在构造函数中进行直接赋值):\nclass A {public:    const int i;    A(int value) : i(value) {} // 在初始化列表中初始化};\n\n如果在实例化对象的时候,  声明了这个实例是 const, 那么就无法调用成员函数中没有在后面声明 const的部分.( 即使实际上并没有修改的函数, 也不能通过编译).  —— 只能调用那些被标记为const的成员函数。\nclass A{  ...  int get_value();  int get_const_value const();}const A a();a.get_value; // ERROR, const对象无法调用非const声明的成员函数a.get_const_value; // ok\n\n\n\n\n\n\n无法用普通的指针来指向 const常量.\n但是可以用指向常量的指针 来指向非常量的对象.\n\n\n全局变量的构造在 main()之前. 静态本地变量在第一次执行到的时候才发生构造, 且只构造一次.\n\n动态内存在 C++ 中，使用 new 关键字分配的空间位于 堆 上，与栈上的自动变量不同，堆上的内存不会自动释放，需要手动使用 delete 来析构以避免内存泄漏。\n示例代码#include &lt;iostream&gt;using namespace std;int main() {    // 使用 new 在堆上分配一个整数    int* ptr = new int(10);    cout &lt;&lt; \"值: \" &lt;&lt; *ptr &lt;&lt; endl;    // 使用 delete 释放内存    delete ptr;    // 指针置空，避免野指针    ptr = nullptr;    return 0;}\n\n注意事项\n每次 new 分配的内存都需要对应的 delete。\n对于数组，使用 new[] 分配，释放时用 delete[]：\n\nint* arr = new int[5];  // 分配数组delete[] arr;           // 释放数组\n\n\nInline ClassDelegating Constructor委托构造函数（Delegating Constructor）是通过一个构造函数调用另一个构造函数来完成初始化的机制, 也就是在初始化列表中调用其他.\n相对于委托构造的构造函数, 被称为 target constructor 目标构造函数.\n目标构造函数的执行先于委托构造函数.\n\n什么是委托构造函数？\n定义: 一个构造函数可以在其初始化列表中调用同一个类的另一个构造函数来完成部分或全部初始化工作。\n目的: 避免在多个构造函数中重复编写相同的初始化逻辑，解决代码重复的问题。\n限制: 委托构造函数本身不能在初始化列表中再初始化其他成员变量，只能依赖被调用的构造函数。\n\n代码示例与分析考虑将下面的冗余代码通过委托构造函数简化:\n\n实现: \n#include &lt;iostream&gt;using namespace std;class ClassC {public:    int max;    int min;    int middle;    // 基础构造函数    ClassC(int my_max) {        max = (my_max &gt; 0) ? my_max : 10;  // 默认值10    }    // 委托给基础构造函数    ClassC(int my_max, int my_min) : ClassC(my_max) {        min = (my_min &gt; 0 &amp;&amp; my_min &lt; max) ? my_min : 1;  // 默认值1    }    // 委托给第二个构造函数    ClassC(int my_max, int my_min, int my_middle) : ClassC(my_max, my_min) {        middle = (my_middle &lt; max &amp;&amp; my_middle &gt; min) ? my_middle : 5;  // 默认值5    }};int main() {    ClassC c1{1, 3, 2};    cout &lt;&lt; \"max: \" &lt;&lt; c1.max &lt;&lt; \", min: \" &lt;&lt; c1.min &lt;&lt; \", middle: \" &lt;&lt; c1.middle &lt;&lt; endl;    return 0;}\n\n运行结果分析\nClassC c1{1, 3, 2}:\n调用 ClassC(int, int, int) 构造函数。\n它委托给 ClassC(int, int)，后者再委托给 ClassC(int)。\n初始化顺序：\nmax = 1（因为 1 &gt; 0）。\nmin = 1（因为 3 &gt; max，不满足条件，使用默认值 1）。\nmiddle = 2（因为 2 &lt; max 且 2 &gt; min 不成立，但逻辑上仍赋值 2，需检查代码逻辑）。\n\n\n\n\n\n关键点\n初始化位置:\n\n成员变量不能在委托构造函数的初始化列表中直接使用参数初始化，必须通过被委托的构造函数完成。\n如 ClassC(int my_max, int my_min) : ClassC(my_max) 中，不能再初始化 min，只能在函数体内赋值。\n\n\n代码重复问题:\n\n如果每个构造函数都独立初始化 max、min 等，会导致重复代码。\n委托构造函数将公共逻辑集中到基础构造函数中。\n\n\n委托链:\n\n可以形成构造函数调用链，如 ClassC(int, int, int) → ClassC(int, int) → ClassC(int)。\n\n\n限制与解决方法:\n\n委托构造函数不能再有其他初始化列表项。\n如果需要更灵活的初始化，可以引入一个私有的辅助构造函数：\n\n\n\nclass ClassC {private:    int max;      int min;    void init(int my_max) { max = my_max &gt; 0 ? my_max : 10; }public:    ClassC(int my_max) { init(my_max); }    ClassC(int my_max, int my_min) : min(my_min) { init(my_max); } // 直接在初始化列表中初始成员变量\t};\n\n\n\n\n\n\n默认参数定义\n默认参数是在函数声明中为参数指定的默认值，调用时未提供参数则使用默认值。\n规则：默认参数必须从右到左设置。\n\n代码示例#include &lt;iostream&gt;using namespace std;// 函数声明int harpo(int n, int m = 4, int j = 5);  // 合法int chico(int n, int m = 6, int j);       // 非法：j 无默认值int groucho(int k = 1, int m = 2, int n = 3);  // 合法int main() {    int beeps;    beeps = harpo(2);      // harpo(2, 4, 5) -&gt; 11    cout &lt;&lt; \"beeps = \" &lt;&lt; beeps &lt;&lt; endl;    beeps = harpo(1, 8);   // harpo(1, 8, 5) -&gt; 14    cout &lt;&lt; \"beeps = \" &lt;&lt; beeps &lt;&lt; endl;    beeps = harpo(8, 7, 6);  // harpo(8, 7, 6) -&gt; 21    cout &lt;&lt; \"beeps = \" &lt;&lt; beeps &lt;&lt; endl;    return 0;}int harpo(int n, int m, int j) {    return n + m + j;}\n\n关键点\n规则:\n默认参数从右到左设置。\nint harpo(int n, int m = 4, int j = 5) 合法。\nint chico(int n, int m = 6, int j) 非法。\n\n\n作用:\n省略参数时自动填充默认值。\n减少函数重载需求。\n\n\n注意:\n默认值在声明中指定，不在定义中。\n不能“跳跃”使用参数，如 harpo(1, , 6) 非法。\n\n\n\n改进建议\n复杂逻辑可考虑函数重载或委托构造函数。\n避免过度使用默认参数以保持代码清晰。\n\n\n内联函数\nInline Functions\n\n定义\n内联函数是用 inline 关键字修饰的函数，编译器会尝试将函数调用替换为函数体代码，减少函数调用的开销。\n\n普通函数的调用需要经历: 压栈、传递参数、跳转到函数地址、返回值处理、出栈等步骤, 由此可见内联函数可以有效提升性能.\n\n\n适用于小型、频繁调用的函数。\n\n\n代码示例#include &lt;iostream&gt;using namespace std;// 内联函数定义inline int square(int x) {    return x * x;}int main() {    int num = 5;    cout &lt;&lt; \"Square of \" &lt;&lt; num &lt;&lt; \" is \" &lt;&lt; square(num) &lt;&lt; endl;  // 输出 25    return 0;}\n\n关键点\n作用:\n减少函数调用开销（如参数传递、栈帧创建）。\n提高执行效率，适合小型函数。\n\n\n使用场景:\n函数体短小、调用频繁。\n不适合复杂函数（可能导致代码膨胀）。\n\n\n注意:\ninline 是建议，编译器可能忽略（例如函数过大或包含循环）。\n内联函数定义通常放在头文件中，避免链接错误 (在多个源文件被调用的时候, inline的声明可以告诉编译器, 重复的定义是被允许的)\n\n\n\n\n[!NOTE]\n\nAny function you define inside a class declaration is automatically an inline.\n\nclass内部**定义**的函数自动为 inline类型. 如果是类外定义(相同的.h文件), 那么需要显式声明为内联函数.\n\n\n内联函数必须在**头文件**中定义，或者在调用它的同一翻译单元中.\n\n如果定义在 .cpp 文件中，调用点无法看到定义，编译器无法内联，链接器会报错.\n\n\n如果决定将类的函数定义写在头文件中, 有以下的两种选择使其成为内联函数;\n\n直接在声明的地方给出完全的定义;\n在类外声明 inline然后定义.\n\n\ninline确实比C语言的 macro更好, 因为内联函数实现了对参数的类型检查.\n\n编译器会对声明为 inline 的函数进行检查: 如果包含了递归 或者 代码量较大, 编译器依旧不会将其视为 inline .\n\n\n\ninline 变量\n[!NOTE]\n\n为静态成员变量声明 inline, 不必在 .cpp中再次声明.\n\n用于在头文件中定义具有外部链接的变量，避免了重复定义的问题.\n\n\n\n在 C++ 传统规则中，全局变量（或者 namespace 作用域的变量）在头文件中定义会导致多个翻译单元（编译文件）出现重复定义错误。在 C++17 之前，通常的做法是：\n// myheader.hextern int myVar; // 声明// mysource.cpp#include \"myheader.h\"int myVar = 42; // 定义\n\n但在 C++17 之后，可以使用 inline 变量，直接在头文件中定义，而不会导致重复定义错误：\n// myheader.hinline int myVar = 42;  // C++17 及以上\n\n在任何 #include \"myheader.h“ 的地方，myVar 仍然是同一个变量。\n\n如果希望不同的文件不是一个实例, 需要声明为 静态全局变量.\n\ninline 变量的特点\n​\t1.\t允许在头文件中定义，避免 extern 的使用。\n​\t2.\t所有包含它的翻译单元共享同一个变量（编译时不会创建多个实例）。\n​\t3.\t必须初始化，否则编译器无法确定变量的值。\n示例：多个文件使用 inline 变量\n假设有以下两个源文件，同时包含 myheader.h，但不会引发重复定义错误：\n头文件 myheader.h\n#ifndef MYHEADER_H#define MYHEADER_H#include &lt;iostream&gt;inline int globalVar = 100; // inline 变量#endif\n\n源文件 file1.cpp\n#include \"myheader.h\"void func1() {    std::cout &lt;&lt; \"file1.cpp: \" &lt;&lt; globalVar &lt;&lt; std::endl;}\n\n源文件 file2.cpp\n#include \"myheader.h\"void func2() {    std::cout &lt;&lt; \"file2.cpp: \" &lt;&lt; globalVar &lt;&lt; std::endl;}\n\n主程序 main.cpp\n#include \"myheader.h\"void func1();void func2();int main() {    func1();    func2();    globalVar += 10;    std::cout &lt;&lt; \"main.cpp: \" &lt;&lt; globalVar &lt;&lt; std::endl;    return 0;}\n\n编译 &amp; 运行\ng++ file1.cpp file2.cpp main.cpp -o output &amp;&amp; ./output\n\n输出示例：\nfile1.cpp: 100file2.cpp: 100main.cpp: 110\n\n说明：\n​\t•\tglobalVar 是同一个变量，而不是多个副本。\n​\t•\tmain.cpp 修改 globalVar 之后，globalVar 在所有翻译单元中都被更新。\n\ninline 变量 vs constexpr 变量\n​\t•\tinline 变量可以是可变的，可以修改其值。\n​\t•\tconstexpr 变量必须是编译时常量，不能修改。\n​\t•\tinline constexpr 变量既有 inline 特性，又是编译时常量。\ninline constexpr int constantVar = 50; // 不能修改\n\n\n\nweakweak允许不同的编译单元存在同名的函数, 并且在实际调用的时候, 优先调用不是 weak的函数. 从而提供了一种默认的实现.\nweak关键字可以用于函数、变量与对象等, 与主要使用于函数的 inline不同.\n如果没有 weak标记, 就是强变量.\n\n一般的编译器需要使用 __attribute__((weak))  来声明:\n\n#include &lt;iostream&gt;// 声明 weak 变量，提供默认值__attribute__((weak)) int globalValue = 42;int main() {    std::cout &lt;&lt; \"globalValue = \" &lt;&lt; globalValue &lt;&lt; std::endl;    return 0;}\n\n\n\nComposition用已有的对象构造新的对象. 称为组合.\n可以用 has-a的关系来描述.\n类内对象的初始化假设我们有一个 Person 类，该类内部包含一个 std::vector&lt;std::string&gt; 类型的成员变量，用于存储人的爱好。我们将展示如何在类的构造函数中使用完全初始化和引用初始化来初始化这个成员变量。\n1. Fully完全初始化是指在类的构造函数中直接为成员变量赋予初始值。这通常通过成员初始化列表（member initializer list）来完成。\nclass Person {public:    std::vector&lt;std::string&gt; hobbies;    // 完全初始化：使用成员初始化列表    Person(const std::vector&lt;std::string&gt;&amp; initialHobbies)        : hobbies(initialHobbies) { }};\n\n解释\n\n成员变量初始化：在 Person 类的构造函数中，我们使用成员初始化列表 : hobbies(initialHobbies) 来完全初始化 hobbies 成员变量。这意味着 person1.hobbies 将拥有 initialHobbies 的一个拷贝。\n独立性：person1.hobbies 是 initialHobbies 的一个独立拷贝，修改 person1.hobbies 不会影响 initialHobbies，反之亦然。\n\n2. Reference引用初始化是指将类内部的成员变量声明为引用类型，并在构造函数中将其绑定到另一个对象。这意味着类内的引用将直接指向外部对象，而不是持有其拷贝。\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;class Person {public:    std::vector&lt;std::string&gt;&amp; hobbiesRef;  // 引用类型的成员变量    // 引用初始化：使用成员初始化列表绑定到外部对象    Person(std::vector&lt;std::string&gt;&amp; externalHobbies)        : hobbiesRef(externalHobbies) { }};\n\n解释\n\n成员变量声明：std::vector&lt;std::string&gt;&amp; hobbiesRef; 声明了一个引用类型的成员变量 hobbiesRef，它将引用外部的 std::vector&lt;std::string&gt; 对象。\n引用绑定：在构造函数中，通过 : hobbiesRef(externalHobbies) 将 hobbiesRef 绑定到传入的 externalHobbies 对象。这意味着 person2.hobbiesRef 和 sharedHobbies 指向同一个内存位置。\n共享数据：对 person2.hobbiesRef 的修改（如添加新爱好）会直接影响到 sharedHobbies，因为它们共享相同的数据。\n\n3. 对比\n\n\n特性\n完全初始化\n引用初始化\n\n\n\n存储方式\n存储外部对象的拷贝\n存储对外部对象的引用\n\n\n内存使用\n额外占用内存用于拷贝\n不占用额外内存，直接引用外部对象\n\n\n数据独立性\n修改类内成员不会影响外部对象\n修改类内成员会影响外部对象\n\n\n生命周期依赖\n类内成员独立于外部对象的生命周期\n类内引用的生命周期必须至少与外部对象相同\n\n\n适用场景\n需要独立副本时使用\n需要与外部对象共享数据时使用, 初始情况下不知道容量\n\n\n注意事项\n引用必须在构造时初始化：引用类型的成员变量必须在构造函数的初始化列表中绑定到一个对象，不能在构造函数体内赋值。\n\n[!NOTE]\n因为引用类型的对象必须在初始化的时候绑定, 并且只能绑定一次.\n\n// 错误示例：试图在构造函数体内赋值给引用class Person {public:    std::vector&lt;std::string&gt;&amp; hobbiesRef;        Person(std::vector&lt;std::string&gt;&amp; externalHobbies) {        hobbiesRef = externalHobbies; // 错误：引用必须在初始化时绑定    }};\n\n生命周期管理：使用引用初始化时，必须确保被引用的对象在使用期间是有效的。如果引用的对象被销毁，引用将变为悬空引用，导致未定义行为。\n// 危险示例：悬空引用std::vector&lt;std::string&gt; createHobbies() {    std::vector&lt;std::string&gt; temp = {\"Temporary\"};    Person person(temp);    return temp; // temp 被销毁，person.hobbiesRef 悬空}\n\n为了避免这种情况，通常可以使用智能指针（如 std::shared_ptr 或 std::unique_ptr）来管理对象的生命周期，或者确保引用的对象在使用期间一直有效。\n\n\n总结\n[!NOTE]\n\n如果使用 完全初始化 的方式, 类内必须包含另一个类的完整定义(引用头文件);\n\n如果是引用初始化, 可以直接在这个类的内部预先声明另一个类的存在即可.\nclass A; // 前向声明class B{  A* ptr;}\n\n\n\nEmbedded objects\n[!NOTE]\n\n对于嵌入对象，如果不用初始化列表，就必须有默认构造函数。\n\n\nnamespace命名空间的别名如果 namespace过长, 可以将其重新赋值并使用:\nnamespace supercalifragilistic {\tvoid f();}namespace short = supercalifragilistic;short::f();\n\n\n\nselection除了直接在一个命名空间内部嵌套其他, 我们也可以在一个命名空间里选择性地使用其他空间的部分函数:\nnamespace mine｛\tusing orig::Cat;\t // use Cat class from origvoid ×O）；\tvoid x()；    void y();}\n\n\n\n\n[!NOTE]\n\nMultiple namespace declarations add to the same namespace.也即是说, 多个 .h文件内相同的命名空间会自动的视作一个.\n\n\nInheritance\n[!NOTE]\n\n继承的对象都具有基类的属性, 但是不一定具有访问的权限.也就是 Think of inherited traits as an embedded object\n派生类的构造函数中的初始化列表应当包含基类的构造函数.\n由于基类的私有成员无法被子类直接访问, 需要让子类调用基类的public的函数, 从而间接访问.\n如果子类和父类含有同名的变量, 将会同时存在, 并且可以在子类中声明 parent_class:A来访问父类中的属性A.\n子类中一定有部分是父类的对象, 并且处于子类的开头(父类必须首先完成初始化).\n\n\n初始化列表的常用场景\n调用基类的构造函数 (否则调用默认构造函数)\nclass Base {public:    Base(int data) { /* ... */ }};class Derived : public Base {public:    Derived(int baseVal) : Base(baseVal) { }};\n\n初始化嵌入类\nclass Member {public:    Member(const std::string&amp; str) { /* ... */ }};class Container {    Member memberObj;public:    Container(const std::string&amp; s) : memberObj(s) { }};\n\n\n需要注意的是, 此处的初始化列表中的嵌入类的构造, 变量名不是类名.\n如果嵌入类不存在默认的构造函数, 那么初始化列表中的显式构造是必要的.\n\n\n初始化常量成员:\nclass MyClass {    const int constMember;public:    MyClass(int val) : constMember(val) { }};\n\n\nconst 成员一旦定义，必须立即初始化，且只能在初始化列表中完成，不能在构造函数体内赋值。\n\n\n初始化引用成员\nclass MyClass {    int&amp; refMember;public:    MyClass(int&amp; ref) : refMember(ref) { }};\n\n\n引用成员（如 int&amp; ref）必须在初始化时绑定对象，不能在构造函数体内赋值，因此也必须使用初始化列表。\n\n\n\n继承: 基于已有的类来设计新的类，新的类的对象可以被当作已有类的对象.\n相比于 composition  的 has-a关系, 继承是 is-a的关系.\n同义词:\n\n父类、超类、基类\n派生类、子类\n\n控制基类成员在派生类中的可见性：\n\npublic：基类的 public 成员在派生类中仍然是 public，protected 成员仍然是 protected。\nprotected：基类的 public 和 protected成员在派生类中都变为 protected。\nprivate：基类的 public 和 protected 成员在派生类中都变为 private。\n\n\n[!NOTE]\n此时, 仍旧可以通过子类的方法来访问基类的属性或者方法, 但是无法通过子类直接访问基类~!\ne.g.\n#include &lt;iostream&gt;class Base{public:    void baseFunction()    {        std::cout &lt;&lt; \"Base function called.\" &lt;&lt; std::endl;    }};class Derived : private Base{public:    void derivedFunction()    {        baseFunction(); // 在子类内部可以访问基类的成员函数    }};int main(){    Derived d;    d.baseFunction();    // 错误：无法从子类外部访问基类的成员函数    d.derivedFunction(); // 可以调用子类的函数，该函数内部调用了基类的函数    return 0;}\nclint class 表示这个类要使用另一个类(中的public).\n子类的对象也可以认为是父类的对象。子类不能访问父类的私有变量，但私有变量存在于这个类中\n当调用构造函数时，我们不能调用父类的私有变量，只能用初始化列表的方式调用父类的构造函数。\n赋值的运算符不会被继承:\n赋值运算符赋值运算符是这样形式的方法:\nPoint &amp;operator=(const Point &amp;other){    cout &lt;&lt; \"Point::operator= 被调用\" &lt;&lt; endl;    if (this != &amp;other)    {        x = other.x;        y = other.y;    }    return *this;}\n\n当我们如此赋值的时候就会发生上述的调用:\nPoint p1(1,2);Point p2(3,4);p1 = p2;\n\n可见, 赋值运算符通过引用快速地将右值中的属性赋值给左侧的目标.\n但是父类的赋值运算符只会确保自身的属性能够被赋值, 无法确保子类自身的属性可以被正确设置. 因此, 为了安全性, CPP不允许子类自动继承父类的赋值运算符.\n\n[!NOTE]\n然而, 编译器可能为子类自动生成一个赋值运算符.\ne.g.\nclass Point{public:    int x, y;    Point(int x = 0, int y = 0) : x(x), y(y) {}    // 自定义赋值运算符    Point &amp;operator=(const Point &amp;other)    {        cout &lt;&lt; \"Point::operator= 被调用\" &lt;&lt; endl;        if (this != &amp;other)        {            x = other.x;            y = other.y;        }        return *this;    }};class ColoredPoint : public Point{public:    string color;    ColoredPoint(int x = 0, int y = 0, string color = \"white\") : Point(x, y), color(color) {}    void print() const    {        cout &lt;&lt; \"x:\" &lt;&lt; x &lt;&lt; \", y:\" &lt;&lt; y &lt;&lt; \", color:\" &lt;&lt; color &lt;&lt; endl;    }};int main(){    ColoredPoint cp1(1, 2, \"red\");    cp1.print();    ColoredPoint cp2(3, 4, \"blue\");    cp2.print();    cp1 = cp2;    cp1.print();}\n\n输出结果:\nx:1, y:2, color:redx:3, y:4, color:bluePoint::operator= 被调用x:3, y:4, color:blue\n\n可见, 父类的赋值运算符也被自动地调用了, 这是因为编译器为子类自动生成了一份.\n\n\n父类的构造是在子类的构造之前。\nusing声明将基类的函数派生使用必须使用 using &lt;parentClass&gt;:: func的方式, 无法忽略 using.\n#include &lt;iostream&gt;using namespace std;class Base{  public:   \tvoid f(double){      cout &lt;&lt; \"double\\n\" &lt;&lt; endl;    }};class Derived : Base{  public:  \tusing Base::f; // 将基类中的私有函数本地使用  \tvoid f(int){      cout &lt;&lt; \"int\\n\"&lt;&lt;endl;    }};int main() {    Derived d;    d.f(4);    d.f(4.5);}\n\nOutput:\nint double\n\n\n\n默认参数值无法通过重载传递在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免多重继承时参数值产生冲突或二义性。默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.\n\n如果你在派生类中重新声明或重载了基类的函数，那么你不能获得默认参数值，必须通过多个重载模拟默认参数功能.\n\nclass A {public:    void f(int a = 3, double b = 2.0);};class B : public A {public:    using A::f;         // ✅ 此时默认参数仍可见    void f(int a);      // ❌ 重载后，这个版本没有默认参数};\n\n\n\n\n但是使用 using声明的父类函数可以获得默认参数值.\n\ne.g.\n#include &lt;iostream&gt;using namespace std;class A{public:    void f(int a = 3, double b = 2.0)    {        std::cout &lt;&lt; \"A::f(\" &lt;&lt; a &lt;&lt; \", \" &lt;&lt; b &lt;&lt; \")\" &lt;&lt; std::endl;    }};class B : public A{public:    using A::f; // 继承 A::f 到 B 中};int main(){    B b;    b.f();        // ✅ 是否等价于 f(3, 2.0)？    b.f(10);      // ✅ 是否等价于 f(10, 2.0)？    b.f(10, 5.5); // ✅ 正常调用}\n\n\n输出:\nA::f(3, 2)A::f(10, 2)A::f(10, 5.5)\n\n解决重写函数的重载问题子类重新定义 (override重写) 了父类的某个函数，就会把父类中对应 overloaded 的函数覆盖:\n#include &lt;iostream&gt;class Base{public:    // 基类中的重载函数    void display(int x)    {        std::cout &lt;&lt; \"Base display(int): \" &lt;&lt; x &lt;&lt; std::endl;    }    void display(double x)    {        std::cout &lt;&lt; \"Base display(double): \" &lt;&lt; x &lt;&lt; std::endl;    }};class Derived : public Base{public:    // 子类重新定义了基类的 display(int)    void display(int x)    {        std::cout &lt;&lt; \"Derived display(int): \" &lt;&lt; x &lt;&lt; std::endl;    }    using Base::display;};int main(){    Derived d;    d.display(5); // 调用 Derived 的 display(int)    d.Base::display(5.5); // 或者d.display(5.5);    return 0;}\n\n\n\n注意, CPP中的浮点数可以隐式转换为整型.\n\n当将一个浮点数赋值给一个整型变量时，编译器会执行隐式转换，将浮点数的值转换为整型。这种转换通常涉及截断（truncation），即去掉小数部分，只保留整数部分.\n\n\n可以通过 using 声明重新引入基类中的重载函数: \nusing Base::display;\n\n\n\nPolymorphism补充\n成员函数（无论是虚函数还是非虚函数）本身不占用类对象的内存空间，因为它们的代码存储在程序的代码段中。只有成员变量和虚表指针（如果有虚函数）会占用对象的内存空间:\nclass A {    int i;    void f();};\n\n此时的 sizeof(A)为4字节.\n\n虚函数指针的大小一般是 8字节. 如果结构体内部存在虚函数指针, 就需要对齐为8字节的倍数.\n\n因为子类的构造在父类的构造之后, 也就是每一个子类对象的前部分都是父类对象. 因此, 我们可以将一个子类对象的指针赋值给父类对象, 只要忽视后续数据结构即可.\n\n多态变量: 指向子类对象的基类指针/引用.\n\n如果类内不存在任何成员变量, 它的对象依旧占用 1 个字节的空间.\n\n如果一个类将来可能具有子类, 就让其析构函数设置为 virtual. —— 任何的类都应该设置它的析构为 virtual.\nclass B: public A{};A* p = new B();delete p;\n\n如果 A 的析构函数不是virtual的, 那么编译器只会调用A的析构函数.\n\n如果父类的构造函数中调用了 virtual 的函数, 那么实际上还是调用自己的函数(静态绑定)\n\n这是因为, 创建一个派生类的对象时, 首先调用父类的构造函数, 然后执行派生类的构造函数;\n此时, 子类的成员还没有初始化, 父类无法调用其重写版本, 也就无法实现多态.\n\n\n\n[!NOTE]\n深刻理解什么叫做多态! 也就是子类对象的引用或者指针赋值给了父类! 此后调用这个对象时, 虚函数是动态绑定到子类的!\nA &amp;ra = b;    // ra是A类型的引用，但指向B类型的对象ra.f();       // 虽然ra是A类型的引用，但f()会调用B::f()\n\n如果B是A的子类:\nA *p1 = new B(3);    // p1是A类型的指针，但指向B类型的对象\n\n实际上,  p1指向的对象是B类的对象\n\n\n当一个被重写的函数在 Derived::func() 中通过 Base::func() 调用其基类版本时，会发生什么？\n\n可以正常调用, 这也正是重写存在的意义——扩充原来的功能, 同时保留.\n\n多态与返回对象类型:\n\n允许重载返回自身的 指针 与 引用, 但是不支持直接返回自身的类型:\n\ni.e. \nClass Expr｛public:  virtual Expr* newExpr （）；  virtual Expr&amp; clone （）；  virtual Expr Expr self（）；｝；class BinaryExpr ： public Expr ｛public：  virtual BinaryExpr* newExpr （）； //Ok  virtual BinaryExpr&amp; clone （）； // Ok  virtual BinaryExpr self（）；// Error！  ｝；\n\n原因: 指针和引用的大小固定, 编译时刻可以确定调用时候所需的空间, 如果按照类型返回, 由于多态的动态绑定是运行时决定调用对应的方法, 所以编译的时候caller不知道要在栈上预留多少的空间.\n\n\n\n\n\n\nPolymorphism\nvirtual functions and override\nabstract functions and classes\n\n\nMultiple Inheritance\n\n由于子类具有父类的所有属性, 因此我们可以将一个子类对象看作父类的对象, 并进行对应的操作.\n将子类对象看作父类对象的操作, 叫做 upcast. 具体是说, 将子类的指针或者引用赋值给基类的对象.\n现在的问题是, 如果采取传统的继承+重写的方式, 我们在子类内部采取重写父类方法, 可能导致 静态绑定 static binding:\n#include &lt;iostream&gt;using namespace std;class Animal{public:    void speak()    {        cout &lt;&lt; \"Animal speaks\" &lt;&lt; endl;    }};class Dog : public Animal{public:    void speak()    {        cout &lt;&lt; \"Dog barks\" &lt;&lt; endl;    }};int main(){    Animal *animal = new Dog(); // 注意：父类指针指向子类对象    animal-&gt;speak();            // 会调用哪个？    delete animal;    return 0;}\n\n\n输出:\nAnimal speaks\n\n为了解决上述的问题, 我们引入 虚函数 的概念.\n虚函数虚函数可以实现 运行时多态. 所谓多态, 就是静态+ 动态的绑定.\n通过在父类的函数前加上 virtual的声明, 我们将其定义为虚函数\ne.g.\n#include &lt;iostream&gt;using namespace std;class Animal {public:    virtual void speak() {        cout &lt;&lt; \"Animal speaks\" &lt;&lt; endl;    }};class Dog : public Animal {public:    void speak() override {        cout &lt;&lt; \"Dog barks\" &lt;&lt; endl;    }};int main() {    Animal* animal = new Dog();     animal-&gt;speak(); // 这次会调用哪个？    delete animal;    return 0;}\n\n\n输出:\nDog barks\n\n\n\noverride声明明确这个函数是重写父类的虚函数, 可以让编译器检查是否存在错误.\n但是上述的关键字也不是必须的.\n\n\n纯虚函数~指的是需要强制派生类去实现的函数:\nvirtual 返回类型 函数名(...) = 0;\n\n\n\n虚函数表\n定义: 虚函数表（virtual table）是 C++ 为了实现运行时多态而采用的一种底层技术手段;\n本质:\nvtable是一个函数指针数组;\n每个类都有自己的vtable\n对象中存在一个隐藏的指针 vptr, 指向该类的vtable\n\n\n\n内存示意图假设有如下结构:\nclass Base {public:    int a;    virtual void func();};\n\n内存布局的伪结构如下:\n+-------------------------+| vptr  → 指向vtable     |  ←隐藏成员+-------------------------+| a : int                |  ←显式成员+-------------------------+vtable (Base):[ func 的地址 ]vtable (Derived):[ 重写的 func 的地址 ]\n\n\n\n拓展说明\nvtable是类级别的, 所有该类的对象共享一个vtable;\nvptr是对象级别的, 隐含于各个对象当中.\n如果类没有虚函数, 就不存在上述的~\n\n抽象类如果一个类中包含至少一个纯虚函数, 那么这个类就是一个抽象类.\n抽象类无法被实例化, 只能用来作为基类.\n使用抽象类定义接口用图形绘制的例子来说明抽象类和纯虚函数的使用:\n#include &lt;iostream&gt;using namespace std;// 抽象类class Shape {public:    // 纯虚函数，子类必须实现    virtual void draw() = 0;};// 派生类：Circleclass Circle : public Shape {public:    void draw() override {        cout &lt;&lt; \"Drawing Circle\" &lt;&lt; endl;    }};// 派生类：Rectangleclass Rectangle : public Shape {public:    void draw() override {        cout &lt;&lt; \"Drawing Rectangle\" &lt;&lt; endl;    }};// 渲染函数：面向抽象类编程void render(Shape* shape) {    shape-&gt;draw();}int main() {    Circle c;    Rectangle r;    render(&amp;c); // Drawing Circle    render(&amp;r); // Drawing Rectangle    return 0;}\n\n\n\n继承链一个抽象类可以有多个纯虚函数, 此时继承的子类可能没有完全实现. \n子类的子类, 也就是在继承链上完成了所有纯虚函数的定义的 最末一级的派生类, 才可以被实例化.\nclass Animal {public:    virtual void speak() = 0;    virtual void run() = 0;        void breathe() {        cout &lt;&lt; \"Breathing...\" &lt;&lt; endl;    }};\n\n\n\n虚析构函数virtual destructor: 虚析构函数\n同样的, 虚析构函数的作用体现在 upcast, 也就是将子类的指针或引用转换为父类的指针或引用的过程. 此时, 如果父类的析构函数不是虚函数, 就会让向上转型之后的对象在析构时调用父类的析构函数.\n#include &lt;iostream&gt;using namespace std;class Base{public:    ~Base()    {        cout &lt;&lt; \"Base Destructor\" &lt;&lt; endl;    }};class Derived : public Base{public:    ~Derived()    {        cout &lt;&lt; \"Derived Destructor\" &lt;&lt; endl;    }};int main(){    Base *obj = new Derived();    delete obj; // 注意这里！    return 0;}\n\n此时会输出 :  Base Destructor , 也就是调用了父类的析构函数.\n这是十分危险的, 特别是我们需要确保子类的所有资源都被安全地释放.\n因此, 我们可以将父类的析构函数也设置为虚函数:\nclass Base {public:    virtual ~Base() {        cout &lt;&lt; \"Base Destructor\" &lt;&lt; endl;    }};class Derived : public Base {public:    ~Derived() {        cout &lt;&lt; \"Derived Destructor\" &lt;&lt; endl;    }};\n\n此时的输出:\nDerived Destructor  Base Destructor\n\n\n先后调用子类和父类的析构函数.\n\n接口类\n也被称为 协议类. 其实就像 swift的协议一样, 强制要求继承的子类定义某些函数实现.\n\n\n含义:\n只定义接口, 不提供实现的抽象类\n所有的成员函数都是纯虚函数;\n一般不包含任何数据成员.\n\n\n\ne.g.\nclass Printable {public:    virtual void print() = 0;    virtual ~Printable() = default; // 记得虚析构函数};class Document : public Printable {public:    void print() override {        cout &lt;&lt; \"Printing Document\" &lt;&lt; endl;    }};\n\n\n\n多重继承多重继承 multiple inheritance 指的是一个类继承自多个基类.\ne.g.\nclass A {public:    void sayA() { cout &lt;&lt; \"I am A\" &lt;&lt; endl; }};class B {public:    void sayB() { cout &lt;&lt; \"I am B\" &lt;&lt; endl; }};class C : public A, public B {    // 继承了 A 和 B 的成员};\n\n可以将多个类的功能整合到一个类中:\nC c;c.sayA(); // OKc.sayB(); // OK\n\n\n\n菱形继承多重继承中的特例:\nclass A {public:    int value;};class B : public A {};class C : public A {};class D : public B, public C {};\n\n继承结构看上去就像菱形:\n   A /   \\B     C \\   /   D\n\n如果我们直接使用D类:\nD d;d.value = 10; // ❌ 编译错误：'value' is ambiguous\n\n这是因为D继承自B和C, 而后者又各自具有自己的A子对象. 导致了二义性的问题.\n\n[!NOTE]\n注意此处的二义性的问题, 来自于在D类对象中直接访问A类对象的成员变量!  什么时候产生二义性? 就是判断此时是否存在多个相同名称的变量.\n\n虚继承C++ 提供了一个机制：虚继承（virtual inheritance），来解决上述问题:\nclass B : virtual public A{};class C : virtual public B{};class D :  public B, public C{}\n\n此时, D中只有一个共享的A子对象.\n#include &lt;iostream&gt;using namespace std;class A{public:    int value;    void ptr()    {        cout &lt;&lt; \"value: \" &lt;&lt; value &lt;&lt; endl;    }};class B : virtual public A {};class C : virtual public A {};class D : public B, public C {};int main(){    D d;    d.value = 10; // ✅ OK，只有一个 A，二义性消除    d.ptr();}\n\n此时, B,C不再具有自己的A.\n\n[!NOTE]\n由于虚继承带来的是“共享”的基类对象，所以：\n\n虚基类的构造 必须由最底层派生类负责\n派生类的构造函数中要显式初始化虚基类\n\n\nCopy and Move补充\nvptr只会初始化一次, 然后保持不变. 发生在构造函数的第一步.\n\n循环内部执行构造和析构时, 作用的地址是同一块. 此时将对象的地址传入到vector of * 时, 得到的是相同的地址;\n\n为了避免上述的情况, 我们在循环内部的构造, 需要为对象直接 new 一个新的空间.\n\n\nstd::move的作用就是告诉编译器: 这个类型是右值引用, 需要使用移动语义.\n\n\nC++中的拷贝构造与移动语义拷贝构造函数基础拷贝构造函数是创建新对象的一种方式，它从现有对象复制数据来初始化新对象。\n\n拷贝构造函数的签名：T::T(const T&amp;)\n如果不提供拷贝构造函数，C++会自动生成一个默认的拷贝构造函数\n默认拷贝构造函数执行的是成员级别的拷贝（memberwise copy），而非位级别的拷贝（bitwise copy）\n对于基本类型成员，直接复制值\n对于对象类型成员，调用其拷贝构造函数\n对于指针类型成员，只复制指针值（浅拷贝），导致两个对象共享同一块内存\n\n\n\n拷贝构造函数的调用时机拷贝构造函数在以下情况下会被调用：\n\n按值传递参数时：当对象作为参数按值传递给函数时\nvoid func(MyClass obj); // 调用时会触发拷贝构造\n\n对象初始化时：\nMyClass a;MyClass b = a;    // 初始化，调用拷贝构造函数MyClass c(a);     // 初始化，调用拷贝构造函数\n\n函数返回对象时：\nMyClass func() {    MyClass obj;    return obj;   // 可能触发拷贝构造（取决于编译器优化）}\n\n拷贝构造函数的最佳实践\n显式定义拷贝构造函数，不要依赖默认版本\n如果类不需要被复制，可以声明私有的拷贝构造函数（不需要定义）\n如果类包含指针成员，必须实现深拷贝的拷贝构造函数\n\n深拷贝构造函数将拷贝的值另外寻找新的内存空间, 而不是指向同一处地址.\n\n如果没有显式定义深拷贝构造函数, 观察下面的代码:\n\nStringHolder original(\"Hello World\");{    StringHolder copy = original; // 调用拷贝构造函数    std::cout &lt;&lt; \"copy包含: \" &lt;&lt; copy.getString() &lt;&lt; std::endl;    // 修改copy，如果是浅拷贝，也会影响original    copy.setString(\"Modified\");    std::cout &lt;&lt; \"修改后，copy包含: \" &lt;&lt; copy.getString() &lt;&lt; std::endl;    std::cout &lt;&lt; \"修改后，original包含: \" &lt;&lt; original.getString() &lt;&lt; std::endl;    // copy在此作用域结束时被销毁}\n\n\n\noriginal的层级在  copy 的外面;\n\n在代码块的内部, 通过浅拷贝构造, 两者的数据共享一个内存空间;\n\n二者先后析构, 导致 double free的问题!\n02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: Double free of object 0x11f6060c002_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: *** set a breakpoint in malloc_error_break to debug\n\n\n由此, 我们需要如此定义:\nclass StringHolder{private:    char *data;public:    // 构造函数    StringHolder(const char *str)    {        if (str)        {            data = new char[strlen(str) + 1];            strcpy(data, str);            std::cout &lt;&lt; \"构造函数: 为\\\"\" &lt;&lt; data &lt;&lt; \"\\\"分配内存\" &lt;&lt; std::endl;        }        else        {            data = nullptr;            std::cout &lt;&lt; \"构造函数: 创建空字符串\" &lt;&lt; std::endl;        }    }    // 自定义拷贝构造函数（深拷贝）    // 如果复制掉这部分的自定义, 将会调用默认的浅拷贝构造函数, 导致问题:浅拷贝的指针两次释放内存    StringHolder(const StringHolder &amp;other)    {        if (other.data)        {            data = new char[strlen(other.data) + 1];            strcpy(data, other.data);            std::cout &lt;&lt; \"深拷贝构造函数: 为\\\"\" &lt;&lt; data &lt;&lt; \"\\\"分配新内存\" &lt;&lt; std::endl;        }        else        {            data = nullptr;            std::cout &lt;&lt; \"深拷贝构造函数: 复制空字符串\" &lt;&lt; std::endl;        }    }    // 析构函数    ~StringHolder()    {        std::cout &lt;&lt; \"析构函数: 释放\\\"\" &lt;&lt; (data ? data : \"nullptr\") &lt;&lt; \"\\\"的内存\" &lt;&lt; std::endl;        delete[] data;    }};\n\n这样就可以避免上面的问题.\n函数参数和返回值的选择\n传入参数：\n\n按值传递：void func(Student s) - 创建新对象，适用于需要存储对象的情况\n如果对象内部的属性存在指针类型的属性, 为了避免浅拷贝, 就需要自定义一个深拷贝构造函数.\n\n\n常量引用：void func(const Student&amp; s) - 不创建新对象，适用于只读取值的情况\n指针/引用：void func(Student* s) 或 void func(Student&amp; s) - 适用于需要修改对象的情况\n\n\n返回值：\n\n按值返回：Student func() - 返回新创建的对象\n返回指针：Student* func() - 注意内存管理问题\n返回引用：Student&amp; func() - 注意生命周期问题\n\n\n\n右值引用与移动语义左值与右值\n左值：可以出现在赋值号左边的表达式\n变量名、引用\n解引用操作符（*）和下标操作符（[]）的结果\n\n\n右值：只能出现在赋值号右边的表达式\n字面量\n表达式结果\n函数返回的临时对象\n\n\n\n右值引用\n使用 &amp;&amp; 声明\n可以绑定到右值，延长其生命周期\n右值引用变量本身是左值\n可以使用 std::move() 将左值转换为右值引用\n\nint x = 10;int&amp;&amp; rx = x * 2;  // 绑定右值rx = 100;          // rx本身是左值，可以被赋值\n\n\n两种可以同时输入左值和右值引用作为参数的方法:\n\n重载\n// 重载函数，分别处理左值和右值void process(int&amp; x) {    std::cout &lt;&lt; \"重载函数 - 处理左值: \" &lt;&lt; x &lt;&lt; std::endl;}void process(int&amp;&amp; x) {    std::cout &lt;&lt; \"重载函数 - 处理右值: \" &lt;&lt; x &lt;&lt; std::endl;}\n\nconst int&amp; x \n// 接受const左值引用的函数（可以接受左值和右值）void processAny(const int&amp; x) {    std::cout &lt;&lt; \"处理任意值: \" &lt;&lt; x &lt;&lt; std::endl;}\n\n\n\n移动构造函数\n签名：T::T(T&amp;&amp; other), 也就是将右值引用作为参数的构造函数\n用于”窃取”即将销毁的对象的资源，避免不必要的深拷贝\n通常将源对象的指针成员置为nullptr，防止资源被错误释放\n\nMyClass(MyClass&amp;&amp; other) :     ptr{other.ptr} {      other.data = 0      other.ptr = nullptr;  // 防止源对象析构时释放内存}\n\n\n与浅拷贝类似, 但是需要在内部将源对象的指针成员 设置为 nullptr , 其他成员设置为有效但是为空的状态\n\n 标准库容器（如 std::vector）在进行元素移动时会优先选择不会抛异常的移动构造函数，否则会退而求其次选择拷贝构造函数（更慢）。\ne.g.\nstd::vector&lt;DynamicArray&gt; vec;vec.push_back(DynamicArray(5));\n\n\n在这个 push_back 中，如果 DynamicArray 的移动构造函数被标记为 noexcept，那么 vector 会使用移动构造（高效）。\n\n初始化方式C++11提供了多种初始化对象的方式：\n\n小括号初始化：MyClass obj(arg1, arg2);\n\n等号初始化：MyClass obj = value;\n\n大括号初始化（统一初始化）：MyClass obj{arg1, arg2};\n\n列表初始化：\nint arr[] = {1, 2, 3};MyClass* ptr = new MyClass{arg1, arg2};\n\n基本类型的初始化// 基本类型的初始化方式int a = 10;             // 等号初始化int b(20);              // 小括号初始化int c{30};              // 大括号初始化（C++11）int d = {40};           // 等号+大括号初始化（C++11）int arr1[] = {1, 2, 3}; // 数组初始化int arr2[]{4, 5, 6};    // 数组大括号初始化（C++11）\n\n\n\n对象的初始化// 对象的初始化方式Person p1(\"张三\", 25);          // 小括号初始化Person p2 = Person(\"李四\", 30); // 等号+临时对象初始化Person p3{\"王五\", 35};          // 大括号初始化（C++11）Person p4 = {\"赵六\", 40};       // 等号+大括号初始化（C++11）\n\n\n\n\n动态分配对象的初始化\n// 动态分配对象的初始化方式Person *pp1 = new Person(\"动态张三\", 25); // 传统newPerson *pp2 = new Person{\"动态李四\", 30}; // 大括号初始化（C++11）\n\n深拷贝与浅拷贝\n浅拷贝：默认拷贝构造函数执行的是浅拷贝，只复制指针值，不复制指针指向的内容\n深拷贝：自定义拷贝构造函数可以实现深拷贝，为指针成员分配新内存并复制内容\n\n何时使用移动语义\n类包含动态分配的资源（如指针成员）\n对象需要在函数间传递\n需要避免不必要的深拷贝操作\n使用容器时（如std::vector、std::string等）\nmove会将一个左值变成右值引用, 从而允许调用移动构造函数!\n使用 move 时, 如果存在对应的移动构造函数, 就会优先调用;\n数组的 push_back也是如此, 优先调用移动构造函数\n但是我们可以使用 emplace来继续优化上述的效率问题——直接将对象存储到数组的末端.\n\n\n\n\n\n总结\n拷贝构造函数用于创建对象的副本，深拷贝需要自定义实现\n移动语义通过右值引用实现资源的高效转移，避免不必要的拷贝, 同时规避了浅拷贝导致的 double free 的问题.\n根据需要选择合适的参数传递和返回值方式\n使用std::move()可以将左值转换为右值引用，触发移动语义\n\n\nOverloaded Operators补充自定义类型的方向转换:  T ==&gt; C\n\n当下面情况存在一种时, 可以发生上述的转换:\n\nC存在以 T 作为输入参数的构造函数;\n\nT 存在 operator C(){ }的成员函数.e.g.\nclass Rational {public:    operator double() const {  // Rational到double的转换        return numerator_ / (double)denominator_;    }};Rational r(1, 3);double d = r;  // 隐式转换：r =&gt; double\n\n\n不同同时存在两者的转换(编译器无法知道采取什么方式)\n\n\n题目:\n\n并非所有运算符都可以用三种方式重载。例如赋值运算符 =、下标运算符 []、函数调用运算符 ()、成员访问运算符 -&gt; 只能作为成员函数重载;\n\n流提取符 &gt;&gt; 和插入符 &lt;&lt; 可以被重载\n\n运算符 + 返回的类型 不一定 要与参数类型一致;\n\n对于友元函数, 在声明处加上 friend标识, 但是在定义处是没有这个标识的. \n\n\n[!NOTE]\n无法被重载的运算符:\n\n条件运算符: ?:\n成员指针访问运算符: .*\n\n\nnew是可以重载的!\n\n运算符的分类:\n\n成员运算符: 在类内部以成员函数形式重载的运算符 ==&gt; 具有隐式的 this;\n\n友元运算符: 定义在类外部（在类内部用 friend 声明），没有 this 指针.\n因此, 一个重载函数只有一个参数时 ==&gt; 二员成员运算符 / 一元友元运算符.\n\n\n\n隐式转换的尝试是从左到右的:\n\n1+a会尝试将类的对象 a 尝试转换为int类型.\n\n\n注意类型:\n// 前缀++const Integer&amp; Integer::operator++() {    *this += 1;  // 先增加    return *this;  // 再返回}// 后缀++（参数int未使用，仅用于区分）const Integer Integer::operator++(int) {    Integer old(*this);  // 先保存    ++(*this);  // 再增加    return old;  // 返回旧值}\n\n前缀++的返回是 &amp; 类型, 因为比较节省空间和时间. 后缀++的返回是值.\n\n[] 的返回必须是 &amp; 类型, 这样可以作为左值赋值.\n\n\n\n返回类型设计的总体原则：\n\n如果运算符需要作为左值（可以出现在赋值左侧），返回非常量引用。\n\n否则, 声明为const类型, 避免成为左值.\n\n\n如果运算符创建新对象，返回值（通常是常量值）。\n\n如果运算符返回布尔结果，直接返回 bool 类型。\n\n如果需要支持链式操作，返回引用。\n\n\n全局和成员函数的设计思路:\n\n一元运算符（如 -a）应该用成员函数，因为只操作一个对象\n赋值相关运算符（=, +=, [], -&gt;()与 -&gt;* 等）必须是成员函数，因为它们需要修改对象状态\n对于二元运算符（如 +, -, *, /)建议使用全局函数，因为：\n支持操作数的对称转换\n更好地支持与其他类型的互操作\n保持了运算符的自然语义（如 3 * x 和 x * 3 应该都能工作）\n\n\n\nC++运算符重载基础运算符重载是C++的一项强大特性，它允许用户定义的类型像内置类型一样使用各种运算符。本质上，运算符重载是函数调用的另一种形式。\n可重载与不可重载的运算符C++允许重载大多数运算符，但以下运算符不能被重载：\n\n. (成员访问运算符)\n.* (成员指针访问运算符)\n:: (作用域解析运算符)\n?: (条件运算符)\nsizeof (获取类型大小)\ntypeid (获取类型信息)\n类型转换运算符 (static_cast, dynamic_cast, const_cast, reinterpret_cast)\n\n运算符重载的限制\n只能重载已存在的运算符\n\n不能创建新的运算符（如Python中的**）\n可以改变运算符的语义（如重载+实现减法），但不推荐\n\n\n运算符必须在类或枚举类型上重载\n\n至少有一个操作数必须是用户定义类型\n\n\n必须保持操作数数量\n\n如二元运算符/重载后仍必须是二元的\n\n\n必须保持优先级和结合律\n\n运算符的优先级和结合律是固定的，不能被改变\n\n\n\n运算符重载的实现方式运算符重载本质上是一个以operator关键字为前缀，后跟运算符的特殊函数。\n成员函数方式作为类的成员函数实现运算符重载时：\n\n第一个操作数（左操作数）隐式为this指针\n不对接收者（左操作数）执行类型转换\n\nclass A {public:    A(int ii) : i(ii) {}    int get() { return i; }        // 重载+运算符，返回新对象    const A operator+(const A&amp; that) const {        A c(this-&gt;i + that.i);        return c;    }private:    int i;};\n\n使用成员函数重载时，左操作数必须是该类的对象：\n\na + b 可行（a是A类对象）\na + 9 可行（9会被隐式转换为A类对象）\n9 + a 不可行（9不是A类对象）\n\n\n[!NOTE]\n隐式转换: 编译器查找是否存在从给出参数作为构造函数的输入, 从而创建一个指定对象的方式:\ne.g.\nInteger h = a + 7; // 7被隐式转换为Integer\n\n上述发生的前提条件是 类 Integer 存在对应的构造函数:\nInteger(int val = 0) : value(val)\n全局函数方式作为全局函数实现运算符重载时：\n\n所有操作数都是显式参数\n开发者不需要特殊访问类的权限\n可能需要声明为友元函数以访问私有成员\n\nclass Integer{private:  int value;  friend const Integer operator*(const Integer &amp;left, const Integer&amp; right);};// 可以直接在全局函数中访问私有成员const Integer operator*(const Integer &amp;left, const Integer &amp;right){    std::cout &lt;&lt; \"调用全局函数*运算符: \" &lt;&lt; left.value &lt;&lt; \" * \" &lt;&lt; right.value &lt;&lt; std::endl;    return Integer(left.value * right.value);}\n\n\n\n当然, 全局函数实现的运算符重载, 可以通过调用类的public中的函数接口, 来间接访问内部的私有成员变量:\nclass Integer{  public:   int getValue(){    return value;  }};// 通过public接口访问内部的私有成员变量.const Integer operator/(const Integer &amp;left, const Integer &amp;right){    std::cout &lt;&lt; \"调用全局函数/运算符: \" &lt;&lt; left.getValue() &lt;&lt; \" / \" &lt;&lt; right.getValue() &lt;&lt; std::endl;    if (right.getValue() == 0)    {        std::cerr &lt;&lt; \"错误: 除数不能为零\" &lt;&lt; std::endl;        return Integer(0);    }    return Integer(left.getValue() / right.getValue());}\n\n\n\n使用全局函数重载时，可以处理左操作数不是该类对象的情况：\n\n9 - b 可行（9会被隐式转换为A类对象）\n因为两个操作数都是普通参数，地位平等, 体现了运算符的对称性\n\n成员函数vs全局函数的选择\n一元运算符应该作为成员函数\n赋值运算符（=, (), [], -&gt;, -&gt;）必须是成员函数\n其他二元运算符最好作为非成员函数（全局函数）\n\n参数传递与返回类型参数传递\n对于只读参数，使用const引用传递（除了内置类型）\n对于不修改对象的成员函数，声明为const\n对于全局函数，如果左操作数会被修改，使用引用传递\n\n返回类型根据运算符的预期含义选择返回类型：\n\n算术运算符（+, -, *, /, %, ^, &amp;, |, ~）\nconst T operator X(const T&amp; l, const T&amp; r);\n\n\n返回新对象，不应返回引用（除非返回成员引用）\n返回const对象防止(a+b) = c这样的操作\n\n\n逻辑运算符（!, &amp;&amp;, ||, &lt;, &lt;=, ==, &gt;=, &gt;）\nbool operator X(const T&amp; l, const T&amp; r);\n\n\n返回布尔值\n\n\n下标运算符（[]）\nE&amp; T::operator[](int index);\n\n\n返回左值（非const引用），允许a[i] = value操作\n不能返回新对象，否则赋值操作无效\n\n\n\n特殊运算符重载自增自减运算符C++区分前缀和后缀自增自减运算符：\n// 前缀++const Integer&amp; Integer::operator++() {    *this += 1;  // 先增加    return *this;  // 再返回}// 后缀++（参数int未使用，仅用于区分）const Integer Integer::operator++(int) {    Integer old(*this);  // 先保存    ++(*this);  // 再增加    return old;  // 返回旧值}\n\n调用方式：\n\n++x 调用 x.operator++()\n\n返回的是引用, 从而支持链式操作 如:\nCounter g = ++(++f); // 可以，因为前缀返回引用\n\n\nx++ 调用 x.operator++(0)\n\n返回的是临时的对象, 也就是旧值的副本. 声明const避免了后缀的链式调用\nCounter h = (f++)++; // 不可以，因为后缀返回const值\n\n之所以要防止上述的后缀链式调用, 是因为 对f++继续自增将会导致语义的混乱.\n\n\n\n\n下标运算符e.g.\n// 下标运算符（返回左值引用，允许修改）int&amp; operator[](int index) {    if (index &lt; 0 || index &gt;= size) {        std::cerr &lt;&lt; \"错误: 下标越界 [\" &lt;&lt; index &lt;&lt; \"]\" &lt;&lt; std::endl;        // 返回第一个元素作为应急措施（实际应用中应抛出异常）        return data[0];    }    return data[index];}// 下标运算符的const版本（返回值，不允许修改）int operator[](int index) const {    if (index &lt; 0 || index &gt;= size) {        std::cerr &lt;&lt; \"错误: 下标越界 [\" &lt;&lt; index &lt;&lt; \"]\" &lt;&lt; std::endl;        // 返回0作为应急措施（实际应用中应抛出异常）        return 0;    }    return data[index];}\n\n\n\n\n\n关系运算符关系运算符通常成对实现，可以相互利用：\nbool Integer::operator==(const Integer&amp; rhs) const {    return i == rhs.i;}bool Integer::operator!=(const Integer&amp; rhs) const {    return !(*this == rhs);  // 利用==运算符}bool Integer::operator&lt;(const Integer&amp; rhs) const {    return i &lt; rhs.i;}bool Integer::operator&gt;(const Integer&amp; rhs) const {    return rhs &lt; *this;  // 利用&lt;运算符}bool Integer::operator&lt;=(const Integer&amp; rhs) const {    return !(rhs &lt; *this);  // 利用&lt;运算符}bool Integer::operator&gt;=(const Integer&amp; rhs) const {    return !(*this &lt; rhs);  // 利用&lt;运算符}\n\n流运算符输入输出流运算符通常实现为全局函数：\n// 输出流运算符ostream&amp; operator&lt;&lt;(ostream&amp; os, const A&amp; a) {    os &lt;&lt; a.get();    return os;  // 返回流对象以支持链式操作}// 输入流运算符istream&amp; operator&gt;&gt;(istream&amp; is, A&amp; a) {    string line;    cin &gt;&gt; line;    // 读取a的数据    return is;  // 返回流对象以支持链式操作}\n\n注意：\n\n输出流运算符的第一个参数不能是const，因为输出会修改流\n输入流运算符的第二个参数不能是const，因为需要修改对象\n通常需要声明为友元以访问私有成员\n\n自定义流操纵符可以定义自己的流操纵符：\nostream&amp; tab(ostream&amp; out) {    return out &lt;&lt; '\\t';}// 使用：cout &lt;&lt; \"Hello\" &lt;&lt; tab &lt;&lt; \"World!\" &lt;&lt; endl;\n\n\n\n\n\n赋值运算符与类型转换赋值运算符赋值运算符有几个重要特点：\n\n必须是成员函数\n如果不提供，编译器会自动生成（行为类似默认拷贝构造函数）\n需要检查自赋值情况\n确保为所有数据成员赋值\n返回*this的引用\n\nA&amp; A::operator=(const A&amp; rhs) {    if (this != &amp;rhs) {  // 检查自赋值        // 释放当前资源        delete[] data;                // 分配新资源        data = new int[rhs.size];        size = rhs.size;                // 复制数据        for (int i = 0; i &lt; size; i++) {            data[i] = rhs.data[i];        }    }    return *this;  // 返回对象引用}\n\n类型转换隐式转换C++支持两种用户定义的类型转换：\n\n构造函数转换：从其他类型到当前类型\nclass PathName {    string name;public:    PathName(const string&amp; s) : name(s) {}  // string到PathName的转换};string abc(\"abc\");PathName xyz = abc;  // 隐式转换：abc =&gt; PathName\n\n可以使用explicit关键字禁止隐式转换：\nexplicit PathName(const string&amp; s);  // 只能用于显式构造\n\n转换运算符：从当前类型到其他类型\nclass Rational {public:    operator double() const {  // Rational到double的转换        return numerator_ / (double)denominator_;    }};Rational r(1, 3);double d = r;  // 隐式转换：r =&gt; double\n\n同样可以使用explicit关键字要求显式转换：\nexplicit operator double() const;double d = (double)r;  // 必须显式转换\n\n注意：如果同时提供了从T到C的构造函数和从C到T的转换运算符，编译器可能会产生歧义。\n显式转换显式转换的外在特点:\n\n使用直接初始化语法\n明确指出要用构造函数创建对象\n转换过程更加清晰可见\n\ne.g.\n// 构造函数转换：double到RationalRational r1 = 3.14;  // 隐式转换Rational r2(2.5);    // 显式转换\n\n\n\n如果声明 explict, 就必须使用强制的显式转换:\n// 如果想要强制显式转换，应该这样声明：explicit Rational(double value) {    const int PRECISION = 10000;    numerator = static_cast&lt;int&gt;(value * PRECISION);    denominator = PRECISION;    simplify();}Rational r1 = 3.14;        // 错误：不允许隐式转换Rational r2(2.5);          // 正确：显式构造Rational r3 = Rational(3.14); // 正确：显式转换\n\n\n\n类型的显式转换:\ndouble d2 = static_cast&lt;double&gt;(r2);  // 显式转换\n\n\n\n混合类型的转换根据运算结果, 自动地将运算的操作数进行类型转换:\n// 混合类型运算Rational r3(1, 2);double d3 = 0.5;// 这里会将r3转换为double，然后进行double加法double result = r3 + d3;\n\n\n\nTemplate模板概述模板是C++中实现**泛型编程**的核心机制，允许我们编写可以处理不同数据类型的代码，而不必为每种类型重复编写相同的逻辑。\n\n首先尝试匹配普通的函数, 否则尝试匹配模板函数\n\n函数模板是声明, 而非定义. 是在实际调用时候去 实例化 对应类型的函数.\n\n必须都放在头文件的实现包含:\n\n函数模板;\n\ninline函数\n\n带有default参数的声明.\n\n类模板的成员函数\ntemplate&lt;T&gt;int Vector&lt;T&gt;::getSize()const{  return size;}\n\n注意, 都需要声明模板类, 并且需要在 &lt; &gt;内部声明类.\n\n\n\ntemplate&lt;class T&gt; 和 template&lt;typename T&gt; 是等价的, 后者是后来引入的更明确的语法.\n\n类模板的每个成员函数在类外定义时，都必须以template&lt;class T&gt;（或template&lt;typename T&gt;）开头，即使该成员函数没有直接使用模板参数T.\n\nVector&lt; int (*)&gt;\n\n\n函数模板基本语法template&lt;class T&gt;void swap(T&amp; x, T&amp; y) {    T temp = x;    x = y;    y = temp;}\n\n\ntemplate 关键字引入模板声明\nclass T 指定参数化类型名称（class在这里表示任何内置类型或用户定义类型）\n在模板内部，T 被用作类型名称\n\n模板实例化int i = 3, j = 4;swap(i, j);  // 使用int类型的swapfloat k = 4.5, m = 3.7;swap(k, m);  // 实例化float类型的swapstd::string s(\"Hello\"), t(\"World\");swap(s, t);  // 实例化std::string类型的swap\n\n编译器会根据传入的参数类型自动生成相应的函数实例。\n模板匹配规则\n只使用类型的精确匹配\n不应用类型转换操作\n即使是隐式转换也会被忽略\n\nswap(int, int);     // 正确swap(double, double); // 正确swap(int, double);  // 错误！类型不匹配\n\n模板函数与普通函数共存如果同时存在模板函数和普通函数，编译器会优先选择**普通函数**.\n显式指定可以显式地指定模板参数类型:\n// 带有返回值的函数模板template &lt;class T&gt;T myMax(T a, T b){    cout &lt;&lt; \"调用模板版本的myMax\" &lt;&lt; endl;    return (a &gt; b) ? a : b;}int main(){  cout &lt;&lt; \"myMax&lt;double&gt;(10, 20.5) = \" &lt;&lt; myMax&lt;double&gt;(10, 20.5) &lt;&lt; endl; }// myMax(10, 20.5);  // 错误：参数类型不一致\n\n\n\n多参数的函数模板同理的, 我们可以设置多个参数类型, 根据输入的类型来推断:\ntemplate &lt;class T1, class T2&gt;T1 myMax(T1 a, T2 b){    cout &lt;&lt; \"调用模板版本的myMax2\" &lt;&lt; endl;    return (a &gt; b) ? a : b;}int main(){  cout &lt;&lt;  myMax(10, 20.5) &lt;&lt; endl; }\n\n 此时, 上述的函数不需要显式的声明参数类型, 因为存在匹配的模板函数.\n同时, 此时根据类型推断, 返回的类型是 int, 然后舍弃 20.5的小数部分, 最终的结果是 20.\n类模板基本语法此处的 Vector是自己定义的.\ntemplate&lt;class T&gt;class Vector {public:    Vector(int);    ~Vector();    Vector(const Vector&amp;);    Vector&amp; operator=(const Vector&amp;);    T&amp; operator[](int);private:    T* m_elements;    int m_size;};\n\n类模板的使用类模板必须显式指定类型参数：\nVector&lt;int&gt; v1(100);Vector&lt;Complex&gt; v2(256);v1[20] = 10;v2[20] = v1[20];  // 如果定义了int到Complex的转换，则正确\n\n类模板成员函数的定义所有成员函数定义都需要包含模板声明：\ntemplate &lt;class T&gt;Vector&lt;T&gt;::Vector(int size) : m_size(size) {    m_elements = new T[m_size];}template &lt;class T&gt;T&amp; Vector&lt;T&gt;::operator[](int indx) {    if (indx &lt; m_size &amp;&amp; indx &gt;= 0) {        return m_elements[indx];    } else {        // 错误处理    }}\n\n注意：\n\n每个成员函数定义前都要加上 template &lt;class T&gt;\n类名必须写为 Vector&lt;T&gt;\n类模板的函数通常在头文件中实现，不需要分离的.cpp文件\n\n多参数模板模板可以使用多个类型参数：\ntemplate&lt;class Key, class Value&gt;class HashTable {    const Value&amp; lookup(const Key&amp;) const;    void install(const Key&amp;, const Value&amp;);    // ...};\n\n嵌套模板模板可以嵌套使用，因为它们只是新的类型：\nVector&lt;Vector&lt;double&gt;&gt; matrix;  // 注意C++11之前需要空格：Vector&lt;Vector&lt;double&gt; &gt;Vector&lt;int (*)(Vector&lt;double&gt;&amp;, int)&gt; functionPointers;  // 函数指针的向量\n\n\n\n非类型模板参数~也就是没有使用模板类型的普通参数.\ntemplate&lt;class Key, class Value, int TableSize = 10&gt;class HashTable {    // ...};\n\n其中的 TableSize 就是普通的参数. 在编译时就确定了类型.\n模板的局限性与注意事项\n模板代码通常放在头文件中，因为编译器需要在编译时看到完整的模板定义\n模板错误通常在实例化时才会被发现，错误信息可能很复杂\n模板可能导致代码膨胀，因为每种类型都会生成一份代码\n模板参数必须支持模板中使用的所有操作\n\n其他\n使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.\n另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.\n\n\n\n访问控制继承关系中的访问控制控制基类成员在派生类中的可见性：\n\npublic：基类的 public 成员在派生类中仍然是 public，protected 成员仍然是 protected。\nprotected：基类的 public 和 protected成员在派生类中都变为 protected。\nprivate：基类的 public 和 protected 成员在派生类中都变为 private。\n\n作用域与生存期本地: 均为本地\n全局: 均为全局\n静态本地: 作用域是本地, 生存期是全局\n静态全局: ~\nIncludesAlgorithmcopy(first, last, result):\n\nfisrt和last是输入迭代器, 表示要复制的范围, 左闭右开即last应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;\nresult是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作\ne.g.std::vector&lt;int&gt; source = {1, 2, 3, 4, 5};std::vector&lt;int&gt; destination(5); // 确保目标容器有足够的空间std::copy(source.begin(), source.end(), destination.begin());for (int num : destination) {    std::cout &lt;&lt; num &lt;&lt; \" \"; // 输出：1 2 3 4 5}std::cout &lt;&lt; std::endl;\n\n\nresult可以直接输出到cout中.  vector&lt;int&gt; vec;for(int i = 0; i &lt; 5; i++){    vec.push_back(i);}vec.erase(vec.begin()+2); //删除第三个元素copy(vec.begin(), vec.end(), ostream_iterator&lt;int&gt;(cout, \",\"));cout &lt;&lt; endl;// 0,1,3,4,\n\n\n\n数组之间不可以直接赋值, 但是字符串可以直接赋值\n\nchar str1[] = \"Hello\";char str2[] = \"World\";str1 = str2;  // 错误，数组之间不可以直接赋值string s1 = \"Hello\";string s2 = \"World\";s1 = s2;  // 正确，字符串可以直接赋值\n\n\n深拷贝string s1 = \"Hello\";string s2 = \"World\";cout &lt;&lt; \"初始状态：\" &lt;&lt; endl;cout &lt;&lt; \"s1: \" &lt;&lt; s1 &lt;&lt; endl;  // 输出：Hellocout &lt;&lt; \"s2: \" &lt;&lt; s2 &lt;&lt; endl;  // 输出：Worlds1 = s2;  // 赋值操作cout &lt;&lt; \"赋值后：\" &lt;&lt; endl;cout &lt;&lt; \"s1: \" &lt;&lt; s1 &lt;&lt; endl;  // 输出：Worldcout &lt;&lt; \"s2: \" &lt;&lt; s2 &lt;&lt; endl;  // 输出：World// 修改 s2 不会影响 s1，因为是深拷贝s2 = \"Changed\";cout &lt;&lt; \"修改 s2 后：\" &lt;&lt; endl;cout &lt;&lt; \"s1: \" &lt;&lt; s1 &lt;&lt; endl;  // 输出：Worldcout &lt;&lt; \"s2: \" &lt;&lt; s2 &lt;&lt; endl;  // 输出：Changed\n\nTemp// 迭代器I.begin();I.end();// Item AccessV.front();;V.back();\n\n区分findfind是字符串类的一种方法, 同时也是标准库algorithm中的一个函数.\n\nfind方法: 用于在字符串中查找子字符串的位置。\n\nstring str = \"Hello World\";size_t pos = str.find(\"World\");if (pos != string::npos) {    cout &lt;&lt; \"Found 'World' at position \" &lt;&lt; pos &lt;&lt; endl;}\n\nalgorithm中的find函数: 用于在容器（如数组、向量等）中查找元素。\n\n#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;int main() {    vector&lt;int&gt; vec = {1, 2, 3, 4, 5};    vector&lt;int&gt;::iterator it = find(vec.begin(), vec.end(), 3);    if (it != vec.end()) {        cout &lt;&lt; \"Found 3 at position \" &lt;&lt; distance(vec.begin(), it) &lt;&lt; endl;    }}// Found 3 at position 2\n\n编译: g++ -std=c++11 test.cpp -o test\n\nerase\n对于字符串的方法: str.erase(pos, len)\n删除从指定位置开始的指定个数字符\n\n\n\nstring str = \"Hello World\";str.erase(6, 5);cout &lt;&lt; str &lt;&lt; endl;  // 输出: Hello\n\n\n\n对于容器的方法: erase(pos1, pos2)\n左闭右开式删除容器当中的元素.\n\n\n\n#include &lt;iostream&gt;#include &lt;vector&gt;int main() {    std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5, 6};    std::cout &lt;&lt; \"Original vector: \";    for (int i : vec) {        std::cout &lt;&lt; i &lt;&lt; \" \";    }    std::cout &lt;&lt; std::endl;    // 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素    vec.erase(vec.begin() + 1, vec.begin() + 4); // 删除 vec[1], vec[2], vec[3]    std::cout &lt;&lt; \"Modified vector: \";    for (int i : vec) {        std::cout &lt;&lt; i &lt;&lt; \" \";    }    std::cout &lt;&lt; std::endl; // 输出 \"1 5 6\"    return 0;}\n\n不知道放在哪里的代码块#include &lt;iostream&gt;#include &lt;list&gt;using namespace std;int main() {// 1. 创建并填充链表list&lt;int&gt; L;                      // 创建一个空的整数链表for(int i=1; i&lt;=5; ++i)          // 循环5次    L.push_back(i);              // 依次在链表尾部添加数字1,2,3,4,5                                 // 此时链表内容为：1,2,3,4,5// 2. 删除第二个元素L.erase( ++L.begin() );          // L.begin()指向第一个元素                                 // ++L.begin()指向第二个元素                                 // erase删除迭代器指向的元素                                 // 此时链表内容为：1,3,4,5// 3. 打印链表内容copy(                            // 标准库算法，用于复制序列    L.begin(),                   // 源序列的起始位置    L.end(),                     // 源序列的结束位置    ostream_iterator&lt;int&gt;(       // 输出流迭代器        cout,                    // 指定输出到标准输出        \",\"                      // 每个元素后面追加的分隔符    ));cout &lt;&lt; endl;                    // 换行}\n\n\n\n课堂缓冲区\n私有的边界是 class而非对象. 也就是说, 相同类的对象可以直接访问对方的私有属性.\n\n不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们之间没有初始化的依赖.\n\n需要尽可能地避免使用全局变量.\n\n一个良好的习惯: 当成员函数不需要改变成员变量的值时, 在后面加上 const的关键字, 确保不会改变;\n\n\nchar* s = \"Hello,world！\"；\n\n\n此时的右侧字符串位于 段 text, 不可写. s本身是一个固定内存的指针.\n\nchar s［］ = \"Hello,world！\"；\n\n\n此时的 s是一个大小等于数组内容的对象.\n\nconst int* f();// 只能将函数的返回值赋值给一个 const int*\n\n\n\n函数内部的对象的空间分配编译器在编译的时候计算得到函数内部所有的对象的空间, 在实际进入函数的时候**, 立即分配所有对象的空间;**\n\n实际执行到的时候发生构造.\n\nQuiz静态全局、本地和成员变量都存储于全局数据区.\n\n静态成员变量的构造也在 main()之前.\n\n题目梳理HW2\n\nANS:  B\n由于此处的map以char *作为key, 同时初始化str的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.\n\n\n\n\n逗号表达式, 从左到右分别计算,最后返回的结果是最右侧的值, 此处为1.\n\n\n\nvector&lt;int&gt; v(10); 创建包含10个元素的容器, 每个元素初始化为 0;\n\nvector &lt;int&gt; v(10, 1);: 创建包含10个元素的容器, 但是都初始化为 1;\n\nvector &lt;int&gt; v{10, 1};: 创建包含10,1 这2个元素的容器;\n\n此外, 还可以使用 vector &lt;int&gt; v;创建一个空的容器; \n\n同时也还可以用 迭代器进行初始化: vector &lt;int&gt; v(arr, arr + 5);\n\n\n\nHW3\n类成员的默认访问权限是 私有的, 即不显式声明访问修饰符, 默认为 private;\n\nHW4可变大小矩阵:#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;class Matrix{private:    int r,c;    vector&lt;vector&lt;int&gt;&gt; m; // 二维向量, 每个向量元素是一个一维向量public:    Matrix(int r, int c) : r(r),c(c){        m.resize(r, vector&lt;int&gt;(c)); // 分配r个一维向量, 每个一维向量的大小为c    }\t...    void transform(){        vector&lt;vector&lt;int&gt;&gt; new_m(c, vector&lt;int&gt;(r,0)); //\t声明一个临时的二维向量            \t// 将矩阵转置, 放入临时的向量        for(int i = 0; i &lt; c; i++){            for(int j = 0 ; j&lt; r; j++){                new_m[i][j] = m[j][i];            }        }        swap(r,c); //改变矩阵的行与列        m = move(new_m); //使用 move 直接将临时变量的所有权交给m, 避免拷贝    }};\n\n\n此处值得注意的是 resize在二维向量中的使用, 以及 move直接给予“所有权”的特性.\n\nHW5判断题: const成员函数不能作用于非const对象\n\n答案是 False. \n题目的意思大致是: 非const对象无法调用 const对象, 实际上是事实是相反的描述. 只需要理解题目的表述即可做出判断.\n\nHW6右值引用本身是一个左值, 可以取地址.\nint&amp;&amp; r = 5;std::cout &lt;&lt; r; // r 在这里是左值，因为它有名字\n\n\n\nHW7HW9\n因为静态成员函数不能是虚函数，所以它们不能实现多态\n\n静态成员函数不与类的任何具体实例（对象）相关联;\n\n\n在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序\n#include &lt;iostream&gt;// 基类Aclass A{public:    A()    {        std::cout &lt;&lt; \"A的构造函数被调用\" &lt;&lt; std::endl;    }};// 基类Bclass B{public:    B()    {        std::cout &lt;&lt; \"B的构造函数被调用\" &lt;&lt; std::endl;    }};// 派生类C，继承自A和Bclass C : public A, public B{public:    // 构造函数中显式调用基类构造函数    C() : B(), A()    { // 注意：这里虽然B在A之前，但实际调用顺序由类定义决定        std::cout &lt;&lt; \"C的构造函数被调用\" &lt;&lt; std::endl;    }};int main(){    C c; // 创建C的实例    return 0;}\n\n输出:\nA的构造函数被调用B的构造函数被调用C的构造函数被调用\n\n由此可见, 虽然在C的初始化列表中声明了B前A后, 但是实际上A优先调用.\n\n如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针）\n\n这句话的括号内部是错误的.\n\n因为我们依旧可以将其的子类 upcast\n#include &lt;iostream&gt;using namespace std;class A{public:    virtual void ptr() = 0;};class B : public A{public:    void ptr() override    {        cout &lt;&lt; \"B\" &lt;&lt; endl;    }};int main(){    A *a = new B();    a-&gt;ptr();    return 0;}\n\n\n\n\n类内的纯虚函数被认为是 inline的函数;\n\n在创建派生类的对象时, 构造函数的执行顺序为—— 基类对象-&gt;对象成员-&gt;派生类自身:\n#include &lt;iostream&gt;using namespace std;class Base{public:    Base() { cout &lt;&lt; \"Base 构造函数\" &lt;&lt; endl; }};class Member{public:    Member() { cout &lt;&lt; \"Member 构造函数\" &lt;&lt; endl; }};class Derived : public Base{    Member m;public:    Derived() { cout &lt;&lt; \"Derived 构造函数\" &lt;&lt; endl; }};int main(){    Derived d;    return 0;}\n\n输出:\nBase 构造函数Member 构造函数Derived 构造函数\n\n私有继承问题: 可以通过方法访问私有继承的public, protected的基类成员(不包括私有成员), 但是无法直接访问.\n#include &lt;iostream&gt;using namespace std;class Base{private:    int a = 1; // 私有protected:    int b = 2; // 保护public:    int c = 3; // 公有};class Derived : private Base{private:    int d = 4; // 派生类自己的私有成员public:    void show()    {        // cout &lt;&lt; a;  // ❌ 错误！Base 的私有成员 a，派生类根本不能访问        cout &lt;&lt; b &lt;&lt; endl; // ✅ OK：Base 的 protected 成员，在 Derived 中变成了 private        cout &lt;&lt; c &lt;&lt; endl; // ✅ OK：Base 的 public 成员，在 Derived 中变成了 private        cout &lt;&lt; d &lt;&lt; endl; // ✅ OK：Derived 的私有成员当然能访问    }};int main(){    Derived d;    d.show();    // cout &lt;&lt; d.b; // ❌ 错误！Base 的 protected 成员，在 Derived 中变成了 private    return 0;}\n\n虚函数也具有 this 指针.\n\n在构造函数中调用虚函数，不是动态联编\n\n原因是：对象还未完全构造完成（或已经开始析构）时，虚函数表（vtable）可能尚未指向最终派生类.\n所以，在构造函数中调用虚函数时，只会调用当前类中该函数的版本，不会发生多态。\n\n\n\n虚析构函数\n为了在多重继承的时候, 可以正确的调用各个阶段的析构函数, 我们需要声明基类的析构为虚函数, 然后在子类中重写:\n\nvirtual ~CRAFT(){    cout &lt;&lt; \"销毁航行器(速度: \" &lt;&lt; speed &lt;&lt; \")\" &lt;&lt; endl;}...~PLANE() override{    cout &lt;&lt; \"销毁飞机(翼展: \" &lt;&lt; width &lt;&lt; \")\" &lt;&lt; endl;}\n\n\n\n\n菱形继承的时候, 注意 virtual public的声明 以及 在底层的子类中的初始化列表的顺序!\nSEAPLANE(float speed, float width, float depth) : CRAFT(speed), PLANE(speed, width), SHIP(speed, depth){  ...}\n\nHW10\n判断: 对象间赋值将调用拷贝构造函数。  \n错误. 对象间的赋值调用的是 拷贝复赋值运算符.\n\n\n\n异常类\n\nA是错误的。C++允许自定义异常类，可以继承标准异常类如std::exception。\nB是正确的，C++异常机制会在异常抛出前自动销毁局部对象。\nC是正确的，抛出异常时对象会被拷贝（或移动）到catch块中。\nD是正确的，在catch块中可以使用对象引用来接收异常对象。\n\n赋值运算符重载\n语法:\n类名&amp; operator=(const 类名&amp; 对象名)\n\n特点:\n\n返回类型是类的引用（为了支持连续赋值 a=b=c）\n参数是const引用（防止修改原对象）\n通常需要先释放自己的资源，再复制数据\n\n\n\ne.g.\nArray&amp; operator=(const Array&amp; a) {    if (this != &amp;a) {  // 防止自赋值        delete[] data;  // 释放原有内存        size = a.size;  // 复制大小        data = new int[size];  // 分配新内存        for (int i = 0; i &lt; size; i++) {  // 复制数据            data[i] = a.data[i];        }    }    return *this;  // 返回对象自身的引用}\n\n\n\nW12\n建立类模板对象的实例化过程为: 模板类-对象.\n编译器根据提供的模板参数将类模板实例化为一个具体的模板类（也称为实例化类或特化类），然后才能创建该模板类的对象。\n类模板的使用实际上是将类模板实例化成一个 类\n\n\n类模板与模板类\n类模板是类的蓝图或规范，它本身不是一个类\n模板类（或实例化类、特化类）是使用具体的类型参数实例化类模板后得到的具体的类。\n\n\n类模板和函数模板的实例化的时期 – 均为编译时期\n函数模板在编译时期检查定义中的基本语法;\n尝试调用某一个函数模板时, 编译器根据实际的参数类型来推导模板参数类型/或者由显式指定类型得到, 如果合法就生成函数实例(i.e. 模板函数), 这个过程就是模板实例化(生成代码).\n\n\n除了使用构造函数, 还可以直接调用 make_pair 让编译器自动推导类型来创建pair对象;\n\n\nL3\n[!NOTE]\n\n内联函数在 编译时展开, 而不是运行时.\n内联函数的声明以及最终的生效与否, 是由 编译器 决定的. 也就是说, 无论是否存在 inline 的声明, 编译器最终决定函数的类型.\n\n\nC++ 初始化列表与成员变量初始化\n[!NOTE]\n\nint和自己定义的类都是cpp的类, 所以可以直接在初始化列表中用 :class_instance{input},...{}来初始化类内的类对象.\n推荐使用 {}来初始化, 不会产生是函数的歧义.\n\n\n1. 构造顺序\n在 C++ 中，成员变量的初始化顺序由它们在类中声明的顺序决定，而不是在初始化列表中的顺序。\n初始化列表用于 直接初始化 成员变量，而不是在构造函数体内先创建未初始化的对象再赋值。\n\n2. 为什么必须使用初始化列表？\n成员变量在进入构造函数体之前就已经完成了初始化，不能在构造函数体内赋值来替代初始化。\n如果成员变量是一个没有默认构造函数的对象，必须在初始化列表中显式调用其构造函数，否则编译会报错。\n在构造函数体内赋值，意味着：\n先调用默认构造函数创建对象（如果 NumberDisplay 没有默认构造函数，这一步会失败）。\n然后使用赋值运算符进行赋值，而赋值运算与初始化是不同的过程。\n\n\n\n3. 示例代码❌ 错误示例（可能会编译失败）class NumberDisplay {public:    NumberDisplay(int max) { /* 初始化代码 */ }};class Clock {private:    NumberDisplay hour_display;    NumberDisplay minute_display;    NumberDisplay second_display;    public:    Clock(int hour, int minute, int second) { // ❌ 错误：NumberDisplay 没有默认构造函数        hour_display = NumberDisplay(24);     // 不能这样赋值        minute_display = NumberDisplay(60);        second_display = NumberDisplay(60);    }};\n✅ 正确示例class Clock {private:    NumberDisplay hour_display;    NumberDisplay minute_display;    NumberDisplay second_display;    public:    // 使用初始化列表    Clock(int hour, int minute, int second)        : hour_display(24), minute_display(60), second_display(60) {        // 构造函数体内的代码可以进行额外的赋值操作    }};\n\n\n\n4. 结论\n​\t•\t所有成员变量都会在构造函数体执行前被初始化，不能依赖在构造函数体内赋值。\n​\t•\t如果成员变量是没有默认构造函数的对象，必须使用初始化列表进行初始化，否则会导致编译错误。\n​\t•\t初始化列表的顺序应与成员变量的声明顺序一致，否则可能会导致未定义行为。\nProjectP1cout &lt;&lt; \"\\\"\" &lt;&lt; value &lt;&lt; \"\\\"\";\n\n如果要输出引号, 需要加入 \\来进行转义!\n使用匿名函数来排序sort(sortedRecords.begin(), sortedRecords.end(),     [](const Record&amp; a, const Record&amp; b) {         if (a.qso_date != b.qso_date) return a.qso_date &lt; b.qso_date;         return a.time_on &lt; b.time_on;     });\n\nsort是 algorithm头文件中的库函数, 支持原地排序.\n第三个参数是一个函数, 返回 true表示这个函数的第一个参数应该排在第二个参数的前面.\n比如此处, 使用了匿名函数 [], 同时比较 date, 当 \nreturn a.qso_date &lt; b.qso_date;\n\n指的是当前者的时间较小, 应该排在前面, 因此是升序.\n\n不要因为语句太长而忘记末尾的 ;.\n\nP2思路分析\n整体设计:\n程序随机生成一组设置, 然后用户开始输入\n大概率, 用户不可避免地会失败, 此时应当让用户选择是否继续参与这场游戏, 否则程序生成下一组的设置;\n\n\n房间:\nmonster所在;\nprincess所在\nlobby;\n普通的room\n具有毒药的房间(接触后限制之后行动的次数)\n解药房间(可以解除中毒的状态)\n地图房间(接触后可以通过输入 map来显示当前的位置)\n\n\n房间个数: \n每次都将上述的因素都加入, 不太合适, 因此需要用户输入游戏的类型/难度;\n经典模式: 只会产生monster, princess,lobby和普通房间. 房间的个数较少;\n挑战模式:  加入毒药, 解药和地图因素; 房间个数较多.\n\n\n\n刷题\nDestructors can not be overloaded.\n\n因为析构函数没有任何的参数和返回类型, 无法重载.\n\n\n类的成员函数可以访问同类的私有成员，即使是其他对象的成员。 回顾类的私有边界不是相对于对象的, 而是类. \n\ncpp中, 构造函数一定不能是 virtual 的! \n\n静态变量需要再类的外部定义, 但是静态函数不一定.\n\n“In C++， struct is actually the same thing as class， except for minor differences in usage.”\n\n这句话是正确的, 注意结构体也是支持继承的. 只是默认的继承方式也是 public.\n\n\nIn C++, inheritance allows a derived class to directly access all of the functions and data of its base class.（T/F）\n\n错误的. 对于 public 类型的继承, 依旧无法直接访问父类的私有成员, 只能通过子类的方法来间接访问.\n\n\n下面的代码段, 能够能够通过编译, 但是存在运行时的错误(越界访问):\nint main() { vector&lt;float&gt; v; v[0] = 2.5; }\n\n\n编译器在编译时候, 检查的主要是程序的语法和类型;\n越界访问的问题存在于运行时检测.\n\n\n64位系统系统环境, 按照8个字节进行对齐:\n// 参考的类定义方式class A1{public:    int i;    void f(){}};// 其他的类型定义\n\nOutput:\nSize of A1 (non - virtual function with int member): 4 bytesSize of A2 (virtual function with int member): 16 bytesSize of A3 (non - virtual function without int member): 1 bytesSize of A4 (virtual function without int member): 8 bytesSize of B (derived from A1): 8 bytes\n\n主要注意2点:\n\n没有任何成员的类, 也占用1个字节的大小;\n\n4+8 将会对齐得到16个字节的空间大小.\n\n[!NOTE]\nvoid* 和 int* 的大小相同! (题目通常给出 int*的大小, 然后给出虚函数)\n\n\n\n\nmalloc 不会调用对象的构造函数, 仅仅分配内存, 并不涉及对象的初始化;\n\nnew会调用构造函数\n\nmalloc 需要显式地类型转换:\nclass MyClass {public:    MyClass() { std::cout &lt;&lt; \"Constructor called!\" &lt;&lt; std::endl; }};MyClass* p1 = new MyClass();  // 输出 \"Constructor called!\"MyClass* p2 = (MyClass*)malloc(sizeof(MyClass));  // 无输出，构造函数未调用\n\n\nnew 是CPP的运算符, 可以重载; malloc是标准库的函数, 无法重载.\n\n每个类最多具有一个析构函数\n\n\n重载问题在 ::, () 和 -&gt;中, 只有 -&gt;可以被重载:\n#include &lt;iostream&gt;class MyClass {public:    void sayHello() {        std::cout &lt;&lt; \"Hello from MyClass!\" &lt;&lt; std::endl;    }};class MyPtr {private:    MyClass* ptr;  // 内部存储一个原生指针public:    // 构造函数    MyPtr(MyClass* p) : ptr(p) {}    // 重载 -&gt; 运算符    MyClass* operator-&gt;() {        return ptr;  // 返回原生指针，使得可以继续用 -&gt; 访问成员    }};int main() {    MyClass obj;    MyPtr myPtr(&amp;obj);  // 用 MyPtr 包装 MyClass 对象    myPtr-&gt;sayHello();  // 调用 MyClass 的成员函数    return 0;}\n\nnew与对象转换#include &lt;iostream&gt;using namespace std;class B;class A{protected:    int x;public:    A(int x = 0) : x(x) {}    operator B();    int getx() { return x; }};class B : public A{public:    B(int x = 0) : A(x) { this-&gt;x++; }    B(const B &amp;b) : A(b.x) { this-&gt;x++; }};A::operator B() { return *new B(x + 1); } // 特别注意此处int main(){    A *p1 = new B(3); // new的时候触发B的构造函数, 自增    A *p2 = new A(9);    B b0 = *p1; // 发生了A类对象向B类对象的转化, 详见下面两行:    // *p1 将要转化的时候,  先传入x+1作为B的初始化参数输入,    // 然后new将触发B的构造函数, 最后返回, 返回结果用于初始化b0, 继续触发拷贝构造函数    B &amp;r = b0;    B b1 = b0;  // 发生了 B类对象的拷贝构造, b1的x为8, 但是不会改变b0的x=7    B b2 = *p2; // 这一步的转换与上面的同理. 也是+3    cout &lt;&lt; p1-&gt;getx() &lt;&lt; endl;    cout &lt;&lt; p2-&gt;getx() &lt;&lt; endl;    cout &lt;&lt; b0.getx() &lt;&lt; endl;    cout &lt;&lt; r.getx() &lt;&lt; endl;    cout &lt;&lt; b1.getx() &lt;&lt; endl;    cout &lt;&lt; b2.getx() &lt;&lt; endl;}\n\n解题过程中的关键步骤已经写在注释当中, 最后的输出是:\n4977812\n\n梳理考察的重要知识点:\n\nupcast的时候, 是子类的属性赋值给父类, 包括虚函数表. 因此, 此时看作是父类的对象, 但是虚函数能够动态绑定.\n\nnew和delete分别自动调用类的构造函数和析构函数;\n\nA::operator B() 形式表示A类对象如何转换成B类型对象的, 在发生转换的时候自动调用这部分的函数.\nA *p1 = new B(3); // 拷贝构造的时候直接自增为4A *p2 = new A(9);\n\n注意上面的指针都指向A类的对象.\n\n\n链式的析构顺序\n构造顺序: 父类-&gt;成员对象-&gt; 自身\n析构顺序: 自身-&gt; 成员对象-&gt; 父类\n\n下面的这道题目涉及的类的关系如下:\n\nP是父类, S是子类;\nP内部有两个P类型的指针成员.\n\n#include &lt;iostream&gt;using namespace std;// 1. 先声明基类 Pclass P{public:    static bool flag; // 静态成员声明    int x;            // 数据成员    P *left, *right;  // 指针成员    // 构造函数    P(P *left = nullptr, P *right = nullptr)        : x(0), left(left), right(right) {}    // 虚析构函数（因为有继承关系，应该是虚函数）    ~P()    {        if (flag)        {            if (left != nullptr)            {                delete left;            }            if (right != nullptr)            {                delete right;            }        }        else        {            if (right != nullptr)            {                delete right;            }            if (left != nullptr)            {                delete left;            }        }        cout &lt;&lt; \"P\" &lt;&lt; x;    }};// 2. 静态成员的定义（必须在类外定义）bool P::flag = false;// 3. 派生类 Sclass S : public P{public:    // 构造函数，调用基类构造函数    S(P *left = nullptr, P *right = nullptr) : P(left, right) {}    // 析构函数    ~S()    {        cout &lt;&lt; \"S\" &lt;&lt; x;    }};int main(){    S *p1 = new S;    p1-&gt;x = 1; // 设置第一个节点的值    S *p2 = new S;    p2-&gt;x = 2;   // 设置第二个节点的值    S s(p1, p2); // 创建根节点，连接p1和p2    s.x = 3;     // 设置根节点的值/    return 0;    // 程序结束时析构对象}\n\n最终的输出:\n\n析构s, 首先析构子类自身, 调用s的析构函数, 输出s;\n然后析构父类, 父类是P, 析构的时候直接调用自身的析构函数, 一词析构右指针和左指针;\n执行到末尾, 输出自身的P3.\n\nOutput:\nS3P2P1P3\n\n\n\n\n\n\n\n操作符的重载#include &lt;iostream&gt;#include &lt;iomanip&gt;#define MAXN 110/* Your answer will be inserted here. Feel free to add anything needed here.*/class vec{private:    int first, second;public:    vec(int a, int b) : first(a), second(b) {}    //  &lt; 的重载    bool operator&lt;(const vec &amp;other) const    {        return second &lt; other.second;    }    // 类型转换的重载    operator double() const    {        return static_cast&lt;double&gt;(first);    }    // 输出的重载    friend std::ostream &amp;operator&lt;&lt;(std::ostream &amp;os, const vec &amp;v)    {        return os &lt;&lt; \"(\" &lt;&lt; v.first &lt;&lt; \",\" &lt;&lt; v.second &lt;&lt; \")\";    }};void printArrayInfo(vec **arr, int n){    vec *maxv = arr[0], *minv = arr[0];    double avg = 0;    for (int i = 0; i &lt; n; ++i)    {        vec *val = arr[i];        if (*val &lt; *minv)            minv = val;        if (*maxv &lt; *val)            maxv = val;        avg = avg + static_cast&lt;double&gt;(*val);    }    avg /= n;    std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; \"min = \" &lt;&lt; *minv &lt;&lt; \", max = \" &lt;&lt; *maxv &lt;&lt; \", avg = \" &lt;&lt; avg &lt;&lt; std::endl;}int main(){    vec *pool[MAXN];    int n;    int a, b;    std::cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    {        std::cin &gt;&gt; a &gt;&gt; b;        pool[i] = new vec(a, b);    }    printArrayInfo(pool, n);    return 0;}\n\n\n\n菱形继承与二义性问题并不是菱形继承的操作都会导致二义性, 要从本质–访问的操作是否导致无法区分正确的单独对象?\n#include &lt;iostream&gt;using namespace std;class A{public:    int x;    A() : x(6) {}    int fun()    {        return x;    }};class B : public A{public:    int fun()    {        return A::fun() + x;    }};class C : public A{public:    int fun()    {        return A::fun() + x;    }};class D : public B, public C{public:    int fun()    {        return B::fun() + C::fun();    }};int main(){    D d;    cout &lt;&lt; d.fun();    // cout &lt;&lt; d.A::fun(); 存在二义性的问题, 因为在D当中分别存在来自于B和C的这个函数!}\n\n在上面代码中, D是菱形继承, 但是可以直接访问d的fun, 因为在d的fun中涉及的是B和C自己的fun. 而后者又能够直接调用自己的继承自A的fun\n\n无法直接调用 d.A::fun(), 参见注释.\n\n最后的枚举转换运算符A::operator B()的含义： 定义了如何将 A 类型的对象转换为 B 类型的对象。\n\nA:: 表示这是 A 类的成员函数\noperator B 表示这是一个到 B 类型的转换运算符\n() 表示这是一个函数\n\n// A 具有一个成员变量且在构造函数中可以赋值A::operator B() { return *new B(x + 1); }\n\n\nnew B(x + 1) 创建一个新的 B 对象，其中 x 是 A 类的成员变量\n* 解引用这个新创建的对象\n返回这个 B 类型的对象\n\n\n[!NOTE]\n注意, 这只是决定了B类对象的如何构造, 并不会影响A类对象本身.\n\n调用的场景: 需要将A类型的对象转换为B类型的对象 e.g.——\nA a(5);B b = a;  // 这里会自动调用 A::operator B()\n\n\n\nconst相关对象与方法的对应C++在选择成员函数时会考虑对象的const属性：\n\nconst对象只能调用const成员函数 \n\n非const对象优先调用非const版本，如果没有非const版本才会调用const版本\n\n\n[!NOTE]\n函数定义的顺序并不会影响调用的选择!\n\n\n\ne.g.\n#include &lt;iostream&gt;using namespace std;class MyClass{public:    MyClass(int x) : val(x) {}    void Print()    {        cout &lt;&lt; 2 &lt;&lt; endl             &lt;&lt; val &lt;&lt; endl;    }    void Print() const { cout &lt;&lt; 1 &lt;&lt; endl                              &lt;&lt; val &lt;&lt; endl; }private:    int val;};int main(){    const MyClass obj1(10);    MyClass obj2(20);    obj1.Print();    obj2.Print();    return 0;}\n\noutput:\n110220\n\n\n\n\n\n初始化先后的问题C++中对象的初始化和销毁顺序遵循特定的规则，这对于理解程序行为和避免内存问题至关重要\n初始化列表类的构造与析构顺序在C++中，对象的构造和析构顺序遵循以下规则：\n\n构造顺序：\n\n基类先于派生类构造\n成员变量按声明顺序构造\n基类构造完成后，才执行派生类构造函数体\n\n[!NOTE]\n对象在调用构造函数之前, 首先完成内部成员对象的构造\n\n\n\n\n析构顺序：\n\n与构造顺序相反\n先执行派生类析构函数体\n然后按声明顺序的逆序析构成员变量\n最后析构基类\n\n\n\n示例分析int main(){    Child c;}\n\n类层次结构X (基础类)↑Y (继承自X)Parent (包含X成员)↑Child (继承自Parent，包含Y成员)\n\n构造过程分析当创建Child对象时，构造顺序为：\n\n首先构造基类Parent\n在Parent构造前，先构造其成员x（调用X::X()）\n然后执行Parent构造函数体（输出”Parent::Parent()”）\n\n\n基类构造完成后，构造Child的成员y\n在构造y前，先构造其基类部分（调用X::X()）\n然后执行Y构造函数体（输出”Y::Y()”）\n\n\n最后执行Child构造函数体（输出”Child::Child()”）\n\n析构过程分析当Child对象离开作用域时，析构顺序为：\n\n首先执行Child析构函数体（输出”Child::~Child()”）\n然后析构成员y\n先执行Y析构函数体（输出”Y::~Y()”）\n然后析构其基类部分（调用X::~X()）\n\n\n最后析构基类Parent\n先执行Parent析构函数体（输出”Parent::~Parent()”）\n然后析构其成员x（调用X::~X()）\n\n\n\n预期输出执行test.cpp程序时，预期输出为：\nX::X()              // Parent的成员x构造Parent::Parent()    // Parent构造函数体X::X()              // Y的基类部分构造Y::Y()              // Y构造函数体Child::Child()      // Child构造函数体Child::~Child()     // Child析构函数体Y::~Y()             // Y析构函数体X::~X()             // Y的基类部分析构Parent::~Parent()   // Parent析构函数体X::~X()             // Parent的成员x析构\n\n重要注意事项\n虚析构函数：当使用多态时，基类应该有虚析构函数，确保正确调用派生类析构函数。\n\n成员初始化列表：推荐使用成员初始化列表而非在构造函数体内赋值，这样可以直接初始化而非先默认构造再赋值。\n\n异常安全：构造过程中如果抛出异常，已构造的成员会被正确析构，但未完全构造的对象不会调用析构函数。\n\nRAII原则：资源获取即初始化，在构造函数中获取资源，在析构函数中释放资源，确保资源管理安全。\n\n\n实际应用理解对象生命周期对以下场景尤为重要：\n\n资源管理：确保资源在不再需要时被释放\n依赖关系处理：确保依赖对象在被依赖对象之前构造，之后析构\n继承层次设计：合理设计基类和派生类的构造和析构行为\n\n","categories":["编程语言","学习笔记"]}]