{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/all.min.css","path":"fontawesome/all.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/brands.min.css","path":"fontawesome/brands.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/fontawesome.min.css","path":"fontawesome/fontawesome.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/duotone.min.css","path":"fontawesome/duotone.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/light.min.css","path":"fontawesome/light.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/sharp-solid.min.css","path":"fontawesome/sharp-solid.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/regular.min.css","path":"fontawesome/regular.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/solid.min.css","path":"fontawesome/solid.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/svg-with-js.min.css","path":"fontawesome/svg-with-js.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/thin.min.css","path":"fontawesome/thin.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v5-font-face.min.css","path":"fontawesome/v5-font-face.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/bookmark-placeholder.svg","path":"images/bookmark-placeholder.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-avatar.svg","path":"images/redefine-avatar.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/loading.svg","path":"images/loading.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-favicon.svg","path":"images/redefine-favicon.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-shims.min.css","path":"fontawesome/v4-shims.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.svg","path":"images/redefine-logo.svg","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.webp","path":"images/redefine-logo.webp","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-og.webp","path":"images/redefine-og.webp","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-light.webp","path":"images/wallhaven-wqery6-light.webp","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-dark.webp","path":"images/wallhaven-wqery6-dark.webp","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/assets/odometer-theme-minimal.css","path":"assets/odometer-theme-minimal.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/assets/hbe.style.css","path":"assets/hbe.style.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/tailwind.source.css","path":"css/tailwind.source.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-font-face.min.css","path":"fontawesome/v4-font-face.min.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build.js","path":"js/build.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.ttf","path":"webfonts/fa-brands-400.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.woff2","path":"webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.woff2","path":"webfonts/fa-duotone-900.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.ttf","path":"webfonts/fa-light-300.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.woff2","path":"webfonts/fa-light-300.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.ttf","path":"webfonts/fa-duotone-900.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.ttf","path":"webfonts/fa-regular-400.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.woff2","path":"webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.ttf","path":"webfonts/fa-sharp-solid-900.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.woff2","path":"webfonts/fa-sharp-solid-900.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.ttf","path":"webfonts/fa-solid-900.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.woff2","path":"webfonts/fa-solid-900.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.ttf","path":"webfonts/fa-thin-100.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.woff2","path":"webfonts/fa-thin-100.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.woff2","path":"webfonts/fa-v4compatibility.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.ttf","path":"webfonts/fa-v4compatibility.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/basic.styl","path":"css/common/basic.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/animated.styl","path":"css/common/animated.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/markdown.styl","path":"css/common/markdown.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/colors.styl","path":"css/common/colors.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/redefine-theme.styl","path":"css/common/redefine-theme.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/theme.styl","path":"css/common/theme.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/variables.styl","path":"css/common/variables.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/animations.styl","path":"css/layout/animations.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/article-content.styl","path":"css/layout/article-content.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/archive-content.styl","path":"css/layout/archive-content.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/bookmarks.styl","path":"css/layout/bookmarks.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-content.styl","path":"css/layout/category-content.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-list.styl","path":"css/layout/category-list.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-content.styl","path":"css/layout/home-content.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/page.styl","path":"css/layout/page.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/tag-content.styl","path":"css/layout/tag-content.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.eot","path":"fonts/Chillax/Chillax-Variable.eot","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.ttf","path":"fonts/Chillax/Chillax-Variable.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff","path":"fonts/Chillax/Chillax-Variable.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-sidebar.styl","path":"css/layout/home-sidebar.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff2","path":"fonts/Chillax/Chillax-Variable.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/chillax.css","path":"fonts/Chillax/chillax.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.ttf","path":"fonts/Geist/GeistVF.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff2","path":"fonts/Geist/GeistVF.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff","path":"fonts/Geist/GeistVF.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/geist.css","path":"fonts/Geist/geist.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.ttf","path":"fonts/GeistMono/GeistMonoVF.ttf","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff","path":"fonts/GeistMono/GeistMonoVF.woff","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/geist-mono.css","path":"fonts/GeistMono/geist-mono.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff2","path":"fonts/GeistMono/GeistMonoVF.woff2","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js","path":"js/build/main.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js.map","path":"js/build/main.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js.map","path":"js/build/utils.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js","path":"js/build/utils.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/aplayer.js","path":"js/plugins/aplayer.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/hbe.js","path":"js/plugins/hbe.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/mermaid.js","path":"js/plugins/mermaid.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/pangu.js","path":"js/plugins/pangu.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/masonry.js","path":"js/plugins/masonry.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/tabs.js","path":"js/plugins/tabs.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/typed.js","path":"js/plugins/typed.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/codeBlock.js","path":"js/tools/codeBlock.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/imageViewer.js","path":"js/tools/imageViewer.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/build/tailwind.css","path":"css/build/tailwind.css","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/localSearch.js","path":"js/tools/localSearch.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/lightDarkSwitch.js","path":"js/tools/lightDarkSwitch.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/runtime.js","path":"js/tools/runtime.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/tocToggle.js","path":"js/tools/tocToggle.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/scrollTopBottom.js","path":"js/tools/scrollTopBottom.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/categoryList.js","path":"js/layouts/categoryList.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/bookmarkNav.js","path":"js/layouts/bookmarkNav.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/essays.js","path":"js/layouts/essays.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/lazyload.js","path":"js/layouts/lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/toc.js","path":"js/layouts/toc.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/navbarShrink.js","path":"js/layouts/navbarShrink.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js","path":"js/libs/APlayer.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js.map","path":"js/libs/APlayer.min.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js","path":"js/libs/Swup.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js.map","path":"js/libs/Swup.min.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js","path":"js/libs/SwupPreloadPlugin.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js.map","path":"js/libs/SwupPreloadPlugin.min.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupProgressPlugin.min.js","path":"js/libs/SwupProgressPlugin.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScriptsPlugin.min.js","path":"js/libs/SwupScriptsPlugin.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js","path":"js/libs/SwupScrollPlugin.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js.map","path":"js/libs/SwupScrollPlugin.min.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupSlideTheme.min.js","path":"js/libs/SwupSlideTheme.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Typed.min.js","path":"js/libs/Typed.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/anime.min.js","path":"js/libs/anime.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js","path":"js/libs/mermaid.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js.map","path":"js/libs/mermaid.min.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/minimasonry.min.js","path":"js/libs/minimasonry.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment-with-locales.min.js","path":"js/libs/moment-with-locales.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment.min.js","path":"js/libs/moment.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/odometer.min.js","path":"js/libs/odometer.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pangu.min.js","path":"js/libs/pangu.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pjax.min.js","path":"js/libs/pjax.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs","path":"js/libs/waline.mjs","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs.map","path":"js/libs/waline.mjs.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-block.styl","path":"css/common/codeblock/code-block.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-theme.styl","path":"css/common/codeblock/code-theme.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/highlight.styl","path":"css/common/codeblock/highlight.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js","path":"js/build/layouts/bookmarkNav.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js.map","path":"js/build/layouts/bookmarkNav.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js","path":"js/build/layouts/categoryList.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js.map","path":"js/build/layouts/categoryList.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js","path":"js/build/layouts/essays.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js.map","path":"js/build/layouts/essays.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js","path":"js/build/layouts/lazyload.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js.map","path":"js/build/layouts/lazyload.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js","path":"js/build/layouts/navbarShrink.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js.map","path":"js/build/layouts/navbarShrink.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js","path":"js/build/layouts/toc.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js.map","path":"js/build/layouts/toc.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js","path":"js/build/plugins/aplayer.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js.map","path":"js/build/plugins/aplayer.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js","path":"js/build/plugins/hbe.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js.map","path":"js/build/plugins/hbe.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js.map","path":"js/build/plugins/masonry.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js","path":"js/build/plugins/mermaid.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js.map","path":"js/build/plugins/mermaid.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js","path":"js/build/plugins/pangu.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js.map","path":"js/build/plugins/pangu.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js","path":"js/build/plugins/tabs.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js.map","path":"js/build/plugins/tabs.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js","path":"js/build/plugins/typed.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js.map","path":"js/build/plugins/typed.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js","path":"js/build/tools/codeBlock.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js.map","path":"js/build/tools/codeBlock.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js","path":"js/build/tools/imageViewer.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js.map","path":"js/build/tools/imageViewer.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js","path":"js/build/tools/lightDarkSwitch.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js","path":"js/build/plugins/masonry.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js","path":"js/build/tools/localSearch.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js.map","path":"js/build/tools/localSearch.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js.map","path":"js/build/tools/lightDarkSwitch.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js","path":"js/build/tools/runtime.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js.map","path":"js/build/tools/runtime.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js","path":"js/build/tools/scrollTopBottom.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js.map","path":"js/build/tools/scrollTopBottom.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js","path":"js/build/tools/tocToggle.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js.map","path":"js/build/tools/tocToggle.js.map","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/APlayer.min.js","path":"js/build/libs/APlayer.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Swup.min.js","path":"js/build/libs/Swup.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupPreloadPlugin.min.js","path":"js/build/libs/SwupPreloadPlugin.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupProgressPlugin.min.js","path":"js/build/libs/SwupProgressPlugin.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScriptsPlugin.min.js","path":"js/build/libs/SwupScriptsPlugin.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScrollPlugin.min.js","path":"js/build/libs/SwupScrollPlugin.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupSlideTheme.min.js","path":"js/build/libs/SwupSlideTheme.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Typed.min.js","path":"js/build/libs/Typed.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/anime.min.js","path":"js/build/libs/anime.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/mermaid.min.js","path":"js/build/libs/mermaid.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/minimasonry.min.js","path":"js/build/libs/minimasonry.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment-with-locales.min.js","path":"js/build/libs/moment-with-locales.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment.min.js","path":"js/build/libs/moment.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/odometer.min.js","path":"js/build/libs/odometer.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pangu.min.js","path":"js/build/libs/pangu.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pjax.min.js","path":"js/build/libs/pjax.min.js","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/default.styl","path":"css/common/codeblock/hljs-themes/light/default.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/atom-one-light.styl","path":"css/common/codeblock/hljs-themes/light/atom-one-light.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/github.styl","path":"css/common/codeblock/hljs-themes/light/github.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/a11y-dark.styl","path":"css/common/codeblock/hljs-themes/dark/a11y-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/agate.styl","path":"css/common/codeblock/hljs-themes/dark/agate.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","path":"css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/github-dark.styl","path":"css/common/codeblock/hljs-themes/dark/github-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","path":"css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/night-owl.styl","path":"css/common/codeblock/hljs-themes/dark/night-owl.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/nord.styl","path":"css/common/codeblock/hljs-themes/dark/nord.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","path":"css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","modified":1,"renderable":1},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/vs2015.styl","path":"css/common/codeblock/hljs-themes/dark/vs2015.styl","modified":1,"renderable":1},{"_id":"source/fonts/LXGWWenKaiGBScreen.ttf","path":"fonts/LXGWWenKaiGBScreen.ttf","modified":1,"renderable":0},{"_id":"source/fonts/MapleMono-Bold.ttf","path":"fonts/MapleMono-Bold.ttf","modified":1,"renderable":0},{"_id":"source/fonts/MapleMono-Italic.ttf","path":"fonts/MapleMono-Italic.ttf","modified":1,"renderable":0},{"_id":"source/fonts/MapleMono-Regular.ttf","path":"fonts/MapleMono-Regular.ttf","modified":1,"renderable":0},{"_id":"source/img/2025-01-16-23-58-21.png","path":"img/2025-01-16-23-58-21.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-17-14-00-36.png","path":"img/2025-01-17-14-00-36.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-11-41-54.png","path":"img/2025-01-18-11-41-54.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-11-45-41.png","path":"img/2025-01-18-11-45-41.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-12-58-38.png","path":"img/2025-01-18-12-58-38.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-13-01-29.png","path":"img/2025-01-18-13-01-29.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-13-03-21.png","path":"img/2025-01-18-13-03-21.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-13-09-11.png","path":"img/2025-01-18-13-09-11.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-13-23-22.png","path":"img/2025-01-18-13-23-22.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-13-15-38.png","path":"img/2025-01-18-13-15-38.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-17-11-36.png","path":"img/2025-01-18-17-11-36.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-17-06-50.png","path":"img/2025-01-18-17-06-50.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-17-14-29.png","path":"img/2025-01-18-17-14-29.png","modified":1,"renderable":0},{"_id":"source/img/Aniya.png","path":"img/Aniya.png","modified":1,"renderable":0},{"_id":"source/img/2025-01-18-17-13-45.png","path":"img/2025-01-18-17-13-45.png","modified":1,"renderable":0},{"_id":"source/img/Aniya_放大镜.jpg","path":"img/Aniya_放大镜.jpg","modified":1,"renderable":0},{"_id":"source/img/avatar.svg","path":"img/avatar.svg","modified":1,"renderable":0},{"_id":"source/img/JS.png","path":"img/JS.png","modified":1,"renderable":0},{"_id":"source/img/bgImg.png","path":"img/bgImg.png","modified":1,"renderable":0},{"_id":"source/img/crypt_index.png","path":"img/crypt_index.png","modified":1,"renderable":0},{"_id":"source/img/db_index.png","path":"img/db_index.png","modified":1,"renderable":0},{"_id":"source/img/edit.gif","path":"img/edit.gif","modified":1,"renderable":0},{"_id":"source/img/find-2025-01-22-11-58-20.png","path":"img/find-2025-01-22-11-58-20.png","modified":1,"renderable":0},{"_id":"source/img/great.jpg","path":"img/great.jpg","modified":1,"renderable":0},{"_id":"source/img/me.jpg","path":"img/me.jpg","modified":1,"renderable":0},{"_id":"source/img/re0-2025-01-18-17-16-53.png","path":"img/re0-2025-01-18-17-16-53.png","modified":1,"renderable":0},{"_id":"source/img/legend-2025-01-21-21-19-51.png","path":"img/legend-2025-01-21-21-19-51.png","modified":1,"renderable":0},{"_id":"source/img/不死鸟.jpg","path":"img/不死鸟.jpg","modified":1,"renderable":0},{"_id":"source/img/sun.png","path":"img/sun.png","modified":1,"renderable":0},{"_id":"source/img/re0-2025-01-18-17-40-27.png","path":"img/re0-2025-01-18-17-40-27.png","modified":1,"renderable":0},{"_id":"source/img/倦鸟.png","path":"img/倦鸟.png","modified":1,"renderable":0},{"_id":"source/img/哭哭帕克.jpg","path":"img/哭哭帕克.jpg","modified":1,"renderable":0},{"_id":"source/img/料理的加护.jpg","path":"img/料理的加护.jpg","modified":1,"renderable":0},{"_id":"source/img/晚霞.jpg","path":"img/晚霞.jpg","modified":1,"renderable":0},{"_id":"source/img/校长帕克.jpg","path":"img/校长帕克.jpg","modified":1,"renderable":0},{"_id":"source/img/照镜子.jpg","path":"img/照镜子.jpg","modified":1,"renderable":0},{"_id":"source/img/猫猫-2025-01-20-22-47-27.png","path":"img/猫猫-2025-01-20-22-47-27.png","modified":1,"renderable":0},{"_id":"source/img/社会心理学.png","path":"img/社会心理学.png","modified":1,"renderable":0},{"_id":"source/img/跨域共享.jpg","path":"img/跨域共享.jpg","modified":1,"renderable":0},{"_id":"source/img/闪光拉姆.jpg","path":"img/闪光拉姆.jpg","modified":1,"renderable":0},{"_id":"source/img/闪耀pack.jpg","path":"img/闪耀pack.jpg","modified":1,"renderable":0},{"_id":"source/img/雪国.jpg","path":"img/雪国.jpg","modified":1,"renderable":0},{"_id":"source/img/雷姆拉姆.jpg","path":"img/雷姆拉姆.jpg","modified":1,"renderable":0}],"Cache":[{"_id":"source/_data/masonry.yml","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746704043936},{"_id":"source/_data/links.yml","hash":"eba0611e49e7f6a09e7cb5c635e82ac0aa5cc0f9","modified":1746715600948},{"_id":"source/_data/essays.yml","hash":"c2c6df4d722695c75adcd63e5652fbc7bef718dc","modified":1746704432834},{"_id":"source/_posts/Prisma.md","hash":"4af49f855ac7ca496ee6d8da4c8a8f8b44288359","modified":1746718312460},{"_id":"source/_posts/chatSQL.md","hash":"1191ead768ebd7de8eb830ba8f0599e18f73c658","modified":1746754857095},{"_id":"source/_posts/swift.md","hash":"c964deb076b65d94788cfd2bbb08e8218ab2116c","modified":1746755202574},{"_id":"source/essays/index.md","hash":"db23a67bfd3dfc5524230a22d0fa988f83514689","modified":1746704413542},{"_id":"source/categories/index.md","hash":"a998b1dba9d37accf8857d4d8a2a0f6c84ae7539","modified":1746703540266},{"_id":"source/links/index.md","hash":"101a187a10829bd1749e7c9ec7e319ee0bd36069","modified":1746755887263},{"_id":"source/fonts/custom-fonts.css","hash":"2e88c887c16da758b125b59b66bcc455224e3807","modified":1746706651872},{"_id":"source/img/2025-01-17-14-00-36.png","hash":"eacdd40a31bb3f4ccec48b38aa01d9e4f4a000d5","modified":1746705359374},{"_id":"source/img/JS.png","hash":"a115cbbec848dea5824181ef22411d8efc6dbfa8","modified":1746705359588},{"_id":"source/img/find-2025-01-22-11-58-20.png","hash":"a889d1dd151686eb085de78836a2cc7e59a43606","modified":1746705359579},{"_id":"source/img/legend-2025-01-21-21-19-51.png","hash":"c56fc82db2388050164829230deac64751c69ea6","modified":1746705359591},{"_id":"source/img/猫猫-2025-01-20-22-47-27.png","hash":"91d8cfe3cb9673a851c50fc6351c91b9cb54bb60","modified":1746705359520},{"_id":"source/tags/index.md","hash":"bb4b605d71337fd94494837d3307db70172dcdfd","modified":1746703334852},{"_id":"source/masonry/index.md","hash":"3cdbc0f704cc49d6e670b9ee7f4db2d98b3be49e","modified":1746703607234},{"_id":"source/_posts/poets/晚霞.md","hash":"5f3b1e345616c7672be3c49f1cfbcce515fc7acc","modified":1746755073079},{"_id":"source/_posts/poets/bird.md","hash":"ad59a01ed0efc77b76e1ea58797755c9e7365b7c","modified":1746755027786},{"_id":"source/_posts/前后端/响应式设计.md","hash":"4fbedebc6df907a8482eed1e6140edf24109a13b","modified":1746705742523},{"_id":"source/_posts/前后端/CORS.md","hash":"c9b26c4ef559cd7c93fee12afca523e7c6275c33","modified":1746705742522},{"_id":"source/_posts/编程语言/css笔记.md","hash":"a7f92a6fd6680a4bd6ba5259b6bffb5e0f785869","modified":1746705099655},{"_id":"source/_posts/前后端/跨组件渲染.md","hash":"fdecea595ecec5bc0fb4211d2b9677fc5bef1748","modified":1746754718254},{"_id":"source/_posts/编程语言/JavaScript.md","hash":"c49c5e026ca5ca87067329d8074f72830ffd7804","modified":1746705286819},{"_id":"source/img/2025-01-18-12-58-38.png","hash":"cf5073b3f0fcc5f8e8b013927dc633cdb0eb478b","modified":1746705359406},{"_id":"source/img/2025-01-18-13-01-29.png","hash":"6dbe8216f8848a8f202de965f4313dbb2eecdd58","modified":1746705359411},{"_id":"source/img/2025-01-18-11-41-54.png","hash":"1d85d673eebe40136f7058b03e7d4aa3d2760b14","modified":1746705359378},{"_id":"source/img/2025-01-16-23-58-21.png","hash":"3707c7284cdeaada1b82a50889d6bc5b66cfab69","modified":1746705359361},{"_id":"source/img/great.jpg","hash":"ad40b86f9b500d362074fe888853c2536ba6e834","modified":1746705359585},{"_id":"source/fonts/MapleMono-Regular.ttf","hash":"8ef0566873ae81ef2dd9ed3fecf13240673fc414","modified":1746706242747},{"_id":"source/fonts/MapleMono-Bold.ttf","hash":"ec54b625650294240d3255287a5cd07afd5bde09","modified":1746706242732},{"_id":"source/img/2025-01-18-13-03-21.png","hash":"25abaf57c0e17909b165180aaf9d390fe09d6c5a","modified":1746705359427},{"_id":"source/img/2025-01-18-13-09-11.png","hash":"47c213fc9292190467b8b6f0e19b9408dbe6824f","modified":1746705359433},{"_id":"source/img/Aniya_放大镜.jpg","hash":"538ff8e7ac38f341c0166820d43617d73675cc86","modified":1746705359546},{"_id":"source/img/不死鸟.jpg","hash":"0baad7c3a94594079f49165c91f061d0689c1035","modified":1746705359479},{"_id":"source/img/晚霞.jpg","hash":"c89abcb798ddb518b6e8ce08e8afd144b00e8a54","modified":1746705359530},{"_id":"source/_posts/编程语言/cpp学习记录.md","hash":"1fe0d63885ef1e15bdbb76125d06348b9ade6669","modified":1746755308191},{"_id":"source/fonts/MapleMono-Italic.ttf","hash":"e6c100ea19c7a8cb4b005a2c61d22e971943a014","modified":1746706242739},{"_id":"source/img/2025-01-18-11-45-41.png","hash":"f9cf4255cce7bad9cfbe29c5264b022933a64c30","modified":1746705359395},{"_id":"source/img/2025-01-18-17-13-45.png","hash":"b4d0e8077ffe69dfd61db955e869126b24c76ce0","modified":1746705359471},{"_id":"source/img/me.jpg","hash":"bdfdab38c41980cff966c08ea26ca8699948cbd6","modified":1746705359594},{"_id":"source/img/料理的加护.jpg","hash":"6364a3389f2ac52ad1ec33c254ebde8740b257cc","modified":1746705359514},{"_id":"source/img/闪光拉姆.jpg","hash":"8e818cc9cee33324fb15a8d52fc69b1262cf87e2","modified":1746705359522},{"_id":"source/img/avatar.svg","hash":"fca0089e299662e3ac16c9e1a594bcbff42db6d6","modified":1746711858937},{"_id":"source/img/哭哭帕克.jpg","hash":"e20aa94b2a43c0194fb3d3a5d0762b6404458003","modified":1746705359497},{"_id":"source/img/雪国.jpg","hash":"e1cc8027328cbc55de92496f1e7c90d3812923b7","modified":1746705359541},{"_id":"source/img/闪耀pack.jpg","hash":"470edf49958168295976933a0135d5517954cdba","modified":1746705359524},{"_id":"source/img/2025-01-18-17-14-29.png","hash":"871f5a88a9d126706973463911056770ae7090e8","modified":1746705359475},{"_id":"source/img/re0-2025-01-18-17-16-53.png","hash":"871f5a88a9d126706973463911056770ae7090e8","modified":1746705359597},{"_id":"source/img/re0-2025-01-18-17-40-27.png","hash":"0f759367f3fa09abcf03a7e92ec340f38e133142","modified":1746705359604},{"_id":"source/img/跨域共享.jpg","hash":"438d4dda0d2271203947bb461416275504601355","modified":1746705359508},{"_id":"source/img/雷姆拉姆.jpg","hash":"a3360d4afcc99266225d67003a06a133a2a8ecc7","modified":1746705359510},{"_id":"source/img/2025-01-18-13-23-22.png","hash":"0c9345d1f0c9af7bc07f7bbf7a15153d4b16aea7","modified":1746705359452},{"_id":"source/img/2025-01-18-13-15-38.png","hash":"a5774370c2e3ac61a14b5847c2c77ea69afecbfe","modified":1746705359441},{"_id":"source/img/2025-01-18-17-11-36.png","hash":"404b6f149798b76095753ac52d034516b37c1555","modified":1746705359462},{"_id":"source/img/照镜子.jpg","hash":"204a3b9a70ad3381fc5c2b78d3fc9afdecc2d995","modified":1746705359544},{"_id":"source/img/校长帕克.jpg","hash":"dbc8efb5b99bf953032dac803a4ea7ac1166974e","modified":1746705359536},{"_id":"node_modules/hexo-theme-redefine/CONTRIBUTING.md","hash":"c6ef834f602b7ae02e2863a2a857e0ce8d392f15","modified":1746717051482},{"_id":"node_modules/hexo-theme-redefine/CODE_OF_CONDUCT.md","hash":"61a6276ef54989b7a1325f3ecb3183a4dfdf50cb","modified":1746717051482},{"_id":"node_modules/hexo-theme-redefine/DONATION.md","hash":"08e105bad07d733efb98543a034f930c569f5c2f","modified":1746717051482},{"_id":"node_modules/hexo-theme-redefine/.coderabbit.yaml","hash":"ba28a5250f22db9a8eb9cd1ee282285eddd848a8","modified":1746717051588},{"_id":"node_modules/hexo-theme-redefine/README_zh-CN.md","hash":"7f7ced9ebf32ab9561ce5bd54445c9622dda6fb1","modified":1746717051482},{"_id":"node_modules/hexo-theme-redefine/LICENSE","hash":"1de7bacb4fbbd7b6d391a69abfe174c2509ec303","modified":1746717049946},{"_id":"node_modules/hexo-theme-redefine/package.json","hash":"1b4d36f90309f4e28b4266ef76f76202d7f38b10","modified":1746717051249},{"_id":"node_modules/hexo-theme-redefine/README_zh-TW.md","hash":"07acc04ccf38f40b5f6be18529c283ab11bec9c3","modified":1746717051483},{"_id":"node_modules/hexo-theme-redefine/README.md","hash":"44578ceb782516967dc0de15fbbc1a78c0986aed","modified":1746717051483},{"_id":"node_modules/hexo-theme-redefine/_config.yml","hash":"c2721e3cd69d2308a5e46a84394ebbff6a21555e","modified":1746717051588},{"_id":"node_modules/hexo-theme-redefine/languages/en.yml","hash":"4cc09fff6895fd864044d7c11f8638ab92d98453","modified":1746717051590},{"_id":"node_modules/hexo-theme-redefine/vercel.json","hash":"357c1fd2678f8ae4a9a852a1a6888c8eca774551","modified":1746717051250},{"_id":"node_modules/hexo-theme-redefine/tailwind.config.js","hash":"63797b8595e3a59c1cdaad7c9268a292fc9c558c","modified":1746717051237},{"_id":"node_modules/hexo-theme-redefine/scripts/config-export.js","hash":"b10185069cd3f3fd7873982e259e402d5f146a58","modified":1746717050988},{"_id":"node_modules/hexo-theme-redefine/scripts/data-handle.js","hash":"c72188b7dd0596d618ecbd3deb1b49ef257014df","modified":1746717050989},{"_id":"node_modules/hexo-theme-redefine/languages/fr.yml","hash":"a249af0bd206f10ce78b186b8f0ef6c483ddfcad","modified":1746717051590},{"_id":"node_modules/hexo-theme-redefine/languages/ja.yml","hash":"6da103d89685ddf6da4c367efd699c6fc1a15f84","modified":1746717051590},{"_id":"node_modules/hexo-theme-redefine/languages/zh-TW.yml","hash":"218fcc4db1d2211bd9839895d7ad6b70a5d50897","modified":1746717051591},{"_id":"node_modules/hexo-theme-redefine/languages/zh-CN.yml","hash":"67d93982759d79f38afadeef871c80b08c21c7ca","modified":1746717051591},{"_id":"node_modules/hexo-theme-redefine/layout/404.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1746717050665},{"_id":"node_modules/hexo-theme-redefine/layout/category.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1746717050714},{"_id":"node_modules/hexo-theme-redefine/layout/archive.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1746717050669},{"_id":"node_modules/hexo-theme-redefine/.husky/pre-commit","hash":"843996b47615c2f8c1037db9183de3006166ac1d","modified":1746717049993},{"_id":"node_modules/hexo-theme-redefine/layout/post.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1746717050781},{"_id":"node_modules/hexo-theme-redefine/layout/page.ejs","hash":"3dc83dae73b48b3e6ae65bdaf6106ec711c88ecd","modified":1746717050777},{"_id":"node_modules/hexo-theme-redefine/layout/index.ejs","hash":"f5fee4e079a9c2c23059ebde4cd89ec723e310c6","modified":1746717050754},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-english.yml","hash":"bf91936a78a2e444dbaf916755f502cc0abe7be3","modified":1746717051589},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/bug-chinese.yml","hash":"73df1f0aabb527a9e3c131d0f0eda0db8b7a1f3b","modified":1746717051589},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/enhancement-english.yml","hash":"d072e75c10673fb70be74f89dff8b1bae6df0c8f","modified":1746717051590},{"_id":"node_modules/hexo-theme-redefine/.github/ISSUE_TEMPLATE/enhancement-chinese.yml","hash":"1ea9f2b52f53e5d1525bb22709bcf37da5a6da01","modified":1746717051590},{"_id":"node_modules/hexo-theme-redefine/layout/tag.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1746717050798},{"_id":"node_modules/hexo-theme-redefine/layout/tags.ejs","hash":"8456f112fc12bbb1c83cd190d0ce83ee474bd297","modified":1746717050799},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/npm-publish.yml","hash":"3379098cb32de9ee4f6e69eb91505a4d3a2f37e6","modified":1746717051590},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/production-deployment.yml","hash":"d411d426c6df79ac7e487401f0f11206c245d1c1","modified":1746717051591},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/build-and-commit.yml","hash":"6cb6834cd753e38dadb25c6492347ddd247935ea","modified":1746717051589},{"_id":"node_modules/hexo-theme-redefine/scripts/events/404.js","hash":"169245d7b2af1ff401cf76e718c28b4e38f637c7","modified":1746717050939},{"_id":"node_modules/hexo-theme-redefine/scripts/events/welcome.js","hash":"7b1e16ef62edfc63ab06b390867aad0ede9589fb","modified":1746717051247},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/preview-deployment.yml","hash":"7fa8860dd2ba4ffc11fbfa1a7d57140af2a0abf0","modified":1746717051591},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/delete-mask-handle.js","hash":"088e205976a09c8ee7afec6445847ed4b3aef71f","modified":1746717050991},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/encrypt.js","hash":"bf6b90842991a25af590af76f10d7164ea34abcb","modified":1746717050991},{"_id":"node_modules/hexo-theme-redefine/layout/layout.ejs","hash":"ecf818cd11e363c1a33e7105ac415d8c192c1f73","modified":1746717050756},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/table-handle.js","hash":"c500c45cd9221788df1f31939c5399eabb62ebb5","modified":1746717051235},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/btn.js","hash":"aa7a34ff5fb0a624163c38fffe0746cef44d2ea3","modified":1746717050979},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/aliyun-cdn-publish.yml","hash":"18975c5422509b0fb7c3b6ddd788eac65802781a","modified":1746717051588},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lazyload-handle.js","hash":"f8ae44311e6463e887c07a41910ebade8766bac2","modified":1746717051002},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/img-handle.js","hash":"b396fe7b6cbc331f2952aa7561f96c1f250d8c52","modified":1746717051002},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/stylus-handle.js","hash":"8a8bf069ce096bd7b42952c8e50c3c89758cbc13","modified":1746717051219},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/folding.js","hash":"cfa6646c1350c557430149bd52578c6cac59063b","modified":1746717050993},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/btns.js","hash":"a91492e772287114527a3fbc85f0c7c1c1b15eb3","modified":1746717050979},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/note-large.js","hash":"ed719ca36bcbfbfd86d4ade5825e8adbbecf29fe","modified":1746717051212},{"_id":"node_modules/hexo-theme-redefine/.github/workflows/stale-issues.yml","hash":"4ae03f0bd4aaf5ccaa08205af07218d406e921da","modified":1746717051591},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/meta-helpers.js","hash":"5484677eb8064880019642f139e4a29f21cab495","modified":1746717051182},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/tabs.js","hash":"74e3b0cdd009206f7b78b04dcb96eccd86e7a996","modified":1746717051235},{"_id":"node_modules/hexo-theme-redefine/scripts/modules/note.js","hash":"d3a0c043246adc0082387c9e39908c18e953d858","modified":1746717051212},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/theme-helpers.js","hash":"0674a7bb30878f7eb6e5711e5ac05542d863082b","modified":1746717051240},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/link-handle.js","hash":"d168d78034c5fa5a75978f47185b50fd79ba54cf","modified":1746717051005},{"_id":"node_modules/hexo-theme-redefine/layout/components/scripts.ejs","hash":"373cbbf8fe0a39fc3de14579e0b3ae20cb429998","modified":1746717050789},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/page-helpers.js","hash":"beaeb760eaa92bb63272d21d0d99ab64b78980e8","modified":1746717051213},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/waline-helpers.js","hash":"9f2c3d6c4c7cf6212d28be0729816cd66921bd67","modified":1746717051247},{"_id":"node_modules/hexo-theme-redefine/scripts/helpers/recommendation-helpers.js","hash":"b9ede93bfd16af13871625d2d127bf79d99724d1","modified":1746717051217},{"_id":"node_modules/hexo-theme-redefine/layout/pages/page-template.ejs","hash":"75a41b963a4ed3fcae846163bc674d8d185a27a9","modified":1746717050775},{"_id":"node_modules/hexo-theme-redefine/layout/utils/side-tools.ejs","hash":"c915643e05f1038549e353a371d72f5bb38c2040","modified":1746717050791},{"_id":"node_modules/hexo-theme-redefine/layout/utils/posts-list.ejs","hash":"80dd9ff9b135b582c32c5506d237db71fa742be5","modified":1746717050782},{"_id":"node_modules/hexo-theme-redefine/layout/utils/local-search.ejs","hash":"06ad51a60648100fcf8a750c471a48bd1c9b31b8","modified":1746717050757},{"_id":"node_modules/hexo-theme-redefine/layout/components/swup.ejs","hash":"ac0263cdb945ad99876a246db43801213b45b309","modified":1746717050794},{"_id":"node_modules/hexo-theme-redefine/layout/utils/paginator.ejs","hash":"cb0a8fca60575195f65510c1a52a7145c819de14","modified":1746717050777},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/brands.min.css","hash":"5119c35bbd273d2ea2501997827f6d644da93164","modified":1746717050383},{"_id":"node_modules/hexo-theme-redefine/layout/utils/image-viewer.ejs","hash":"2f31d56e7ed88dadeacffa5af69931461f4fb4f9","modified":1746717050753},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/sharp-solid.min.css","hash":"7d1a13c6b8178b29f5bcb1a639a1998fc9de16c4","modified":1746717050593},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/light.min.css","hash":"18a176eb2486db4e938e568083fa578b641ccc83","modified":1746717050589},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/regular.min.css","hash":"d27c4fed54dacff688010e51f611d950dd6e0aca","modified":1746717050591},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/solid.min.css","hash":"e727feabedb171fb0b398151870d7739ef4e2432","modified":1746717050594},{"_id":"node_modules/hexo-theme-redefine/source/images/bookmark-placeholder.svg","hash":"255a1236bab60d2871da31e4f0db947b44931df6","modified":1746717051504},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/svg-with-js.min.css","hash":"f4c08e37c4d44b3ed7a3f377d1cb5d7fca4d04bc","modified":1746717050600},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/thin.min.css","hash":"3d46be31379b07ffb24d69c6c915725eaa2e89e9","modified":1746717050636},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-avatar.svg","hash":"d0d20061bda08894a82d7691b660be7c6aaa0608","modified":1746717051504},{"_id":"node_modules/hexo-theme-redefine/source/images/loading.svg","hash":"938c2a41c8ba18e37ed659e481696e40a4c8f3a4","modified":1746717051504},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-favicon.svg","hash":"420f930a1df64a3c4391ff80326a8a2d7d5a6418","modified":1746717051504},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v5-font-face.min.css","hash":"260ea7a5e0b89963a5dcf2600a4decdf0f408f3f","modified":1746717050663},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-shims.min.css","hash":"96f037860b8e9b59af8e47571ea98791616dbfd8","modified":1746717050657},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.svg","hash":"472776b6f013aad44706fee6c94201c96ee83932","modified":1746717051504},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-logo.webp","hash":"0a07e3fb6d9125dee44798c8c110187b16fb42a9","modified":1746717051563},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-light.webp","hash":"d25389973d0359b78f1e9c74a850ef425690ba40","modified":1746717051564},{"_id":"node_modules/hexo-theme-redefine/source/assets/odometer-theme-minimal.css","hash":"793c31feb38e241a5ff6ecc5e65e61751507d728","modified":1746717050590},{"_id":"node_modules/hexo-theme-redefine/source/assets/hbe.style.css","hash":"29be8fc47be885e9954e310cbc68dfadd3b4cee6","modified":1746717050585},{"_id":"node_modules/hexo-theme-redefine/source/images/wallhaven-wqery6-dark.webp","hash":"d0066e0b025ae748448a3d6a96165d45a55d2f22","modified":1746717051564},{"_id":"node_modules/hexo-theme-redefine/source/css/style.styl","hash":"0d78bda29a5b0446074ed724f4f9fe772d4b15cc","modified":1746717051501},{"_id":"node_modules/hexo-theme-redefine/source/images/redefine-og.webp","hash":"44fb793383da185808ed682d7dd916e10eb65b4d","modified":1746717051564},{"_id":"node_modules/hexo-theme-redefine/source/js/main.js","hash":"cee5f0dcb5b1f0f7f952e24d31cce2bd785b29cc","modified":1746717051009},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/v4-font-face.min.css","hash":"0be987628c8b485b39f064da41c90f15c0596c1f","modified":1746717050651},{"_id":"node_modules/hexo-theme-redefine/source/js/build.js","hash":"61eb4760cefeffa79550f3f7387e701d554a0709","modified":1746717050982},{"_id":"node_modules/hexo-theme-redefine/source/css/tailwind.source.css","hash":"1dc3152fe841290f3bd56074f726df975ab91b6e","modified":1746717050636},{"_id":"node_modules/hexo-theme-redefine/source/js/utils.js","hash":"5efa4c652a1e7f4852fb8df9bf60de170b4b41db","modified":1746717051246},{"_id":"node_modules/hexo-theme-redefine/scripts/filters/lib/hbe.default.js","hash":"fee2c92011ef007121b992193bbab0f3b196d873","modified":1746717050995},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.woff2","hash":"d02b1adc81fd5bec023e25a7770779b99d6dd742","modified":1746717051587},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/waline.ejs","hash":"35239e49743c6b7f40014bd753bff9c415b5fcbb","modified":1746717050800},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-v4compatibility.ttf","hash":"b54531dd09c5089eb93b12ce8f90ff521855ff8a","modified":1746717051561},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/comment.ejs","hash":"98c2db06626a82f24886cd8b77118014ef8aa6e2","modified":1746717050718},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/giscus.ejs","hash":"afa08ddc80ae3f1c57d9b85d2625f11751801540","modified":1746717050734},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/twikoo.ejs","hash":"49d230c1a732e0f3504a57dfd169738156ed22ba","modified":1746717050800},{"_id":"node_modules/hexo-theme-redefine/layout/components/comments/gitalk.ejs","hash":"f94607c4bb12f5c2325e674e25a428dae742e99e","modified":1746717050735},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/head.ejs","hash":"1287e5913f72f6624ff375dc51c939823c55d4da","modified":1746717050739},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/navbar.ejs","hash":"e520f72c4d5116bd0f4c65f3efe617e0a494e2fb","modified":1746717050766},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/preloader.ejs","hash":"a450ba1381dd43d348a3f538bb17ffbd1d332cad","modified":1746717050784},{"_id":"node_modules/hexo-theme-redefine/layout/components/header/progress-bar.ejs","hash":"e552f0f5e6ab6398ab42eef1788f7c0dcb8f4c18","modified":1746717050785},{"_id":"node_modules/hexo-theme-redefine/layout/components/plugins/aplayer.ejs","hash":"2d34a3583ac0b2b08b6ae035e8d3f97c51db070c","modified":1746717050668},{"_id":"node_modules/hexo-theme-redefine/layout/pages/friends/friends-link.ejs","hash":"c4a8555880ab546a9bc829386c4fc2b43cdcece2","modified":1746717050733},{"_id":"node_modules/hexo-theme-redefine/layout/pages/masonry/masonry.ejs","hash":"c45f6faf5ccd4db3bd5533eacb6333744a480e27","modified":1746717050764},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-article.ejs","hash":"b54a0df26341fa5f26a6e1eedb91cd11014d50c5","modified":1746717050746},{"_id":"node_modules/hexo-theme-redefine/layout/components/footer/footer.ejs","hash":"acb56ecba5c231f5c8c6701de6d54e3d654948a2","modified":1746717050727},{"_id":"node_modules/hexo-theme-redefine/layout/pages/bookmarks/bookmarks.ejs","hash":"38ab41cfe2d31ee145af229b3b65ac8743821e0d","modified":1746717050707},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-background.ejs","hash":"dd120259ab091b8087d0194ea2291676556efad8","modified":1746717050746},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-content.ejs","hash":"6985ec3528866f90ce882564556c30c151050061","modified":1746717050751},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-banner.ejs","hash":"0e0a29a652e5063d89bee3037c3410865f6852a7","modified":1746717050748},{"_id":"node_modules/hexo-theme-redefine/layout/pages/archive/archive.ejs","hash":"11fb21fe971157a1a6053ecbd6de9ffbe8ba88a8","modified":1746717050674},{"_id":"node_modules/hexo-theme-redefine/layout/pages/notfound/notfound.ejs","hash":"5e90d8519d19a31234de10a33983b8d70aed94a2","modified":1746717050771},{"_id":"node_modules/hexo-theme-redefine/layout/pages/home/home-sidebar.ejs","hash":"8df645c6e1878187909d749639ecce6edc0ee72c","modified":1746717050751},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-copyright.ejs","hash":"8e97d76ded33d1e334c376451e2f3d5fd177a958","modified":1746717050683},{"_id":"node_modules/hexo-theme-redefine/layout/pages/category/category-detail.ejs","hash":"ee99263b6761e9865b06d427597435e69b40dda9","modified":1746717050713},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-content.ejs","hash":"8b0b987406057f2eb2ade99f6d68ef5577e14a79","modified":1746717050681},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/post-tools.ejs","hash":"5336e36394250d2f25d26432262061c752b1868a","modified":1746717050779},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/author.ejs","hash":"422aed0f3f67529c1ea87ee43f8f680ffc531b45","modified":1746717050699},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/toc.ejs","hash":"c3bd7f4632ded1b59a2479028070fa2b292d8c5e","modified":1746717050800},{"_id":"node_modules/hexo-theme-redefine/layout/pages/post/article-info.ejs","hash":"f42db25cc0f4e3bbce5b8602365025dd37d643d0","modified":1746717050692},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/statistics.ejs","hash":"4329363d232de541e1cb8f24eb59c1a8bacc9b9c","modified":1746717050793},{"_id":"node_modules/hexo-theme-redefine/layout/components/sidebar/avatar.ejs","hash":"47cd8318471493c82f5e5983550145d4fd0a2ddc","modified":1746717050700},{"_id":"node_modules/hexo-theme-redefine/layout/pages/tag/tags.ejs","hash":"ff59878833eb2a72fda7c78690a36a9c0c522c76","modified":1746717050798},{"_id":"node_modules/hexo-theme-redefine/layout/pages/tag/tag-detail.ejs","hash":"8864356337a301a123e85fb3aec6f3d9b1f2197c","modified":1746717050796},{"_id":"node_modules/hexo-theme-redefine/layout/pages/shuoshuo/essays.ejs","hash":"7d9e7de29e1dab92c333affd5c592e2ee2e92293","modified":1746717050724},{"_id":"node_modules/hexo-theme-redefine/layout/pages/category/categories.ejs","hash":"fe6e11590c28cc8462a04580868aa6b8b472a9d1","modified":1746717050712},{"_id":"node_modules/hexo-theme-redefine/source/css/common/markdown.styl","hash":"b356d00c6c6557cf7708a02080b163dc0b667184","modified":1746717051498},{"_id":"node_modules/hexo-theme-redefine/source/css/common/animated.styl","hash":"1d5a026f3a023031772fdca7d7359bbe7a28548a","modified":1746717051489},{"_id":"node_modules/hexo-theme-redefine/source/css/common/colors.styl","hash":"e4a5336757de7b04c01d8c2a2b4bb1de885c6ae0","modified":1746717051494},{"_id":"node_modules/hexo-theme-redefine/source/css/common/basic.styl","hash":"81bab41a756832a86a6c06df1ea298e4849435f9","modified":1746717051493},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/animations.styl","hash":"2c48fec80bd56164bff297727d06ab5c343b3b41","modified":1746717051490},{"_id":"node_modules/hexo-theme-redefine/source/css/common/redefine-theme.styl","hash":"068b95881387ee2b70ba94a6489ee21171f26bf3","modified":1746717051500},{"_id":"node_modules/hexo-theme-redefine/source/css/common/variables.styl","hash":"961f936e6d08372bdc1e9379e7d1288410e4a319","modified":1746717051502},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/article-content.styl","hash":"94771695782abe5e723918a1319a953fbd2031e0","modified":1746717051491},{"_id":"node_modules/hexo-theme-redefine/source/css/common/theme.styl","hash":"0c5eedb57874c91babdb603b1daef35d70a7c150","modified":1746717051501},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/bookmarks.styl","hash":"a89f96f73d9f1d51e455b53bbcf13d003d672d33","modified":1746717051493},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/archive-content.styl","hash":"4e329547447c716c986e0b4a4f54afc59fc6b486","modified":1746717051491},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-content.styl","hash":"1221a4e0fa2ab5c49e886e0a5bb6dc1d23d969e8","modified":1746717051493},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/tag-content.styl","hash":"3d08edcfbd866627f5681c368d5c61270ba2f682","modified":1746717051501},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-content.styl","hash":"65a5184a667966f5c5387662de77da512faa4e0e","modified":1746717051497},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/category-list.styl","hash":"aaccab4fb21e25086323e7e418e7fea945f551be","modified":1746717051493},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/page.styl","hash":"ffc2622357f1556a95fc8f138b7e8ac27b0bba2c","modified":1746717051500},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff","hash":"fc0e791429c274c4c9312d810e7ae9503cab34ab","modified":1746717051565},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/chillax.css","hash":"210179f53c6bce91a12ca6db9129184cc1549c36","modified":1746717050409},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.woff2","hash":"fc5d99b40db9deca7d151f9bd16b96ff160828b7","modified":1746717051567},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/home-sidebar.styl","hash":"daad28f2c004f7afe335080d67e977660829d63e","modified":1746717051497},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff2","hash":"772998a8569a6caa04927d876fbe9e0fb859658b","modified":1746717051588},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/geist.css","hash":"17f37a09d6192f06b2190f8319114238b0a2ec8c","modified":1746717050576},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/geist-mono.css","hash":"b89d5af7e04df579c8ad62c0ea445ff7d16eec11","modified":1746717050565},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js.map","hash":"d9a1eed23a96de49c30ebccb52620e24204ea10e","modified":1746717051471},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/aplayer.js","hash":"f2818445cfbdbf936f136c3d0f983583c581d77e","modified":1746717050965},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff2","hash":"11e9a061ce255fc4cc45ac3eeb8cab09a49f5ccc","modified":1746717051587},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/hbe.js","hash":"f7bd9258359dc8f70c6faec3f4fe22a1852d9bf1","modified":1746717050998},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js.map","hash":"b089351e96e8f99395ac9b44aea257364a475dca","modified":1746717051262},{"_id":"node_modules/hexo-theme-redefine/source/js/build/utils.js","hash":"5a3707671ffb8544ef6e90c3713c4da785f06488","modified":1746717051246},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/pangu.js","hash":"25af6a33c9176a00f21f45cf5cfad0eb7d473841","modified":1746717051214},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/masonry.js","hash":"92734a30a21f8b16f20aa75208f6c082890275fb","modified":1746717051010},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/tabs.js","hash":"964ec5c25a8d78763ba2ba9bfbd5b1b49ed05381","modified":1746717051236},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/mermaid.js","hash":"303254d382869ed618025fcb328426bd10314583","modified":1746717051010},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/codeBlock.js","hash":"344e6c83e6ffda22f6e5bc724d603066b49a7d8b","modified":1746717050986},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/imageViewer.js","hash":"33c4e4a28cf66be0cb3f181acae082a5a5404a89","modified":1746717051001},{"_id":"node_modules/hexo-theme-redefine/source/css/build/tailwind.css","hash":"298ca1975af73e8101d77491566de03543a56a65","modified":1746717050621},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/lightDarkSwitch.js","hash":"97b7e68f871dc218fceca77b85ac051c7c6306af","modified":1746717051004},{"_id":"node_modules/hexo-theme-redefine/source/js/plugins/typed.js","hash":"f46f636a32e7569a9ff8b8b301bf860e598bd4fe","modified":1746717051243},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/localSearch.js","hash":"f6e59f65c676457198c2cf5d78bd06052499ee38","modified":1746717051005},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/categoryList.js","hash":"eb1af2cd0726f56ff7861222ea543315fe295a17","modified":1746717050982},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/scrollTopBottom.js","hash":"9e54fa4310bb98ea5ba61780a9ef56d05d475203","modified":1746717051218},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/runtime.js","hash":"eb0374b6f033f7ac25f49b1b079aa163e14b0fcd","modified":1746717051218},{"_id":"node_modules/hexo-theme-redefine/source/js/tools/tocToggle.js","hash":"c2224ff0370fcf109e94194613b9480a3913c82d","modified":1746717051242},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/essays.js","hash":"df82365c7287710dd876e452f8ef4e1d87b8c09e","modified":1746717050992},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/navbarShrink.js","hash":"3e80bf9ef719b2ddb2d1c4b67eb169d2ef52dbb8","modified":1746717051210},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/bookmarkNav.js","hash":"3155ed3e6e2aa2e32dbd9e4e06b863e63c2a9b9d","modified":1746717050977},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/toc.js","hash":"7a768982f6cb1f40552cce063d5743fe862db762","modified":1746717051241},{"_id":"node_modules/hexo-theme-redefine/source/js/layouts/lazyload.js","hash":"c06323d68bbdebbb685db5010e7655b8ed0caf42","modified":1746717051003},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1746717050969},{"_id":"node_modules/hexo-theme-redefine/source/js/build/main.js","hash":"2fcd1ce192bb34997c2e962d9c98a389573969ac","modified":1746717051008},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1746717051226},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1746717051229},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupPreloadPlugin.min.js.map","hash":"40513fec1323b601667876a97a9ef8a0c88bff63","modified":1746717051467},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1746717051225},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js.map","hash":"63cf04ba556b256379e103ef7d3ba12d629449a4","modified":1746717051468},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1746717051231},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1746717050952},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1746717051234},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1746717051244},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1746717051235},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment.min.js","hash":"20bd76acf8e950e5cf7243f60e1192705dacca7d","modified":1746717051209},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1746717051213},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1746717051217},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/pangu.min.js","hash":"ebc25ecdbf464407c5886f024d13f1f6da51ec85","modified":1746717051215},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1746717051183},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-block.styl","hash":"e6a793c6b2c54549db8226fcb13ee3c4b3a1c45d","modified":1746717051494},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/code-theme.styl","hash":"79d13151f771a7a967fbf18eab955354466335a8","modified":1746717051494},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/highlight.styl","hash":"35cfa277f1f2ea3c3876e50ac56c7401e1b8a4c7","modified":1746717051496},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/buttons.styl","hash":"32be9cf72f19b588b6e0db6b6e23146293b64268","modified":1746717051493},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/aplayer.styl","hash":"5d9b58f0d5226ef2a2a67502577539115ae29942","modified":1746717051490},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/tabs.styl","hash":"fb5f2f223f7d4ed86d3693fdc0977362f456212e","modified":1746717051501},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/folding.styl","hash":"b5e5c2407eb83ae4b3ee4ed73490dcd41edef705","modified":1746717051495},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_modules/notes.styl","hash":"37b2a4a0669414c74498ed0ecae873c90b15fe6e","modified":1746717051499},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/404.styl","hash":"16215f6fe664d1ddc5744a626405bc774dc30f70","modified":1746717051487},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/article-copyright-info.styl","hash":"12fad2f674e8a7ad009cabecf4e98b65d5ed8b1e","modified":1746717051491},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/archive-list.styl","hash":"d57516e1723b807d38cb7955a9a1422dd03ac820","modified":1746717051491},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/footer.styl","hash":"0dc8796e312215e45e1daf566a495c00480b68e3","modified":1746717051495},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/home-banner.styl","hash":"9f0fb6bd26e73bf07c556a3c1f552997234cb81c","modified":1746717051496},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/article-meta-info.styl","hash":"141ae2639ac760ced89887cce139adbc76c18cea","modified":1746717051491},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/image-viewer.styl","hash":"6c8eeb7a96cae110cd9a684a3a5076148b8154d8","modified":1746717051497},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/local-search.styl","hash":"45e7580258bc2d85cc12313abcc24cba9e531e00","modified":1746717051497},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/page-template.styl","hash":"e2e1826427e1fc5f88d4c31ddd508818a0b0d87d","modified":1746717051499},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/navbar.styl","hash":"b95efbade2b4cfd8000fd8238bdbd3de522b319e","modified":1746717051498},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/post-tools.styl","hash":"d602c2fe191d2c639f7cd8c4d0ee618f8c80f5c1","modified":1746717051500},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/paginator.styl","hash":"53421b731f3d7ed34a3a4c87405e06ae3d6519e0","modified":1746717051500},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/progress-bar.styl","hash":"d3715280d9b62d89ccd1b79ab5e5f030669f4d88","modified":1746717051500},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/side-tools.styl","hash":"995982b8c228f7386d352042f64587d06663716e","modified":1746717051500},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/toc.styl","hash":"13949981a5afa2b0483da1836af5999d992961f9","modified":1746717051502},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/tagcloud.styl","hash":"cb12c8ef44b5e597eb971d3341919fe9569da709","modified":1746717051501},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js","hash":"fbd5599508c60dc20fa90a9f37db27770e3773d5","modified":1746717050991},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js","hash":"a92d80fb49180a2700e069451c3ee9fde3f7cde0","modified":1746717050974},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/bookmarkNav.js.map","hash":"ba215231cccf6495570205bf974a83142592a22b","modified":1746717051255},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js","hash":"cd8e7825b6dce79cac97e6047f9a80f0fb893213","modified":1746717050982},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js","hash":"eacb006bd852a3c9881438b75d45e72d87914ad7","modified":1746717051003},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/essays.js.map","hash":"60c58a3fc229cd497ad782e6f2b642e6be600e4c","modified":1746717051259},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js.map","hash":"275dbb4ded89c2d2d805edbbf678475139bcc442","modified":1746717051465},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/navbarShrink.js","hash":"181c0c7e45f0c3a099d272b7c531559cd0d4fdbf","modified":1746717051209},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js","hash":"892929c5bb2293804f4c5f911dd901969f08ef67","modified":1746717051241},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/toc.js.map","hash":"9a413e8dbc2ff2a6fc21eb2899e59d5af75942a3","modified":1746717051470},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/lazyload.js.map","hash":"d365d984dfa37411397b36c69e24e4d5d0b32bee","modified":1746717051261},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js.map","hash":"daefe65fb99e2f7699f3fd25ec90b7f38469da5d","modified":1746717051251},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/aplayer.js","hash":"bef8536cb25306f78f80c1744c07544a46dac970","modified":1746717050961},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js.map","hash":"53deed7e9b802b964ff90d3303f957238f2b1421","modified":1746717051259},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js.map","hash":"b2d93754a64f84ef67528d320de69561fc763525","modified":1746717051264},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/hbe.js","hash":"383a946a2be735bc30c0bb331bbee335fe5b6942","modified":1746717050996},{"_id":"node_modules/hexo-theme-redefine/source/js/build/layouts/categoryList.js.map","hash":"fb9f8f83a1d0510eaa510fe58891de555d4839a8","modified":1746717051256},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js.map","hash":"27d5318b81541274c3026e4892ee43ba2c410951","modified":1746717051466},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js","hash":"2deee4201b637c54c1be0e1b686a97050fb37cce","modified":1746717051010},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/mermaid.js.map","hash":"5a8b4e15316517af607d3c12cf4a6e3447cfec22","modified":1746717051265},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js.map","hash":"218abee3893ecdee6f6c633b9fd13520a4eefabf","modified":1746717051469},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/tabs.js","hash":"b14b70e316e3151d591f03cbaf3c70c11ae5aad5","modified":1746717051235},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js","hash":"d8999de0b92fe1e1c9061040d6e95a9b607caa23","modified":1746717051243},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/typed.js.map","hash":"4840c94f7639cee4615916ce2cabd172a565a71c","modified":1746717051470},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js","hash":"8aa8e62cdc3891c9c608c1f52866aeab8cef0457","modified":1746717050984},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/codeBlock.js.map","hash":"fe609e1f8c1d028eca5e131b6a98cd71547be39c","modified":1746717051257},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js","hash":"310f06d38245235e1a65a5a7f1a6f673647faa6f","modified":1746717050999},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/imageViewer.js.map","hash":"6bf89edc74bc48b0e6f616d1ac0b0bb52df09353","modified":1746717051260},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js","hash":"dee772cad8a9ab42d54b6ea99599534524c47f18","modified":1746717051004},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/masonry.js","hash":"b5b44a6d4b74beea1938334b3558bd3d1caec07a","modified":1746717051009},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js","hash":"4ddb3808f9216b848a14e66c813ae883d0f883b1","modified":1746717051005},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/lightDarkSwitch.js.map","hash":"0fd195af186727b3b6f8a7d29035f35f7375e5a1","modified":1746717051261},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js.map","hash":"43ed778e985cbf71e7d62c5960da98a431ad43e3","modified":1746717051466},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/localSearch.js.map","hash":"86630e1b406ad10fe0450ccc49fbf07154fab9e5","modified":1746717051261},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js.map","hash":"76a041bbbd0d49426322c4fc1ee05bf327ffb7bd","modified":1746717051466},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/scrollTopBottom.js","hash":"037720022f64622f244682c176c5f0ab8f1efb54","modified":1746717051218},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/runtime.js","hash":"99d9fbc2022a12dd7f9bab4f88384f563f3f51e8","modified":1746717051218},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js","hash":"978bc1a31f8026ac9522198bca3c892ebf3551bc","modified":1746717051242},{"_id":"node_modules/hexo-theme-redefine/source/js/build/tools/tocToggle.js.map","hash":"6fd262220a32c784f194d21c7e514f21122bde2f","modified":1746717051470},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1746717051222},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1746717051231},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1746717051226},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1746717050966},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1746717051227},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1746717051234},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1746717051243},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1746717051232},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1746717051183},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1746717050945},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1746717051212},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1746717051216},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/pangu.min.js","hash":"ebc25ecdbf464407c5886f024d13f1f6da51ec85","modified":1746717051214},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/comment.styl","hash":"71529ec72f356c78f75a752e5400c1197aa5ea96","modified":1746717051495},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/twikoo.styl","hash":"448cbc045bcffa2d666094b81dd99eb980676fff","modified":1746717051502},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/gitalk.styl","hash":"85f26189ec6dee13a0a743687e7b5391f170c33f","modified":1746717051495},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment.min.js","hash":"20bd76acf8e950e5cf7243f60e1192705dacca7d","modified":1746717051207},{"_id":"node_modules/hexo-theme-redefine/source/css/layout/_partials/comments/waline.styl","hash":"0663e8e50eff65afb4dbcbc7c4758d8acdd1d368","modified":1746717051503},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/github.styl","hash":"a2a15ed938b319c369569845bf35d00c6624d136","modified":1746717051496},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/atom-one-light.styl","hash":"99de67d507bd6ffed5993097a6ce2be6422480b1","modified":1746717051492},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/light/default.styl","hash":"c2b8d16ba4dffdd3bae4db4f817bc18cdd7c1d60","modified":1746717051495},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/a11y-dark.styl","hash":"457e0df301f4dc1cc96371e65173b94bec0161fe","modified":1746717051488},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/agate.styl","hash":"a33ce49622c788e5d8bba32573e0b701e4cb7ead","modified":1746717051488},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/monokai-sublime.styl","hash":"803773d8c6dd5ecf957596ca57584a6618f373ac","modified":1746717051498},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/atom-one-dark.styl","hash":"8802725310cf86c4a179d874072188f31d10b224","modified":1746717051491},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/night-owl.styl","hash":"07c331a0c45051e93d24e10688425f1e30f0e99f","modified":1746717051499},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/nord.styl","hash":"9b88c9e8bca2b8995fdc71519c01a9c80121161c","modified":1746717051499},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/tokyo-night-dark.styl","hash":"2ae8e43a87b18bb899ac9c802d3774232160b8e7","modified":1746717051502},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/github-dark.styl","hash":"fab5f7f62407b66f8b5f2837b178ef5b09a4badc","modified":1746717051496},{"_id":"node_modules/hexo-theme-redefine/source/css/common/codeblock/hljs-themes/dark/vs2015.styl","hash":"c54d91bf767efe0671c4dfbe874fac678cfde117","modified":1746717051502},{"_id":"node_modules/hexo-theme-redefine/source/js/build/plugins/pangu.js","hash":"e96959eb39ca702242aca08c75f2230aa1bda7e4","modified":1746717051214},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.woff2","hash":"a358912d781e6249a8d291e4ce9ebd0a9ab9452e","modified":1746717051569},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.ttf","hash":"9a531509e4e768e9102d11f5d7d293e3f04d9c64","modified":1746717051562},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.ttf","hash":"d72ec9d729305fc24f38e1ba69174e93b700cd69","modified":1746717051562},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Geist/GeistVF.woff","hash":"d06c767b3837999a8b98426e4eb16ca0a8080880","modified":1746717051566},{"_id":"node_modules/hexo-theme-redefine/source/fonts/GeistMono/GeistMonoVF.woff","hash":"fd8c986a8767d59a36e2d194299466720c916ee2","modified":1746717051565},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/Swup.min.js.map","hash":"f74755d9318a86939791027767f631472b876207","modified":1746717051467},{"_id":"source/img/社会心理学.png","hash":"c9c128c4eec5c43793b46f64bbe65c4c3e248913","modified":1746705359527},{"_id":"source/img/2025-01-18-17-06-50.png","hash":"876ab15e17ea9dcea496b762bca7caf19c89fdec","modified":1746705359458},{"_id":"source/img/倦鸟.png","hash":"3d1326ddaa360899150a6857a8c96b50ea6c5e80","modified":1746705359492},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/fontawesome.min.css","hash":"44e6d666b45a6875e4fce11159876129e7a1cceb","modified":1746717050551},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-brands-400.ttf","hash":"ba9322d66c19f635e15e458cc39fcb509818332f","modified":1746717051508},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.eot","hash":"50a4e2ab17155fe7449e0ee488a6242180f3b256","modified":1746717050936},{"_id":"node_modules/hexo-theme-redefine/source/fonts/Chillax/Chillax-Variable.ttf","hash":"01aafadc0ca4ace59127a5594a8f534e83b84879","modified":1746717051506},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1746717051255},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs","hash":"d94e0f396776a003b603d6e90a732a548c2fda33","modified":1746717051486},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.woff2","hash":"74d0af1108ab8157993ca03cef80e89e35e2408d","modified":1746717051582},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/duotone.min.css","hash":"0becc4b085bd9d377a8ff4b5160f8e19c8ec27a0","modified":1746717050513},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.woff2","hash":"e73d164db2aff2c91d18c07da03e8db9d0c5dfd4","modified":1746717051583},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/moment-with-locales.min.js","hash":"dd1c67b36c800c00b7901f17af6200b26f2bb42c","modified":1746717051206},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/moment-with-locales.min.js","hash":"dd1c67b36c800c00b7901f17af6200b26f2bb42c","modified":1746717051194},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.woff2","hash":"def760895375328ccdcf62b2b9b9001a21947acd","modified":1746717051577},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.woff2","hash":"2cc24434345b80a844a6bda1139539fe41e4df53","modified":1746717051573},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.woff2","hash":"486fed640153de1de84f460834c73daef060ed20","modified":1746717051580},{"_id":"node_modules/hexo-theme-redefine/source/fontawesome/all.min.css","hash":"630bf0e29410ec27622f65d1270c6bc435cdff21","modified":1746717050369},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.woff2","hash":"e0a4482c20f6b67784df54965539a317a3bd681b","modified":1746717051586},{"_id":"source/img/Aniya.png","hash":"97b6ac6164cda9614d8a8abdcc1eb78c3bb38f41","modified":1746705359553},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-sharp-solid-900.ttf","hash":"0d710cd7bd1b7ff574e88bb812de82babe45e415","modified":1746717051541},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-solid-900.ttf","hash":"40b536c3667547db70ee9ca6f3c94fbc33e0cab7","modified":1746717051549},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-regular-400.ttf","hash":"cdec068700dc440530e5bbeff7e8bb33a01b4132","modified":1746717051535},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/waline.mjs.map","hash":"37c5b3e6aa5e1b70358426345a1a1329d6b896d3","modified":1746717051481},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-light-300.ttf","hash":"cc5d9f4f994c82e23f58cdde1eec8792d81633c7","modified":1746717051524},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-thin-100.ttf","hash":"c1fee6e6986b14533ce022afada5fbe10c0f6562","modified":1746717051560},{"_id":"source/img/crypt_index.png","hash":"cbdb5c4cf5938dfb15001186a76e20e25e498122","modified":1746705359570},{"_id":"node_modules/hexo-theme-redefine/source/webfonts/fa-duotone-900.ttf","hash":"e0313a772ea710cb5ea4bd08f5dedb0a0025f8ca","modified":1746717051515},{"_id":"source/img/sun.png","hash":"fea6d5ddff389d6bc7e3cfb0ef1f8d768fdaf202","modified":1746705359609},{"_id":"source/img/db_index.png","hash":"a93dad5a557fbb0869d1570638b4d2aa00474ec8","modified":1746705359576},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js","hash":"22eeb45e4dfff78a42bc8dad60d3a8ff64968a9d","modified":1746717051180},{"_id":"node_modules/hexo-theme-redefine/source/js/build/libs/mermaid.min.js","hash":"22eeb45e4dfff78a42bc8dad60d3a8ff64968a9d","modified":1746717051095},{"_id":"source/img/bgImg.png","hash":"8869c9029beef9c1240289e9fefc394972af5f64","modified":1746705359560},{"_id":"source/img/edit.gif","hash":"c546bb91850e8fb3161ac8ac31f5865ae68c40cf","modified":1746718565719},{"_id":"node_modules/hexo-theme-redefine/source/js/libs/mermaid.min.js.map","hash":"2e1a632f0588c4370188887d79a10ff8b38a49b5","modified":1746717051465},{"_id":"source/fonts/LXGWWenKaiGBScreen.ttf","hash":"e2139681d643e07e2ffb498fa3d656f6cba75afa","modified":1746706150824},{"_id":"public/fonts/custom-fonts.css","hash":"2e88c887c16da758b125b59b66bcc455224e3807","modified":1746755907079},{"_id":"public/search.json","hash":"0048e71a0afb269f93701e8cf8c955cd6d9dda1a","modified":1746755907079},{"_id":"public/masonry/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/404.html","hash":"93cc136c11f3b8d733ce84eef3c9e87d0b326c26","modified":1746755907079},{"_id":"public/categories/index.html","hash":"a2f745f7470d81158aeb937f833210a618aecfd7","modified":1746755907079},{"_id":"public/links/index.html","hash":"b3ffff159ea381d7c422dfe095b07b92f6746fbe","modified":1746755907079},{"_id":"public/tags/index.html","hash":"afce531a05cec2d0540ad5369e459169ea2a8915","modified":1746755907079},{"_id":"public/2025/05/08/chatSQL/index.html","hash":"6d95ff59273ce6baece4e01e91a5fa6f9493e1a7","modified":1746755907079},{"_id":"public/2025/04/28/Prisma/index.html","hash":"35d51fe96510c2f1ec2a43568959e1407fcd8cbd","modified":1746755907079},{"_id":"public/2025/04/17/swift/index.html","hash":"ca33a087c5be39793253cf0e1a2ddfde123db76b","modified":1746755907079},{"_id":"public/2025/02/16/前后端/跨组件渲染/index.html","hash":"8aef2df4a7c0ea15c9aa421e36b728f492ce2a32","modified":1746755907079},{"_id":"public/2025/02/14/编程语言/cpp学习记录/index.html","hash":"336ca4e25421315c26d2976d4b0280f215360115","modified":1746755907079},{"_id":"public/2025/01/20/前后端/响应式设计/index.html","hash":"2bd093d84046a0b1a2ebe98422c069fdfea71497","modified":1746755907079},{"_id":"public/2025/01/16/前后端/CORS/index.html","hash":"ec86dad233c097c37ef736e98e182c65e42ed31e","modified":1746755907079},{"_id":"public/2025/01/09/poets/晚霞/index.html","hash":"2e4cc00fce65f0033961b1e7c69e435ef17cc7ce","modified":1746755907079},{"_id":"public/2025/01/09/编程语言/JavaScript/index.html","hash":"61166acdd9c0e8d6e3da6b5cfdeba046952168eb","modified":1746755907079},{"_id":"public/2025/01/08/编程语言/css笔记/index.html","hash":"e03c8e5ed256e542b9c9201a308623d4739ccebe","modified":1746755907079},{"_id":"public/2025/01/08/poets/bird/index.html","hash":"e76474665105dec4e58c2181fc55e2da8200375a","modified":1746755907079},{"_id":"public/archives/index.html","hash":"3bb97167bdc6ed9fbf33e61751d6b2ebd1e68a5a","modified":1746755907079},{"_id":"public/archives/page/2/index.html","hash":"5549eedd1ba4e9b6cf1142f6e71d89ba00ac62df","modified":1746755907079},{"_id":"public/archives/2025/index.html","hash":"7c1861c7f68819c2a2a617e60255c738e713deb5","modified":1746755907079},{"_id":"public/archives/2025/page/2/index.html","hash":"0dc6d77989877895b03f838a044e7cf5da391052","modified":1746755907079},{"_id":"public/archives/2025/01/index.html","hash":"85717419128157240b2179862dd47b805abb2ebb","modified":1746755907079},{"_id":"public/archives/2025/02/index.html","hash":"b55562da562baa5e5260c7f3085d630f79a9744c","modified":1746755907079},{"_id":"public/archives/2025/04/index.html","hash":"8a7b0a37e3f77e1cea322e7ce8f1b85da9c8526f","modified":1746755907079},{"_id":"public/archives/2025/05/index.html","hash":"0bc3ad04c9541f2b44db1deb67af75448b3c22f2","modified":1746755907079},{"_id":"public/categories/前后端开发/index.html","hash":"05ad9ef2e2baa47b588319303cf4e1a9aedf8ccf","modified":1746755907079},{"_id":"public/essays/index.html","hash":"fc37884e2958fc039a1c60f07aebfbb9de720b24","modified":1746755907079},{"_id":"public/categories/随机掉落的文字碎片/index.html","hash":"555877b07ea5fd7086a5ff9c5ca962c75c50042f","modified":1746755907079},{"_id":"public/categories/编程语言/index.html","hash":"b2195967703f5b88b788a8f473357ef9af0475ae","modified":1746755907079},{"_id":"public/categories/学习笔记/index.html","hash":"32ce3fb9092931d5fb43db3c9de9b39322c09809","modified":1746755907079},{"_id":"public/categories/编程语言/学习笔记/index.html","hash":"8f00ea7974e3223ee9fdeac627c88b5c79592aa5","modified":1746755907079},{"_id":"public/page/2/index.html","hash":"65f2b9279951a2f6f58c4438d4b826d464467f30","modified":1746755907079},{"_id":"public/tags/数据库/index.html","hash":"46e5b2470490db7e554839d8bd5f8cf43f1f3a67","modified":1746755907079},{"_id":"public/index.html","hash":"d5048443e9201e63333e6a626f624f1cff484bd2","modified":1746755907079},{"_id":"public/tags/奇思妙想/index.html","hash":"53a194135995ca678918122b995f9478e0bbf603","modified":1746755907079},{"_id":"public/tags/短诗/index.html","hash":"f4bfda4104ded6a7214c4f9cef2fbf07d6594bcf","modified":1746755907079},{"_id":"public/tags/自然/index.html","hash":"ca7368929317a894d11b5c95b6a5a20b32ef9e96","modified":1746755907079},{"_id":"public/tags/前后端交互/index.html","hash":"3dc5224f137136fc97004cbb1b5f142d4bfe78e8","modified":1746755907079},{"_id":"public/tags/网站开发/index.html","hash":"fce14eab3d79daeccc27861529aa48df97a72ca3","modified":1746755907079},{"_id":"public/tags/杂记/index.html","hash":"f585a9967b42c3cf1bf65bf58e8dbd6e7257c743","modified":1746755907079},{"_id":"public/tags/前端/index.html","hash":"24064ec471b16373c7c1ad907ffb2d074cc2a104","modified":1746755907079},{"_id":"public/tags/CSS/index.html","hash":"4fa5e33cea89104577294296609bd605dd9051a0","modified":1746755907079},{"_id":"public/tags/JS/index.html","hash":"0904d289df5b158f02fae6120afa00cd1e7bed30","modified":1746755907079},{"_id":"public/images/redefine-favicon.svg","hash":"420f930a1df64a3c4391ff80326a8a2d7d5a6418","modified":1746755907079},{"_id":"public/images/bookmark-placeholder.svg","hash":"255a1236bab60d2871da31e4f0db947b44931df6","modified":1746755907079},{"_id":"public/images/redefine-logo.svg","hash":"472776b6f013aad44706fee6c94201c96ee83932","modified":1746755907079},{"_id":"public/images/redefine-avatar.svg","hash":"d0d20061bda08894a82d7691b660be7c6aaa0608","modified":1746755907079},{"_id":"public/images/loading.svg","hash":"938c2a41c8ba18e37ed659e481696e40a4c8f3a4","modified":1746755907079},{"_id":"public/images/redefine-logo.webp","hash":"0a07e3fb6d9125dee44798c8c110187b16fb42a9","modified":1746755907079},{"_id":"public/images/wallhaven-wqery6-light.webp","hash":"d25389973d0359b78f1e9c74a850ef425690ba40","modified":1746755907079},{"_id":"public/images/wallhaven-wqery6-dark.webp","hash":"d0066e0b025ae748448a3d6a96165d45a55d2f22","modified":1746755907079},{"_id":"public/images/redefine-og.webp","hash":"44fb793383da185808ed682d7dd916e10eb65b4d","modified":1746755907079},{"_id":"public/webfonts/fa-v4compatibility.ttf","hash":"b54531dd09c5089eb93b12ce8f90ff521855ff8a","modified":1746755907079},{"_id":"public/webfonts/fa-v4compatibility.woff2","hash":"d02b1adc81fd5bec023e25a7770779b99d6dd742","modified":1746755907079},{"_id":"public/fonts/Chillax/Chillax-Variable.woff","hash":"fc0e791429c274c4c9312d810e7ae9503cab34ab","modified":1746755907079},{"_id":"public/fonts/Chillax/Chillax-Variable.woff2","hash":"fc5d99b40db9deca7d151f9bd16b96ff160828b7","modified":1746755907079},{"_id":"public/fonts/Geist/GeistVF.woff2","hash":"772998a8569a6caa04927d876fbe9e0fb859658b","modified":1746755907079},{"_id":"public/js/build/main.js.map","hash":"b089351e96e8f99395ac9b44aea257364a475dca","modified":1746755907079},{"_id":"public/fonts/GeistMono/GeistMonoVF.woff2","hash":"11e9a061ce255fc4cc45ac3eeb8cab09a49f5ccc","modified":1746755907079},{"_id":"public/js/build/utils.js.map","hash":"d9a1eed23a96de49c30ebccb52620e24204ea10e","modified":1746755907079},{"_id":"public/js/libs/SwupPreloadPlugin.min.js.map","hash":"40513fec1323b601667876a97a9ef8a0c88bff63","modified":1746755907079},{"_id":"public/js/libs/SwupScrollPlugin.min.js.map","hash":"63cf04ba556b256379e103ef7d3ba12d629449a4","modified":1746755907079},{"_id":"public/js/build/layouts/categoryList.js.map","hash":"fb9f8f83a1d0510eaa510fe58891de555d4839a8","modified":1746755907079},{"_id":"public/js/plugins/hbe.js","hash":"f7bd9258359dc8f70c6faec3f4fe22a1852d9bf1","modified":1746755907079},{"_id":"public/js/build/layouts/navbarShrink.js.map","hash":"275dbb4ded89c2d2d805edbbf678475139bcc442","modified":1746755907079},{"_id":"public/js/build/layouts/toc.js.map","hash":"9a413e8dbc2ff2a6fc21eb2899e59d5af75942a3","modified":1746755907079},{"_id":"public/js/build/plugins/aplayer.js.map","hash":"daefe65fb99e2f7699f3fd25ec90b7f38469da5d","modified":1746755907079},{"_id":"public/js/build/plugins/hbe.js.map","hash":"53deed7e9b802b964ff90d3303f957238f2b1421","modified":1746755907079},{"_id":"public/js/build/layouts/essays.js.map","hash":"60c58a3fc229cd497ad782e6f2b642e6be600e4c","modified":1746755907079},{"_id":"public/js/build/plugins/masonry.js.map","hash":"b2d93754a64f84ef67528d320de69561fc763525","modified":1746755907079},{"_id":"public/js/build/plugins/pangu.js.map","hash":"27d5318b81541274c3026e4892ee43ba2c410951","modified":1746755907079},{"_id":"public/js/build/plugins/mermaid.js.map","hash":"5a8b4e15316517af607d3c12cf4a6e3447cfec22","modified":1746755907079},{"_id":"public/js/build/plugins/typed.js.map","hash":"4840c94f7639cee4615916ce2cabd172a565a71c","modified":1746755907079},{"_id":"public/js/build/tools/localSearch.js.map","hash":"86630e1b406ad10fe0450ccc49fbf07154fab9e5","modified":1746755907079},{"_id":"public/js/build/plugins/tabs.js.map","hash":"218abee3893ecdee6f6c633b9fd13520a4eefabf","modified":1746755907079},{"_id":"public/js/build/tools/imageViewer.js.map","hash":"6bf89edc74bc48b0e6f616d1ac0b0bb52df09353","modified":1746755907079},{"_id":"public/js/build/tools/lightDarkSwitch.js.map","hash":"0fd195af186727b3b6f8a7d29035f35f7375e5a1","modified":1746755907079},{"_id":"public/js/build/layouts/bookmarkNav.js.map","hash":"ba215231cccf6495570205bf974a83142592a22b","modified":1746755907079},{"_id":"public/js/build/layouts/lazyload.js.map","hash":"d365d984dfa37411397b36c69e24e4d5d0b32bee","modified":1746755907079},{"_id":"public/js/build/tools/scrollTopBottom.js.map","hash":"76a041bbbd0d49426322c4fc1ee05bf327ffb7bd","modified":1746755907079},{"_id":"public/js/build/tools/runtime.js.map","hash":"43ed778e985cbf71e7d62c5960da98a431ad43e3","modified":1746755907079},{"_id":"public/js/build/tools/codeBlock.js.map","hash":"fe609e1f8c1d028eca5e131b6a98cd71547be39c","modified":1746755907079},{"_id":"public/js/build/tools/tocToggle.js.map","hash":"6fd262220a32c784f194d21c7e514f21122bde2f","modified":1746755907079},{"_id":"public/img/2025-01-17-14-00-36.png","hash":"eacdd40a31bb3f4ccec48b38aa01d9e4f4a000d5","modified":1746755907079},{"_id":"public/img/JS.png","hash":"a115cbbec848dea5824181ef22411d8efc6dbfa8","modified":1746755907079},{"_id":"public/img/find-2025-01-22-11-58-20.png","hash":"a889d1dd151686eb085de78836a2cc7e59a43606","modified":1746755907079},{"_id":"public/img/legend-2025-01-21-21-19-51.png","hash":"c56fc82db2388050164829230deac64751c69ea6","modified":1746755907079},{"_id":"public/img/猫猫-2025-01-20-22-47-27.png","hash":"91d8cfe3cb9673a851c50fc6351c91b9cb54bb60","modified":1746755907079},{"_id":"public/css/hbe.style.css","hash":"29be8fc47be885e9954e310cbc68dfadd3b4cee6","modified":1746755907079},{"_id":"public/webfonts/fa-brands-400.woff2","hash":"a358912d781e6249a8d291e4ce9ebd0a9ab9452e","modified":1746755907079},{"_id":"public/fonts/Geist/GeistVF.ttf","hash":"9a531509e4e768e9102d11f5d7d293e3f04d9c64","modified":1746755907079},{"_id":"public/fonts/GeistMono/GeistMonoVF.ttf","hash":"d72ec9d729305fc24f38e1ba69174e93b700cd69","modified":1746755907079},{"_id":"public/fonts/Geist/GeistVF.woff","hash":"d06c767b3837999a8b98426e4eb16ca0a8080880","modified":1746755907079},{"_id":"public/fonts/GeistMono/GeistMonoVF.woff","hash":"fd8c986a8767d59a36e2d194299466720c916ee2","modified":1746755907079},{"_id":"public/js/libs/Swup.min.js.map","hash":"f74755d9318a86939791027767f631472b876207","modified":1746755907079},{"_id":"public/img/2025-01-18-12-58-38.png","hash":"cf5073b3f0fcc5f8e8b013927dc633cdb0eb478b","modified":1746755907079},{"_id":"public/img/2025-01-18-11-41-54.png","hash":"1d85d673eebe40136f7058b03e7d4aa3d2760b14","modified":1746755907079},{"_id":"public/img/2025-01-16-23-58-21.png","hash":"3707c7284cdeaada1b82a50889d6bc5b66cfab69","modified":1746755907079},{"_id":"public/img/2025-01-18-13-01-29.png","hash":"6dbe8216f8848a8f202de965f4313dbb2eecdd58","modified":1746755907079},{"_id":"public/fontawesome/all.min.css","hash":"630bf0e29410ec27622f65d1270c6bc435cdff21","modified":1746755907079},{"_id":"public/fontawesome/brands.min.css","hash":"5119c35bbd273d2ea2501997827f6d644da93164","modified":1746755907079},{"_id":"public/fontawesome/duotone.min.css","hash":"0becc4b085bd9d377a8ff4b5160f8e19c8ec27a0","modified":1746755907079},{"_id":"public/fontawesome/fontawesome.min.css","hash":"44e6d666b45a6875e4fce11159876129e7a1cceb","modified":1746755907079},{"_id":"public/fontawesome/sharp-solid.min.css","hash":"7d1a13c6b8178b29f5bcb1a639a1998fc9de16c4","modified":1746755907079},{"_id":"public/fontawesome/regular.min.css","hash":"d27c4fed54dacff688010e51f611d950dd6e0aca","modified":1746755907079},{"_id":"public/fontawesome/light.min.css","hash":"18a176eb2486db4e938e568083fa578b641ccc83","modified":1746755907079},{"_id":"public/fontawesome/svg-with-js.min.css","hash":"f4c08e37c4d44b3ed7a3f377d1cb5d7fca4d04bc","modified":1746755907079},{"_id":"public/fontawesome/v5-font-face.min.css","hash":"260ea7a5e0b89963a5dcf2600a4decdf0f408f3f","modified":1746755907079},{"_id":"public/assets/hbe.style.css","hash":"29be8fc47be885e9954e310cbc68dfadd3b4cee6","modified":1746755907079},{"_id":"public/fontawesome/solid.min.css","hash":"e727feabedb171fb0b398151870d7739ef4e2432","modified":1746755907079},{"_id":"public/fontawesome/v4-shims.min.css","hash":"96f037860b8e9b59af8e47571ea98791616dbfd8","modified":1746755907079},{"_id":"public/assets/odometer-theme-minimal.css","hash":"793c31feb38e241a5ff6ecc5e65e61751507d728","modified":1746755907079},{"_id":"public/css/tailwind.source.css","hash":"1dc3152fe841290f3bd56074f726df975ab91b6e","modified":1746755907079},{"_id":"public/css/style.css","hash":"493139177fefeff9bd9806723981c91edbeaf53c","modified":1746755907079},{"_id":"public/fontawesome/v4-font-face.min.css","hash":"0be987628c8b485b39f064da41c90f15c0596c1f","modified":1746755907079},{"_id":"public/js/main.js","hash":"cee5f0dcb5b1f0f7f952e24d31cce2bd785b29cc","modified":1746755907079},{"_id":"public/css/common/markdown.css","hash":"881de2418975ebe1a11385d43fa5b99ea17717a2","modified":1746755907079},{"_id":"public/fontawesome/thin.min.css","hash":"3d46be31379b07ffb24d69c6c915725eaa2e89e9","modified":1746755907079},{"_id":"public/js/build.js","hash":"61eb4760cefeffa79550f3f7387e701d554a0709","modified":1746755907079},{"_id":"public/css/common/colors.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/redefine-theme.css","hash":"9f4f241b990fea4fb6a5dd8bbcce42bb1ab23017","modified":1746755907079},{"_id":"public/css/common/basic.css","hash":"d547a68138f0dab38e53e7074083cb31e707cbe8","modified":1746755907079},{"_id":"public/js/utils.js","hash":"5efa4c652a1e7f4852fb8df9bf60de170b4b41db","modified":1746755907079},{"_id":"public/css/common/variables.css","hash":"a616865e4f6a648b12ed19b1bff04daffd85f20d","modified":1746755907079},{"_id":"public/css/layout/article-content.css","hash":"3b490662379c6057f8499625bd3b0cc12f9edabe","modified":1746755907079},{"_id":"public/css/common/animated.css","hash":"ba9249b8bc0f2220620c552e215d1c3bdb1640e0","modified":1746755907079},{"_id":"public/css/common/theme.css","hash":"a616865e4f6a648b12ed19b1bff04daffd85f20d","modified":1746755907079},{"_id":"public/css/layout/animations.css","hash":"aaffd18490f8be21e8bf8f9e1867a05bdc443801","modified":1746755907079},{"_id":"public/css/layout/bookmarks.css","hash":"4f8097c9909cfc13723e30b55af0fcb4bd439a97","modified":1746755907079},{"_id":"public/css/layout/archive-content.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/layout/tag-content.css","hash":"11991efea1836af042bfec474dcd80a4387644a9","modified":1746755907079},{"_id":"public/css/layout/home-sidebar.css","hash":"d559d5f9c5681da2cde858ecaae42872c9dc6e98","modified":1746755907079},{"_id":"public/fonts/Geist/geist.css","hash":"17f37a09d6192f06b2190f8319114238b0a2ec8c","modified":1746755907079},{"_id":"public/css/layout/home-content.css","hash":"29f09fbeaa55a1ec0d5e6561826ba50480ae23e7","modified":1746755907079},{"_id":"public/css/layout/category-list.css","hash":"207173ef7a7835c0aee5cf72d85567dd413998c5","modified":1746755907079},{"_id":"public/css/layout/page.css","hash":"6550f6706bb525b45f46be821bd5e857b2ea709c","modified":1746755907079},{"_id":"public/js/build/main.js","hash":"2fcd1ce192bb34997c2e962d9c98a389573969ac","modified":1746755907079},{"_id":"public/css/layout/category-content.css","hash":"5b7f95726c84464280fd17cdea3cbdaff4a4e6fa","modified":1746755907079},{"_id":"public/js/plugins/mermaid.js","hash":"303254d382869ed618025fcb328426bd10314583","modified":1746755907079},{"_id":"public/fonts/GeistMono/geist-mono.css","hash":"b89d5af7e04df579c8ad62c0ea445ff7d16eec11","modified":1746755907079},{"_id":"public/js/plugins/pangu.js","hash":"25af6a33c9176a00f21f45cf5cfad0eb7d473841","modified":1746755907079},{"_id":"public/js/plugins/aplayer.js","hash":"f2818445cfbdbf936f136c3d0f983583c581d77e","modified":1746755907079},{"_id":"public/js/plugins/masonry.js","hash":"92734a30a21f8b16f20aa75208f6c082890275fb","modified":1746755907079},{"_id":"public/js/plugins/typed.js","hash":"f46f636a32e7569a9ff8b8b301bf860e598bd4fe","modified":1746755907079},{"_id":"public/js/tools/codeBlock.js","hash":"344e6c83e6ffda22f6e5bc724d603066b49a7d8b","modified":1746755907079},{"_id":"public/js/tools/imageViewer.js","hash":"33c4e4a28cf66be0cb3f181acae082a5a5404a89","modified":1746755907079},{"_id":"public/js/tools/localSearch.js","hash":"f6e59f65c676457198c2cf5d78bd06052499ee38","modified":1746755907079},{"_id":"public/fonts/Chillax/chillax.css","hash":"210179f53c6bce91a12ca6db9129184cc1549c36","modified":1746755907079},{"_id":"public/js/build/utils.js","hash":"5a3707671ffb8544ef6e90c3713c4da785f06488","modified":1746755907079},{"_id":"public/js/plugins/tabs.js","hash":"964ec5c25a8d78763ba2ba9bfbd5b1b49ed05381","modified":1746755907079},{"_id":"public/js/tools/lightDarkSwitch.js","hash":"97b7e68f871dc218fceca77b85ac051c7c6306af","modified":1746755907079},{"_id":"public/css/build/tailwind.css","hash":"298ca1975af73e8101d77491566de03543a56a65","modified":1746755907079},{"_id":"public/js/tools/runtime.js","hash":"eb0374b6f033f7ac25f49b1b079aa163e14b0fcd","modified":1746755907079},{"_id":"public/js/layouts/bookmarkNav.js","hash":"3155ed3e6e2aa2e32dbd9e4e06b863e63c2a9b9d","modified":1746755907079},{"_id":"public/js/tools/tocToggle.js","hash":"c2224ff0370fcf109e94194613b9480a3913c82d","modified":1746755907079},{"_id":"public/js/layouts/essays.js","hash":"df82365c7287710dd876e452f8ef4e1d87b8c09e","modified":1746755907079},{"_id":"public/js/tools/scrollTopBottom.js","hash":"9e54fa4310bb98ea5ba61780a9ef56d05d475203","modified":1746755907079},{"_id":"public/js/layouts/categoryList.js","hash":"eb1af2cd0726f56ff7861222ea543315fe295a17","modified":1746755907079},{"_id":"public/js/layouts/lazyload.js","hash":"c06323d68bbdebbb685db5010e7655b8ed0caf42","modified":1746755907079},{"_id":"public/js/layouts/toc.js","hash":"7a768982f6cb1f40552cce063d5743fe862db762","modified":1746755907079},{"_id":"public/js/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1746755907079},{"_id":"public/js/layouts/navbarShrink.js","hash":"3e80bf9ef719b2ddb2d1c4b67eb169d2ef52dbb8","modified":1746755907079},{"_id":"public/js/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1746755907079},{"_id":"public/js/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1746755907079},{"_id":"public/js/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1746755907079},{"_id":"public/js/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1746755907079},{"_id":"public/js/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1746755907079},{"_id":"public/js/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1746755907079},{"_id":"public/js/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1746755907079},{"_id":"public/js/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1746755907079},{"_id":"public/js/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1746755907079},{"_id":"public/js/libs/moment-with-locales.min.js","hash":"dd1c67b36c800c00b7901f17af6200b26f2bb42c","modified":1746755907079},{"_id":"public/js/libs/moment.min.js","hash":"20bd76acf8e950e5cf7243f60e1192705dacca7d","modified":1746755907079},{"_id":"public/js/libs/pangu.min.js","hash":"ebc25ecdbf464407c5886f024d13f1f6da51ec85","modified":1746755907079},{"_id":"public/css/common/codeblock/highlight.css","hash":"a55cd34231706e78263e628973db8766fdc1fa08","modified":1746755907079},{"_id":"public/js/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1746755907079},{"_id":"public/css/common/codeblock/code-theme.css","hash":"69d40098d69002d99c262279dc3d45338accadcb","modified":1746755907079},{"_id":"public/js/build/layouts/bookmarkNav.js","hash":"a92d80fb49180a2700e069451c3ee9fde3f7cde0","modified":1746755907079},{"_id":"public/js/build/layouts/categoryList.js","hash":"cd8e7825b6dce79cac97e6047f9a80f0fb893213","modified":1746755907079},{"_id":"public/js/build/layouts/navbarShrink.js","hash":"181c0c7e45f0c3a099d272b7c531559cd0d4fdbf","modified":1746755907079},{"_id":"public/js/build/layouts/lazyload.js","hash":"eacb006bd852a3c9881438b75d45e72d87914ad7","modified":1746755907079},{"_id":"public/js/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1746755907079},{"_id":"public/css/common/codeblock/code-block.css","hash":"b3f8ad7bab043ff05546ee596ea9fa25c71b28e9","modified":1746755907079},{"_id":"public/js/build/layouts/toc.js","hash":"892929c5bb2293804f4c5f911dd901969f08ef67","modified":1746755907079},{"_id":"public/js/build/plugins/hbe.js","hash":"383a946a2be735bc30c0bb331bbee335fe5b6942","modified":1746755907079},{"_id":"public/js/build/plugins/pangu.js","hash":"e96959eb39ca702242aca08c75f2230aa1bda7e4","modified":1746755907079},{"_id":"public/js/build/plugins/mermaid.js","hash":"2deee4201b637c54c1be0e1b686a97050fb37cce","modified":1746755907079},{"_id":"public/js/build/layouts/essays.js","hash":"fbd5599508c60dc20fa90a9f37db27770e3773d5","modified":1746755907079},{"_id":"public/js/build/tools/codeBlock.js","hash":"8aa8e62cdc3891c9c608c1f52866aeab8cef0457","modified":1746755907079},{"_id":"public/js/build/plugins/typed.js","hash":"d8999de0b92fe1e1c9061040d6e95a9b607caa23","modified":1746755907079},{"_id":"public/js/build/tools/lightDarkSwitch.js","hash":"dee772cad8a9ab42d54b6ea99599534524c47f18","modified":1746755907079},{"_id":"public/js/build/tools/imageViewer.js","hash":"310f06d38245235e1a65a5a7f1a6f673647faa6f","modified":1746755907079},{"_id":"public/js/build/tools/localSearch.js","hash":"4ddb3808f9216b848a14e66c813ae883d0f883b1","modified":1746755907079},{"_id":"public/js/build/plugins/masonry.js","hash":"b5b44a6d4b74beea1938334b3558bd3d1caec07a","modified":1746755907079},{"_id":"public/js/build/plugins/aplayer.js","hash":"bef8536cb25306f78f80c1744c07544a46dac970","modified":1746755907079},{"_id":"public/js/build/plugins/tabs.js","hash":"b14b70e316e3151d591f03cbaf3c70c11ae5aad5","modified":1746755907079},{"_id":"public/js/build/tools/scrollTopBottom.js","hash":"037720022f64622f244682c176c5f0ab8f1efb54","modified":1746755907079},{"_id":"public/js/build/tools/runtime.js","hash":"99d9fbc2022a12dd7f9bab4f88384f563f3f51e8","modified":1746755907079},{"_id":"public/js/build/libs/Swup.min.js","hash":"cc054d34e74a1feecfae75064f6a4d6107607396","modified":1746755907079},{"_id":"public/js/build/tools/tocToggle.js","hash":"978bc1a31f8026ac9522198bca3c892ebf3551bc","modified":1746755907079},{"_id":"public/js/build/libs/SwupScrollPlugin.min.js","hash":"6c3afca9bb98f79d14516c093f27e3e50a3fd82e","modified":1746755907079},{"_id":"public/js/build/libs/SwupProgressPlugin.min.js","hash":"fd30fe1c43072017f67bbaac18b962a5ac218711","modified":1746755907079},{"_id":"public/js/build/libs/SwupScriptsPlugin.min.js","hash":"b17f3434035f1339d6f9cd5c8a055d2a1b6602e9","modified":1746755907079},{"_id":"public/js/build/libs/SwupPreloadPlugin.min.js","hash":"d911512891ecbe1935203bcd3d93427ad75e45c8","modified":1746755907079},{"_id":"public/js/build/libs/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1746755907079},{"_id":"public/js/build/libs/APlayer.min.js","hash":"22caa28ff6b41a16ff40f15d38f1739e22359478","modified":1746755907079},{"_id":"public/js/build/libs/SwupSlideTheme.min.js","hash":"e9d143780e879d958164b1356b7f918ec25e838a","modified":1746755907079},{"_id":"public/js/build/libs/Typed.min.js","hash":"e8ce2b674a637b0c0396a3106c1aedf10186249c","modified":1746755907079},{"_id":"public/js/build/libs/minimasonry.min.js","hash":"9681cc509cb8aa733d36aad032e6e8acdb33c08c","modified":1746755907079},{"_id":"public/js/build/libs/pjax.min.js","hash":"3d796e5be9cdd4067c94e190ea2482d7fdb4856c","modified":1746755907079},{"_id":"public/js/build/libs/moment-with-locales.min.js","hash":"dd1c67b36c800c00b7901f17af6200b26f2bb42c","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/light/default.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/light/atom-one-light.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/js/build/libs/pangu.min.js","hash":"ebc25ecdbf464407c5886f024d13f1f6da51ec85","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/light/github.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/agate.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/a11y-dark.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/atom-one-dark.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/monokai-sublime.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/github-dark.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/night-owl.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/nord.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/tokyo-night-dark.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/js/build/libs/odometer.min.js","hash":"fe5beb60997c84ab2f91b54535c4221443cdd21f","modified":1746755907079},{"_id":"public/css/common/codeblock/hljs-themes/dark/vs2015.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1746755907079},{"_id":"public/js/build/libs/moment.min.js","hash":"20bd76acf8e950e5cf7243f60e1192705dacca7d","modified":1746755907079},{"_id":"public/img/great.jpg","hash":"ad40b86f9b500d362074fe888853c2536ba6e834","modified":1746755907079},{"_id":"public/webfonts/fa-brands-400.ttf","hash":"ba9322d66c19f635e15e458cc39fcb509818332f","modified":1746755907079},{"_id":"public/fonts/Chillax/Chillax-Variable.eot","hash":"50a4e2ab17155fe7449e0ee488a6242180f3b256","modified":1746755907079},{"_id":"public/fonts/Chillax/Chillax-Variable.ttf","hash":"01aafadc0ca4ace59127a5594a8f534e83b84879","modified":1746755907079},{"_id":"public/js/libs/APlayer.min.js.map","hash":"31a19da0f0cb6b00ec212eafa847f31af86788df","modified":1746755907079},{"_id":"public/js/libs/waline.mjs","hash":"d94e0f396776a003b603d6e90a732a548c2fda33","modified":1746755907079},{"_id":"public/fonts/MapleMono-Regular.ttf","hash":"8ef0566873ae81ef2dd9ed3fecf13240673fc414","modified":1746755907079},{"_id":"public/fonts/MapleMono-Bold.ttf","hash":"ec54b625650294240d3255287a5cd07afd5bde09","modified":1746755907079},{"_id":"public/img/2025-01-18-13-03-21.png","hash":"25abaf57c0e17909b165180aaf9d390fe09d6c5a","modified":1746755907079},{"_id":"public/img/2025-01-18-13-09-11.png","hash":"47c213fc9292190467b8b6f0e19b9408dbe6824f","modified":1746755907079},{"_id":"public/img/Aniya_放大镜.jpg","hash":"538ff8e7ac38f341c0166820d43617d73675cc86","modified":1746755907079},{"_id":"public/img/不死鸟.jpg","hash":"0baad7c3a94594079f49165c91f061d0689c1035","modified":1746755907079},{"_id":"public/img/晚霞.jpg","hash":"c89abcb798ddb518b6e8ce08e8afd144b00e8a54","modified":1746755907079},{"_id":"public/webfonts/fa-sharp-solid-900.woff2","hash":"74d0af1108ab8157993ca03cef80e89e35e2408d","modified":1746755907079},{"_id":"public/fonts/MapleMono-Italic.ttf","hash":"e6c100ea19c7a8cb4b005a2c61d22e971943a014","modified":1746755907079},{"_id":"public/img/2025-01-18-11-45-41.png","hash":"f9cf4255cce7bad9cfbe29c5264b022933a64c30","modified":1746755907079},{"_id":"public/img/2025-01-18-17-13-45.png","hash":"b4d0e8077ffe69dfd61db955e869126b24c76ce0","modified":1746755907079},{"_id":"public/img/me.jpg","hash":"bdfdab38c41980cff966c08ea26ca8699948cbd6","modified":1746755907079},{"_id":"public/img/料理的加护.jpg","hash":"6364a3389f2ac52ad1ec33c254ebde8740b257cc","modified":1746755907079},{"_id":"public/img/闪光拉姆.jpg","hash":"8e818cc9cee33324fb15a8d52fc69b1262cf87e2","modified":1746755907079},{"_id":"public/webfonts/fa-solid-900.woff2","hash":"e73d164db2aff2c91d18c07da03e8db9d0c5dfd4","modified":1746755907079},{"_id":"public/img/avatar.svg","hash":"fca0089e299662e3ac16c9e1a594bcbff42db6d6","modified":1746755907079},{"_id":"public/img/哭哭帕克.jpg","hash":"e20aa94b2a43c0194fb3d3a5d0762b6404458003","modified":1746755907079},{"_id":"public/img/闪耀pack.jpg","hash":"470edf49958168295976933a0135d5517954cdba","modified":1746755907079},{"_id":"public/img/雪国.jpg","hash":"e1cc8027328cbc55de92496f1e7c90d3812923b7","modified":1746755907079},{"_id":"public/img/2025-01-18-17-14-29.png","hash":"871f5a88a9d126706973463911056770ae7090e8","modified":1746755907079},{"_id":"public/js/libs/mermaid.min.js","hash":"22eeb45e4dfff78a42bc8dad60d3a8ff64968a9d","modified":1746755907079},{"_id":"public/js/build/libs/mermaid.min.js","hash":"22eeb45e4dfff78a42bc8dad60d3a8ff64968a9d","modified":1746755907079},{"_id":"public/img/re0-2025-01-18-17-16-53.png","hash":"871f5a88a9d126706973463911056770ae7090e8","modified":1746755907079},{"_id":"public/img/re0-2025-01-18-17-40-27.png","hash":"0f759367f3fa09abcf03a7e92ec340f38e133142","modified":1746755907079},{"_id":"public/img/跨域共享.jpg","hash":"438d4dda0d2271203947bb461416275504601355","modified":1746755907079},{"_id":"public/img/雷姆拉姆.jpg","hash":"a3360d4afcc99266225d67003a06a133a2a8ecc7","modified":1746755907079},{"_id":"public/webfonts/fa-duotone-900.woff2","hash":"2cc24434345b80a844a6bda1139539fe41e4df53","modified":1746755907079},{"_id":"public/webfonts/fa-light-300.woff2","hash":"def760895375328ccdcf62b2b9b9001a21947acd","modified":1746755907079},{"_id":"public/webfonts/fa-regular-400.woff2","hash":"486fed640153de1de84f460834c73daef060ed20","modified":1746755907079},{"_id":"public/img/2025-01-18-13-23-22.png","hash":"0c9345d1f0c9af7bc07f7bbf7a15153d4b16aea7","modified":1746755907079},{"_id":"public/img/2025-01-18-13-15-38.png","hash":"a5774370c2e3ac61a14b5847c2c77ea69afecbfe","modified":1746755907079},{"_id":"public/img/2025-01-18-17-11-36.png","hash":"404b6f149798b76095753ac52d034516b37c1555","modified":1746755907079},{"_id":"public/img/照镜子.jpg","hash":"204a3b9a70ad3381fc5c2b78d3fc9afdecc2d995","modified":1746755907079},{"_id":"public/webfonts/fa-thin-100.woff2","hash":"e0a4482c20f6b67784df54965539a317a3bd681b","modified":1746755907079},{"_id":"public/img/校长帕克.jpg","hash":"dbc8efb5b99bf953032dac803a4ea7ac1166974e","modified":1746755907079},{"_id":"public/webfonts/fa-sharp-solid-900.ttf","hash":"0d710cd7bd1b7ff574e88bb812de82babe45e415","modified":1746755907079},{"_id":"public/webfonts/fa-solid-900.ttf","hash":"40b536c3667547db70ee9ca6f3c94fbc33e0cab7","modified":1746755907079},{"_id":"public/webfonts/fa-regular-400.ttf","hash":"cdec068700dc440530e5bbeff7e8bb33a01b4132","modified":1746755907079},{"_id":"public/img/2025-01-18-17-06-50.png","hash":"876ab15e17ea9dcea496b762bca7caf19c89fdec","modified":1746755907079},{"_id":"public/img/社会心理学.png","hash":"c9c128c4eec5c43793b46f64bbe65c4c3e248913","modified":1746755907079},{"_id":"public/img/倦鸟.png","hash":"3d1326ddaa360899150a6857a8c96b50ea6c5e80","modified":1746755907079},{"_id":"public/js/libs/waline.mjs.map","hash":"37c5b3e6aa5e1b70358426345a1a1329d6b896d3","modified":1746755907079},{"_id":"public/webfonts/fa-light-300.ttf","hash":"cc5d9f4f994c82e23f58cdde1eec8792d81633c7","modified":1746755907079},{"_id":"public/webfonts/fa-thin-100.ttf","hash":"c1fee6e6986b14533ce022afada5fbe10c0f6562","modified":1746755907079},{"_id":"public/webfonts/fa-duotone-900.ttf","hash":"e0313a772ea710cb5ea4bd08f5dedb0a0025f8ca","modified":1746755907079},{"_id":"public/img/Aniya.png","hash":"97b6ac6164cda9614d8a8abdcc1eb78c3bb38f41","modified":1746755907079},{"_id":"public/img/crypt_index.png","hash":"cbdb5c4cf5938dfb15001186a76e20e25e498122","modified":1746755907079},{"_id":"public/img/sun.png","hash":"fea6d5ddff389d6bc7e3cfb0ef1f8d768fdaf202","modified":1746755907079},{"_id":"public/img/db_index.png","hash":"a93dad5a557fbb0869d1570638b4d2aa00474ec8","modified":1746755907079},{"_id":"public/img/bgImg.png","hash":"8869c9029beef9c1240289e9fefc394972af5f64","modified":1746755907079},{"_id":"public/img/edit.gif","hash":"c546bb91850e8fb3161ac8ac31f5865ae68c40cf","modified":1746755907079},{"_id":"public/js/libs/mermaid.min.js.map","hash":"2e1a632f0588c4370188887d79a10ff8b38a49b5","modified":1746755907079},{"_id":"public/fonts/LXGWWenKaiGBScreen.ttf","hash":"e2139681d643e07e2ffb498fa3d656f6cba75afa","modified":1746755907079}],"Category":[{"name":"前后端开发","_id":"cmag5d8a800032xqgftg131vl"},{"name":"随机掉落的文字碎片","_id":"cmag5d8ae000f2xqg6j7xgg0i"},{"name":"学习笔记","_id":"cmag5d8ag000q2xqg4p8j6051"},{"name":"编程语言","_id":"cmag5d8ai00152xqg87m00t6g"},{"name":"学习笔记","parent":"cmag5d8ai00152xqg87m00t6g","_id":"cmag5d8ai001d2xqg4n0f15l5"}],"Data":[{"_id":"links","data":[{"links_category":null,"has_thumbnail":false,"list":[{"name":"Seele","link":"https://elysiafollower.github.io/","description":"在体力和智力上都是超人般的存在","avatar":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508221526599.png?imageSlim"}]}]},{"_id":"essays","data":[{"content":"第一条说说内容","date":"2019-01-01T10:00:00.000Z"},{"content":"第二条说说内容","date":"2019-01-02T10:00:00.000Z"}]}],"Page":[{"title":"categories","date":"2025-05-08T11:25:32.000Z","template":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2025-05-08 19:25:32\ntemplate: categories\n---\n","updated":"2025-05-08T11:25:40.266Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cmag5d8a300002xqghv4480su","content":"","excerpt":"","more":"","_processedHighlight":true},{"title":"essays","type":"shuoshuo","date":"2025-05-08T11:39:59.000Z","_content":"","source":"essays/index.md","raw":"---\ntitle: essays\ntype: shuoshuo\ndate: 2025-05-08 19:39:59\n---\n","updated":"2025-05-08T11:40:13.542Z","path":"essays/index.html","comments":1,"layout":"page","_id":"cmag5d8a700022xqg9mqnd5bg","content":"","excerpt":"","more":"","_processedHighlight":true},{"title":"Friends🫶🏻","date":"2025-05-08T11:15:51.000Z","template":"links","_content":"","source":"links/index.md","raw":"---\ntitle: Friends🫶🏻\ndate: 2025-05-08 19:15:51\ntemplate: links\n---\n","updated":"2025-05-09T01:58:07.263Z","path":"links/index.html","comments":1,"layout":"page","_id":"cmag5d8aa00052xqgby2u67pj","content":"","excerpt":"","more":"","_processedHighlight":true},{"_content":"/* 霞鹜文楷屏幕版 - 中文字体 */\n@font-face {\n  font-family: 'WenKai';\n  font-style: normal;\n  font-weight: normal;\n  src: url('/fonts/LXGWWenKaiGBScreen.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: normal;\n  font-weight: normal;\n  src: url('/fonts/MapleMono-Regular.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: italic;\n  font-weight: normal;\n  src: url('/fonts/MapleMono-Italic.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: normal;\n  font-weight: bold;\n  src: url('/fonts/MapleMono-Bold.ttf') format('truetype');\n  font-display: swap;\n}\n","source":"fonts/custom-fonts.css","raw":"/* 霞鹜文楷屏幕版 - 中文字体 */\n@font-face {\n  font-family: 'WenKai';\n  font-style: normal;\n  font-weight: normal;\n  src: url('/fonts/LXGWWenKaiGBScreen.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: normal;\n  font-weight: normal;\n  src: url('/fonts/MapleMono-Regular.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: italic;\n  font-weight: normal;\n  src: url('/fonts/MapleMono-Italic.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: normal;\n  font-weight: bold;\n  src: url('/fonts/MapleMono-Bold.ttf') format('truetype');\n  font-display: swap;\n}\n","date":"2025-05-08T12:38:03.703Z","updated":"2025-05-08T12:17:31.872Z","path":"fonts/custom-fonts.css","layout":"false","title":"","comments":1,"_id":"cmag5d8ab00062xqgekd6dgaz","content":"/* 霞鹜文楷屏幕版 - 中文字体 */\n@font-face {\n  font-family: 'WenKai';\n  font-style: normal;\n  font-weight: normal;\n  src: url('/fonts/LXGWWenKaiGBScreen.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: normal;\n  font-weight: normal;\n  src: url('/fonts/MapleMono-Regular.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: italic;\n  font-weight: normal;\n  src: url('/fonts/MapleMono-Italic.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'mono';\n  font-style: normal;\n  font-weight: bold;\n  src: url('/fonts/MapleMono-Bold.ttf') format('truetype');\n  font-display: swap;\n}\n"},{"title":"tags","date":"2025-05-08T11:22:04.000Z","template":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2025-05-08 19:22:04\ntemplate: tags\n---\n","updated":"2025-05-08T11:22:14.852Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cmag5d8ab00072xqg31hahg3g","content":"","excerpt":"","more":"","_processedHighlight":true},{"title":"masonry","date":"2025-05-08T11:26:38.000Z","template":"masonry","_content":"","source":"masonry/index.md","raw":"---\ntitle: masonry\ndate: 2025-05-08 19:26:38\ntemplate: masonry\n---\n","updated":"2025-05-08T11:26:47.234Z","path":"masonry/index.html","comments":1,"layout":"page","_id":"cmag5d8ab00092xqg8sp61tge","content":"","excerpt":"","more":"","_processedHighlight":true}],"Post":[{"title":"Prisma","date":"2025-04-28T06:00:00.000Z","excerpt":"在图书管理系统的后端中, 使用Prisma连接本地的sql数据库.","_content":"\n### Prisma 命令行相关\n\n#### 数据库迁移\n\n1. **创建并应用新的迁移**：\n   \n   ```bash\n   npx prisma migrate dev --name add_timestamps\n   ```\n   - 根据 `schema.prisma` 的更改生成迁移文件，并应用到数据库。\n   - `--name` 指定迁移的名称。\n   \n2. **重置并重新应用所有迁移**：\n   \n   ```bash\n   npx prisma migrate reset\n   ```\n   - 重置数据库并重新应用所有迁移，适用于开发环境。\n   \n3. **生成迁移文件但不应用**：\n   ```bash\n   npx prisma migrate dev --create-only\n   ```\n   - 生成迁移文件但不应用到数据库，可以手动修改迁移文件后再应用。\n\n4. **应用未应用的迁移**：\n   ```bash\n   npx prisma migrate deploy\n   ```\n   - 将未应用的迁移应用到生产环境。\n\n5. **查看迁移状态**：\n   ```bash\n   npx prisma migrate status\n   ```\n   - 查看当前数据库的迁移状态。\n   \n6. **回滚迁移状体**;\n\n   ```bash\n   npx prisma migrate resolve --rolled-back <migration_name>\n   ```\n\n   \n\n---\n\n#### 数据库操作\n\n1. **生成 Prisma 客户端**：\n   ```bash\n   npx prisma generate\n   ```\n   - 根据 `schema.prisma` 生成 Prisma 客户端代码。\n\n2. **推送 schema 到数据库（不生成迁移）**：\n   ```bash\n   npx prisma db push\n   ```\n   - 将 `schema.prisma` 的更改直接应用到数据库，不生成迁移文件。\n\n3. **查看数据库数据**：\n   ```bash\n   npx prisma studio\n   ```\n   - 启动 Prisma Studio，一个可视化工具，用于查看和操作数据库数据。\n\n---\n\n#### 数据操作\n\n1. **执行种子脚本**：\n   ```bash\n   npx prisma db seed\n   ```\n   - 运行 `prisma/seed.ts` 或 `prisma/seed.js` 脚本，用于填充数据库初始数据。\n\n2. **运行自定义脚本**：\n   ```bash\n   npx prisma execute --file ./scripts/my-script.ts\n   ```\n   - 执行自定义的 TypeScript 或 JavaScript 脚本。\n\n---\n\n#### 其他常用命令\n\n1. **初始化 Prisma**：\n   ```bash\n   npx prisma init\n   ```\n   - 初始化 Prisma，生成 `prisma/schema.prisma` 和 `.env` 文件。\n\n2. **格式化 `schema.prisma`**：\n   ```bash\n   npx prisma format\n   ```\n   - 格式化 `schema.prisma` 文件，使其更易读。\n\n3. **检查 Prisma 版本**：\n   ```bash\n   npx prisma --version\n   ```\n   - 查看当前安装的 Prisma 版本。\n\n4. **清理未使用的迁移文件**：\n   ```bash\n   npx prisma migrate resolve --applied \"20231010123456_add_timestamps\"\n   ```\n   - 标记迁移文件为已应用，用于修复迁移状态不一致的问题。\n\n---\n\n\n\n### 语言特性\n\nPrisma 中的关系定义需要双向声明\n\n- 在引用表中进行外键的声明\n\n  ```sql\n  model BorrowRecord {\n  \tbookId string \n  \tbook       Book       @relation(fields: [bookId], references: [id])\n  }\n  ```\n\n  > 表示当前表中的 `bookId`字段是被应用表 `Book` 的属性 `id`的外键.\n\n- 同时在被引用表中定义:\n\n  ```sql\n  model Book{\n    id             String         @id\n    borrowRecords  BorrowRecord[] // 添加反向关系\n  }\n  ```\n\n\n\n\n\n---\n\n### 使用TS交互客户端\n\nPrisma Client 是一个类型安全的数据库查询工具，它根据 `schema.prisma` 文件生成 TypeScript 类型定义和数据库操作 API。\n\n以下是其主要功能及代码示例。\n\n---\n\n#### 1. **初始化 Prisma Client**\n\n在使用 Prisma Client 之前，需要初始化一个 `PrismaClient` 实例。\n\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n```\n\n---\n\n#### 2. **查询数据**\n\n- **查询所有记录**\n\n使用 `findMany` 方法查询表中的所有记录。\n\n```typescript\nasync function getAllUsers() {\n  const users = await prisma.user.findMany();\n  console.log('All users:', users);\n}\n\ngetAllUsers();\n```\n\n- **查询单条记录**\n\n使用 `findUnique` 方法根据唯一条件查询单条记录。\n\n```typescript\nasync function getUserById(id: number) {\n  const user = await prisma.user.findUnique({\n    where: { id },\n  });\n  console.log('User:', user);\n}\n\ngetUserById(1);\n```\n\n- **条件查询**\n\n使用 `where` 条件过滤查询结果。\n\n```typescript\nasync function getUsersByName(name: string) {\n  const users = await prisma.user.findMany({\n    where: { name },\n  });\n  console.log('Users with name:', name, users);\n}\n\ngetUsersByName('Alice');\n```\n\n---\n\n#### 3. **创建数据**\n\n使用 `create` 方法插入新数据:\n\n```typescript\nasync function createUser(name: string, email: string) {\n  const newUser = await prisma.user.create({\n    data: {\n      name,\n      email,\n    },\n  });\n  console.log('Created new user:', newUser);\n}\n\ncreateUser('Bob', 'bob@example.com');\n```\n\n---\n\n#### 4. **更新数据**\n\n使用 `update` 方法修改现有数据。\n\n```typescript\nasync function updateUserEmail(id: number, newEmail: string) {\n  const updatedUser = await prisma.user.update({\n    where: { id },\n    data: { email: newEmail },\n  });\n  console.log('Updated user:', updatedUser);\n}\n\nupdateUserEmail(1, 'alice_new@example.com');\n```\n\n---\n\n#### 5. **删除数据**\n\n使用 `delete` 方法删除数据。\n\n```typescript\nasync function deleteUser(id: number) {\n  const deletedUser = await prisma.user.delete({\n    where: { id },\n  });\n  console.log('Deleted user:', deletedUser);\n}\n\ndeleteUser(1);\n```\n\n---\n\n#### 6. **关系查询**\n\n- **查询关联数据**\n\n使用 `include` 查询关联的模型数据。\n\n```typescript\nasync function getUserWithPosts(userId: number) {\n  const userWithPosts = await prisma.user.findUnique({\n    where: { id: userId },\n    include: { posts: true }, // 假设 User 模型与 Post 模型有关联\n  });\n  console.log('User with posts:', userWithPosts);\n}\n\ngetUserWithPosts(1);\n```\n\n- **嵌套查询**\n\n支持嵌套查询关联数据。\n\n```typescript\nasync function getPostWithAuthor(postId: number) {\n  const postWithAuthor = await prisma.post.findUnique({\n    where: { id: postId },\n    include: { author: true }, // 假设 Post 模型与 User 模型有关联\n  });\n  console.log('Post with author:', postWithAuthor);\n}\n\ngetPostWithAuthor(1);\n```\n\n---\n\n#### 7. **分页查询**\n\n使用 `skip` 和 `take` 实现分页查询。\n\n```typescript\nasync function getUsersPaginated(page: number, pageSize: number) {\n  const users = await prisma.user.findMany({\n    skip: (page - 1) * pageSize,\n    take: pageSize,\n  });\n  console.log('Paginated users:', users);\n}\n\ngetUsersPaginated(1, 10); // 查询第 1 页，每页 10 条记录\n```\n\n---\n\n#### 8. **排序查询**\n\n使用 `orderBy` 对查询结果排序。\n\n```typescript\nasync function getUsersSortedByName() {\n  const users = await prisma.user.findMany({\n    orderBy: { name: 'asc' }, // 按 name 字段升序排序\n  });\n  console.log('Sorted users:', users);\n}\n\ngetUsersSortedByName();\n```\n\n---\n\n#### 9. **聚合查询**\n\n使用 `count`、`sum`、`avg` 等聚合函数。\n\n- **统计记录数**\n\n```typescript\nasync function countUsers() {\n  const userCount = await prisma.user.count();\n  console.log('Total users:', userCount);\n}\n\ncountUsers();\n```\n\n- **计算字段平均值**\n\n```typescript\nasync function averageUserAge() {\n  const avgAge = await prisma.user.aggregate({\n    _avg: { age: true }, // 假设 User 模型有 age 字段\n  });\n  console.log('Average user age:', avgAge._avg.age);\n}\n\naverageUserAge();\n```\n\n---\n\n#### 10. **事务操作**\n\n使用 `$transaction` 执行事务操作。\n\n```typescript\nasync function transferBalance(fromId: number, toId: number, amount: number) {\n  await prisma.$transaction([\n    prisma.user.update({\n      where: { id: fromId },\n      data: { balance: { decrement: amount } }, // 假设 User 模型有 balance 字段\n    }),\n    prisma.user.update({\n      where: { id: toId },\n      data: { balance: { increment: amount } },\n    }),\n  ]);\n  console.log('Balance transfer completed');\n}\n\ntransferBalance(1, 2, 100);\n```\n\n---\n\n#### 11. **关闭 Prisma Client**\n\n在程序结束时，关闭 Prisma Client 以释放数据库连接。\n\n```typescript\nasync function main() {\n  // 数据库操作代码\n}\n\nmain()\n  .catch(e => {\n    console.error(e);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n```\n\n---\n\n","source":"_posts/Prisma.md","raw":"---\ntitle: Prisma\ndate: 2025-04-28 14:00\ntags: 数据库\ncategories: 前后端开发\nexcerpt: 在图书管理系统的后端中, 使用Prisma连接本地的sql数据库.\n---\n\n### Prisma 命令行相关\n\n#### 数据库迁移\n\n1. **创建并应用新的迁移**：\n   \n   ```bash\n   npx prisma migrate dev --name add_timestamps\n   ```\n   - 根据 `schema.prisma` 的更改生成迁移文件，并应用到数据库。\n   - `--name` 指定迁移的名称。\n   \n2. **重置并重新应用所有迁移**：\n   \n   ```bash\n   npx prisma migrate reset\n   ```\n   - 重置数据库并重新应用所有迁移，适用于开发环境。\n   \n3. **生成迁移文件但不应用**：\n   ```bash\n   npx prisma migrate dev --create-only\n   ```\n   - 生成迁移文件但不应用到数据库，可以手动修改迁移文件后再应用。\n\n4. **应用未应用的迁移**：\n   ```bash\n   npx prisma migrate deploy\n   ```\n   - 将未应用的迁移应用到生产环境。\n\n5. **查看迁移状态**：\n   ```bash\n   npx prisma migrate status\n   ```\n   - 查看当前数据库的迁移状态。\n   \n6. **回滚迁移状体**;\n\n   ```bash\n   npx prisma migrate resolve --rolled-back <migration_name>\n   ```\n\n   \n\n---\n\n#### 数据库操作\n\n1. **生成 Prisma 客户端**：\n   ```bash\n   npx prisma generate\n   ```\n   - 根据 `schema.prisma` 生成 Prisma 客户端代码。\n\n2. **推送 schema 到数据库（不生成迁移）**：\n   ```bash\n   npx prisma db push\n   ```\n   - 将 `schema.prisma` 的更改直接应用到数据库，不生成迁移文件。\n\n3. **查看数据库数据**：\n   ```bash\n   npx prisma studio\n   ```\n   - 启动 Prisma Studio，一个可视化工具，用于查看和操作数据库数据。\n\n---\n\n#### 数据操作\n\n1. **执行种子脚本**：\n   ```bash\n   npx prisma db seed\n   ```\n   - 运行 `prisma/seed.ts` 或 `prisma/seed.js` 脚本，用于填充数据库初始数据。\n\n2. **运行自定义脚本**：\n   ```bash\n   npx prisma execute --file ./scripts/my-script.ts\n   ```\n   - 执行自定义的 TypeScript 或 JavaScript 脚本。\n\n---\n\n#### 其他常用命令\n\n1. **初始化 Prisma**：\n   ```bash\n   npx prisma init\n   ```\n   - 初始化 Prisma，生成 `prisma/schema.prisma` 和 `.env` 文件。\n\n2. **格式化 `schema.prisma`**：\n   ```bash\n   npx prisma format\n   ```\n   - 格式化 `schema.prisma` 文件，使其更易读。\n\n3. **检查 Prisma 版本**：\n   ```bash\n   npx prisma --version\n   ```\n   - 查看当前安装的 Prisma 版本。\n\n4. **清理未使用的迁移文件**：\n   ```bash\n   npx prisma migrate resolve --applied \"20231010123456_add_timestamps\"\n   ```\n   - 标记迁移文件为已应用，用于修复迁移状态不一致的问题。\n\n---\n\n\n\n### 语言特性\n\nPrisma 中的关系定义需要双向声明\n\n- 在引用表中进行外键的声明\n\n  ```sql\n  model BorrowRecord {\n  \tbookId string \n  \tbook       Book       @relation(fields: [bookId], references: [id])\n  }\n  ```\n\n  > 表示当前表中的 `bookId`字段是被应用表 `Book` 的属性 `id`的外键.\n\n- 同时在被引用表中定义:\n\n  ```sql\n  model Book{\n    id             String         @id\n    borrowRecords  BorrowRecord[] // 添加反向关系\n  }\n  ```\n\n\n\n\n\n---\n\n### 使用TS交互客户端\n\nPrisma Client 是一个类型安全的数据库查询工具，它根据 `schema.prisma` 文件生成 TypeScript 类型定义和数据库操作 API。\n\n以下是其主要功能及代码示例。\n\n---\n\n#### 1. **初始化 Prisma Client**\n\n在使用 Prisma Client 之前，需要初始化一个 `PrismaClient` 实例。\n\n```typescript\nimport { PrismaClient } from '@prisma/client';\n\nconst prisma = new PrismaClient();\n```\n\n---\n\n#### 2. **查询数据**\n\n- **查询所有记录**\n\n使用 `findMany` 方法查询表中的所有记录。\n\n```typescript\nasync function getAllUsers() {\n  const users = await prisma.user.findMany();\n  console.log('All users:', users);\n}\n\ngetAllUsers();\n```\n\n- **查询单条记录**\n\n使用 `findUnique` 方法根据唯一条件查询单条记录。\n\n```typescript\nasync function getUserById(id: number) {\n  const user = await prisma.user.findUnique({\n    where: { id },\n  });\n  console.log('User:', user);\n}\n\ngetUserById(1);\n```\n\n- **条件查询**\n\n使用 `where` 条件过滤查询结果。\n\n```typescript\nasync function getUsersByName(name: string) {\n  const users = await prisma.user.findMany({\n    where: { name },\n  });\n  console.log('Users with name:', name, users);\n}\n\ngetUsersByName('Alice');\n```\n\n---\n\n#### 3. **创建数据**\n\n使用 `create` 方法插入新数据:\n\n```typescript\nasync function createUser(name: string, email: string) {\n  const newUser = await prisma.user.create({\n    data: {\n      name,\n      email,\n    },\n  });\n  console.log('Created new user:', newUser);\n}\n\ncreateUser('Bob', 'bob@example.com');\n```\n\n---\n\n#### 4. **更新数据**\n\n使用 `update` 方法修改现有数据。\n\n```typescript\nasync function updateUserEmail(id: number, newEmail: string) {\n  const updatedUser = await prisma.user.update({\n    where: { id },\n    data: { email: newEmail },\n  });\n  console.log('Updated user:', updatedUser);\n}\n\nupdateUserEmail(1, 'alice_new@example.com');\n```\n\n---\n\n#### 5. **删除数据**\n\n使用 `delete` 方法删除数据。\n\n```typescript\nasync function deleteUser(id: number) {\n  const deletedUser = await prisma.user.delete({\n    where: { id },\n  });\n  console.log('Deleted user:', deletedUser);\n}\n\ndeleteUser(1);\n```\n\n---\n\n#### 6. **关系查询**\n\n- **查询关联数据**\n\n使用 `include` 查询关联的模型数据。\n\n```typescript\nasync function getUserWithPosts(userId: number) {\n  const userWithPosts = await prisma.user.findUnique({\n    where: { id: userId },\n    include: { posts: true }, // 假设 User 模型与 Post 模型有关联\n  });\n  console.log('User with posts:', userWithPosts);\n}\n\ngetUserWithPosts(1);\n```\n\n- **嵌套查询**\n\n支持嵌套查询关联数据。\n\n```typescript\nasync function getPostWithAuthor(postId: number) {\n  const postWithAuthor = await prisma.post.findUnique({\n    where: { id: postId },\n    include: { author: true }, // 假设 Post 模型与 User 模型有关联\n  });\n  console.log('Post with author:', postWithAuthor);\n}\n\ngetPostWithAuthor(1);\n```\n\n---\n\n#### 7. **分页查询**\n\n使用 `skip` 和 `take` 实现分页查询。\n\n```typescript\nasync function getUsersPaginated(page: number, pageSize: number) {\n  const users = await prisma.user.findMany({\n    skip: (page - 1) * pageSize,\n    take: pageSize,\n  });\n  console.log('Paginated users:', users);\n}\n\ngetUsersPaginated(1, 10); // 查询第 1 页，每页 10 条记录\n```\n\n---\n\n#### 8. **排序查询**\n\n使用 `orderBy` 对查询结果排序。\n\n```typescript\nasync function getUsersSortedByName() {\n  const users = await prisma.user.findMany({\n    orderBy: { name: 'asc' }, // 按 name 字段升序排序\n  });\n  console.log('Sorted users:', users);\n}\n\ngetUsersSortedByName();\n```\n\n---\n\n#### 9. **聚合查询**\n\n使用 `count`、`sum`、`avg` 等聚合函数。\n\n- **统计记录数**\n\n```typescript\nasync function countUsers() {\n  const userCount = await prisma.user.count();\n  console.log('Total users:', userCount);\n}\n\ncountUsers();\n```\n\n- **计算字段平均值**\n\n```typescript\nasync function averageUserAge() {\n  const avgAge = await prisma.user.aggregate({\n    _avg: { age: true }, // 假设 User 模型有 age 字段\n  });\n  console.log('Average user age:', avgAge._avg.age);\n}\n\naverageUserAge();\n```\n\n---\n\n#### 10. **事务操作**\n\n使用 `$transaction` 执行事务操作。\n\n```typescript\nasync function transferBalance(fromId: number, toId: number, amount: number) {\n  await prisma.$transaction([\n    prisma.user.update({\n      where: { id: fromId },\n      data: { balance: { decrement: amount } }, // 假设 User 模型有 balance 字段\n    }),\n    prisma.user.update({\n      where: { id: toId },\n      data: { balance: { increment: amount } },\n    }),\n  ]);\n  console.log('Balance transfer completed');\n}\n\ntransferBalance(1, 2, 100);\n```\n\n---\n\n#### 11. **关闭 Prisma Client**\n\n在程序结束时，关闭 Prisma Client 以释放数据库连接。\n\n```typescript\nasync function main() {\n  // 数据库操作代码\n}\n\nmain()\n  .catch(e => {\n    console.error(e);\n  })\n  .finally(async () => {\n    await prisma.$disconnect();\n  });\n```\n\n---\n\n","slug":"Prisma","published":1,"updated":"2025-05-08T15:31:52.460Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8a600012xqg6r8phc1l","content":"<h3 id=\"Prisma-命令行相关\"><a href=\"#Prisma-命令行相关\" class=\"headerlink\" title=\"Prisma 命令行相关\"></a>Prisma 命令行相关</h3><h4 id=\"数据库迁移\"><a href=\"#数据库迁移\" class=\"headerlink\" title=\"数据库迁移\"></a>数据库迁移</h4><ol>\n<li><p><strong>创建并应用新的迁移</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate dev --name add_timestamps</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>根据 <code>schema.prisma</code> 的更改生成迁移文件，并应用到数据库。</li>\n<li><code>--name</code> 指定迁移的名称。</li>\n</ul>\n</li>\n<li><p><strong>重置并重新应用所有迁移</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate reset</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>重置数据库并重新应用所有迁移，适用于开发环境。</li>\n</ul>\n</li>\n<li><p><strong>生成迁移文件但不应用</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate dev --create-only</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>生成迁移文件但不应用到数据库，可以手动修改迁移文件后再应用。</li>\n</ul>\n</li>\n<li><p><strong>应用未应用的迁移</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate deploy</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>将未应用的迁移应用到生产环境。</li>\n</ul>\n</li>\n<li><p><strong>查看迁移状态</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate status</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>查看当前数据库的迁移状态。</li>\n</ul>\n</li>\n<li><p><strong>回滚迁移状体</strong>;</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate resolve --rolled-back &lt;migration_name&gt;</span><br></pre></td></tr></table></figure></div></li>\n</ol>\n<hr>\n<h4 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h4><ol>\n<li><p><strong>生成 Prisma 客户端</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma generate</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>根据 <code>schema.prisma</code> 生成 Prisma 客户端代码。</li>\n</ul>\n</li>\n<li><p><strong>推送 schema 到数据库（不生成迁移）</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma db push</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>将 <code>schema.prisma</code> 的更改直接应用到数据库，不生成迁移文件。</li>\n</ul>\n</li>\n<li><p><strong>查看数据库数据</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma studio</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>启动 Prisma Studio，一个可视化工具，用于查看和操作数据库数据。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"数据操作\"><a href=\"#数据操作\" class=\"headerlink\" title=\"数据操作\"></a>数据操作</h4><ol>\n<li><p><strong>执行种子脚本</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma db seed</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>运行 <code>prisma/seed.ts</code> 或 <code>prisma/seed.js</code> 脚本，用于填充数据库初始数据。</li>\n</ul>\n</li>\n<li><p><strong>运行自定义脚本</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma execute --file ./scripts/my-script.ts</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>执行自定义的 TypeScript 或 JavaScript 脚本。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"其他常用命令\"><a href=\"#其他常用命令\" class=\"headerlink\" title=\"其他常用命令\"></a>其他常用命令</h4><ol>\n<li><p><strong>初始化 Prisma</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma init</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>初始化 Prisma，生成 <code>prisma/schema.prisma</code> 和 <code>.env</code> 文件。</li>\n</ul>\n</li>\n<li><p><strong>格式化 <code>schema.prisma</code></strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma format</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>格式化 <code>schema.prisma</code> 文件，使其更易读。</li>\n</ul>\n</li>\n<li><p><strong>检查 Prisma 版本</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma --version</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>查看当前安装的 Prisma 版本。</li>\n</ul>\n</li>\n<li><p><strong>清理未使用的迁移文件</strong>：</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate resolve --applied <span class=\"string\">&quot;20231010123456_add_timestamps&quot;</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>标记迁移文件为已应用，用于修复迁移状态不一致的问题。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"语言特性\"><a href=\"#语言特性\" class=\"headerlink\" title=\"语言特性\"></a>语言特性</h3><p>Prisma 中的关系定义需要双向声明</p>\n<ul>\n<li><p>在引用表中进行外键的声明</p>\n<div class=\"code-container\" data-rel=\"Sql\"><figure class=\"iseeu highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model BorrowRecord &#123;</span><br><span class=\"line\">\tbookId string </span><br><span class=\"line\">\tbook       Book       <span class=\"variable\">@relation</span>(fields: [bookId], <span class=\"keyword\">references</span>: [id])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>表示当前表中的 <code>bookId</code>字段是被应用表 <code>Book</code> 的属性 <code>id</code>的外键.</p>\n</blockquote>\n</li>\n<li><p>同时在被引用表中定义:</p>\n<div class=\"code-container\" data-rel=\"Sql\"><figure class=\"iseeu highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model Book&#123;</span><br><span class=\"line\">  id             String         <span class=\"variable\">@id</span></span><br><span class=\"line\">  borrowRecords  BorrowRecord[] <span class=\"operator\">/</span><span class=\"operator\">/</span> 添加反向关系</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<hr>\n<h3 id=\"使用TS交互客户端\"><a href=\"#使用TS交互客户端\" class=\"headerlink\" title=\"使用TS交互客户端\"></a>使用TS交互客户端</h3><p>Prisma Client 是一个类型安全的数据库查询工具，它根据 <code>schema.prisma</code> 文件生成 TypeScript 类型定义和数据库操作 API。</p>\n<p>以下是其主要功能及代码示例。</p>\n<hr>\n<h4 id=\"1-初始化-Prisma-Client\"><a href=\"#1-初始化-Prisma-Client\" class=\"headerlink\" title=\"1. 初始化 Prisma Client\"></a>1. <strong>初始化 Prisma Client</strong></h4><p>在使用 Prisma Client 之前，需要初始化一个 <code>PrismaClient</code> 实例。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">PrismaClient</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@prisma/client&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> prisma = <span class=\"keyword\">new</span> <span class=\"title class_\">PrismaClient</span>();</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"2-查询数据\"><a href=\"#2-查询数据\" class=\"headerlink\" title=\"2. 查询数据\"></a>2. <strong>查询数据</strong></h4><ul>\n<li><strong>查询所有记录</strong></li>\n</ul>\n<p>使用 <code>findMany</code> 方法查询表中的所有记录。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getAllUsers</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findMany</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;All users:&#x27;</span>, users);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getAllUsers</span>();</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>查询单条记录</strong></li>\n</ul>\n<p>使用 <code>findUnique</code> 方法根据唯一条件查询单条记录。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUserById</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findUnique</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; id &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;User:&#x27;</span>, user);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUserById</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>条件查询</strong></li>\n</ul>\n<p>使用 <code>where</code> 条件过滤查询结果。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUsersByName</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findMany</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; name &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Users with name:&#x27;</span>, name, users);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUsersByName</span>(<span class=\"string\">&#x27;Alice&#x27;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"3-创建数据\"><a href=\"#3-创建数据\" class=\"headerlink\" title=\"3. 创建数据\"></a>3. <strong>创建数据</strong></h4><p>使用 <code>create</code> 方法插入新数据:</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createUser</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">email</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newUser = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">      name,</span><br><span class=\"line\">      email,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Created new user:&#x27;</span>, newUser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">createUser</span>(<span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;bob@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"4-更新数据\"><a href=\"#4-更新数据\" class=\"headerlink\" title=\"4. 更新数据\"></a>4. <strong>更新数据</strong></h4><p>使用 <code>update</code> 方法修改现有数据。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">updateUserEmail</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">newEmail</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> updatedUser = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">update</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; id &#125;,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123; <span class=\"attr\">email</span>: newEmail &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Updated user:&#x27;</span>, updatedUser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">updateUserEmail</span>(<span class=\"number\">1</span>, <span class=\"string\">&#x27;alice_new@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"5-删除数据\"><a href=\"#5-删除数据\" class=\"headerlink\" title=\"5. 删除数据\"></a>5. <strong>删除数据</strong></h4><p>使用 <code>delete</code> 方法删除数据。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">deleteUser</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> deletedUser = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">delete</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; id &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Deleted user:&#x27;</span>, deletedUser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">deleteUser</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"6-关系查询\"><a href=\"#6-关系查询\" class=\"headerlink\" title=\"6. 关系查询\"></a>6. <strong>关系查询</strong></h4><ul>\n<li><strong>查询关联数据</strong></li>\n</ul>\n<p>使用 <code>include</code> 查询关联的模型数据。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUserWithPosts</span>(<span class=\"params\"><span class=\"attr\">userId</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userWithPosts = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findUnique</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; <span class=\"attr\">id</span>: userId &#125;,</span><br><span class=\"line\">    <span class=\"attr\">include</span>: &#123; <span class=\"attr\">posts</span>: <span class=\"literal\">true</span> &#125;, <span class=\"comment\">// 假设 User 模型与 Post 模型有关联</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;User with posts:&#x27;</span>, userWithPosts);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUserWithPosts</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>嵌套查询</strong></li>\n</ul>\n<p>支持嵌套查询关联数据。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getPostWithAuthor</span>(<span class=\"params\"><span class=\"attr\">postId</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> postWithAuthor = <span class=\"keyword\">await</span> prisma.<span class=\"property\">post</span>.<span class=\"title function_\">findUnique</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; <span class=\"attr\">id</span>: postId &#125;,</span><br><span class=\"line\">    <span class=\"attr\">include</span>: &#123; <span class=\"attr\">author</span>: <span class=\"literal\">true</span> &#125;, <span class=\"comment\">// 假设 Post 模型与 User 模型有关联</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Post with author:&#x27;</span>, postWithAuthor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getPostWithAuthor</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"7-分页查询\"><a href=\"#7-分页查询\" class=\"headerlink\" title=\"7. 分页查询\"></a>7. <strong>分页查询</strong></h4><p>使用 <code>skip</code> 和 <code>take</code> 实现分页查询。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUsersPaginated</span>(<span class=\"params\"><span class=\"attr\">page</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">pageSize</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findMany</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">skip</span>: (page - <span class=\"number\">1</span>) * pageSize,</span><br><span class=\"line\">    <span class=\"attr\">take</span>: pageSize,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Paginated users:&#x27;</span>, users);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUsersPaginated</span>(<span class=\"number\">1</span>, <span class=\"number\">10</span>); <span class=\"comment\">// 查询第 1 页，每页 10 条记录</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"8-排序查询\"><a href=\"#8-排序查询\" class=\"headerlink\" title=\"8. 排序查询\"></a>8. <strong>排序查询</strong></h4><p>使用 <code>orderBy</code> 对查询结果排序。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUsersSortedByName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findMany</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">orderBy</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;asc&#x27;</span> &#125;, <span class=\"comment\">// 按 name 字段升序排序</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Sorted users:&#x27;</span>, users);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUsersSortedByName</span>();</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"9-聚合查询\"><a href=\"#9-聚合查询\" class=\"headerlink\" title=\"9. 聚合查询\"></a>9. <strong>聚合查询</strong></h4><p>使用 <code>count</code>、<code>sum</code>、<code>avg</code> 等聚合函数。</p>\n<ul>\n<li><strong>统计记录数</strong></li>\n</ul>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">countUsers</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userCount = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">count</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Total users:&#x27;</span>, userCount);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">countUsers</span>();</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><strong>计算字段平均值</strong></li>\n</ul>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">averageUserAge</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> avgAge = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">aggregate</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">_avg</span>: &#123; <span class=\"attr\">age</span>: <span class=\"literal\">true</span> &#125;, <span class=\"comment\">// 假设 User 模型有 age 字段</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Average user age:&#x27;</span>, avgAge.<span class=\"property\">_avg</span>.<span class=\"property\">age</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">averageUserAge</span>();</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"10-事务操作\"><a href=\"#10-事务操作\" class=\"headerlink\" title=\"10. 事务操作\"></a>10. <strong>事务操作</strong></h4><p>使用 <code>$transaction</code> 执行事务操作。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">transferBalance</span>(<span class=\"params\"><span class=\"attr\">fromId</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">toId</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">amount</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> prisma.$transaction([</span><br><span class=\"line\">    prisma.<span class=\"property\">user</span>.<span class=\"title function_\">update</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123; <span class=\"attr\">id</span>: fromId &#125;,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: &#123; <span class=\"attr\">balance</span>: &#123; <span class=\"attr\">decrement</span>: amount &#125; &#125;, <span class=\"comment\">// 假设 User 模型有 balance 字段</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    prisma.<span class=\"property\">user</span>.<span class=\"title function_\">update</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123; <span class=\"attr\">id</span>: toId &#125;,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: &#123; <span class=\"attr\">balance</span>: &#123; <span class=\"attr\">increment</span>: amount &#125; &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Balance transfer completed&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">transferBalance</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"11-关闭-Prisma-Client\"><a href=\"#11-关闭-Prisma-Client\" class=\"headerlink\" title=\"11. 关闭 Prisma Client\"></a>11. <strong>关闭 Prisma Client</strong></h4><p>在程序结束时，关闭 Prisma Client 以释放数据库连接。</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 数据库操作代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">main</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(e);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">finally</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> prisma.$disconnect();</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n","more":"<h3 id=\"Prisma-命令行相关\"><a href=\"#Prisma-命令行相关\" class=\"headerlink\" title=\"Prisma 命令行相关\"></a>Prisma 命令行相关</h3><h4 id=\"数据库迁移\"><a href=\"#数据库迁移\" class=\"headerlink\" title=\"数据库迁移\"></a>数据库迁移</h4><ol>\n<li><p><strong>创建并应用新的迁移</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate dev --name add_timestamps</span><br></pre></td></tr></table></figure>\n<ul>\n<li>根据 <code>schema.prisma</code> 的更改生成迁移文件，并应用到数据库。</li>\n<li><code>--name</code> 指定迁移的名称。</li>\n</ul>\n</li>\n<li><p><strong>重置并重新应用所有迁移</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate reset</span><br></pre></td></tr></table></figure>\n<ul>\n<li>重置数据库并重新应用所有迁移，适用于开发环境。</li>\n</ul>\n</li>\n<li><p><strong>生成迁移文件但不应用</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate dev --create-only</span><br></pre></td></tr></table></figure>\n<ul>\n<li>生成迁移文件但不应用到数据库，可以手动修改迁移文件后再应用。</li>\n</ul>\n</li>\n<li><p><strong>应用未应用的迁移</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate deploy</span><br></pre></td></tr></table></figure>\n<ul>\n<li>将未应用的迁移应用到生产环境。</li>\n</ul>\n</li>\n<li><p><strong>查看迁移状态</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate status</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看当前数据库的迁移状态。</li>\n</ul>\n</li>\n<li><p><strong>回滚迁移状体</strong>;</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate resolve --rolled-back &lt;migration_name&gt;</span><br></pre></td></tr></table></figure></li>\n</ol>\n<hr>\n<h4 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h4><ol>\n<li><p><strong>生成 Prisma 客户端</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma generate</span><br></pre></td></tr></table></figure>\n<ul>\n<li>根据 <code>schema.prisma</code> 生成 Prisma 客户端代码。</li>\n</ul>\n</li>\n<li><p><strong>推送 schema 到数据库（不生成迁移）</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma db push</span><br></pre></td></tr></table></figure>\n<ul>\n<li>将 <code>schema.prisma</code> 的更改直接应用到数据库，不生成迁移文件。</li>\n</ul>\n</li>\n<li><p><strong>查看数据库数据</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma studio</span><br></pre></td></tr></table></figure>\n<ul>\n<li>启动 Prisma Studio，一个可视化工具，用于查看和操作数据库数据。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"数据操作\"><a href=\"#数据操作\" class=\"headerlink\" title=\"数据操作\"></a>数据操作</h4><ol>\n<li><p><strong>执行种子脚本</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma db seed</span><br></pre></td></tr></table></figure>\n<ul>\n<li>运行 <code>prisma/seed.ts</code> 或 <code>prisma/seed.js</code> 脚本，用于填充数据库初始数据。</li>\n</ul>\n</li>\n<li><p><strong>运行自定义脚本</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma execute --file ./scripts/my-script.ts</span><br></pre></td></tr></table></figure>\n<ul>\n<li>执行自定义的 TypeScript 或 JavaScript 脚本。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h4 id=\"其他常用命令\"><a href=\"#其他常用命令\" class=\"headerlink\" title=\"其他常用命令\"></a>其他常用命令</h4><ol>\n<li><p><strong>初始化 Prisma</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma init</span><br></pre></td></tr></table></figure>\n<ul>\n<li>初始化 Prisma，生成 <code>prisma/schema.prisma</code> 和 <code>.env</code> 文件。</li>\n</ul>\n</li>\n<li><p><strong>格式化 <code>schema.prisma</code></strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma format</span><br></pre></td></tr></table></figure>\n<ul>\n<li>格式化 <code>schema.prisma</code> 文件，使其更易读。</li>\n</ul>\n</li>\n<li><p><strong>检查 Prisma 版本</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma --version</span><br></pre></td></tr></table></figure>\n<ul>\n<li>查看当前安装的 Prisma 版本。</li>\n</ul>\n</li>\n<li><p><strong>清理未使用的迁移文件</strong>：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx prisma migrate resolve --applied <span class=\"string\">&quot;20231010123456_add_timestamps&quot;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>标记迁移文件为已应用，用于修复迁移状态不一致的问题。</li>\n</ul>\n</li>\n</ol>\n<hr>\n<h3 id=\"语言特性\"><a href=\"#语言特性\" class=\"headerlink\" title=\"语言特性\"></a>语言特性</h3><p>Prisma 中的关系定义需要双向声明</p>\n<ul>\n<li><p>在引用表中进行外键的声明</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model BorrowRecord &#123;</span><br><span class=\"line\">\tbookId string </span><br><span class=\"line\">\tbook       Book       <span class=\"variable\">@relation</span>(fields: [bookId], <span class=\"keyword\">references</span>: [id])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>表示当前表中的 <code>bookId</code>字段是被应用表 <code>Book</code> 的属性 <code>id</code>的外键.</p>\n</blockquote>\n</li>\n<li><p>同时在被引用表中定义:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model Book&#123;</span><br><span class=\"line\">  id             String         <span class=\"variable\">@id</span></span><br><span class=\"line\">  borrowRecords  BorrowRecord[] <span class=\"operator\">/</span><span class=\"operator\">/</span> 添加反向关系</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"使用TS交互客户端\"><a href=\"#使用TS交互客户端\" class=\"headerlink\" title=\"使用TS交互客户端\"></a>使用TS交互客户端</h3><p>Prisma Client 是一个类型安全的数据库查询工具，它根据 <code>schema.prisma</code> 文件生成 TypeScript 类型定义和数据库操作 API。</p>\n<p>以下是其主要功能及代码示例。</p>\n<hr>\n<h4 id=\"1-初始化-Prisma-Client\"><a href=\"#1-初始化-Prisma-Client\" class=\"headerlink\" title=\"1. 初始化 Prisma Client\"></a>1. <strong>初始化 Prisma Client</strong></h4><p>在使用 Prisma Client 之前，需要初始化一个 <code>PrismaClient</code> 实例。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; <span class=\"title class_\">PrismaClient</span> &#125; <span class=\"keyword\">from</span> <span class=\"string\">&#x27;@prisma/client&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> prisma = <span class=\"keyword\">new</span> <span class=\"title class_\">PrismaClient</span>();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"2-查询数据\"><a href=\"#2-查询数据\" class=\"headerlink\" title=\"2. 查询数据\"></a>2. <strong>查询数据</strong></h4><ul>\n<li><strong>查询所有记录</strong></li>\n</ul>\n<p>使用 <code>findMany</code> 方法查询表中的所有记录。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getAllUsers</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findMany</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;All users:&#x27;</span>, users);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getAllUsers</span>();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>查询单条记录</strong></li>\n</ul>\n<p>使用 <code>findUnique</code> 方法根据唯一条件查询单条记录。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUserById</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> user = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findUnique</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; id &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;User:&#x27;</span>, user);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUserById</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>条件查询</strong></li>\n</ul>\n<p>使用 <code>where</code> 条件过滤查询结果。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUsersByName</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findMany</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; name &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Users with name:&#x27;</span>, name, users);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUsersByName</span>(<span class=\"string\">&#x27;Alice&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"3-创建数据\"><a href=\"#3-创建数据\" class=\"headerlink\" title=\"3. 创建数据\"></a>3. <strong>创建数据</strong></h4><p>使用 <code>create</code> 方法插入新数据:</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">createUser</span>(<span class=\"params\"><span class=\"attr\">name</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">email</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newUser = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">create</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123;</span><br><span class=\"line\">      name,</span><br><span class=\"line\">      email,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Created new user:&#x27;</span>, newUser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">createUser</span>(<span class=\"string\">&#x27;Bob&#x27;</span>, <span class=\"string\">&#x27;bob@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"4-更新数据\"><a href=\"#4-更新数据\" class=\"headerlink\" title=\"4. 更新数据\"></a>4. <strong>更新数据</strong></h4><p>使用 <code>update</code> 方法修改现有数据。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">updateUserEmail</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">newEmail</span>: <span class=\"built_in\">string</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> updatedUser = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">update</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; id &#125;,</span><br><span class=\"line\">    <span class=\"attr\">data</span>: &#123; <span class=\"attr\">email</span>: newEmail &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Updated user:&#x27;</span>, updatedUser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">updateUserEmail</span>(<span class=\"number\">1</span>, <span class=\"string\">&#x27;alice_new@example.com&#x27;</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"5-删除数据\"><a href=\"#5-删除数据\" class=\"headerlink\" title=\"5. 删除数据\"></a>5. <strong>删除数据</strong></h4><p>使用 <code>delete</code> 方法删除数据。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">deleteUser</span>(<span class=\"params\"><span class=\"attr\">id</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> deletedUser = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">delete</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; id &#125;,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Deleted user:&#x27;</span>, deletedUser);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">deleteUser</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"6-关系查询\"><a href=\"#6-关系查询\" class=\"headerlink\" title=\"6. 关系查询\"></a>6. <strong>关系查询</strong></h4><ul>\n<li><strong>查询关联数据</strong></li>\n</ul>\n<p>使用 <code>include</code> 查询关联的模型数据。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUserWithPosts</span>(<span class=\"params\"><span class=\"attr\">userId</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userWithPosts = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findUnique</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; <span class=\"attr\">id</span>: userId &#125;,</span><br><span class=\"line\">    <span class=\"attr\">include</span>: &#123; <span class=\"attr\">posts</span>: <span class=\"literal\">true</span> &#125;, <span class=\"comment\">// 假设 User 模型与 Post 模型有关联</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;User with posts:&#x27;</span>, userWithPosts);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUserWithPosts</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>嵌套查询</strong></li>\n</ul>\n<p>支持嵌套查询关联数据。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getPostWithAuthor</span>(<span class=\"params\"><span class=\"attr\">postId</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> postWithAuthor = <span class=\"keyword\">await</span> prisma.<span class=\"property\">post</span>.<span class=\"title function_\">findUnique</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">where</span>: &#123; <span class=\"attr\">id</span>: postId &#125;,</span><br><span class=\"line\">    <span class=\"attr\">include</span>: &#123; <span class=\"attr\">author</span>: <span class=\"literal\">true</span> &#125;, <span class=\"comment\">// 假设 Post 模型与 User 模型有关联</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Post with author:&#x27;</span>, postWithAuthor);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getPostWithAuthor</span>(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"7-分页查询\"><a href=\"#7-分页查询\" class=\"headerlink\" title=\"7. 分页查询\"></a>7. <strong>分页查询</strong></h4><p>使用 <code>skip</code> 和 <code>take</code> 实现分页查询。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUsersPaginated</span>(<span class=\"params\"><span class=\"attr\">page</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">pageSize</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findMany</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">skip</span>: (page - <span class=\"number\">1</span>) * pageSize,</span><br><span class=\"line\">    <span class=\"attr\">take</span>: pageSize,</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Paginated users:&#x27;</span>, users);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUsersPaginated</span>(<span class=\"number\">1</span>, <span class=\"number\">10</span>); <span class=\"comment\">// 查询第 1 页，每页 10 条记录</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"8-排序查询\"><a href=\"#8-排序查询\" class=\"headerlink\" title=\"8. 排序查询\"></a>8. <strong>排序查询</strong></h4><p>使用 <code>orderBy</code> 对查询结果排序。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">getUsersSortedByName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> users = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">findMany</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">orderBy</span>: &#123; <span class=\"attr\">name</span>: <span class=\"string\">&#x27;asc&#x27;</span> &#125;, <span class=\"comment\">// 按 name 字段升序排序</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Sorted users:&#x27;</span>, users);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">getUsersSortedByName</span>();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"9-聚合查询\"><a href=\"#9-聚合查询\" class=\"headerlink\" title=\"9. 聚合查询\"></a>9. <strong>聚合查询</strong></h4><p>使用 <code>count</code>、<code>sum</code>、<code>avg</code> 等聚合函数。</p>\n<ul>\n<li><strong>统计记录数</strong></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">countUsers</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> userCount = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">count</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Total users:&#x27;</span>, userCount);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">countUsers</span>();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>计算字段平均值</strong></li>\n</ul>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">averageUserAge</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> avgAge = <span class=\"keyword\">await</span> prisma.<span class=\"property\">user</span>.<span class=\"title function_\">aggregate</span>(&#123;</span><br><span class=\"line\">    <span class=\"attr\">_avg</span>: &#123; <span class=\"attr\">age</span>: <span class=\"literal\">true</span> &#125;, <span class=\"comment\">// 假设 User 模型有 age 字段</span></span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Average user age:&#x27;</span>, avgAge.<span class=\"property\">_avg</span>.<span class=\"property\">age</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">averageUserAge</span>();</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"10-事务操作\"><a href=\"#10-事务操作\" class=\"headerlink\" title=\"10. 事务操作\"></a>10. <strong>事务操作</strong></h4><p>使用 <code>$transaction</code> 执行事务操作。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">transferBalance</span>(<span class=\"params\"><span class=\"attr\">fromId</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">toId</span>: <span class=\"built_in\">number</span>, <span class=\"attr\">amount</span>: <span class=\"built_in\">number</span></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">await</span> prisma.$transaction([</span><br><span class=\"line\">    prisma.<span class=\"property\">user</span>.<span class=\"title function_\">update</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123; <span class=\"attr\">id</span>: fromId &#125;,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: &#123; <span class=\"attr\">balance</span>: &#123; <span class=\"attr\">decrement</span>: amount &#125; &#125;, <span class=\"comment\">// 假设 User 模型有 balance 字段</span></span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">    prisma.<span class=\"property\">user</span>.<span class=\"title function_\">update</span>(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123; <span class=\"attr\">id</span>: toId &#125;,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: &#123; <span class=\"attr\">balance</span>: &#123; <span class=\"attr\">increment</span>: amount &#125; &#125;,</span><br><span class=\"line\">    &#125;),</span><br><span class=\"line\">  ]);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">&#x27;Balance transfer completed&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">transferBalance</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">100</span>);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"11-关闭-Prisma-Client\"><a href=\"#11-关闭-Prisma-Client\" class=\"headerlink\" title=\"11. 关闭 Prisma Client\"></a>11. <strong>关闭 Prisma Client</strong></h4><p>在程序结束时，关闭 Prisma Client 以释放数据库连接。</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">async</span> <span class=\"keyword\">function</span> <span class=\"title function_\">main</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 数据库操作代码</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">main</span>()</span><br><span class=\"line\">  .<span class=\"title function_\">catch</span>(<span class=\"function\"><span class=\"params\">e</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">error</span>(e);</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">  .<span class=\"title function_\">finally</span>(<span class=\"title function_\">async</span> () =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">await</span> prisma.$disconnect();</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n\n<hr>\n","_processedHighlight":true},{"title":"𝐜𝐡𝐚𝐭𝐒𝐐𝐋","date":"2025-05-08T15:30:56.000Z","thumbnail":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508164908220.png?imageSlim","excerpt":"~~你的下一款minisql, 何必是minisql.~~ chatSQL 是一个交互式 SQL 学习平台，通过人工智能技术生成个性化的 SQL 练习题，帮助用户从入门到精通 SQL 查询语言。平台结合了直观的数据库可视化工具、智能代码编辑器和即时反馈系统，为用户提供沉浸式学习体验。","_content":"<p align=\"center\" style=\"font-size: 1.2em; margin: 20px 0;\">\n  <a href=\"https://chat-sql-hazel.vercel.app/\" target=\"_blank\" style=\"font-size: 1.2em; font-weight: bold;\">Website</a>\n  <a href=\"hhttps://github.com/ffy6511/chatSQL\" target=\"_blank\" style=\"font-size: 1.2em; font-weight: bold;\">Github Repo</a>\n</p>\n<p align=\"center\">\n  <a href=\"https://deepwiki.com/ffy6511/chatSQL\"><img src=\"https://deepwiki.com/badge.svg\" alt=\"Ask DeepWiki\" /></a>\n</p>\n\n**什么是chatSQL**:\n\nchatSQL 是一个交互式 SQL 学习平台，通过人工智能技术生成个性化的 SQL 练习题，帮助用户从入门到精通 SQL 查询语言。平台结合了直观的数据库可视化工具、智能代码编辑器和即时反馈系统，为用户提供沉浸式学习体验。无论您是 SQL 初学者还是希望提升查询技能的开发者，chatSQL 都能根据您的水平定制适合的学习内容，让 SQL 学习变得更加高效和有趣。\n\n## 产生背景\n在初学sql的时候, 总觉得在纸上谈兵的感觉不太切实, ~~总是不知道自己胡乱写的sql语句是否正确~~. 偶然的机会看到了一个在线的[自学sql网站](http://xuesql.cn/lesson/select_queries_with_constraints), 提供了数据库结构,元组信息以及sql编辑平台, 供用户实时查询:\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508234644726.png?imageSlim)\n\n然而该网站的习题内容对免费用户十分有限, 不足以sql学习者反复的练习. 于是我想到, 为什么不自己做一个呢? \n\n### sql题目的生成\ngemini免费的api + dify上免费的工作流 = 无穷无尽的sql题目~\n\n由于有过dify平台上搭建工作流的经验, 我还是选择用dify来针对用户的需求生成不同难度和类型的sql题目. \n\n### schema的可视化\n在写数据库作业的时候, 意外发现了[chartDB](https://chartdb.io/)这个网站, 其中的数据库结构的可视化十分优雅.经过对其源码的\"探测\", 我挖掘到了xyflow这个组件库.\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509000938549.png?imageSlim)\n\n同时, 我决定直接用MUI组件库中的表格作为数据库元组的展示, 让元组的信息更加直观.\n\n### sql语句的执行\n这部分可谓是项目中最难实现的任务了.\n\n其实一开始并没有立刻开始做chatSQL, 就是因为我没有现成的在虚拟/实际数据库中执行sql语句的方法. \n\n然而, 某天浏览数据库教材的时候, 意外发现了官网上存在一个前端执行sql语句查询的demo! 发现叫做[sql.js](https://sql.js.org/#/)的库似乎就可扮演在前端的sql引擎角色. 因此, 我觉得万事俱备了! 开始设计前后端的字段, 布局排版, 然后实现基础的UI...\n\n然而然而, 当我准备开始做sql引擎的时候, 发现sql.js竟然与react高版本框架和一些依赖不兼容! 然而我只剩下sql引擎的执行部分了... 也不好就此放弃. 那么就~~借助augment的力量~~自己写一个吧~\n\n1. 首先, 从monaco editor入手, 建立一个类似于vscode风格的代码编辑区;\n2. 然后, 利用[node-sql-parser](https://www.npmjs.com/package/node-sql-parser)库, 我们将标准的sql语句传入给解析组件, 获得ast语法树;\n3. 最后, 我们编写自己的sql执行引擎, 利用ast语法树执行sql语句.\n\n> 下面基本是项目仓库中README的部分.\n\n\n\n## ✨ 特性\n\n- 🤖 AI 生成练习：提供两种方式的习题来源\n  - 通过预设的教程, 循序渐进地练习`select`, `join`, 聚合操作与嵌套子查询等知识点.\n  - 与dify工作流交互, 输入难度,标签与描述自动生成 SQL 练习题.\n\n- 📊 数据库结构可视化：直观展示表关系和字段信息, 外检约束等信息一目了然;\n- ⌨️ Monaco编辑器与schema的补全整合：\n  - 支持sql语法高亮和悬浮的语法提示\n  - 针对当前schema信息提供`tab`的自动补全\n\n- 📝 即时结果验证：实时验证查询结果\n  - 由构建于前端的sql引擎0延迟地处理sql查询结果.\n  - 支持将查询结果与期望结果进行比较, 评价查询结果是否正确.\n\n\n\n\n## 🖥 界面预览\n\n### 初始化界面\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508164908220.png?imageSlim)\n\n- 点击侧边栏中的“初始化教程”, 可以同预设的数据库表结构进行交互;\n- 点击侧边栏中的“帮助”, 可以查看基本的操作演示.\n\n### 数据库结构可视化\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508165221364.png?imageSlim)\n\n- 默认显示数据库结构的可视化视图;\n- 可在左下角切换元组视图.\n\n### SQL 编辑器演示\n\n<img src=\"/img/edit.gif\" alt=\"编辑器演示\" width=\"80%\" />\n\n对应快捷键:\n\n- `command+enter` : 执行查询\n- `command+j`: 检测查询结果是否匹配;\n- `command+k`: 搜索历史记录.\n\n## 🛠 技术栈\n\n<p align=\"left\">\n  <img src=\"https://img.shields.io/badge/Next.js-black?style=for-the-badge&logo=next.js\" alt=\"Next.js\" />\n  <img src=\"https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=react&logoColor=black\" alt=\"React\" />\n  <img src=\"https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=typescript&logoColor=white\" alt=\"TypeScript\" />\n  <img src=\"https://img.shields.io/badge/Ant%20Design-0170FE?style=for-the-badge&logo=antdesign&logoColor=white\" alt=\"Ant Design\" />\n  <img src=\"https://img.shields.io/badge/Material--UI-007FFF?style=for-the-badge&logo=mui&logoColor=white\" alt=\"Material-UI\" />\n  <img src=\"https://img.shields.io/badge/Monaco%20Editor-DD1100?style=for-the-badge&logo=visualstudiocode&logoColor=white\" alt=\"Monaco Editor\" />\n  <img src=\"https://img.shields.io/badge/XY%20Flow-22C55E?style=for-the-badge&logo=diagram&logoColor=white\" alt=\"XY Flow\" />\n</p>\n\n- **框架**: [Next.js](https://nextjs.org/) 15.3.0\n- **UI 组件**:\n  - [Ant Design](https://ant.design/) 5.24.6\n  - [Material-UI](https://mui.com/) 7.0.2\n- **编辑器**: [Monaco Editor](https://microsoft.github.io/monaco-editor/)\n- **流程图**:\n  - [XY Flow](https://reactflow.dev/) (@xyflow/react)\n  - 用于数据库表关系可视化\n  - 支持自定义节点和边的样式\n  - 提供图表交互操作\n  - 基于 D3.js 的缩放和拖拽功能\n- **AI 集成**: [Dify.ai](https://dify.ai/)\n- **类型检查**: [TypeScript](https://www.typescriptlang.org/)\n\n## 🚀 快速开始\n> 得益于~~预制课~~教程系列的完善, 您可以直接clone仓库后, 通过`npm install`安装依赖, `npm run dev`启动前端即可进行基本教程的学习, 而无需配置dify工作流. 😌\n\n### 前置要求\n\n- Node.js 18.0 或更高版本\n- npm 包管理器\n- Dify.ai 账号和 API 密钥\n\n### 安装步骤\n\n1. 克隆仓库\n\n```bash\ngit clone https://github.com/ffy6511/chatSQL.git\ncd chatSQL/chat-sql\n```\n\n2. 安装依赖\n\n```bash\nnpm install\n```\n\n3. 配置环境变量\n\n```bash\ntouch .env\n```\n\n编辑 `.env` 文件并添加你的 Dify API 密钥：\n\n```\nNEXT_PUBLIC_DIFY_API_KEY=your_api_key_here\n```\n\n4. 启动开发服务器\n\n```bash\nnpm run dev\n```\n\n5. 更新git日志: 如果您希望更新自己的\"更新日志\"界面, 请执行\n\n```bash\nnpm run generate-git\n```\n### Dify 工作流配置\n\n1. 在 [Dify 平台](https://dify.ai) 创建新应用（选择工作流）\n2. 导入工作流配置：\n   - 从项目中下载 `public/chatSQL.yml` 文件\n   - 在 Dify 平台中导入该配置文件\n   - ![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefineddify.png?imageSlim)\n3. 获取 API 密钥并在个人设置中配置（工作流默认使用 Gemini，可根据需要修改）\n\n## 🤝 贡献\n\n欢迎提交 Pull Request 和 Issue！\n","source":"_posts/chatSQL.md","raw":"---\ntitle: 𝐜𝐡𝐚𝐭𝐒𝐐𝐋\ndate: 2025-05-08 23:30:56\ntags: 奇思妙想\ncategories: 前后端开发\nthumbnail: https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508164908220.png?imageSlim\nexcerpt: ~~你的下一款minisql, 何必是minisql.~~ chatSQL 是一个交互式 SQL 学习平台，通过人工智能技术生成个性化的 SQL 练习题，帮助用户从入门到精通 SQL 查询语言。平台结合了直观的数据库可视化工具、智能代码编辑器和即时反馈系统，为用户提供沉浸式学习体验。\n---\n<p align=\"center\" style=\"font-size: 1.2em; margin: 20px 0;\">\n  <a href=\"https://chat-sql-hazel.vercel.app/\" target=\"_blank\" style=\"font-size: 1.2em; font-weight: bold;\">Website</a>\n  <a href=\"hhttps://github.com/ffy6511/chatSQL\" target=\"_blank\" style=\"font-size: 1.2em; font-weight: bold;\">Github Repo</a>\n</p>\n<p align=\"center\">\n  <a href=\"https://deepwiki.com/ffy6511/chatSQL\"><img src=\"https://deepwiki.com/badge.svg\" alt=\"Ask DeepWiki\" /></a>\n</p>\n\n**什么是chatSQL**:\n\nchatSQL 是一个交互式 SQL 学习平台，通过人工智能技术生成个性化的 SQL 练习题，帮助用户从入门到精通 SQL 查询语言。平台结合了直观的数据库可视化工具、智能代码编辑器和即时反馈系统，为用户提供沉浸式学习体验。无论您是 SQL 初学者还是希望提升查询技能的开发者，chatSQL 都能根据您的水平定制适合的学习内容，让 SQL 学习变得更加高效和有趣。\n\n## 产生背景\n在初学sql的时候, 总觉得在纸上谈兵的感觉不太切实, ~~总是不知道自己胡乱写的sql语句是否正确~~. 偶然的机会看到了一个在线的[自学sql网站](http://xuesql.cn/lesson/select_queries_with_constraints), 提供了数据库结构,元组信息以及sql编辑平台, 供用户实时查询:\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508234644726.png?imageSlim)\n\n然而该网站的习题内容对免费用户十分有限, 不足以sql学习者反复的练习. 于是我想到, 为什么不自己做一个呢? \n\n### sql题目的生成\ngemini免费的api + dify上免费的工作流 = 无穷无尽的sql题目~\n\n由于有过dify平台上搭建工作流的经验, 我还是选择用dify来针对用户的需求生成不同难度和类型的sql题目. \n\n### schema的可视化\n在写数据库作业的时候, 意外发现了[chartDB](https://chartdb.io/)这个网站, 其中的数据库结构的可视化十分优雅.经过对其源码的\"探测\", 我挖掘到了xyflow这个组件库.\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509000938549.png?imageSlim)\n\n同时, 我决定直接用MUI组件库中的表格作为数据库元组的展示, 让元组的信息更加直观.\n\n### sql语句的执行\n这部分可谓是项目中最难实现的任务了.\n\n其实一开始并没有立刻开始做chatSQL, 就是因为我没有现成的在虚拟/实际数据库中执行sql语句的方法. \n\n然而, 某天浏览数据库教材的时候, 意外发现了官网上存在一个前端执行sql语句查询的demo! 发现叫做[sql.js](https://sql.js.org/#/)的库似乎就可扮演在前端的sql引擎角色. 因此, 我觉得万事俱备了! 开始设计前后端的字段, 布局排版, 然后实现基础的UI...\n\n然而然而, 当我准备开始做sql引擎的时候, 发现sql.js竟然与react高版本框架和一些依赖不兼容! 然而我只剩下sql引擎的执行部分了... 也不好就此放弃. 那么就~~借助augment的力量~~自己写一个吧~\n\n1. 首先, 从monaco editor入手, 建立一个类似于vscode风格的代码编辑区;\n2. 然后, 利用[node-sql-parser](https://www.npmjs.com/package/node-sql-parser)库, 我们将标准的sql语句传入给解析组件, 获得ast语法树;\n3. 最后, 我们编写自己的sql执行引擎, 利用ast语法树执行sql语句.\n\n> 下面基本是项目仓库中README的部分.\n\n\n\n## ✨ 特性\n\n- 🤖 AI 生成练习：提供两种方式的习题来源\n  - 通过预设的教程, 循序渐进地练习`select`, `join`, 聚合操作与嵌套子查询等知识点.\n  - 与dify工作流交互, 输入难度,标签与描述自动生成 SQL 练习题.\n\n- 📊 数据库结构可视化：直观展示表关系和字段信息, 外检约束等信息一目了然;\n- ⌨️ Monaco编辑器与schema的补全整合：\n  - 支持sql语法高亮和悬浮的语法提示\n  - 针对当前schema信息提供`tab`的自动补全\n\n- 📝 即时结果验证：实时验证查询结果\n  - 由构建于前端的sql引擎0延迟地处理sql查询结果.\n  - 支持将查询结果与期望结果进行比较, 评价查询结果是否正确.\n\n\n\n\n## 🖥 界面预览\n\n### 初始化界面\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508164908220.png?imageSlim)\n\n- 点击侧边栏中的“初始化教程”, 可以同预设的数据库表结构进行交互;\n- 点击侧边栏中的“帮助”, 可以查看基本的操作演示.\n\n### 数据库结构可视化\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508165221364.png?imageSlim)\n\n- 默认显示数据库结构的可视化视图;\n- 可在左下角切换元组视图.\n\n### SQL 编辑器演示\n\n<img src=\"/img/edit.gif\" alt=\"编辑器演示\" width=\"80%\" />\n\n对应快捷键:\n\n- `command+enter` : 执行查询\n- `command+j`: 检测查询结果是否匹配;\n- `command+k`: 搜索历史记录.\n\n## 🛠 技术栈\n\n<p align=\"left\">\n  <img src=\"https://img.shields.io/badge/Next.js-black?style=for-the-badge&logo=next.js\" alt=\"Next.js\" />\n  <img src=\"https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=react&logoColor=black\" alt=\"React\" />\n  <img src=\"https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=typescript&logoColor=white\" alt=\"TypeScript\" />\n  <img src=\"https://img.shields.io/badge/Ant%20Design-0170FE?style=for-the-badge&logo=antdesign&logoColor=white\" alt=\"Ant Design\" />\n  <img src=\"https://img.shields.io/badge/Material--UI-007FFF?style=for-the-badge&logo=mui&logoColor=white\" alt=\"Material-UI\" />\n  <img src=\"https://img.shields.io/badge/Monaco%20Editor-DD1100?style=for-the-badge&logo=visualstudiocode&logoColor=white\" alt=\"Monaco Editor\" />\n  <img src=\"https://img.shields.io/badge/XY%20Flow-22C55E?style=for-the-badge&logo=diagram&logoColor=white\" alt=\"XY Flow\" />\n</p>\n\n- **框架**: [Next.js](https://nextjs.org/) 15.3.0\n- **UI 组件**:\n  - [Ant Design](https://ant.design/) 5.24.6\n  - [Material-UI](https://mui.com/) 7.0.2\n- **编辑器**: [Monaco Editor](https://microsoft.github.io/monaco-editor/)\n- **流程图**:\n  - [XY Flow](https://reactflow.dev/) (@xyflow/react)\n  - 用于数据库表关系可视化\n  - 支持自定义节点和边的样式\n  - 提供图表交互操作\n  - 基于 D3.js 的缩放和拖拽功能\n- **AI 集成**: [Dify.ai](https://dify.ai/)\n- **类型检查**: [TypeScript](https://www.typescriptlang.org/)\n\n## 🚀 快速开始\n> 得益于~~预制课~~教程系列的完善, 您可以直接clone仓库后, 通过`npm install`安装依赖, `npm run dev`启动前端即可进行基本教程的学习, 而无需配置dify工作流. 😌\n\n### 前置要求\n\n- Node.js 18.0 或更高版本\n- npm 包管理器\n- Dify.ai 账号和 API 密钥\n\n### 安装步骤\n\n1. 克隆仓库\n\n```bash\ngit clone https://github.com/ffy6511/chatSQL.git\ncd chatSQL/chat-sql\n```\n\n2. 安装依赖\n\n```bash\nnpm install\n```\n\n3. 配置环境变量\n\n```bash\ntouch .env\n```\n\n编辑 `.env` 文件并添加你的 Dify API 密钥：\n\n```\nNEXT_PUBLIC_DIFY_API_KEY=your_api_key_here\n```\n\n4. 启动开发服务器\n\n```bash\nnpm run dev\n```\n\n5. 更新git日志: 如果您希望更新自己的\"更新日志\"界面, 请执行\n\n```bash\nnpm run generate-git\n```\n### Dify 工作流配置\n\n1. 在 [Dify 平台](https://dify.ai) 创建新应用（选择工作流）\n2. 导入工作流配置：\n   - 从项目中下载 `public/chatSQL.yml` 文件\n   - 在 Dify 平台中导入该配置文件\n   - ![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefineddify.png?imageSlim)\n3. 获取 API 密钥并在个人设置中配置（工作流默认使用 Gemini，可根据需要修改）\n\n## 🤝 贡献\n\n欢迎提交 Pull Request 和 Issue！\n","slug":"chatSQL","published":1,"updated":"2025-05-09T01:40:57.095Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ac000b2xqg59vt8b9j","content":"<p align=\"center\" style=\"font-size: 1.2em; margin: 20px 0;\">\n  <a class=\"link\"   href=\"https://chat-sql-hazel.vercel.app/\"  target=\"_blank\" style=\"font-size: 1.2em; font-weight: bold;\">Website<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>\n  <a class=\"link\"   href=\"hhttps://github.com/ffy6511/chatSQL\"  target=\"_blank\" style=\"font-size: 1.2em; font-weight: bold;\">Github Repo<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>\n</p>\n<p align=\"center\">\n  <a href=\"https://deepwiki.com/ffy6511/chatSQL\"><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://deepwiki.com/badge.svg\"\n                      alt=\"Ask DeepWiki\" \n                ></a>\n</p>\n\n<p><strong>什么是chatSQL</strong>:</p>\n<p>chatSQL 是一个交互式 SQL 学习平台，通过人工智能技术生成个性化的 SQL 练习题，帮助用户从入门到精通 SQL 查询语言。平台结合了直观的数据库可视化工具、智能代码编辑器和即时反馈系统，为用户提供沉浸式学习体验。无论您是 SQL 初学者还是希望提升查询技能的开发者，chatSQL 都能根据您的水平定制适合的学习内容，让 SQL 学习变得更加高效和有趣。</p>\n<h2 id=\"产生背景\"><a href=\"#产生背景\" class=\"headerlink\" title=\"产生背景\"></a>产生背景</h2><p>在初学sql的时候, 总觉得在纸上谈兵的感觉不太切实, <del>总是不知道自己胡乱写的sql语句是否正确</del>. 偶然的机会看到了一个在线的<a class=\"link\"   href=\"http://xuesql.cn/lesson/select_queries_with_constraints\" >自学sql网站<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>, 提供了数据库结构,元组信息以及sql编辑平台, 供用户实时查询:</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508234644726.png?imageSlim\"\n                     \n                ></p>\n<p>然而该网站的习题内容对免费用户十分有限, 不足以sql学习者反复的练习. 于是我想到, 为什么不自己做一个呢? </p>\n<h3 id=\"sql题目的生成\"><a href=\"#sql题目的生成\" class=\"headerlink\" title=\"sql题目的生成\"></a>sql题目的生成</h3><p>gemini免费的api + dify上免费的工作流 &#x3D; 无穷无尽的sql题目~</p>\n<p>由于有过dify平台上搭建工作流的经验, 我还是选择用dify来针对用户的需求生成不同难度和类型的sql题目. </p>\n<h3 id=\"schema的可视化\"><a href=\"#schema的可视化\" class=\"headerlink\" title=\"schema的可视化\"></a>schema的可视化</h3><p>在写数据库作业的时候, 意外发现了<a class=\"link\"   href=\"https://chartdb.io/\" >chartDB<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>这个网站, 其中的数据库结构的可视化十分优雅.经过对其源码的”探测”, 我挖掘到了xyflow这个组件库.<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509000938549.png?imageSlim\"\n                     \n                ></p>\n<p>同时, 我决定直接用MUI组件库中的表格作为数据库元组的展示, 让元组的信息更加直观.</p>\n<h3 id=\"sql语句的执行\"><a href=\"#sql语句的执行\" class=\"headerlink\" title=\"sql语句的执行\"></a>sql语句的执行</h3><p>这部分可谓是项目中最难实现的任务了.</p>\n<p>其实一开始并没有立刻开始做chatSQL, 就是因为我没有现成的在虚拟&#x2F;实际数据库中执行sql语句的方法. </p>\n<p>然而, 某天浏览数据库教材的时候, 意外发现了官网上存在一个前端执行sql语句查询的demo! 发现叫做<a class=\"link\"   href=\"https://sql.js.org/#/\" >sql.js<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>的库似乎就可扮演在前端的sql引擎角色. 因此, 我觉得万事俱备了! 开始设计前后端的字段, 布局排版, 然后实现基础的UI…</p>\n<p>然而然而, 当我准备开始做sql引擎的时候, 发现sql.js竟然与react高版本框架和一些依赖不兼容! 然而我只剩下sql引擎的执行部分了… 也不好就此放弃. 那么就<del>借助augment的力量</del>自己写一个吧~</p>\n<ol>\n<li>首先, 从monaco editor入手, 建立一个类似于vscode风格的代码编辑区;</li>\n<li>然后, 利用<a class=\"link\"   href=\"https://www.npmjs.com/package/node-sql-parser\" >node-sql-parser<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>库, 我们将标准的sql语句传入给解析组件, 获得ast语法树;</li>\n<li>最后, 我们编写自己的sql执行引擎, 利用ast语法树执行sql语句.</li>\n</ol>\n<blockquote>\n<p>下面基本是项目仓库中README的部分.</p>\n</blockquote>\n<h2 id=\"✨-特性\"><a href=\"#✨-特性\" class=\"headerlink\" title=\"✨ 特性\"></a>✨ 特性</h2><ul>\n<li><p>🤖 AI 生成练习：提供两种方式的习题来源</p>\n<ul>\n<li>通过预设的教程, 循序渐进地练习<code>select</code>, <code>join</code>, 聚合操作与嵌套子查询等知识点.</li>\n<li>与dify工作流交互, 输入难度,标签与描述自动生成 SQL 练习题.</li>\n</ul>\n</li>\n<li><p>📊 数据库结构可视化：直观展示表关系和字段信息, 外检约束等信息一目了然;</p>\n</li>\n<li><p>⌨️ Monaco编辑器与schema的补全整合：</p>\n<ul>\n<li>支持sql语法高亮和悬浮的语法提示</li>\n<li>针对当前schema信息提供<code>tab</code>的自动补全</li>\n</ul>\n</li>\n<li><p>📝 即时结果验证：实时验证查询结果</p>\n<ul>\n<li>由构建于前端的sql引擎0延迟地处理sql查询结果.</li>\n<li>支持将查询结果与期望结果进行比较, 评价查询结果是否正确.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"🖥-界面预览\"><a href=\"#🖥-界面预览\" class=\"headerlink\" title=\"🖥 界面预览\"></a>🖥 界面预览</h2><h3 id=\"初始化界面\"><a href=\"#初始化界面\" class=\"headerlink\" title=\"初始化界面\"></a>初始化界面</h3><p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508164908220.png?imageSlim\"\n                     \n                ></p>\n<ul>\n<li>点击侧边栏中的“初始化教程”, 可以同预设的数据库表结构进行交互;</li>\n<li>点击侧边栏中的“帮助”, 可以查看基本的操作演示.</li>\n</ul>\n<h3 id=\"数据库结构可视化\"><a href=\"#数据库结构可视化\" class=\"headerlink\" title=\"数据库结构可视化\"></a>数据库结构可视化</h3><p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508165221364.png?imageSlim\"\n                     \n                ></p>\n<ul>\n<li>默认显示数据库结构的可视化视图;</li>\n<li>可在左下角切换元组视图.</li>\n</ul>\n<h3 id=\"SQL-编辑器演示\"><a href=\"#SQL-编辑器演示\" class=\"headerlink\" title=\"SQL 编辑器演示\"></a>SQL 编辑器演示</h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/img/edit.gif\"\n                      alt=\"编辑器演示\" width=\"80%\" \n                >\n\n<p>对应快捷键:</p>\n<ul>\n<li><code>command+enter</code> : 执行查询</li>\n<li><code>command+j</code>: 检测查询结果是否匹配;</li>\n<li><code>command+k</code>: 搜索历史记录.</li>\n</ul>\n<h2 id=\"🛠-技术栈\"><a href=\"#🛠-技术栈\" class=\"headerlink\" title=\"🛠 技术栈\"></a>🛠 技术栈</h2><p align=\"left\">\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/Next.js-black?style=for-the-badge&logo=next.js\"\n                      alt=\"Next.js\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=react&logoColor=black\"\n                      alt=\"React\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=typescript&logoColor=white\"\n                      alt=\"TypeScript\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/Ant%20Design-0170FE?style=for-the-badge&logo=antdesign&logoColor=white\"\n                      alt=\"Ant Design\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/Material--UI-007FFF?style=for-the-badge&logo=mui&logoColor=white\"\n                      alt=\"Material-UI\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/Monaco%20Editor-DD1100?style=for-the-badge&logo=visualstudiocode&logoColor=white\"\n                      alt=\"Monaco Editor\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/XY%20Flow-22C55E?style=for-the-badge&logo=diagram&logoColor=white\"\n                      alt=\"XY Flow\" \n                >\n</p>\n\n<ul>\n<li><strong>框架</strong>: <a class=\"link\"   href=\"https://nextjs.org/\" >Next.js<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 15.3.0</li>\n<li><strong>UI 组件</strong>:<ul>\n<li><a class=\"link\"   href=\"https://ant.design/\" >Ant Design<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 5.24.6</li>\n<li><a class=\"link\"   href=\"https://mui.com/\" >Material-UI<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 7.0.2</li>\n</ul>\n</li>\n<li><strong>编辑器</strong>: <a class=\"link\"   href=\"https://microsoft.github.io/monaco-editor/\" >Monaco Editor<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>流程图</strong>:<ul>\n<li><a class=\"link\"   href=\"https://reactflow.dev/\" >XY Flow<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> (@xyflow&#x2F;react)</li>\n<li>用于数据库表关系可视化</li>\n<li>支持自定义节点和边的样式</li>\n<li>提供图表交互操作</li>\n<li>基于 D3.js 的缩放和拖拽功能</li>\n</ul>\n</li>\n<li><strong>AI 集成</strong>: <a class=\"link\"   href=\"https://dify.ai/\" >Dify.ai<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>类型检查</strong>: <a class=\"link\"   href=\"https://www.typescriptlang.org/\" >TypeScript<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h2 id=\"🚀-快速开始\"><a href=\"#🚀-快速开始\" class=\"headerlink\" title=\"🚀 快速开始\"></a>🚀 快速开始</h2><blockquote>\n<p>得益于<del>预制课</del>教程系列的完善, 您可以直接clone仓库后, 通过<code>npm install</code>安装依赖, <code>npm run dev</code>启动前端即可进行基本教程的学习, 而无需配置dify工作流. 😌</p>\n</blockquote>\n<h3 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h3><ul>\n<li>Node.js 18.0 或更高版本</li>\n<li>npm 包管理器</li>\n<li>Dify.ai 账号和 API 密钥</li>\n</ul>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ol>\n<li>克隆仓库</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ffy6511/chatSQL.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> chatSQL/chat-sql</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>安装依赖</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li>配置环境变量</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">touch</span> .<span class=\"built_in\">env</span></span><br></pre></td></tr></table></figure></div>\n\n<p>编辑 <code>.env</code> 文件并添加你的 Dify API 密钥：</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NEXT_PUBLIC_DIFY_API_KEY=your_api_key_here</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"4\">\n<li>启动开发服务器</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run dev</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"5\">\n<li>更新git日志: 如果您希望更新自己的”更新日志”界面, 请执行</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run generate-git</span><br></pre></td></tr></table></figure></div>\n<h3 id=\"Dify-工作流配置\"><a href=\"#Dify-工作流配置\" class=\"headerlink\" title=\"Dify 工作流配置\"></a>Dify 工作流配置</h3><ol>\n<li>在 <a class=\"link\"   href=\"https://dify.ai/\" >Dify 平台<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 创建新应用（选择工作流）</li>\n<li>导入工作流配置：<ul>\n<li>从项目中下载 <code>public/chatSQL.yml</code> 文件</li>\n<li>在 Dify 平台中导入该配置文件</li>\n<li><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefineddify.png?imageSlim\"\n                     \n                ></li>\n</ul>\n</li>\n<li>获取 API 密钥并在个人设置中配置（工作流默认使用 Gemini，可根据需要修改）</li>\n</ol>\n<h2 id=\"🤝-贡献\"><a href=\"#🤝-贡献\" class=\"headerlink\" title=\"🤝 贡献\"></a>🤝 贡献</h2><p>欢迎提交 Pull Request 和 Issue！</p>\n","more":"<p align=\"center\" style=\"font-size: 1.2em; margin: 20px 0;\">\n  <a class=\"link\"   href=\"https://chat-sql-hazel.vercel.app/\"  target=\"_blank\" style=\"font-size: 1.2em; font-weight: bold;\">Website<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>\n  <a class=\"link\"   href=\"hhttps://github.com/ffy6511/chatSQL\"  target=\"_blank\" style=\"font-size: 1.2em; font-weight: bold;\">Github Repo<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>\n</p>\n<p align=\"center\">\n  <a href=\"https://deepwiki.com/ffy6511/chatSQL\"><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://deepwiki.com/badge.svg\"\n                      alt=\"Ask DeepWiki\" \n                ></a>\n</p>\n\n<p><strong>什么是chatSQL</strong>:</p>\n<p>chatSQL 是一个交互式 SQL 学习平台，通过人工智能技术生成个性化的 SQL 练习题，帮助用户从入门到精通 SQL 查询语言。平台结合了直观的数据库可视化工具、智能代码编辑器和即时反馈系统，为用户提供沉浸式学习体验。无论您是 SQL 初学者还是希望提升查询技能的开发者，chatSQL 都能根据您的水平定制适合的学习内容，让 SQL 学习变得更加高效和有趣。</p>\n<h2 id=\"产生背景\"><a href=\"#产生背景\" class=\"headerlink\" title=\"产生背景\"></a>产生背景</h2><p>在初学sql的时候, 总觉得在纸上谈兵的感觉不太切实, <del>总是不知道自己胡乱写的sql语句是否正确</del>. 偶然的机会看到了一个在线的<a class=\"link\"   href=\"http://xuesql.cn/lesson/select_queries_with_constraints\" >自学sql网站<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>, 提供了数据库结构,元组信息以及sql编辑平台, 供用户实时查询:</p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508234644726.png?imageSlim\"\n                     \n                ></p>\n<p>然而该网站的习题内容对免费用户十分有限, 不足以sql学习者反复的练习. 于是我想到, 为什么不自己做一个呢? </p>\n<h3 id=\"sql题目的生成\"><a href=\"#sql题目的生成\" class=\"headerlink\" title=\"sql题目的生成\"></a>sql题目的生成</h3><p>gemini免费的api + dify上免费的工作流 &#x3D; 无穷无尽的sql题目~</p>\n<p>由于有过dify平台上搭建工作流的经验, 我还是选择用dify来针对用户的需求生成不同难度和类型的sql题目. </p>\n<h3 id=\"schema的可视化\"><a href=\"#schema的可视化\" class=\"headerlink\" title=\"schema的可视化\"></a>schema的可视化</h3><p>在写数据库作业的时候, 意外发现了<a class=\"link\"   href=\"https://chartdb.io/\" >chartDB<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>这个网站, 其中的数据库结构的可视化十分优雅.经过对其源码的”探测”, 我挖掘到了xyflow这个组件库.<br><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509000938549.png?imageSlim\"\n                     \n                ></p>\n<p>同时, 我决定直接用MUI组件库中的表格作为数据库元组的展示, 让元组的信息更加直观.</p>\n<h3 id=\"sql语句的执行\"><a href=\"#sql语句的执行\" class=\"headerlink\" title=\"sql语句的执行\"></a>sql语句的执行</h3><p>这部分可谓是项目中最难实现的任务了.</p>\n<p>其实一开始并没有立刻开始做chatSQL, 就是因为我没有现成的在虚拟&#x2F;实际数据库中执行sql语句的方法. </p>\n<p>然而, 某天浏览数据库教材的时候, 意外发现了官网上存在一个前端执行sql语句查询的demo! 发现叫做<a class=\"link\"   href=\"https://sql.js.org/#/\" >sql.js<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>的库似乎就可扮演在前端的sql引擎角色. 因此, 我觉得万事俱备了! 开始设计前后端的字段, 布局排版, 然后实现基础的UI…</p>\n<p>然而然而, 当我准备开始做sql引擎的时候, 发现sql.js竟然与react高版本框架和一些依赖不兼容! 然而我只剩下sql引擎的执行部分了… 也不好就此放弃. 那么就<del>借助augment的力量</del>自己写一个吧~</p>\n<ol>\n<li>首先, 从monaco editor入手, 建立一个类似于vscode风格的代码编辑区;</li>\n<li>然后, 利用<a class=\"link\"   href=\"https://www.npmjs.com/package/node-sql-parser\" >node-sql-parser<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>库, 我们将标准的sql语句传入给解析组件, 获得ast语法树;</li>\n<li>最后, 我们编写自己的sql执行引擎, 利用ast语法树执行sql语句.</li>\n</ol>\n<blockquote>\n<p>下面基本是项目仓库中README的部分.</p>\n</blockquote>\n<h2 id=\"✨-特性\"><a href=\"#✨-特性\" class=\"headerlink\" title=\"✨ 特性\"></a>✨ 特性</h2><ul>\n<li><p>🤖 AI 生成练习：提供两种方式的习题来源</p>\n<ul>\n<li>通过预设的教程, 循序渐进地练习<code>select</code>, <code>join</code>, 聚合操作与嵌套子查询等知识点.</li>\n<li>与dify工作流交互, 输入难度,标签与描述自动生成 SQL 练习题.</li>\n</ul>\n</li>\n<li><p>📊 数据库结构可视化：直观展示表关系和字段信息, 外检约束等信息一目了然;</p>\n</li>\n<li><p>⌨️ Monaco编辑器与schema的补全整合：</p>\n<ul>\n<li>支持sql语法高亮和悬浮的语法提示</li>\n<li>针对当前schema信息提供<code>tab</code>的自动补全</li>\n</ul>\n</li>\n<li><p>📝 即时结果验证：实时验证查询结果</p>\n<ul>\n<li>由构建于前端的sql引擎0延迟地处理sql查询结果.</li>\n<li>支持将查询结果与期望结果进行比较, 评价查询结果是否正确.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"🖥-界面预览\"><a href=\"#🖥-界面预览\" class=\"headerlink\" title=\"🖥 界面预览\"></a>🖥 界面预览</h2><h3 id=\"初始化界面\"><a href=\"#初始化界面\" class=\"headerlink\" title=\"初始化界面\"></a>初始化界面</h3><p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508164908220.png?imageSlim\"\n                     \n                ></p>\n<ul>\n<li>点击侧边栏中的“初始化教程”, 可以同预设的数据库表结构进行交互;</li>\n<li>点击侧边栏中的“帮助”, 可以查看基本的操作演示.</li>\n</ul>\n<h3 id=\"数据库结构可视化\"><a href=\"#数据库结构可视化\" class=\"headerlink\" title=\"数据库结构可视化\"></a>数据库结构可视化</h3><p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250508165221364.png?imageSlim\"\n                     \n                ></p>\n<ul>\n<li>默认显示数据库结构的可视化视图;</li>\n<li>可在左下角切换元组视图.</li>\n</ul>\n<h3 id=\"SQL-编辑器演示\"><a href=\"#SQL-编辑器演示\" class=\"headerlink\" title=\"SQL 编辑器演示\"></a>SQL 编辑器演示</h3><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/img/edit.gif\"\n                      alt=\"编辑器演示\" width=\"80%\" \n                >\n\n<p>对应快捷键:</p>\n<ul>\n<li><code>command+enter</code> : 执行查询</li>\n<li><code>command+j</code>: 检测查询结果是否匹配;</li>\n<li><code>command+k</code>: 搜索历史记录.</li>\n</ul>\n<h2 id=\"🛠-技术栈\"><a href=\"#🛠-技术栈\" class=\"headerlink\" title=\"🛠 技术栈\"></a>🛠 技术栈</h2><p align=\"left\">\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/Next.js-black?style=for-the-badge&logo=next.js\"\n                      alt=\"Next.js\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/React-61DAFB?style=for-the-badge&logo=react&logoColor=black\"\n                      alt=\"React\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/TypeScript-3178C6?style=for-the-badge&logo=typescript&logoColor=white\"\n                      alt=\"TypeScript\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/Ant%20Design-0170FE?style=for-the-badge&logo=antdesign&logoColor=white\"\n                      alt=\"Ant Design\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/Material--UI-007FFF?style=for-the-badge&logo=mui&logoColor=white\"\n                      alt=\"Material-UI\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/Monaco%20Editor-DD1100?style=for-the-badge&logo=visualstudiocode&logoColor=white\"\n                      alt=\"Monaco Editor\" \n                >\n  <img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://img.shields.io/badge/XY%20Flow-22C55E?style=for-the-badge&logo=diagram&logoColor=white\"\n                      alt=\"XY Flow\" \n                >\n</p>\n\n<ul>\n<li><strong>框架</strong>: <a class=\"link\"   href=\"https://nextjs.org/\" >Next.js<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 15.3.0</li>\n<li><strong>UI 组件</strong>:<ul>\n<li><a class=\"link\"   href=\"https://ant.design/\" >Ant Design<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 5.24.6</li>\n<li><a class=\"link\"   href=\"https://mui.com/\" >Material-UI<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 7.0.2</li>\n</ul>\n</li>\n<li><strong>编辑器</strong>: <a class=\"link\"   href=\"https://microsoft.github.io/monaco-editor/\" >Monaco Editor<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>流程图</strong>:<ul>\n<li><a class=\"link\"   href=\"https://reactflow.dev/\" >XY Flow<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> (@xyflow&#x2F;react)</li>\n<li>用于数据库表关系可视化</li>\n<li>支持自定义节点和边的样式</li>\n<li>提供图表交互操作</li>\n<li>基于 D3.js 的缩放和拖拽功能</li>\n</ul>\n</li>\n<li><strong>AI 集成</strong>: <a class=\"link\"   href=\"https://dify.ai/\" >Dify.ai<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>类型检查</strong>: <a class=\"link\"   href=\"https://www.typescriptlang.org/\" >TypeScript<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h2 id=\"🚀-快速开始\"><a href=\"#🚀-快速开始\" class=\"headerlink\" title=\"🚀 快速开始\"></a>🚀 快速开始</h2><blockquote>\n<p>得益于<del>预制课</del>教程系列的完善, 您可以直接clone仓库后, 通过<code>npm install</code>安装依赖, <code>npm run dev</code>启动前端即可进行基本教程的学习, 而无需配置dify工作流. 😌</p>\n</blockquote>\n<h3 id=\"前置要求\"><a href=\"#前置要求\" class=\"headerlink\" title=\"前置要求\"></a>前置要求</h3><ul>\n<li>Node.js 18.0 或更高版本</li>\n<li>npm 包管理器</li>\n<li>Dify.ai 账号和 API 密钥</li>\n</ul>\n<h3 id=\"安装步骤\"><a href=\"#安装步骤\" class=\"headerlink\" title=\"安装步骤\"></a>安装步骤</h3><ol>\n<li>克隆仓库</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/ffy6511/chatSQL.git</span><br><span class=\"line\"><span class=\"built_in\">cd</span> chatSQL/chat-sql</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>安装依赖</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>配置环境变量</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">touch</span> .<span class=\"built_in\">env</span></span><br></pre></td></tr></table></figure>\n\n<p>编辑 <code>.env</code> 文件并添加你的 Dify API 密钥：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NEXT_PUBLIC_DIFY_API_KEY=your_api_key_here</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>启动开发服务器</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run dev</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>更新git日志: 如果您希望更新自己的”更新日志”界面, 请执行</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm run generate-git</span><br></pre></td></tr></table></figure>\n<h3 id=\"Dify-工作流配置\"><a href=\"#Dify-工作流配置\" class=\"headerlink\" title=\"Dify 工作流配置\"></a>Dify 工作流配置</h3><ol>\n<li>在 <a class=\"link\"   href=\"https://dify.ai/\" >Dify 平台<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a> 创建新应用（选择工作流）</li>\n<li>导入工作流配置：<ul>\n<li>从项目中下载 <code>public/chatSQL.yml</code> 文件</li>\n<li>在 Dify 平台中导入该配置文件</li>\n<li><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefineddify.png?imageSlim\"\n                     \n                ></li>\n</ul>\n</li>\n<li>获取 API 密钥并在个人设置中配置（工作流默认使用 Gemini，可根据需要修改）</li>\n</ol>\n<h2 id=\"🤝-贡献\"><a href=\"#🤝-贡献\" class=\"headerlink\" title=\"🤝 贡献\"></a>🤝 贡献</h2><p>欢迎提交 Pull Request 和 Issue！</p>\n","_processedHighlight":true},{"title":"倦鸟","date":"2025-01-08T08:10:10.000Z","thumbnail":"/img/倦鸟.png","_content":"<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟\n<br>\n越过人海 坠入你乌黑瞳仁中的夜\n</p>\n\n\n> 下附最初的三节诗, 以及灵感来源.\n\n\n<details>\n<summary> 完整三节诗</summary>\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    line-height: 1.5em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟 <br>\n越过人海终于落入你乌黑瞳仁中的夜<br>\n<br>\n你澄澈的眼眸映照着闪烁明灭的晨星<br>\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br>\n<br>\n我们的目光还是悄然相遇了<br>\n你温和的凝视又让我想起黎明的微光<br>\n我漆黑的羽翼微微颤动 随后灼灼燃烧<br>\n于是 我的目光载着余烬 再度飞远了<br>\n</p>\n</details>\n\n<details>\n<summary> 「灵感」Tagore's</summary>\n\n<p style = \" \n    font-size: 1.1em;\n    text-align: center;\n    line-height: 2em;\"\n>\nMy heart, the bird of the wilderness, <br>\nhas found its sky in your eyes.<br>\n\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    color: grey;\n    line-height: 2em;\"\n>(出自泰戈尔的园丁集)\n</p>\n\n</p>\n</details>","source":"_posts/poets/bird.md","raw":"---\ntitle: 倦鸟\ndate: 2025-01-08 16:10:10\ntags: \n- 短诗\ncategories: 随机掉落的文字碎片\nthumbnail: /img/倦鸟.png\n---\n<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟\n<br>\n越过人海 坠入你乌黑瞳仁中的夜\n</p>\n\n\n> 下附最初的三节诗, 以及灵感来源.\n\n\n<details>\n<summary> 完整三节诗</summary>\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    line-height: 1.5em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟 <br>\n越过人海终于落入你乌黑瞳仁中的夜<br>\n<br>\n你澄澈的眼眸映照着闪烁明灭的晨星<br>\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br>\n<br>\n我们的目光还是悄然相遇了<br>\n你温和的凝视又让我想起黎明的微光<br>\n我漆黑的羽翼微微颤动 随后灼灼燃烧<br>\n于是 我的目光载着余烬 再度飞远了<br>\n</p>\n</details>\n\n<details>\n<summary> 「灵感」Tagore's</summary>\n\n<p style = \" \n    font-size: 1.1em;\n    text-align: center;\n    line-height: 2em;\"\n>\nMy heart, the bird of the wilderness, <br>\nhas found its sky in your eyes.<br>\n\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    color: grey;\n    line-height: 2em;\"\n>(出自泰戈尔的园丁集)\n</p>\n\n</p>\n</details>","slug":"poets/bird","published":1,"updated":"2025-05-09T01:43:47.786Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ad000c2xqg96faa0z1","content":"<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟\n<br>\n越过人海 坠入你乌黑瞳仁中的夜\n</p>\n\n\n<blockquote>\n<p>下附最初的三节诗, 以及灵感来源.</p>\n</blockquote>\n<details>\n<summary> 完整三节诗</summary>\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    line-height: 1.5em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟 <br>\n越过人海终于落入你乌黑瞳仁中的夜<br>\n<br>\n你澄澈的眼眸映照着闪烁明灭的晨星<br>\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br>\n<br>\n我们的目光还是悄然相遇了<br>\n你温和的凝视又让我想起黎明的微光<br>\n我漆黑的羽翼微微颤动 随后灼灼燃烧<br>\n于是 我的目光载着余烬 再度飞远了<br>\n</p>\n</details>\n\n<details>\n<summary> 「灵感」Tagore's</summary>\n\n<p style = \" \n    font-size: 1.1em;\n    text-align: center;\n    line-height: 2em;\"\n>\nMy heart, the bird of the wilderness, <br>\nhas found its sky in your eyes.<br>\n\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    color: grey;\n    line-height: 2em;\"\n>(出自泰戈尔的园丁集)\n</p>\n\n</p>\n</details>","excerpt":"","more":"<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟\n<br>\n越过人海 坠入你乌黑瞳仁中的夜\n</p>\n\n\n<blockquote>\n<p>下附最初的三节诗, 以及灵感来源.</p>\n</blockquote>\n<details>\n<summary> 完整三节诗</summary>\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    line-height: 1.5em;\"\n>\n我盘旋的目光是漂泊不息的倦鸟 <br>\n越过人海终于落入你乌黑瞳仁中的夜<br>\n<br>\n你澄澈的眼眸映照着闪烁明灭的晨星<br>\n你泛着红晕的脸颊 留着朝霞热切亲吻的印记<br>\n<br>\n我们的目光还是悄然相遇了<br>\n你温和的凝视又让我想起黎明的微光<br>\n我漆黑的羽翼微微颤动 随后灼灼燃烧<br>\n于是 我的目光载着余烬 再度飞远了<br>\n</p>\n</details>\n\n<details>\n<summary> 「灵感」Tagore's</summary>\n\n<p style = \" \n    font-size: 1.1em;\n    text-align: center;\n    line-height: 2em;\"\n>\nMy heart, the bird of the wilderness, <br>\nhas found its sky in your eyes.<br>\n\n<p style = \" \n    font-size: 1em;\n    text-align: center;\n    color: grey;\n    line-height: 2em;\"\n>(出自泰戈尔的园丁集)\n</p>\n\n</p>\n</details>","_processedHighlight":true},{"title":"晚霞","date":"2025-01-09T12:59:02.000Z","excerpt":"记紫金港的世纪晚霞","thumbnail":"/img/晚霞.jpg","_content":"<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n白昼飞红了她的<span style = \"color: #fe4017\">脸颊</span> <br>\n以隐匿于远山之后的凝望<br>  \n默默期待着  <br>\n月色的降临  <br>\n</p>\n","source":"_posts/poets/晚霞.md","raw":"---\ntitle: 晚霞\ndate: 2025-01-09 20:59:02\ntags: \n- 短诗\n- 自然\ncategories: 随机掉落的文字碎片\nexcerpt: 记紫金港的世纪晚霞\nthumbnail: /img/晚霞.jpg\n---\n<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n白昼飞红了她的<span style = \"color: #fe4017\">脸颊</span> <br>\n以隐匿于远山之后的凝望<br>  \n默默期待着  <br>\n月色的降临  <br>\n</p>\n","slug":"poets/晚霞","published":1,"updated":"2025-05-09T01:44:33.079Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ad000e2xqg7zf10hz5","content":"<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n白昼飞红了她的<span style = \"color: #fe4017\">脸颊</span> <br>\n以隐匿于远山之后的凝望<br>  \n默默期待着  <br>\n月色的降临  <br>\n</p>\n","more":"<br>\n<p style = \" \n    font-size: 1.3em;\n    text-align: center;\n    line-height: 2em;\"\n>\n白昼飞红了她的<span style = \"color: #fe4017\">脸颊</span> <br>\n以隐匿于远山之后的凝望<br>  \n默默期待着  <br>\n月色的降临  <br>\n</p>\n","_processedHighlight":true},{"title":"CORS","date":"2025-01-16T02:11:38.000Z","excerpt":"在前后端分离的项目中, 常常需要注意跨域资源共享的问题.","index_img":"/img/跨域共享.jpg","_content":"\n# 跨域资源共享（CORS）技术指南\n\n## 目录\n1. [概述](#概述)\n2. [技术背景](#技术背景)\n3. [配置方案](#配置方案)\n4. [最佳实践](#最佳实践)\n5. [问题排查](#问题排查)\n6. [参考文献](#参考文献)\n\n## 概述\n\n跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。\n\n## 技术背景\n\n### 同源策略基础\n\n同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：\n\n```plaintext\n基准URL：http://example.com/page.html\n\n跨域场景：\n- http://api.example.com/data     // 子域名差异\n- https://example.com/data        // 协议差异\n- http://example.com:8080/data    // 端口差异\n```\n\n## 配置方案\n\n### 环境变量驱动的CORS配置\n\n以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：\n\n```python\nimport os\nfrom flask import Flask\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n\n# 从环境变量获取前端URL，如果没有设置则使用默认值\nFRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')\n\n# CORS配置实现\nCORS(app, resources={\n    r\"/api/*\": {\n        \"origins\": FRONTEND_URL,\n        \"methods\": [\"GET\", \"POST\", \"OPTIONS\", \"PUT\", \"DELETE\"],\n        \"allow_headers\": [\"Content-Type\", \"Authorization\", \"X-Requested-With\"],\n        \"supports_credentials\": True,\n        \"expose_headers\": [\"Content-Disposition\"]\n    }\n})\n```\n\n### 配置详解\n\n让我们逐行分析这个配置：\n\n1. **环境变量设置**\n```python\nFRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')\n```\n- 使用`os.environ.get()`获取环境变量\n- 提供默认值`'http://localhost:3000'`作为本地开发环境的配置\n- 可以通过环境变量轻松切换不同环境的配置\n\n2. **CORS配置参数**\n```python\n\"origins\": FRONTEND_URL\n```\n- 动态设置允许的源，基于环境变量\n- 避免了硬编码的问题\n- 支持不同部署环境的灵活配置\n\n3. **HTTP方法配置**\n```python\n\"methods\": [\"GET\", \"POST\", \"OPTIONS\", \"PUT\", \"DELETE\"]\n```\n- 明确定义允许的HTTP方法\n- 包含了RESTful API所需的全部方法\n- `OPTIONS`用于预检请求（preflight request）\n\n4. **请求头配置**\n```python\n\"allow_headers\": [\"Content-Type\", \"Authorization\", \"X-Requested-With\"]\n```\n- `Content-Type`：允许设置请求的内容类型\n- `Authorization`：支持身份验证令牌\n- `X-Requested-With`：用于标识AJAX请求\n\n5. **凭证支持**\n```python\n\"supports_credentials\": True\n```\n- 允许跨域请求携带凭证（如Cookie）\n- 对需要身份验证的API至关重要\n\n6. **响应头暴露**\n```python\n\"expose_headers\": [\"Content-Disposition\"]\n```\n- 允许客户端访问`Content-Disposition`响应头\n- 通常用于文件下载功能\n\n### 环境变量配置示例\n\n```bash\n# 开发环境\nexport FRONTEND_URL=http://localhost:3000\n\n# 测试环境\nexport FRONTEND_URL=http://test.example.com\n\n# 生产环境\nexport FRONTEND_URL=https://www.example.com\n```\n\n## 最佳实践\n\n### 环境变量管理建议\n\n1. **开发环境**\n- 使用`.env`文件管理本地开发环境变量\n- 将`.env`文件加入`.gitignore`\n\n2. **生产环境**\n- 使用容器化部署时通过环境变量注入\n- 使用配置管理系统统一管理环境变量\n\n### 安全性考虑\n\n1. **避免过于宽松的配置**\n```python\n# 不推荐\n\"origins\": \"*\"  \n\n# 推荐\n\"origins\": FRONTEND_URL\n```\n\n2. **合理设置凭证策略**\n- 仅在必要时启用`supports_credentials`\n- 确保前端配置匹配（`credentials: 'include'`）\n\n## 问题排查\n\n### 常见错误及解决方案\n\n1. **CORS策略违规**\n```plaintext\nAccess to XMLHttpRequest at 'http://api.example.com' from origin 'http://example.com' \nhas been blocked by CORS policy\n```\n解决方案：\n- 检查环境变量是否正确设置\n- 验证前端请求URL与配置是否匹配\n- 确认所有必要的请求头都已配置\n\n## 参考文献\n\n1. [W3C CORS Specification](https://fetch.spec.whatwg.org/?locale=zh_CN)\n2. [MDN Web Docs - Cross-Origin Resource Sharing](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n3. [Flask-CORS Official Documentation](https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN)\n","source":"_posts/前后端/CORS.md","raw":"---\ntitle: CORS\ndate: 2025-01-16 10:11:38\ntags: \n- 前后端交互  \n- 网站开发\ncategories: 学习笔记\nexcerpt: 在前后端分离的项目中, 常常需要注意跨域资源共享的问题.\nindex_img: /img/跨域共享.jpg\n---\n\n# 跨域资源共享（CORS）技术指南\n\n## 目录\n1. [概述](#概述)\n2. [技术背景](#技术背景)\n3. [配置方案](#配置方案)\n4. [最佳实践](#最佳实践)\n5. [问题排查](#问题排查)\n6. [参考文献](#参考文献)\n\n## 概述\n\n跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。\n\n## 技术背景\n\n### 同源策略基础\n\n同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：\n\n```plaintext\n基准URL：http://example.com/page.html\n\n跨域场景：\n- http://api.example.com/data     // 子域名差异\n- https://example.com/data        // 协议差异\n- http://example.com:8080/data    // 端口差异\n```\n\n## 配置方案\n\n### 环境变量驱动的CORS配置\n\n以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：\n\n```python\nimport os\nfrom flask import Flask\nfrom flask_cors import CORS\n\napp = Flask(__name__)\n\n# 从环境变量获取前端URL，如果没有设置则使用默认值\nFRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')\n\n# CORS配置实现\nCORS(app, resources={\n    r\"/api/*\": {\n        \"origins\": FRONTEND_URL,\n        \"methods\": [\"GET\", \"POST\", \"OPTIONS\", \"PUT\", \"DELETE\"],\n        \"allow_headers\": [\"Content-Type\", \"Authorization\", \"X-Requested-With\"],\n        \"supports_credentials\": True,\n        \"expose_headers\": [\"Content-Disposition\"]\n    }\n})\n```\n\n### 配置详解\n\n让我们逐行分析这个配置：\n\n1. **环境变量设置**\n```python\nFRONTEND_URL = os.environ.get('FRONTEND_URL', 'http://localhost:3000')\n```\n- 使用`os.environ.get()`获取环境变量\n- 提供默认值`'http://localhost:3000'`作为本地开发环境的配置\n- 可以通过环境变量轻松切换不同环境的配置\n\n2. **CORS配置参数**\n```python\n\"origins\": FRONTEND_URL\n```\n- 动态设置允许的源，基于环境变量\n- 避免了硬编码的问题\n- 支持不同部署环境的灵活配置\n\n3. **HTTP方法配置**\n```python\n\"methods\": [\"GET\", \"POST\", \"OPTIONS\", \"PUT\", \"DELETE\"]\n```\n- 明确定义允许的HTTP方法\n- 包含了RESTful API所需的全部方法\n- `OPTIONS`用于预检请求（preflight request）\n\n4. **请求头配置**\n```python\n\"allow_headers\": [\"Content-Type\", \"Authorization\", \"X-Requested-With\"]\n```\n- `Content-Type`：允许设置请求的内容类型\n- `Authorization`：支持身份验证令牌\n- `X-Requested-With`：用于标识AJAX请求\n\n5. **凭证支持**\n```python\n\"supports_credentials\": True\n```\n- 允许跨域请求携带凭证（如Cookie）\n- 对需要身份验证的API至关重要\n\n6. **响应头暴露**\n```python\n\"expose_headers\": [\"Content-Disposition\"]\n```\n- 允许客户端访问`Content-Disposition`响应头\n- 通常用于文件下载功能\n\n### 环境变量配置示例\n\n```bash\n# 开发环境\nexport FRONTEND_URL=http://localhost:3000\n\n# 测试环境\nexport FRONTEND_URL=http://test.example.com\n\n# 生产环境\nexport FRONTEND_URL=https://www.example.com\n```\n\n## 最佳实践\n\n### 环境变量管理建议\n\n1. **开发环境**\n- 使用`.env`文件管理本地开发环境变量\n- 将`.env`文件加入`.gitignore`\n\n2. **生产环境**\n- 使用容器化部署时通过环境变量注入\n- 使用配置管理系统统一管理环境变量\n\n### 安全性考虑\n\n1. **避免过于宽松的配置**\n```python\n# 不推荐\n\"origins\": \"*\"  \n\n# 推荐\n\"origins\": FRONTEND_URL\n```\n\n2. **合理设置凭证策略**\n- 仅在必要时启用`supports_credentials`\n- 确保前端配置匹配（`credentials: 'include'`）\n\n## 问题排查\n\n### 常见错误及解决方案\n\n1. **CORS策略违规**\n```plaintext\nAccess to XMLHttpRequest at 'http://api.example.com' from origin 'http://example.com' \nhas been blocked by CORS policy\n```\n解决方案：\n- 检查环境变量是否正确设置\n- 验证前端请求URL与配置是否匹配\n- 确认所有必要的请求头都已配置\n\n## 参考文献\n\n1. [W3C CORS Specification](https://fetch.spec.whatwg.org/?locale=zh_CN)\n2. [MDN Web Docs - Cross-Origin Resource Sharing](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS)\n3. [Flask-CORS Official Documentation](https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN)\n","slug":"前后端/CORS","published":1,"updated":"2025-05-08T12:02:22.522Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ae000g2xqg44rq0ue4","content":"<h1 id=\"跨域资源共享（CORS）技术指南\"><a href=\"#跨域资源共享（CORS）技术指南\" class=\"headerlink\" title=\"跨域资源共享（CORS）技术指南\"></a>跨域资源共享（CORS）技术指南</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#%E6%A6%82%E8%BF%B0\">概述</a></li>\n<li><a href=\"#%E6%8A%80%E6%9C%AF%E8%83%8C%E6%99%AF\">技术背景</a></li>\n<li><a href=\"#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88\">配置方案</a></li>\n<li><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">最佳实践</a></li>\n<li><a href=\"#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5\">问题排查</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</a></li>\n</ol>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。</p>\n<h2 id=\"技术背景\"><a href=\"#技术背景\" class=\"headerlink\" title=\"技术背景\"></a>技术背景</h2><h3 id=\"同源策略基础\"><a href=\"#同源策略基础\" class=\"headerlink\" title=\"同源策略基础\"></a>同源策略基础</h3><p>同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基准URL：http://example.com/page.html</span><br><span class=\"line\"></span><br><span class=\"line\">跨域场景：</span><br><span class=\"line\">- http://api.example.com/data     // 子域名差异</span><br><span class=\"line\">- https://example.com/data        // 协议差异</span><br><span class=\"line\">- http://example.com:8080/data    // 端口差异</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"配置方案\"><a href=\"#配置方案\" class=\"headerlink\" title=\"配置方案\"></a>配置方案</h2><h3 id=\"环境变量驱动的CORS配置\"><a href=\"#环境变量驱动的CORS配置\" class=\"headerlink\" title=\"环境变量驱动的CORS配置\"></a>环境变量驱动的CORS配置</h3><p>以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：</p>\n<div class=\"code-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_cors <span class=\"keyword\">import</span> CORS</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从环境变量获取前端URL，如果没有设置则使用默认值</span></span><br><span class=\"line\">FRONTEND_URL = os.environ.get(<span class=\"string\">&#x27;FRONTEND_URL&#x27;</span>, <span class=\"string\">&#x27;http://localhost:3000&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CORS配置实现</span></span><br><span class=\"line\">CORS(app, resources=&#123;</span><br><span class=\"line\">    <span class=\"string\">r&quot;/api/*&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;origins&quot;</span>: FRONTEND_URL,</span><br><span class=\"line\">        <span class=\"string\">&quot;methods&quot;</span>: [<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;OPTIONS&quot;</span>, <span class=\"string\">&quot;PUT&quot;</span>, <span class=\"string\">&quot;DELETE&quot;</span>],</span><br><span class=\"line\">        <span class=\"string\">&quot;allow_headers&quot;</span>: [<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;Authorization&quot;</span>, <span class=\"string\">&quot;X-Requested-With&quot;</span>],</span><br><span class=\"line\">        <span class=\"string\">&quot;supports_credentials&quot;</span>: <span class=\"literal\">True</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;expose_headers&quot;</span>: [<span class=\"string\">&quot;Content-Disposition&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"配置详解\"><a href=\"#配置详解\" class=\"headerlink\" title=\"配置详解\"></a>配置详解</h3><p>让我们逐行分析这个配置：</p>\n<ol>\n<li><strong>环境变量设置</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FRONTEND_URL = os.environ.get(<span class=\"string\">&#x27;FRONTEND_URL&#x27;</span>, <span class=\"string\">&#x27;http://localhost:3000&#x27;</span>)</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>使用<code>os.environ.get()</code>获取环境变量</li>\n<li>提供默认值<code>&#39;http://localhost:3000&#39;</code>作为本地开发环境的配置</li>\n<li>可以通过环境变量轻松切换不同环境的配置</li>\n</ul>\n<ol start=\"2\">\n<li><strong>CORS配置参数</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;origins&quot;</span>: FRONTEND_URL</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>动态设置允许的源，基于环境变量</li>\n<li>避免了硬编码的问题</li>\n<li>支持不同部署环境的灵活配置</li>\n</ul>\n<ol start=\"3\">\n<li><strong>HTTP方法配置</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;methods&quot;</span>: [<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;OPTIONS&quot;</span>, <span class=\"string\">&quot;PUT&quot;</span>, <span class=\"string\">&quot;DELETE&quot;</span>]</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>明确定义允许的HTTP方法</li>\n<li>包含了RESTful API所需的全部方法</li>\n<li><code>OPTIONS</code>用于预检请求（preflight request）</li>\n</ul>\n<ol start=\"4\">\n<li><strong>请求头配置</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;allow_headers&quot;</span>: [<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;Authorization&quot;</span>, <span class=\"string\">&quot;X-Requested-With&quot;</span>]</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>Content-Type</code>：允许设置请求的内容类型</li>\n<li><code>Authorization</code>：支持身份验证令牌</li>\n<li><code>X-Requested-With</code>：用于标识AJAX请求</li>\n</ul>\n<ol start=\"5\">\n<li><strong>凭证支持</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;supports_credentials&quot;</span>: <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>允许跨域请求携带凭证（如Cookie）</li>\n<li>对需要身份验证的API至关重要</li>\n</ul>\n<ol start=\"6\">\n<li><strong>响应头暴露</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;expose_headers&quot;</span>: [<span class=\"string\">&quot;Content-Disposition&quot;</span>]</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>允许客户端访问<code>Content-Disposition</code>响应头</li>\n<li>通常用于文件下载功能</li>\n</ul>\n<h3 id=\"环境变量配置示例\"><a href=\"#环境变量配置示例\" class=\"headerlink\" title=\"环境变量配置示例\"></a>环境变量配置示例</h3><div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开发环境</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> FRONTEND_URL=http://localhost:3000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试环境</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> FRONTEND_URL=http://test.example.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生产环境</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> FRONTEND_URL=https://www.example.com</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"环境变量管理建议\"><a href=\"#环境变量管理建议\" class=\"headerlink\" title=\"环境变量管理建议\"></a>环境变量管理建议</h3><ol>\n<li><strong>开发环境</strong></li>\n</ol>\n<ul>\n<li>使用<code>.env</code>文件管理本地开发环境变量</li>\n<li>将<code>.env</code>文件加入<code>.gitignore</code></li>\n</ul>\n<ol start=\"2\">\n<li><strong>生产环境</strong></li>\n</ol>\n<ul>\n<li>使用容器化部署时通过环境变量注入</li>\n<li>使用配置管理系统统一管理环境变量</li>\n</ul>\n<h3 id=\"安全性考虑\"><a href=\"#安全性考虑\" class=\"headerlink\" title=\"安全性考虑\"></a>安全性考虑</h3><ol>\n<li><strong>避免过于宽松的配置</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Python\"><figure class=\"iseeu highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不推荐</span></span><br><span class=\"line\"><span class=\"string\">&quot;origins&quot;</span>: <span class=\"string\">&quot;*&quot;</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推荐</span></span><br><span class=\"line\"><span class=\"string\">&quot;origins&quot;</span>: FRONTEND_URL</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li><strong>合理设置凭证策略</strong></li>\n</ol>\n<ul>\n<li>仅在必要时启用<code>supports_credentials</code></li>\n<li>确保前端配置匹配（<code>credentials: &#39;include&#39;</code>）</li>\n</ul>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><h3 id=\"常见错误及解决方案\"><a href=\"#常见错误及解决方案\" class=\"headerlink\" title=\"常见错误及解决方案\"></a>常见错误及解决方案</h3><ol>\n<li><strong>CORS策略违规</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access to XMLHttpRequest at &#x27;http://api.example.com&#x27; from origin &#x27;http://example.com&#x27; </span><br><span class=\"line\">has been blocked by CORS policy</span><br></pre></td></tr></table></figure></div>\n<p>解决方案：</p>\n<ul>\n<li>检查环境变量是否正确设置</li>\n<li>验证前端请求URL与配置是否匹配</li>\n<li>确认所有必要的请求头都已配置</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a class=\"link\"   href=\"https://fetch.spec.whatwg.org/?locale=zh_CN\" >W3C CORS Specification<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\" >MDN Web Docs - Cross-Origin Resource Sharing<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN\" >Flask-CORS Official Documentation<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ol>\n","more":"<h1 id=\"跨域资源共享（CORS）技术指南\"><a href=\"#跨域资源共享（CORS）技术指南\" class=\"headerlink\" title=\"跨域资源共享（CORS）技术指南\"></a>跨域资源共享（CORS）技术指南</h1><h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><ol>\n<li><a href=\"#%E6%A6%82%E8%BF%B0\">概述</a></li>\n<li><a href=\"#%E6%8A%80%E6%9C%AF%E8%83%8C%E6%99%AF\">技术背景</a></li>\n<li><a href=\"#%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88\">配置方案</a></li>\n<li><a href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\">最佳实践</a></li>\n<li><a href=\"#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5\">问题排查</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE\">参考文献</a></li>\n</ol>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>跨域资源共享（Cross-Origin Resource Sharing, CORS）是现代Web应用程序中的重要安全机制。本文档旨在提供全面的CORS配置指南，涵盖从开发环境到生产部署的完整实施方案。</p>\n<h2 id=\"技术背景\"><a href=\"#技术背景\" class=\"headerlink\" title=\"技术背景\"></a>技术背景</h2><h3 id=\"同源策略基础\"><a href=\"#同源策略基础\" class=\"headerlink\" title=\"同源策略基础\"></a>同源策略基础</h3><p>同源策略是Web应用安全的基石，要求协议（Protocol）、域名（Domain）和端口（Port）三者均相同。以下为不同场景的示例分析：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基准URL：http://example.com/page.html</span><br><span class=\"line\"></span><br><span class=\"line\">跨域场景：</span><br><span class=\"line\">- http://api.example.com/data     // 子域名差异</span><br><span class=\"line\">- https://example.com/data        // 协议差异</span><br><span class=\"line\">- http://example.com:8080/data    // 端口差异</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"配置方案\"><a href=\"#配置方案\" class=\"headerlink\" title=\"配置方案\"></a>配置方案</h2><h3 id=\"环境变量驱动的CORS配置\"><a href=\"#环境变量驱动的CORS配置\" class=\"headerlink\" title=\"环境变量驱动的CORS配置\"></a>环境变量驱动的CORS配置</h3><p>以下是一个完整的、基于环境变量的CORS配置示例。这种方案具有良好的灵活性和可维护性：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask</span><br><span class=\"line\"><span class=\"keyword\">from</span> flask_cors <span class=\"keyword\">import</span> CORS</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从环境变量获取前端URL，如果没有设置则使用默认值</span></span><br><span class=\"line\">FRONTEND_URL = os.environ.get(<span class=\"string\">&#x27;FRONTEND_URL&#x27;</span>, <span class=\"string\">&#x27;http://localhost:3000&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># CORS配置实现</span></span><br><span class=\"line\">CORS(app, resources=&#123;</span><br><span class=\"line\">    <span class=\"string\">r&quot;/api/*&quot;</span>: &#123;</span><br><span class=\"line\">        <span class=\"string\">&quot;origins&quot;</span>: FRONTEND_URL,</span><br><span class=\"line\">        <span class=\"string\">&quot;methods&quot;</span>: [<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;OPTIONS&quot;</span>, <span class=\"string\">&quot;PUT&quot;</span>, <span class=\"string\">&quot;DELETE&quot;</span>],</span><br><span class=\"line\">        <span class=\"string\">&quot;allow_headers&quot;</span>: [<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;Authorization&quot;</span>, <span class=\"string\">&quot;X-Requested-With&quot;</span>],</span><br><span class=\"line\">        <span class=\"string\">&quot;supports_credentials&quot;</span>: <span class=\"literal\">True</span>,</span><br><span class=\"line\">        <span class=\"string\">&quot;expose_headers&quot;</span>: [<span class=\"string\">&quot;Content-Disposition&quot;</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置详解\"><a href=\"#配置详解\" class=\"headerlink\" title=\"配置详解\"></a>配置详解</h3><p>让我们逐行分析这个配置：</p>\n<ol>\n<li><strong>环境变量设置</strong></li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FRONTEND_URL = os.environ.get(<span class=\"string\">&#x27;FRONTEND_URL&#x27;</span>, <span class=\"string\">&#x27;http://localhost:3000&#x27;</span>)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用<code>os.environ.get()</code>获取环境变量</li>\n<li>提供默认值<code>&#39;http://localhost:3000&#39;</code>作为本地开发环境的配置</li>\n<li>可以通过环境变量轻松切换不同环境的配置</li>\n</ul>\n<ol start=\"2\">\n<li><strong>CORS配置参数</strong></li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;origins&quot;</span>: FRONTEND_URL</span><br></pre></td></tr></table></figure>\n<ul>\n<li>动态设置允许的源，基于环境变量</li>\n<li>避免了硬编码的问题</li>\n<li>支持不同部署环境的灵活配置</li>\n</ul>\n<ol start=\"3\">\n<li><strong>HTTP方法配置</strong></li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;methods&quot;</span>: [<span class=\"string\">&quot;GET&quot;</span>, <span class=\"string\">&quot;POST&quot;</span>, <span class=\"string\">&quot;OPTIONS&quot;</span>, <span class=\"string\">&quot;PUT&quot;</span>, <span class=\"string\">&quot;DELETE&quot;</span>]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>明确定义允许的HTTP方法</li>\n<li>包含了RESTful API所需的全部方法</li>\n<li><code>OPTIONS</code>用于预检请求（preflight request）</li>\n</ul>\n<ol start=\"4\">\n<li><strong>请求头配置</strong></li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;allow_headers&quot;</span>: [<span class=\"string\">&quot;Content-Type&quot;</span>, <span class=\"string\">&quot;Authorization&quot;</span>, <span class=\"string\">&quot;X-Requested-With&quot;</span>]</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>Content-Type</code>：允许设置请求的内容类型</li>\n<li><code>Authorization</code>：支持身份验证令牌</li>\n<li><code>X-Requested-With</code>：用于标识AJAX请求</li>\n</ul>\n<ol start=\"5\">\n<li><strong>凭证支持</strong></li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;supports_credentials&quot;</span>: <span class=\"literal\">True</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>允许跨域请求携带凭证（如Cookie）</li>\n<li>对需要身份验证的API至关重要</li>\n</ul>\n<ol start=\"6\">\n<li><strong>响应头暴露</strong></li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">&quot;expose_headers&quot;</span>: [<span class=\"string\">&quot;Content-Disposition&quot;</span>]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>允许客户端访问<code>Content-Disposition</code>响应头</li>\n<li>通常用于文件下载功能</li>\n</ul>\n<h3 id=\"环境变量配置示例\"><a href=\"#环境变量配置示例\" class=\"headerlink\" title=\"环境变量配置示例\"></a>环境变量配置示例</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 开发环境</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> FRONTEND_URL=http://localhost:3000</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 测试环境</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> FRONTEND_URL=http://test.example.com</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 生产环境</span></span><br><span class=\"line\"><span class=\"built_in\">export</span> FRONTEND_URL=https://www.example.com</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h2><h3 id=\"环境变量管理建议\"><a href=\"#环境变量管理建议\" class=\"headerlink\" title=\"环境变量管理建议\"></a>环境变量管理建议</h3><ol>\n<li><strong>开发环境</strong></li>\n</ol>\n<ul>\n<li>使用<code>.env</code>文件管理本地开发环境变量</li>\n<li>将<code>.env</code>文件加入<code>.gitignore</code></li>\n</ul>\n<ol start=\"2\">\n<li><strong>生产环境</strong></li>\n</ol>\n<ul>\n<li>使用容器化部署时通过环境变量注入</li>\n<li>使用配置管理系统统一管理环境变量</li>\n</ul>\n<h3 id=\"安全性考虑\"><a href=\"#安全性考虑\" class=\"headerlink\" title=\"安全性考虑\"></a>安全性考虑</h3><ol>\n<li><strong>避免过于宽松的配置</strong></li>\n</ol>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 不推荐</span></span><br><span class=\"line\"><span class=\"string\">&quot;origins&quot;</span>: <span class=\"string\">&quot;*&quot;</span>  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 推荐</span></span><br><span class=\"line\"><span class=\"string\">&quot;origins&quot;</span>: FRONTEND_URL</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li><strong>合理设置凭证策略</strong></li>\n</ol>\n<ul>\n<li>仅在必要时启用<code>supports_credentials</code></li>\n<li>确保前端配置匹配（<code>credentials: &#39;include&#39;</code>）</li>\n</ul>\n<h2 id=\"问题排查\"><a href=\"#问题排查\" class=\"headerlink\" title=\"问题排查\"></a>问题排查</h2><h3 id=\"常见错误及解决方案\"><a href=\"#常见错误及解决方案\" class=\"headerlink\" title=\"常见错误及解决方案\"></a>常见错误及解决方案</h3><ol>\n<li><strong>CORS策略违规</strong></li>\n</ol>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Access to XMLHttpRequest at &#x27;http://api.example.com&#x27; from origin &#x27;http://example.com&#x27; </span><br><span class=\"line\">has been blocked by CORS policy</span><br></pre></td></tr></table></figure>\n<p>解决方案：</p>\n<ul>\n<li>检查环境变量是否正确设置</li>\n<li>验证前端请求URL与配置是否匹配</li>\n<li>确认所有必要的请求头都已配置</li>\n</ul>\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><ol>\n<li><a class=\"link\"   href=\"https://fetch.spec.whatwg.org/?locale=zh_CN\" >W3C CORS Specification<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS\" >MDN Web Docs - Cross-Origin Resource Sharing<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://flask-cors.readthedocs.io/en/latest/?locale=zh_CN\" >Flask-CORS Official Documentation<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ol>\n","_processedHighlight":true},{"title":"响应式设计","date":"2025-01-20T13:38:45.000Z","excerpt":"通过在freecodeCamp上的入门项目“响应式设计”来复习html等基础知识.","index_img":null,"math":true,"_content":"\n所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:\n- 第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；\n- 另一个作用是当图片无法加载时，页面需要显示的替代文本。\n\n<br>\n\n注意嵌套的形式.\ne.g\n```html\n <p>See more <a href=\"https://freecatphotoapp.com\">cat photos</a> in our gallery.</p>\n```\n\n<br>\n\n\n要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。\n```html\n<p>See more <a href=\"https://freecatphotoapp.com\" target = \"_blank\">cat photos</a> in our gallery.</p>\n```\n\n<br>\n\n锚元素除了能将文本转化为链接, 还可以将 **图片** 转换为链接:\n```html\n<a hreg = \"https://freecatphotoapp.com\">\n    <img src=\"https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg\" alt=\"A cute orange cat lying on its back.\">\n</a>\n```\n\n<br>\n\n\n**section** 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。\n\n<br>\n\n\n列表:\n- 无序列表: `ul`;\n- 有序列表:`ol`;\n- 列表项: `li`;\n\n<br>\n\n\n**figure** 元素代表自包含的内容，允许将图像与标题相关联;\n**figcaption** 元素用于添加标题以描述 figure 元素中包含的图像。\n```html\n<figure>\n  <img src=\"image.jpg\" alt=\"A description of the image\">\n  <figcaption>A cute cat</figcaption>\n</figure>\n```\n\n<br>\n\n\n- 使用 **em** 使得文字为斜体;\n- `strong` 加深文字;\n\n<br>\n\n\nform 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。\n- `action`属性指定表单数据发送的位置;\n``` html\n<form action=\"/submit-url\"></form>\n```\n\n---\ninput 允许通过多种方式从Web表单中收集数据:\n- 与`img`一样为空元素——不需要结束标签;\n- 使用 `type` 属性创建多种输入;\n  - `text` : 文本;\n  - `radio`: 可以使用单选按钮;\n  - `checkbox`: 表单使用 **复选框**;\n- 使用`name`属性使得区分提交的数据;\n  - 令多个单选按钮具有 **相同** 的`name`, 使得在选中其中一个按钮时自动取消另外的单选按钮;\n  - 形成`name = value`形式的属性对进行提交;\n```html\n<label><input id=\"indoor\" type=\"radio\" name = \"indoor-outdoor\"> Indoor</label>\n<label><input id=\"outdoor\" type=\"radio\" name = 'indoor-outdoor'> Outdoor</label>\n```\n- `placeholder` 中为 **占位符** 文本, 用于提示输入框中输入的信息;\n- `required`属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;\n\n```html\n    <input type=\"text\" name = \"catphotourl\">\n```\n\n<br>\n\n\n`button` 用于创建可点击的按钮:\n- 单击**没有任何属性**的表单按钮的默认行为会将表单提交到**表单**的 `action `属性中指定的位置;\n- 由于`input`和`button`为 **内联** 元素, 即使相隔书写也会显示在同行:\n- `type`的`submit`明确了为 可提交按钮;\n```html\n<button type = \"submit\">Submit</button>\n```\n\n<br>\n\nlabel 元素用于帮助将 input 元素的文本与 input 元素本身关联起来\n```html\n<label><input type=\"radio\"> cat</label>\n<!-- 点击单词 \"cat\" 也将选择 radio 按钮。 -->\n```\n\n<br>\n\n`id`用于标识特定的HTML元素\n\n<br>\n\n`fieldset` 元素用于在 Web 表单中将相关的输入和标签组合在一起:\n  - 块级元素，这意味着它们出现在新的一行上。\n  - `legend` 元素充当 fieldset 元素中内容的标题。\n```html\n<fieldset>\n        <legend> Is your cat an indoor or outdoor cat?</legend>\n          <label><input id=\"indoor\" type=\"radio\" name=\"indoor-outdoor\" value=\"indoor\"> Indoor</label>\n          <label><input id=\"outdoor\" type=\"radio\" name=\"indoor-outdoor\" value=\"outdoor\"> Outdoor</label>\n</fieldset>\n```\n![](/img/legend-2025-01-21-21-19-51.png)\n\n<br>\n\n还可以使用`for`属性将文本直接嵌套在`label`当中, 同时设置`input`的`id`与上述的`for`属性相同, 从而实现文本与元素相关联的效果:\n```html\n<input id=\"loving\" type=\"checkbox\"> \n<label for = \"loving\"> Loving </label>\n```\n\n<br>\n\n默认选中的按钮: `checked`\n```html\n<input checked type=\"radio\" name=\"meal\" value=\"breakfast\"> Breakfast\n```\n> checked属性无需额外赋值.\n\n<br>\n\n`footer`素用于定义文档或章节的页脚:\n- 脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.\n\n<br>\n\nhead 相关\n- 存放 $\\underline{元数据}$ 不会实际显示在html中的数据;\n- `title `元素决定了浏览器在页面的标题栏或选项卡中显示的内容;\n- `<link rel = \"stylesheet\" href = \"styles.css\">` 将CSS文件链接到当前的HTML\n\nelse:\n- `<!DOCTYPE html`: 声明满足最新版本html相关设置的要求;\n- `meta`是空元素; `<meta charset = \"utf-8\">`;\n- \n\n\n---\n\n选择器:\n- **id**选择器\n```css\n#cat {\n  width: 250px;\n}\n```\n- **class**选择器\n```css\n.class-name, .other-class {\n  styles\n}\n```\n- class类中元素的选择\n```css\n.item p{\n  /* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */\n  display: inline-block; \n}\n```\n- **伪元素**\n```css\n/* 已访问链接后设置为灰色 */\na:visited{\n  color: grey;\n}\n\n/* 悬浮时的变色 */\na:hover {\n  color: brown;\n}\n\n/* 点击时的状态设置 */\na:active{\n  color: white;\n}\n```\n<br>\n\n```css\n  margin-left : auto;\n  margin-right: auto;\n```\n> 使得**普通**元素在父级元素的空间内 **水平居中**\n\n\n<br>\n\n`article`是一个语义化标签:\n- 用于表示文档、页面或应用中的**独立**的、完整的内容单元;\n- 清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;\n- 内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.\n\n与其他类似标签的区别:\n- `div`: 粹的容器，没有语义，常用于布局;\n- `section`: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;\n- `article`: 示一个可以独立存在的内容单元.\n\n<br>\n\n```css\n/* 设置备用字体 */\nh1, h2 {\n  font-family: Impact, serif;\n}\n```\n\n\n","source":"_posts/前后端/响应式设计.md","raw":"---\ntitle: 响应式设计\ndate: 2025-01-20 21:38:45\ntags: \n- 杂记\nexcerpt: 通过在freecodeCamp上的入门项目“响应式设计”来复习html等基础知识.\nindex_img: \ncategories: 学习笔记\nmath: true\n---\n\n所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:\n- 第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；\n- 另一个作用是当图片无法加载时，页面需要显示的替代文本。\n\n<br>\n\n注意嵌套的形式.\ne.g\n```html\n <p>See more <a href=\"https://freecatphotoapp.com\">cat photos</a> in our gallery.</p>\n```\n\n<br>\n\n\n要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。\n```html\n<p>See more <a href=\"https://freecatphotoapp.com\" target = \"_blank\">cat photos</a> in our gallery.</p>\n```\n\n<br>\n\n锚元素除了能将文本转化为链接, 还可以将 **图片** 转换为链接:\n```html\n<a hreg = \"https://freecatphotoapp.com\">\n    <img src=\"https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg\" alt=\"A cute orange cat lying on its back.\">\n</a>\n```\n\n<br>\n\n\n**section** 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。\n\n<br>\n\n\n列表:\n- 无序列表: `ul`;\n- 有序列表:`ol`;\n- 列表项: `li`;\n\n<br>\n\n\n**figure** 元素代表自包含的内容，允许将图像与标题相关联;\n**figcaption** 元素用于添加标题以描述 figure 元素中包含的图像。\n```html\n<figure>\n  <img src=\"image.jpg\" alt=\"A description of the image\">\n  <figcaption>A cute cat</figcaption>\n</figure>\n```\n\n<br>\n\n\n- 使用 **em** 使得文字为斜体;\n- `strong` 加深文字;\n\n<br>\n\n\nform 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。\n- `action`属性指定表单数据发送的位置;\n``` html\n<form action=\"/submit-url\"></form>\n```\n\n---\ninput 允许通过多种方式从Web表单中收集数据:\n- 与`img`一样为空元素——不需要结束标签;\n- 使用 `type` 属性创建多种输入;\n  - `text` : 文本;\n  - `radio`: 可以使用单选按钮;\n  - `checkbox`: 表单使用 **复选框**;\n- 使用`name`属性使得区分提交的数据;\n  - 令多个单选按钮具有 **相同** 的`name`, 使得在选中其中一个按钮时自动取消另外的单选按钮;\n  - 形成`name = value`形式的属性对进行提交;\n```html\n<label><input id=\"indoor\" type=\"radio\" name = \"indoor-outdoor\"> Indoor</label>\n<label><input id=\"outdoor\" type=\"radio\" name = 'indoor-outdoor'> Outdoor</label>\n```\n- `placeholder` 中为 **占位符** 文本, 用于提示输入框中输入的信息;\n- `required`属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;\n\n```html\n    <input type=\"text\" name = \"catphotourl\">\n```\n\n<br>\n\n\n`button` 用于创建可点击的按钮:\n- 单击**没有任何属性**的表单按钮的默认行为会将表单提交到**表单**的 `action `属性中指定的位置;\n- 由于`input`和`button`为 **内联** 元素, 即使相隔书写也会显示在同行:\n- `type`的`submit`明确了为 可提交按钮;\n```html\n<button type = \"submit\">Submit</button>\n```\n\n<br>\n\nlabel 元素用于帮助将 input 元素的文本与 input 元素本身关联起来\n```html\n<label><input type=\"radio\"> cat</label>\n<!-- 点击单词 \"cat\" 也将选择 radio 按钮。 -->\n```\n\n<br>\n\n`id`用于标识特定的HTML元素\n\n<br>\n\n`fieldset` 元素用于在 Web 表单中将相关的输入和标签组合在一起:\n  - 块级元素，这意味着它们出现在新的一行上。\n  - `legend` 元素充当 fieldset 元素中内容的标题。\n```html\n<fieldset>\n        <legend> Is your cat an indoor or outdoor cat?</legend>\n          <label><input id=\"indoor\" type=\"radio\" name=\"indoor-outdoor\" value=\"indoor\"> Indoor</label>\n          <label><input id=\"outdoor\" type=\"radio\" name=\"indoor-outdoor\" value=\"outdoor\"> Outdoor</label>\n</fieldset>\n```\n![](/img/legend-2025-01-21-21-19-51.png)\n\n<br>\n\n还可以使用`for`属性将文本直接嵌套在`label`当中, 同时设置`input`的`id`与上述的`for`属性相同, 从而实现文本与元素相关联的效果:\n```html\n<input id=\"loving\" type=\"checkbox\"> \n<label for = \"loving\"> Loving </label>\n```\n\n<br>\n\n默认选中的按钮: `checked`\n```html\n<input checked type=\"radio\" name=\"meal\" value=\"breakfast\"> Breakfast\n```\n> checked属性无需额外赋值.\n\n<br>\n\n`footer`素用于定义文档或章节的页脚:\n- 脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.\n\n<br>\n\nhead 相关\n- 存放 $\\underline{元数据}$ 不会实际显示在html中的数据;\n- `title `元素决定了浏览器在页面的标题栏或选项卡中显示的内容;\n- `<link rel = \"stylesheet\" href = \"styles.css\">` 将CSS文件链接到当前的HTML\n\nelse:\n- `<!DOCTYPE html`: 声明满足最新版本html相关设置的要求;\n- `meta`是空元素; `<meta charset = \"utf-8\">`;\n- \n\n\n---\n\n选择器:\n- **id**选择器\n```css\n#cat {\n  width: 250px;\n}\n```\n- **class**选择器\n```css\n.class-name, .other-class {\n  styles\n}\n```\n- class类中元素的选择\n```css\n.item p{\n  /* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */\n  display: inline-block; \n}\n```\n- **伪元素**\n```css\n/* 已访问链接后设置为灰色 */\na:visited{\n  color: grey;\n}\n\n/* 悬浮时的变色 */\na:hover {\n  color: brown;\n}\n\n/* 点击时的状态设置 */\na:active{\n  color: white;\n}\n```\n<br>\n\n```css\n  margin-left : auto;\n  margin-right: auto;\n```\n> 使得**普通**元素在父级元素的空间内 **水平居中**\n\n\n<br>\n\n`article`是一个语义化标签:\n- 用于表示文档、页面或应用中的**独立**的、完整的内容单元;\n- 清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;\n- 内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.\n\n与其他类似标签的区别:\n- `div`: 粹的容器，没有语义，常用于布局;\n- `section`: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;\n- `article`: 示一个可以独立存在的内容单元.\n\n<br>\n\n```css\n/* 设置备用字体 */\nh1, h2 {\n  font-family: Impact, serif;\n}\n```\n\n\n","slug":"前后端/响应式设计","published":1,"updated":"2025-05-08T12:02:22.523Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ae000i2xqghw0ygtux","content":"<p>所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:</p>\n<ul>\n<li>第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；</li>\n<li>另一个作用是当图片无法加载时，页面需要显示的替代文本。</li>\n</ul>\n<br>\n\n<p>注意嵌套的形式.<br>e.g</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>See more <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://freecatphotoapp.com&quot;</span>&gt;</span>cat photos<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> in our gallery.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n\n<p>要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>See more <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://freecatphotoapp.com&quot;</span> <span class=\"attr\">target</span> = <span class=\"string\">&quot;_blank&quot;</span>&gt;</span>cat photos<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> in our gallery.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n<p>锚元素除了能将文本转化为链接, 还可以将 <strong>图片</strong> 转换为链接:</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">hreg</span> = <span class=\"string\">&quot;https://freecatphotoapp.com&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;A cute orange cat lying on its back.&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n\n<p><strong>section</strong> 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。</p>\n<br>\n\n\n<p>列表:</p>\n<ul>\n<li>无序列表: <code>ul</code>;</li>\n<li>有序列表:<code>ol</code>;</li>\n<li>列表项: <code>li</code>;</li>\n</ul>\n<br>\n\n\n<p><strong>figure</strong> 元素代表自包含的内容，允许将图像与标题相关联;<br><strong>figcaption</strong> 元素用于添加标题以描述 figure 元素中包含的图像。</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">figure</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;image.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;A description of the image&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">figcaption</span>&gt;</span>A cute cat<span class=\"tag\">&lt;/<span class=\"name\">figcaption</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">figure</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n\n<ul>\n<li>使用 <strong>em</strong> 使得文字为斜体;</li>\n<li><code>strong</code> 加深文字;</li>\n</ul>\n<br>\n\n\n<p>form 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。</p>\n<ul>\n<li><code>action</code>属性指定表单数据发送的位置;</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/submit-url&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p>input 允许通过多种方式从Web表单中收集数据:</p>\n<ul>\n<li>与<code>img</code>一样为空元素——不需要结束标签;</li>\n<li>使用 <code>type</code> 属性创建多种输入;<ul>\n<li><code>text</code> : 文本;</li>\n<li><code>radio</code>: 可以使用单选按钮;</li>\n<li><code>checkbox</code>: 表单使用 <strong>复选框</strong>;</li>\n</ul>\n</li>\n<li>使用<code>name</code>属性使得区分提交的数据;<ul>\n<li>令多个单选按钮具有 <strong>相同</strong> 的<code>name</code>, 使得在选中其中一个按钮时自动取消另外的单选按钮;</li>\n<li>形成<code>name = value</code>形式的属性对进行提交;</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;indoor&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span> = <span class=\"string\">&quot;indoor-outdoor&quot;</span>&gt;</span> Indoor<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;outdoor&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span> = <span class=\"string\">&#x27;indoor-outdoor&#x27;</span>&gt;</span> Outdoor<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>placeholder</code> 中为 <strong>占位符</strong> 文本, 用于提示输入框中输入的信息;</li>\n<li><code>required</code>属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span> = <span class=\"string\">&quot;catphotourl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n\n<p><code>button</code> 用于创建可点击的按钮:</p>\n<ul>\n<li>单击<strong>没有任何属性</strong>的表单按钮的默认行为会将表单提交到<strong>表单</strong>的 <code>action </code>属性中指定的位置;</li>\n<li>由于<code>input</code>和<code>button</code>为 <strong>内联</strong> 元素, 即使相隔书写也会显示在同行:</li>\n<li><code>type</code>的<code>submit</code>明确了为 可提交按钮;</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span> = <span class=\"string\">&quot;submit&quot;</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n<p>label 元素用于帮助将 input 元素的文本与 input 元素本身关联起来</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span>&gt;</span> cat<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 点击单词 &quot;cat&quot; 也将选择 radio 按钮。 --&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n<p><code>id</code>用于标识特定的HTML元素</p>\n<br>\n\n<p><code>fieldset</code> 元素用于在 Web 表单中将相关的输入和标签组合在一起:</p>\n<ul>\n<li>块级元素，这意味着它们出现在新的一行上。</li>\n<li><code>legend</code> 元素充当 fieldset 元素中内容的标题。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span> Is your cat an indoor or outdoor cat?<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;indoor&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;indoor-outdoor&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;indoor&quot;</span>&gt;</span> Indoor<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;outdoor&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;indoor-outdoor&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;outdoor&quot;</span>&gt;</span> Outdoor<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/img/legend-2025-01-21-21-19-51.png\"\n                     \n                ></p>\n<br>\n\n<p>还可以使用<code>for</code>属性将文本直接嵌套在<code>label</code>当中, 同时设置<code>input</code>的<code>id</code>与上述的<code>for</code>属性相同, 从而实现文本与元素相关联的效果:</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;loving&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span> = <span class=\"string\">&quot;loving&quot;</span>&gt;</span> Loving <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n<p>默认选中的按钮: <code>checked</code></p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">checked</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;meal&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;breakfast&quot;</span>&gt;</span> Breakfast</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>checked属性无需额外赋值.</p>\n</blockquote>\n<br>\n\n<p><code>footer</code>素用于定义文档或章节的页脚:</p>\n<ul>\n<li>脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.</li>\n</ul>\n<br>\n\n<p>head 相关</p>\n<ul>\n<li>存放 $\\underline{元数据}$ 不会实际显示在html中的数据;</li>\n<li><code>title </code>元素决定了浏览器在页面的标题栏或选项卡中显示的内容;</li>\n<li><code>&lt;link rel = &quot;stylesheet&quot; href = &quot;styles.css&quot;&gt;</code> 将CSS文件链接到当前的HTML</li>\n</ul>\n<p>else:</p>\n<ul>\n<li><code>&lt;!DOCTYPE html</code>: 声明满足最新版本html相关设置的要求;</li>\n<li><code>meta</code>是空元素; <code>&lt;meta charset = &quot;utf-8&quot;&gt;</code>;</li>\n<li></li>\n</ul>\n<hr>\n<p>选择器:</p>\n<ul>\n<li><strong>id</strong>选择器</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#cat</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">250px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><strong>class</strong>选择器</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.class-name</span>, <span class=\"selector-class\">.other-class</span> &#123;</span><br><span class=\"line\">  styles</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>class类中元素的选择</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> <span class=\"selector-tag\">p</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><strong>伪元素</strong></li>\n</ul>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 已访问链接后设置为灰色 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:visited</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: grey;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 悬浮时的变色 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: brown;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 点击时的状态设置 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:active</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<br>\n\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">margin-left</span> : auto;</span><br><span class=\"line\"><span class=\"attribute\">margin-right</span>: auto;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>使得<strong>普通</strong>元素在父级元素的空间内 <strong>水平居中</strong></p>\n</blockquote>\n<br>\n\n<p><code>article</code>是一个语义化标签:</p>\n<ul>\n<li>用于表示文档、页面或应用中的<strong>独立</strong>的、完整的内容单元;</li>\n<li>清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;</li>\n<li>内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.</li>\n</ul>\n<p>与其他类似标签的区别:</p>\n<ul>\n<li><code>div</code>: 粹的容器，没有语义，常用于布局;</li>\n<li><code>section</code>: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;</li>\n<li><code>article</code>: 示一个可以独立存在的内容单元.</li>\n</ul>\n<br>\n\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置备用字体 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span>, <span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: Impact, serif;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n","more":"<p>所有的 img 元素都应该有一个 alt 属性。 alt 属性的文本（值）有两个作用:</p>\n<ul>\n<li>第一个作用是让屏幕阅读器可以知晓图片的内容，这会对网页的可访问性有很大提升；</li>\n<li>另一个作用是当图片无法加载时，页面需要显示的替代文本。</li>\n</ul>\n<br>\n\n<p>注意嵌套的形式.<br>e.g</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>See more <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://freecatphotoapp.com&quot;</span>&gt;</span>cat photos<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> in our gallery.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n\n<p>要在新标签页中打开链接，可以在锚元素（a）中使用 target 属性。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span>See more <span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">&quot;https://freecatphotoapp.com&quot;</span> <span class=\"attr\">target</span> = <span class=\"string\">&quot;_blank&quot;</span>&gt;</span>cat photos<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span> in our gallery.<span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n<p>锚元素除了能将文本转化为链接, 还可以将 <strong>图片</strong> 转换为链接:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">hreg</span> = <span class=\"string\">&quot;https://freecatphotoapp.com&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;https://cdn.freecodecamp.org/curriculum/cat-photo-app/relaxing-cat.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;A cute orange cat lying on its back.&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n\n<p><strong>section</strong> 元素用于在文档中定义各部分，如章节、标题、页脚或文档的任何其他部分。 它是一个对 SEO 和无障碍特性有帮助的语义元素。</p>\n<br>\n\n\n<p>列表:</p>\n<ul>\n<li>无序列表: <code>ul</code>;</li>\n<li>有序列表:<code>ol</code>;</li>\n<li>列表项: <code>li</code>;</li>\n</ul>\n<br>\n\n\n<p><strong>figure</strong> 元素代表自包含的内容，允许将图像与标题相关联;<br><strong>figcaption</strong> 元素用于添加标题以描述 figure 元素中包含的图像。</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">figure</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">&quot;image.jpg&quot;</span> <span class=\"attr\">alt</span>=<span class=\"string\">&quot;A description of the image&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">figcaption</span>&gt;</span>A cute cat<span class=\"tag\">&lt;/<span class=\"name\">figcaption</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">figure</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n\n<ul>\n<li>使用 <strong>em</strong> 使得文字为斜体;</li>\n<li><code>strong</code> 加深文字;</li>\n</ul>\n<br>\n\n\n<p>form 元素用于从用户获取信息，如姓名、电子邮件和其他详细信息。</p>\n<ul>\n<li><code>action</code>属性指定表单数据发送的位置;</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">form</span> <span class=\"attr\">action</span>=<span class=\"string\">&quot;/submit-url&quot;</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">form</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>input 允许通过多种方式从Web表单中收集数据:</p>\n<ul>\n<li>与<code>img</code>一样为空元素——不需要结束标签;</li>\n<li>使用 <code>type</code> 属性创建多种输入;<ul>\n<li><code>text</code> : 文本;</li>\n<li><code>radio</code>: 可以使用单选按钮;</li>\n<li><code>checkbox</code>: 表单使用 <strong>复选框</strong>;</li>\n</ul>\n</li>\n<li>使用<code>name</code>属性使得区分提交的数据;<ul>\n<li>令多个单选按钮具有 <strong>相同</strong> 的<code>name</code>, 使得在选中其中一个按钮时自动取消另外的单选按钮;</li>\n<li>形成<code>name = value</code>形式的属性对进行提交;</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;indoor&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span> = <span class=\"string\">&quot;indoor-outdoor&quot;</span>&gt;</span> Indoor<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;outdoor&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span> = <span class=\"string\">&#x27;indoor-outdoor&#x27;</span>&gt;</span> Outdoor<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>placeholder</code> 中为 <strong>占位符</strong> 文本, 用于提示输入框中输入的信息;</li>\n<li><code>required</code>属性可以避免缺少所需信息时的提交, 无需赋值, 确保空格即可;</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;text&quot;</span> <span class=\"attr\">name</span> = <span class=\"string\">&quot;catphotourl&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n\n<p><code>button</code> 用于创建可点击的按钮:</p>\n<ul>\n<li>单击<strong>没有任何属性</strong>的表单按钮的默认行为会将表单提交到<strong>表单</strong>的 <code>action </code>属性中指定的位置;</li>\n<li>由于<code>input</code>和<code>button</code>为 <strong>内联</strong> 元素, 即使相隔书写也会显示在同行:</li>\n<li><code>type</code>的<code>submit</code>明确了为 可提交按钮;</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span> <span class=\"attr\">type</span> = <span class=\"string\">&quot;submit&quot;</span>&gt;</span>Submit<span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n<p>label 元素用于帮助将 input 元素的文本与 input 元素本身关联起来</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span>&gt;</span> cat<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- 点击单词 &quot;cat&quot; 也将选择 radio 按钮。 --&gt;</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n<p><code>id</code>用于标识特定的HTML元素</p>\n<br>\n\n<p><code>fieldset</code> 元素用于在 Web 表单中将相关的输入和标签组合在一起:</p>\n<ul>\n<li>块级元素，这意味着它们出现在新的一行上。</li>\n<li><code>legend</code> 元素充当 fieldset 元素中内容的标题。</li>\n</ul>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">fieldset</span>&gt;</span></span><br><span class=\"line\">        <span class=\"tag\">&lt;<span class=\"name\">legend</span>&gt;</span> Is your cat an indoor or outdoor cat?<span class=\"tag\">&lt;/<span class=\"name\">legend</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;indoor&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;indoor-outdoor&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;indoor&quot;</span>&gt;</span> Indoor<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\">          <span class=\"tag\">&lt;<span class=\"name\">label</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;outdoor&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;indoor-outdoor&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;outdoor&quot;</span>&gt;</span> Outdoor<span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">fieldset</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/img/legend-2025-01-21-21-19-51.png\"\n                     \n                ></p>\n<br>\n\n<p>还可以使用<code>for</code>属性将文本直接嵌套在<code>label</code>当中, 同时设置<code>input</code>的<code>id</code>与上述的<code>for</code>属性相同, 从而实现文本与元素相关联的效果:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">&quot;loving&quot;</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;checkbox&quot;</span>&gt;</span> </span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span> = <span class=\"string\">&quot;loving&quot;</span>&gt;</span> Loving <span class=\"tag\">&lt;/<span class=\"name\">label</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n<p>默认选中的按钮: <code>checked</code></p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">checked</span> <span class=\"attr\">type</span>=<span class=\"string\">&quot;radio&quot;</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;meal&quot;</span> <span class=\"attr\">value</span>=<span class=\"string\">&quot;breakfast&quot;</span>&gt;</span> Breakfast</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>checked属性无需额外赋值.</p>\n</blockquote>\n<br>\n\n<p><code>footer</code>素用于定义文档或章节的页脚:</p>\n<ul>\n<li>脚通常包含文档作者信息、版权数据、使用条款链接、联系信息等.</li>\n</ul>\n<br>\n\n<p>head 相关</p>\n<ul>\n<li>存放 $\\underline{元数据}$ 不会实际显示在html中的数据;</li>\n<li><code>title </code>元素决定了浏览器在页面的标题栏或选项卡中显示的内容;</li>\n<li><code>&lt;link rel = &quot;stylesheet&quot; href = &quot;styles.css&quot;&gt;</code> 将CSS文件链接到当前的HTML</li>\n</ul>\n<p>else:</p>\n<ul>\n<li><code>&lt;!DOCTYPE html</code>: 声明满足最新版本html相关设置的要求;</li>\n<li><code>meta</code>是空元素; <code>&lt;meta charset = &quot;utf-8&quot;&gt;</code>;</li>\n<li></li>\n</ul>\n<hr>\n<p>选择器:</p>\n<ul>\n<li><strong>id</strong>选择器</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-id\">#cat</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">width</span>: <span class=\"number\">250px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>class</strong>选择器</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.class-name</span>, <span class=\"selector-class\">.other-class</span> &#123;</span><br><span class=\"line\">  styles</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>class类中元素的选择</li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.item</span> <span class=\"selector-tag\">p</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* 设置为样式近似于内联--排列在同一行, 同时可以设置宽高、边距 */</span></span><br><span class=\"line\">  <span class=\"attribute\">display</span>: inline-block; </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li><strong>伪元素</strong></li>\n</ul>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 已访问链接后设置为灰色 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:visited</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: grey;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 悬浮时的变色 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: brown;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 点击时的状态设置 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:active</span>&#123;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: white;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<br>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">margin-left</span> : auto;</span><br><span class=\"line\"><span class=\"attribute\">margin-right</span>: auto;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>使得<strong>普通</strong>元素在父级元素的空间内 <strong>水平居中</strong></p>\n</blockquote>\n<br>\n\n<p><code>article</code>是一个语义化标签:</p>\n<ul>\n<li>用于表示文档、页面或应用中的<strong>独立</strong>的、完整的内容单元;</li>\n<li>清晰地表明内容的用途，帮助开发者和搜索引擎理解页面结构;</li>\n<li>内容通常可以通过RSS订阅、社交媒体分享等方式单独发布.</li>\n</ul>\n<p>与其他类似标签的区别:</p>\n<ul>\n<li><code>div</code>: 粹的容器，没有语义，常用于布局;</li>\n<li><code>section</code>: 表示文档中的一个逻辑区域，通常用于分组内容，但不一定是独立的内容单元;</li>\n<li><code>article</code>: 示一个可以独立存在的内容单元.</li>\n</ul>\n<br>\n\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 设置备用字体 */</span></span><br><span class=\"line\"><span class=\"selector-tag\">h1</span>, <span class=\"selector-tag\">h2</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">font-family</span>: Impact, serif;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n","_processedHighlight":true},{"title":"跨组件渲染","date":"2025-02-16T07:40:06.000Z","_content":"# React Context 实现跨组件实时渲染的实践分析\n\n## 为什么需要跨组件实时渲染？\n\n在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：\n\n- 用户在一个组件中编辑内容，其他组件需要立即看到更新\n- 多个组件需要共享同一份数据\n- 需要避免通过层层组件传递 props（即所谓的 prop drilling）\n\n这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。\n\n## 最小实现示例\n\n以下是实现跨组件实时渲染的最简代码结构：\n\n```typescript\n// 1. 定义 Context 类型\ninterface SharedContextType {\n  data: any;\n  updateData: (newData: any) => void;\n}\n\n// 2. 创建 Context\nconst SharedContext = createContext<SharedContextType | undefined>(undefined);\n\n// 3. 创建 Provider 组件\nexport function SharedProvider({ children }: { children: React.ReactNode }) {\n  const [data, setData] = useState<any>(null);\n\n  const updateData = useCallback((newData: any) => {\n    setData(newData);\n  }, []);\n\n  return (\n    <SharedContext.Provider value={{ data, updateData }}>\n      {children}\n    </SharedContext.Provider>\n  );\n}\n\n// 4. 创建自定义 Hook\nexport function useShared() {\n  const context = useContext(SharedContext);\n  if (!context) {\n    throw new Error('useShared must be used within SharedProvider');\n  }\n  return context;\n}\n```\n\n## 实际应用分析\n\n让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：\n\n```typescript\n// 1. 定义具体的数据结构\ninterface HistoryItem {\n  id: string;\n  content: string;\n  mermaidCode: string;\n  timestamp: number;\n}\n\n// 2. 实现带有持久化的 Context Provider\nexport function HistoryProvider({ children }: { children: React.ReactNode }) {\n  const [selectedHistory, setSelectedHistory] = useState<HistoryItem | null>(null);\n  const [historyList, setHistoryList] = useState<HistoryItem[]>([]);\n\n  // 数据持久化\n  useEffect(() => {\n    if (selectedHistory) {\n      localStorage.setItem('selectedHistory', JSON.stringify(selectedHistory));\n    }\n  }, [selectedHistory]);\n\n  // 实时更新方法\n  const addHistory = async (content: string, mermaidCode: string) => {\n    const historyItem: HistoryItem = {\n      id: Date.now().toString(),\n      content,\n      mermaidCode,\n      timestamp: Date.now()\n    };\n    setHistoryList(prev => [historyItem, ...prev]);\n  };\n\n  return (\n    <HistoryContext.Provider\n      value={{\n        selectedHistory,\n        setSelectedHistory,\n        addHistory,\n        historyList\n      }}\n    >\n      {children}\n    </HistoryContext.Provider>\n  );\n}\n```\n\n在这个实际例子中，我们可以看到几个关键点：\n\n1. **状态定义**：使用 TypeScript 接口明确定义了数据结构，确保类型安全\n2. **状态持久化**：通过 `useEffect` 监听状态变化并保存到 localStorage\n3. **实时更新**：通过 `setHistoryList` 确保状态更新后所有使用该 Context 的组件都能即时获得更新\n\n当组件需要使用这些共享状态时，只需：\n\n```typescript\nfunction HistoryViewer() {\n  const { selectedHistory } = useHistory();\n  \n  return (\n    <div>\n      {selectedHistory && (\n        <div>{selectedHistory.content}</div>\n      )}\n    </div>\n  );\n}\n```\n\n这种模式的优势在于：\n\n- 避免了 props 的层层传递\n- 实现了组件间的解耦\n- 确保了状态更新的实时性\n- 提供了类型安全的数据访问\n\n## 参考资料\n\n- [React Context Documentation](https://react.dev/reference/react/createContext)\n- [TypeScript Handbook](https://www.typescriptlang.org/docs/)\n- [React Hooks API Reference](https://react.dev/reference/react/hooks)\n","source":"_posts/前后端/跨组件渲染.md","raw":"---\ntitle: 跨组件渲染\ndate: 2025-02-16 15:40:06\ntags: \n- 前端\ncategories:\n---\n# React Context 实现跨组件实时渲染的实践分析\n\n## 为什么需要跨组件实时渲染？\n\n在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：\n\n- 用户在一个组件中编辑内容，其他组件需要立即看到更新\n- 多个组件需要共享同一份数据\n- 需要避免通过层层组件传递 props（即所谓的 prop drilling）\n\n这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。\n\n## 最小实现示例\n\n以下是实现跨组件实时渲染的最简代码结构：\n\n```typescript\n// 1. 定义 Context 类型\ninterface SharedContextType {\n  data: any;\n  updateData: (newData: any) => void;\n}\n\n// 2. 创建 Context\nconst SharedContext = createContext<SharedContextType | undefined>(undefined);\n\n// 3. 创建 Provider 组件\nexport function SharedProvider({ children }: { children: React.ReactNode }) {\n  const [data, setData] = useState<any>(null);\n\n  const updateData = useCallback((newData: any) => {\n    setData(newData);\n  }, []);\n\n  return (\n    <SharedContext.Provider value={{ data, updateData }}>\n      {children}\n    </SharedContext.Provider>\n  );\n}\n\n// 4. 创建自定义 Hook\nexport function useShared() {\n  const context = useContext(SharedContext);\n  if (!context) {\n    throw new Error('useShared must be used within SharedProvider');\n  }\n  return context;\n}\n```\n\n## 实际应用分析\n\n让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：\n\n```typescript\n// 1. 定义具体的数据结构\ninterface HistoryItem {\n  id: string;\n  content: string;\n  mermaidCode: string;\n  timestamp: number;\n}\n\n// 2. 实现带有持久化的 Context Provider\nexport function HistoryProvider({ children }: { children: React.ReactNode }) {\n  const [selectedHistory, setSelectedHistory] = useState<HistoryItem | null>(null);\n  const [historyList, setHistoryList] = useState<HistoryItem[]>([]);\n\n  // 数据持久化\n  useEffect(() => {\n    if (selectedHistory) {\n      localStorage.setItem('selectedHistory', JSON.stringify(selectedHistory));\n    }\n  }, [selectedHistory]);\n\n  // 实时更新方法\n  const addHistory = async (content: string, mermaidCode: string) => {\n    const historyItem: HistoryItem = {\n      id: Date.now().toString(),\n      content,\n      mermaidCode,\n      timestamp: Date.now()\n    };\n    setHistoryList(prev => [historyItem, ...prev]);\n  };\n\n  return (\n    <HistoryContext.Provider\n      value={{\n        selectedHistory,\n        setSelectedHistory,\n        addHistory,\n        historyList\n      }}\n    >\n      {children}\n    </HistoryContext.Provider>\n  );\n}\n```\n\n在这个实际例子中，我们可以看到几个关键点：\n\n1. **状态定义**：使用 TypeScript 接口明确定义了数据结构，确保类型安全\n2. **状态持久化**：通过 `useEffect` 监听状态变化并保存到 localStorage\n3. **实时更新**：通过 `setHistoryList` 确保状态更新后所有使用该 Context 的组件都能即时获得更新\n\n当组件需要使用这些共享状态时，只需：\n\n```typescript\nfunction HistoryViewer() {\n  const { selectedHistory } = useHistory();\n  \n  return (\n    <div>\n      {selectedHistory && (\n        <div>{selectedHistory.content}</div>\n      )}\n    </div>\n  );\n}\n```\n\n这种模式的优势在于：\n\n- 避免了 props 的层层传递\n- 实现了组件间的解耦\n- 确保了状态更新的实时性\n- 提供了类型安全的数据访问\n\n## 参考资料\n\n- [React Context Documentation](https://react.dev/reference/react/createContext)\n- [TypeScript Handbook](https://www.typescriptlang.org/docs/)\n- [React Hooks API Reference](https://react.dev/reference/react/hooks)\n","slug":"前后端/跨组件渲染","published":1,"updated":"2025-05-09T01:38:38.254Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ae000l2xqg65pwekqj","content":"<h1 id=\"React-Context-实现跨组件实时渲染的实践分析\"><a href=\"#React-Context-实现跨组件实时渲染的实践分析\" class=\"headerlink\" title=\"React Context 实现跨组件实时渲染的实践分析\"></a>React Context 实现跨组件实时渲染的实践分析</h1><h2 id=\"为什么需要跨组件实时渲染？\"><a href=\"#为什么需要跨组件实时渲染？\" class=\"headerlink\" title=\"为什么需要跨组件实时渲染？\"></a>为什么需要跨组件实时渲染？</h2><p>在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：</p>\n<ul>\n<li>用户在一个组件中编辑内容，其他组件需要立即看到更新</li>\n<li>多个组件需要共享同一份数据</li>\n<li>需要避免通过层层组件传递 props（即所谓的 prop drilling）</li>\n</ul>\n<p>这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。</p>\n<h2 id=\"最小实现示例\"><a href=\"#最小实现示例\" class=\"headerlink\" title=\"最小实现示例\"></a>最小实现示例</h2><p>以下是实现跨组件实时渲染的最简代码结构：</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义 Context 类型</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">SharedContextType</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  <span class=\"attr\">updateData</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">newData</span>: <span class=\"built_in\">any</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 创建 Context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">SharedContext</span> = createContext&lt;<span class=\"title class_\">SharedContextType</span> | <span class=\"literal\">undefined</span>&gt;(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 创建 Provider 组件</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">SharedProvider</span>(<span class=\"params\">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [data, setData] = useState&lt;<span class=\"built_in\">any</span>&gt;(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> updateData = <span class=\"title function_\">useCallback</span>(<span class=\"function\">(<span class=\"params\"><span class=\"attr\">newData</span>: <span class=\"built_in\">any</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setData</span>(newData);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">SharedContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">data</span>, <span class=\"attr\">updateData</span> &#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">SharedContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建自定义 Hook</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">useShared</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = <span class=\"title function_\">useContext</span>(<span class=\"title class_\">SharedContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;useShared must be used within SharedProvider&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"实际应用分析\"><a href=\"#实际应用分析\" class=\"headerlink\" title=\"实际应用分析\"></a>实际应用分析</h2><p>让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义具体的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">HistoryItem</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">mermaidCode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">timestamp</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 实现带有持久化的 Context Provider</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">HistoryProvider</span>(<span class=\"params\">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [selectedHistory, setSelectedHistory] = useState&lt;<span class=\"title class_\">HistoryItem</span> | <span class=\"literal\">null</span>&gt;(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [historyList, setHistoryList] = useState&lt;<span class=\"title class_\">HistoryItem</span>[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 数据持久化</span></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedHistory) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">setItem</span>(<span class=\"string\">&#x27;selectedHistory&#x27;</span>, <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(selectedHistory));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, [selectedHistory]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实时更新方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">addHistory</span> = <span class=\"keyword\">async</span> (<span class=\"params\"><span class=\"attr\">content</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">mermaidCode</span>: <span class=\"built_in\">string</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">historyItem</span>: <span class=\"title class_\">HistoryItem</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">id</span>: <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>().<span class=\"title function_\">toString</span>(),</span><br><span class=\"line\">      content,</span><br><span class=\"line\">      mermaidCode,</span><br><span class=\"line\">      <span class=\"attr\">timestamp</span>: <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"title function_\">setHistoryList</span>(<span class=\"function\"><span class=\"params\">prev</span> =&gt;</span> [historyItem, ...prev]);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">HistoryContext.Provider</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">selectedHistory</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">setSelectedHistory</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">addHistory</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">historyList</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">HistoryContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>在这个实际例子中，我们可以看到几个关键点：</p>\n<ol>\n<li><strong>状态定义</strong>：使用 TypeScript 接口明确定义了数据结构，确保类型安全</li>\n<li><strong>状态持久化</strong>：通过 <code>useEffect</code> 监听状态变化并保存到 localStorage</li>\n<li><strong>实时更新</strong>：通过 <code>setHistoryList</code> 确保状态更新后所有使用该 Context 的组件都能即时获得更新</li>\n</ol>\n<p>当组件需要使用这些共享状态时，只需：</p>\n<div class=\"code-container\" data-rel=\"Typescript\"><figure class=\"iseeu highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">HistoryViewer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; selectedHistory &#125; = <span class=\"title function_\">useHistory</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;selectedHistory &amp;&amp; (</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;selectedHistory.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      )&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>这种模式的优势在于：</p>\n<ul>\n<li>避免了 props 的层层传递</li>\n<li>实现了组件间的解耦</li>\n<li>确保了状态更新的实时性</li>\n<li>提供了类型安全的数据访问</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a class=\"link\"   href=\"https://react.dev/reference/react/createContext\" >React Context Documentation<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.typescriptlang.org/docs/\" >TypeScript Handbook<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://react.dev/reference/react/hooks\" >React Hooks API Reference<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n","excerpt":"","more":"<h1 id=\"React-Context-实现跨组件实时渲染的实践分析\"><a href=\"#React-Context-实现跨组件实时渲染的实践分析\" class=\"headerlink\" title=\"React Context 实现跨组件实时渲染的实践分析\"></a>React Context 实现跨组件实时渲染的实践分析</h1><h2 id=\"为什么需要跨组件实时渲染？\"><a href=\"#为什么需要跨组件实时渲染？\" class=\"headerlink\" title=\"为什么需要跨组件实时渲染？\"></a>为什么需要跨组件实时渲染？</h2><p>在开发 React 应用时，我们经常遇到这样的场景：某个组件的状态变化需要即时反映在其他不相关的组件中。例如：</p>\n<ul>\n<li>用户在一个组件中编辑内容，其他组件需要立即看到更新</li>\n<li>多个组件需要共享同一份数据</li>\n<li>需要避免通过层层组件传递 props（即所谓的 prop drilling）</li>\n</ul>\n<p>这种情况下，使用 React Context 来实现跨组件的实时渲染就显得尤为重要。</p>\n<h2 id=\"最小实现示例\"><a href=\"#最小实现示例\" class=\"headerlink\" title=\"最小实现示例\"></a>最小实现示例</h2><p>以下是实现跨组件实时渲染的最简代码结构：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义 Context 类型</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">SharedContextType</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">data</span>: <span class=\"built_in\">any</span>;</span><br><span class=\"line\">  <span class=\"attr\">updateData</span>: <span class=\"function\">(<span class=\"params\"><span class=\"attr\">newData</span>: <span class=\"built_in\">any</span></span>) =&gt;</span> <span class=\"built_in\">void</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 创建 Context</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title class_\">SharedContext</span> = createContext&lt;<span class=\"title class_\">SharedContextType</span> | <span class=\"literal\">undefined</span>&gt;(<span class=\"literal\">undefined</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 创建 Provider 组件</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">SharedProvider</span>(<span class=\"params\">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [data, setData] = useState&lt;<span class=\"built_in\">any</span>&gt;(<span class=\"literal\">null</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">const</span> updateData = <span class=\"title function_\">useCallback</span>(<span class=\"function\">(<span class=\"params\"><span class=\"attr\">newData</span>: <span class=\"built_in\">any</span></span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"title function_\">setData</span>(newData);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">SharedContext.Provider</span> <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;</span> <span class=\"attr\">data</span>, <span class=\"attr\">updateData</span> &#125;&#125;&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">SharedContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 创建自定义 Hook</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">useShared</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> context = <span class=\"title function_\">useContext</span>(<span class=\"title class_\">SharedContext</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!context) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"title class_\">Error</span>(<span class=\"string\">&#x27;useShared must be used within SharedProvider&#x27;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> context;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"实际应用分析\"><a href=\"#实际应用分析\" class=\"headerlink\" title=\"实际应用分析\"></a>实际应用分析</h2><p>让我们以一个实际的 Mermaid 图表生成器项目为例，分析如何运用这个模式：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1. 定义具体的数据结构</span></span><br><span class=\"line\"><span class=\"keyword\">interface</span> <span class=\"title class_\">HistoryItem</span> &#123;</span><br><span class=\"line\">  <span class=\"attr\">id</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">content</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">mermaidCode</span>: <span class=\"built_in\">string</span>;</span><br><span class=\"line\">  <span class=\"attr\">timestamp</span>: <span class=\"built_in\">number</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 实现带有持久化的 Context Provider</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">function</span> <span class=\"title function_\">HistoryProvider</span>(<span class=\"params\">&#123; children &#125;: &#123; children: React.ReactNode &#125;</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [selectedHistory, setSelectedHistory] = useState&lt;<span class=\"title class_\">HistoryItem</span> | <span class=\"literal\">null</span>&gt;(<span class=\"literal\">null</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> [historyList, setHistoryList] = useState&lt;<span class=\"title class_\">HistoryItem</span>[]&gt;([]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 数据持久化</span></span><br><span class=\"line\">  <span class=\"title function_\">useEffect</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (selectedHistory) &#123;</span><br><span class=\"line\">      <span class=\"variable language_\">localStorage</span>.<span class=\"title function_\">setItem</span>(<span class=\"string\">&#x27;selectedHistory&#x27;</span>, <span class=\"title class_\">JSON</span>.<span class=\"title function_\">stringify</span>(selectedHistory));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;, [selectedHistory]);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 实时更新方法</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"title function_\">addHistory</span> = <span class=\"keyword\">async</span> (<span class=\"params\"><span class=\"attr\">content</span>: <span class=\"built_in\">string</span>, <span class=\"attr\">mermaidCode</span>: <span class=\"built_in\">string</span></span>) =&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"attr\">historyItem</span>: <span class=\"title class_\">HistoryItem</span> = &#123;</span><br><span class=\"line\">      <span class=\"attr\">id</span>: <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>().<span class=\"title function_\">toString</span>(),</span><br><span class=\"line\">      content,</span><br><span class=\"line\">      mermaidCode,</span><br><span class=\"line\">      <span class=\"attr\">timestamp</span>: <span class=\"title class_\">Date</span>.<span class=\"title function_\">now</span>()</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"title function_\">setHistoryList</span>(<span class=\"function\"><span class=\"params\">prev</span> =&gt;</span> [historyItem, ...prev]);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">HistoryContext.Provider</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      <span class=\"attr\">value</span>=<span class=\"string\">&#123;&#123;</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">selectedHistory</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">setSelectedHistory</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">addHistory</span>,</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">        <span class=\"attr\">historyList</span></span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">      &#125;&#125;</span></span></span><br><span class=\"line\"><span class=\"tag\"><span class=\"language-xml\">    &gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;children&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">HistoryContext.Provider</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在这个实际例子中，我们可以看到几个关键点：</p>\n<ol>\n<li><strong>状态定义</strong>：使用 TypeScript 接口明确定义了数据结构，确保类型安全</li>\n<li><strong>状态持久化</strong>：通过 <code>useEffect</code> 监听状态变化并保存到 localStorage</li>\n<li><strong>实时更新</strong>：通过 <code>setHistoryList</code> 确保状态更新后所有使用该 Context 的组件都能即时获得更新</li>\n</ol>\n<p>当组件需要使用这些共享状态时，只需：</p>\n<figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">HistoryViewer</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; selectedHistory &#125; = <span class=\"title function_\">useHistory</span>();</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    <span class=\"language-xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      &#123;selectedHistory &amp;&amp; (</span></span><br><span class=\"line\"><span class=\"language-xml\">        <span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>&#123;selectedHistory.content&#125;<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\"><span class=\"language-xml\">      )&#125;</span></span><br><span class=\"line\"><span class=\"language-xml\">    <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span></span><br><span class=\"line\">  );</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种模式的优势在于：</p>\n<ul>\n<li>避免了 props 的层层传递</li>\n<li>实现了组件间的解耦</li>\n<li>确保了状态更新的实时性</li>\n<li>提供了类型安全的数据访问</li>\n</ul>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a class=\"link\"   href=\"https://react.dev/reference/react/createContext\" >React Context Documentation<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.typescriptlang.org/docs/\" >TypeScript Handbook<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://react.dev/reference/react/hooks\" >React Hooks API Reference<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n","_processedHighlight":true},{"title":"css笔记","date":"2025-01-08T10:33:32.000Z","index_img":"/img/Aniya.png","excerpt":"css属性好多好复杂😶‍🌫️","_content":"> [在线编辑平台](https://jsfiddle.net/?locale=zh_CN)\n\n\n### 伪元素\n使用伪元素`before`和`after`可以为元素添加内容.\n```html\n<div class=\"author\">待抉</div>\n\n<style>\n.author:before {\n  content: \"Author: \";\n  font-weight: bold; /* 加粗字体 */\n  color: blue; /* 文本颜色为蓝色 */\n}\n.author:after {\n  content: \" ✍️\";\n  font-size: 1.2em; /* 调整图标大小 */\n  margin-left: 5px; /* 添加左边距 */\n}\n</style>\n```\n\n\n`:nth-child`可用于对序列中不同的元素进行有序的样式设计:\n```html\n<div class=\"index-card\">内容1</div>\n<div class=\"index-card\">内容2</div>\n<div class=\"index-card\">内容3</div>\n<div class=\"index-card\">内容4</div>\n\n<style>\n.index-card:nth-child(odd) {\n  flex-direction: row-reverse;\n}\n</style>\n```\n- 选择所有类名为 \"index-card\" 的元素;\n- `row-reverse` 会让 flex 容器中的项目从右到左排列;\n> 同理, `even`选择偶数位置的元素; `3n+1`等函数表达式也可以起作用.\n\n### 基本的元素属性\n#### 布局属性\n- `margin`: 控制元素的外边距;\n- `padding`: 控制元素的内边距;\n\n#### 文本属性\n- `font-size`: 控制字体大小;\n- `font-weight`: 控制字体粗细;\n- `text-align`: 控制文本的对齐方式;\n- `text-decoration`: 控制文本的装饰;\n- `line-height`: 控制行高;\n- `letter-spacing`: 控制字符间距;\n- `text-transform`: 控制文本的大小写;\n\n#### 边框属性\n- `border`: e.g. `border: 1px solid red;` 简写属性;\n- `border-radius`: 控制元素的圆角;\n- `border-style`: solid, dashed, dotted...\n\n#### 其他\n- `overflow`: visible, hidden, scroll, auto;\n- `opacity`: 控制元素的透明度;\n- `cursor`: pointer, default, move, not-allowed...\n\n### 动感魔法\n#### hover效果\n通过为class设置`:hover`伪类，可以为元素添加鼠标悬停时的效果。\n```css\n.my-element:hover {\n  background-color: green;\n  color: red;\n  transform: scale(1.1);\n  font-size:20px;\n}\n```\n> 空格将不会被忽略, 需要确保类名与`:hover`之间不存在空格;\n\n其他的一些常用的伪类:\n```css\na:hover {\n      color: red;\n    }\n    button:active {\n      background-color: green;\n    }\n    input:focus {\n      border-color: blue;\n    }\n    a:visited {\n      color: purple;\n    }\n    p:first-child {\n      font-weight: bold;\n    }\n    p:last-child {\n      font-style: italic;\n    }\n    li:nth-child(2) {\n      color: red;\n    }\n    p:only-child {\n      color: green;\n    }\n    div:empty {\n      background-color: yellow;\n    }\n```\n\n### Flex\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <style>\n    /* 定义Flex容器 */\n    .container {\n      display: flex; /* 将容器设置为Flexbox容器 */\n      \n      /* flex-direction: 定义主轴方向 */\n      /* row: 水平从左到右（默认） */\n      /* row-reverse: 水平从右到左 */\n      /* column: 垂直从上到下 */\n      /* column-reverse: 垂直从下到上 */\n      flex-direction: row; /* 可以改为row-reverse, column, column-reverse */\n\n      /* flex-wrap: 定义是否换行 */\n      /* nowrap: 不换行（默认） */\n      /* wrap: 换行 */\n      /* wrap-reverse: 反向换行 */\n      flex-wrap: wrap; /* 可以改为nowrap, wrap-reverse */\n\n      /* flex-flow: flex-direction 和 flex-wrap 的简写 */\n      /* flex-flow: <flex-direction> <flex-wrap>; */\n      flex-flow: row wrap; /* 可以改为column nowrap等组合 */\n\n      /* justify-content: 定义在主轴上的对齐方式 */\n      /* flex-start: 起始对齐（默认） */\n      /* flex-end: 末端对齐 */\n      /* center: 居中对齐 */\n      /* space-between: 两端对齐，项目之间间隔相等 */\n      /* space-around: 项目之间间隔相等，项目两边有半个间隔 */\n      /* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */\n      justify-content: space-between; /* 可以改为flex-start, flex-end, center, space-around, space-evenly */\n\n      /* align-items: 定义在交叉轴上的对齐方式 */\n      /* stretch: 拉伸适应容器（默认） */\n      /* flex-start: 交叉轴起始对齐 */\n      /* flex-end: 交叉轴末端对齐 */\n      /* center: 交叉轴居中对齐 */\n      /* baseline: 项目基线对齐 */\n      align-items: center; /* 可以改为flex-start, flex-end, stretch, baseline */\n\n      /* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */\n      /* stretch: 拉伸适应容器（默认） */\n      /* flex-start: 交叉轴起始对齐 */\n      /* flex-end: 交叉轴末端对齐 */\n      /* center: 交叉轴居中对齐 */\n      /* space-between: 多行两端对齐，行之间间隔相等 */\n      /* space-around: 多行之间间隔相等，行两边有半个间隔 */\n      align-content: space-between; /* 可以改为flex-start, flex-end, center, space-around */\n      \n      height: 100vh; /* 设置容器高度 */\n      background-color: #f0f0f0; /* 设置容器背景颜色 */\n    }\n    \n    /* 定义Flex项目 */\n    .item {\n      flex: 1; /* 设置项目的flex属性，项目平分空间 */\n      padding: 20px; /* 设置项目内边距 */\n      background-color: lightblue; /* 设置项目背景颜色 */\n      margin: 10px; /* 设置项目外边距 */\n      text-align: center; /* 设置项目文本居中 */\n      flex-grow: 1;/*尝试向flex容器扩展空间*/\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"item\">Item 1</div>\n    <div class=\"item\">Item 2</div>\n    <div class=\"item\">Item 3</div>\n  </div>\n</body>\n</html>\n```\n\n","source":"_posts/编程语言/css笔记.md","raw":"---\ntitle: css笔记\ndate: 2025-01-08 18:33:32\ntags:\n- 前端\n- CSS\nindex_img: /img/Aniya.png\ncategories: 学习笔记\nexcerpt: css属性好多好复杂😶‍🌫️\n---\n> [在线编辑平台](https://jsfiddle.net/?locale=zh_CN)\n\n\n### 伪元素\n使用伪元素`before`和`after`可以为元素添加内容.\n```html\n<div class=\"author\">待抉</div>\n\n<style>\n.author:before {\n  content: \"Author: \";\n  font-weight: bold; /* 加粗字体 */\n  color: blue; /* 文本颜色为蓝色 */\n}\n.author:after {\n  content: \" ✍️\";\n  font-size: 1.2em; /* 调整图标大小 */\n  margin-left: 5px; /* 添加左边距 */\n}\n</style>\n```\n\n\n`:nth-child`可用于对序列中不同的元素进行有序的样式设计:\n```html\n<div class=\"index-card\">内容1</div>\n<div class=\"index-card\">内容2</div>\n<div class=\"index-card\">内容3</div>\n<div class=\"index-card\">内容4</div>\n\n<style>\n.index-card:nth-child(odd) {\n  flex-direction: row-reverse;\n}\n</style>\n```\n- 选择所有类名为 \"index-card\" 的元素;\n- `row-reverse` 会让 flex 容器中的项目从右到左排列;\n> 同理, `even`选择偶数位置的元素; `3n+1`等函数表达式也可以起作用.\n\n### 基本的元素属性\n#### 布局属性\n- `margin`: 控制元素的外边距;\n- `padding`: 控制元素的内边距;\n\n#### 文本属性\n- `font-size`: 控制字体大小;\n- `font-weight`: 控制字体粗细;\n- `text-align`: 控制文本的对齐方式;\n- `text-decoration`: 控制文本的装饰;\n- `line-height`: 控制行高;\n- `letter-spacing`: 控制字符间距;\n- `text-transform`: 控制文本的大小写;\n\n#### 边框属性\n- `border`: e.g. `border: 1px solid red;` 简写属性;\n- `border-radius`: 控制元素的圆角;\n- `border-style`: solid, dashed, dotted...\n\n#### 其他\n- `overflow`: visible, hidden, scroll, auto;\n- `opacity`: 控制元素的透明度;\n- `cursor`: pointer, default, move, not-allowed...\n\n### 动感魔法\n#### hover效果\n通过为class设置`:hover`伪类，可以为元素添加鼠标悬停时的效果。\n```css\n.my-element:hover {\n  background-color: green;\n  color: red;\n  transform: scale(1.1);\n  font-size:20px;\n}\n```\n> 空格将不会被忽略, 需要确保类名与`:hover`之间不存在空格;\n\n其他的一些常用的伪类:\n```css\na:hover {\n      color: red;\n    }\n    button:active {\n      background-color: green;\n    }\n    input:focus {\n      border-color: blue;\n    }\n    a:visited {\n      color: purple;\n    }\n    p:first-child {\n      font-weight: bold;\n    }\n    p:last-child {\n      font-style: italic;\n    }\n    li:nth-child(2) {\n      color: red;\n    }\n    p:only-child {\n      color: green;\n    }\n    div:empty {\n      background-color: yellow;\n    }\n```\n\n### Flex\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <style>\n    /* 定义Flex容器 */\n    .container {\n      display: flex; /* 将容器设置为Flexbox容器 */\n      \n      /* flex-direction: 定义主轴方向 */\n      /* row: 水平从左到右（默认） */\n      /* row-reverse: 水平从右到左 */\n      /* column: 垂直从上到下 */\n      /* column-reverse: 垂直从下到上 */\n      flex-direction: row; /* 可以改为row-reverse, column, column-reverse */\n\n      /* flex-wrap: 定义是否换行 */\n      /* nowrap: 不换行（默认） */\n      /* wrap: 换行 */\n      /* wrap-reverse: 反向换行 */\n      flex-wrap: wrap; /* 可以改为nowrap, wrap-reverse */\n\n      /* flex-flow: flex-direction 和 flex-wrap 的简写 */\n      /* flex-flow: <flex-direction> <flex-wrap>; */\n      flex-flow: row wrap; /* 可以改为column nowrap等组合 */\n\n      /* justify-content: 定义在主轴上的对齐方式 */\n      /* flex-start: 起始对齐（默认） */\n      /* flex-end: 末端对齐 */\n      /* center: 居中对齐 */\n      /* space-between: 两端对齐，项目之间间隔相等 */\n      /* space-around: 项目之间间隔相等，项目两边有半个间隔 */\n      /* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */\n      justify-content: space-between; /* 可以改为flex-start, flex-end, center, space-around, space-evenly */\n\n      /* align-items: 定义在交叉轴上的对齐方式 */\n      /* stretch: 拉伸适应容器（默认） */\n      /* flex-start: 交叉轴起始对齐 */\n      /* flex-end: 交叉轴末端对齐 */\n      /* center: 交叉轴居中对齐 */\n      /* baseline: 项目基线对齐 */\n      align-items: center; /* 可以改为flex-start, flex-end, stretch, baseline */\n\n      /* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */\n      /* stretch: 拉伸适应容器（默认） */\n      /* flex-start: 交叉轴起始对齐 */\n      /* flex-end: 交叉轴末端对齐 */\n      /* center: 交叉轴居中对齐 */\n      /* space-between: 多行两端对齐，行之间间隔相等 */\n      /* space-around: 多行之间间隔相等，行两边有半个间隔 */\n      align-content: space-between; /* 可以改为flex-start, flex-end, center, space-around */\n      \n      height: 100vh; /* 设置容器高度 */\n      background-color: #f0f0f0; /* 设置容器背景颜色 */\n    }\n    \n    /* 定义Flex项目 */\n    .item {\n      flex: 1; /* 设置项目的flex属性，项目平分空间 */\n      padding: 20px; /* 设置项目内边距 */\n      background-color: lightblue; /* 设置项目背景颜色 */\n      margin: 10px; /* 设置项目外边距 */\n      text-align: center; /* 设置项目文本居中 */\n      flex-grow: 1;/*尝试向flex容器扩展空间*/\n    }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"item\">Item 1</div>\n    <div class=\"item\">Item 2</div>\n    <div class=\"item\">Item 3</div>\n  </div>\n</body>\n</html>\n```\n\n","slug":"编程语言/css笔记","published":1,"updated":"2025-05-08T11:51:39.655Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8af000n2xqg7963hbb1","content":"<blockquote>\n<p><a class=\"link\"   href=\"https://jsfiddle.net/?locale=zh_CN\" >在线编辑平台<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n</blockquote>\n<h3 id=\"伪元素\"><a href=\"#伪元素\" class=\"headerlink\" title=\"伪元素\"></a>伪元素</h3><p>使用伪元素<code>before</code>和<code>after</code>可以为元素添加内容.</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;author&quot;</span>&gt;</span>待抉<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.author</span><span class=\"selector-pseudo\">:before</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;Author: &quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">font-weight</span>: bold; <span class=\"comment\">/* 加粗字体 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">color</span>: blue; <span class=\"comment\">/* 文本颜色为蓝色 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.author</span><span class=\"selector-pseudo\">:after</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot; ✍️&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2em</span>; <span class=\"comment\">/* 调整图标大小 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">5px</span>; <span class=\"comment\">/* 添加左边距 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n\n<p><code>:nth-child</code>可用于对序列中不同的元素进行有序的样式设计:</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;index-card&quot;</span>&gt;</span>内容1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;index-card&quot;</span>&gt;</span>内容2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;index-card&quot;</span>&gt;</span>内容3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;index-card&quot;</span>&gt;</span>内容4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.index-card</span><span class=\"selector-pseudo\">:nth-child</span>(odd) &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">flex-direction</span>: row-reverse;</span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>选择所有类名为 “index-card” 的元素;</li>\n<li><code>row-reverse</code> 会让 flex 容器中的项目从右到左排列;<blockquote>\n<p>同理, <code>even</code>选择偶数位置的元素; <code>3n+1</code>等函数表达式也可以起作用.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"基本的元素属性\"><a href=\"#基本的元素属性\" class=\"headerlink\" title=\"基本的元素属性\"></a>基本的元素属性</h3><h4 id=\"布局属性\"><a href=\"#布局属性\" class=\"headerlink\" title=\"布局属性\"></a>布局属性</h4><ul>\n<li><code>margin</code>: 控制元素的外边距;</li>\n<li><code>padding</code>: 控制元素的内边距;</li>\n</ul>\n<h4 id=\"文本属性\"><a href=\"#文本属性\" class=\"headerlink\" title=\"文本属性\"></a>文本属性</h4><ul>\n<li><code>font-size</code>: 控制字体大小;</li>\n<li><code>font-weight</code>: 控制字体粗细;</li>\n<li><code>text-align</code>: 控制文本的对齐方式;</li>\n<li><code>text-decoration</code>: 控制文本的装饰;</li>\n<li><code>line-height</code>: 控制行高;</li>\n<li><code>letter-spacing</code>: 控制字符间距;</li>\n<li><code>text-transform</code>: 控制文本的大小写;</li>\n</ul>\n<h4 id=\"边框属性\"><a href=\"#边框属性\" class=\"headerlink\" title=\"边框属性\"></a>边框属性</h4><ul>\n<li><code>border</code>: e.g. <code>border: 1px solid red;</code> 简写属性;</li>\n<li><code>border-radius</code>: 控制元素的圆角;</li>\n<li><code>border-style</code>: solid, dashed, dotted…</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li><code>overflow</code>: visible, hidden, scroll, auto;</li>\n<li><code>opacity</code>: 控制元素的透明度;</li>\n<li><code>cursor</code>: pointer, default, move, not-allowed…</li>\n</ul>\n<h3 id=\"动感魔法\"><a href=\"#动感魔法\" class=\"headerlink\" title=\"动感魔法\"></a>动感魔法</h3><h4 id=\"hover效果\"><a href=\"#hover效果\" class=\"headerlink\" title=\"hover效果\"></a>hover效果</h4><p>通过为class设置<code>:hover</code>伪类，可以为元素添加鼠标悬停时的效果。</p>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.my-element</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>空格将不会被忽略, 需要确保类名与<code>:hover</code>之间不存在空格;</p>\n</blockquote>\n<p>其他的一些常用的伪类:</p>\n<div class=\"code-container\" data-rel=\"Css\"><figure class=\"iseeu highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">:active</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:focus</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">border-color</span>: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:visited</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: purple;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:first-child</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:last-child</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">font-style</span>: italic;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:only-child</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: green;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:empty</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: yellow;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Flex\"><a href=\"#Flex\" class=\"headerlink\" title=\"Flex\"></a>Flex</h3><div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"comment\">/* 定义Flex容器 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">display</span>: flex; <span class=\"comment\">/* 将容器设置为Flexbox容器 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      </span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-direction: 定义主轴方向 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* row: 水平从左到右（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* row-reverse: 水平从右到左 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* column: 垂直从上到下 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* column-reverse: 垂直从下到上 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex-direction</span>: row; <span class=\"comment\">/* 可以改为row-reverse, column, column-reverse */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-wrap: 定义是否换行 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* nowrap: 不换行（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* wrap: 换行 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* wrap-reverse: 反向换行 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex-wrap</span>: wrap; <span class=\"comment\">/* 可以改为nowrap, wrap-reverse */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-flow: flex-direction 和 flex-wrap 的简写 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex-flow</span>: row wrap; <span class=\"comment\">/* 可以改为column nowrap等组合 */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* justify-content: 定义在主轴上的对齐方式 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-start: 起始对齐（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-end: 末端对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* center: 居中对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-between: 两端对齐，项目之间间隔相等 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-around: 项目之间间隔相等，项目两边有半个间隔 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">justify-content</span>: space-between; <span class=\"comment\">/* 可以改为flex-start, flex-end, center, space-around, space-evenly */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* align-items: 定义在交叉轴上的对齐方式 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* stretch: 拉伸适应容器（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-start: 交叉轴起始对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-end: 交叉轴末端对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* center: 交叉轴居中对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* baseline: 项目基线对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">align-items</span>: center; <span class=\"comment\">/* 可以改为flex-start, flex-end, stretch, baseline */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* stretch: 拉伸适应容器（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-start: 交叉轴起始对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-end: 交叉轴末端对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* center: 交叉轴居中对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-between: 多行两端对齐，行之间间隔相等 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-around: 多行之间间隔相等，行两边有半个间隔 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">align-content</span>: space-between; <span class=\"comment\">/* 可以改为flex-start, flex-end, center, space-around */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      </span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>; <span class=\"comment\">/* 设置容器高度 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">background-color</span>: <span class=\"number\">#f0f0f0</span>; <span class=\"comment\">/* 设置容器背景颜色 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">    </span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"comment\">/* 定义Flex项目 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-class\">.item</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>; <span class=\"comment\">/* 设置项目的flex属性，项目平分空间 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>; <span class=\"comment\">/* 设置项目内边距 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">background-color</span>: lightblue; <span class=\"comment\">/* 设置项目背景颜色 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; <span class=\"comment\">/* 设置项目外边距 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">text-align</span>: center; <span class=\"comment\">/* 设置项目文本居中 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex-grow</span>: <span class=\"number\">1</span>;<span class=\"comment\">/*尝试向flex容器扩展空间*/</span></span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>Item 1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>Item 2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>Item 3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n\n","more":"<blockquote>\n<p><a class=\"link\"   href=\"https://jsfiddle.net/?locale=zh_CN\" >在线编辑平台<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n</blockquote>\n<h3 id=\"伪元素\"><a href=\"#伪元素\" class=\"headerlink\" title=\"伪元素\"></a>伪元素</h3><p>使用伪元素<code>before</code>和<code>after</code>可以为元素添加内容.</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;author&quot;</span>&gt;</span>待抉<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.author</span><span class=\"selector-pseudo\">:before</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot;Author: &quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">font-weight</span>: bold; <span class=\"comment\">/* 加粗字体 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">color</span>: blue; <span class=\"comment\">/* 文本颜色为蓝色 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.author</span><span class=\"selector-pseudo\">:after</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">content</span>: <span class=\"string\">&quot; ✍️&quot;</span>;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">font-size</span>: <span class=\"number\">1.2em</span>; <span class=\"comment\">/* 调整图标大小 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">margin-left</span>: <span class=\"number\">5px</span>; <span class=\"comment\">/* 添加左边距 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n\n<p><code>:nth-child</code>可用于对序列中不同的元素进行有序的样式设计:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;index-card&quot;</span>&gt;</span>内容1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;index-card&quot;</span>&gt;</span>内容2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;index-card&quot;</span>&gt;</span>内容3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;index-card&quot;</span>&gt;</span>内容4<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\"><span class=\"selector-class\">.index-card</span><span class=\"selector-pseudo\">:nth-child</span>(odd) &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">  <span class=\"attribute\">flex-direction</span>: row-reverse;</span></span><br><span class=\"line\"><span class=\"language-css\">&#125;</span></span><br><span class=\"line\"><span class=\"language-css\"></span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>选择所有类名为 “index-card” 的元素;</li>\n<li><code>row-reverse</code> 会让 flex 容器中的项目从右到左排列;<blockquote>\n<p>同理, <code>even</code>选择偶数位置的元素; <code>3n+1</code>等函数表达式也可以起作用.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"基本的元素属性\"><a href=\"#基本的元素属性\" class=\"headerlink\" title=\"基本的元素属性\"></a>基本的元素属性</h3><h4 id=\"布局属性\"><a href=\"#布局属性\" class=\"headerlink\" title=\"布局属性\"></a>布局属性</h4><ul>\n<li><code>margin</code>: 控制元素的外边距;</li>\n<li><code>padding</code>: 控制元素的内边距;</li>\n</ul>\n<h4 id=\"文本属性\"><a href=\"#文本属性\" class=\"headerlink\" title=\"文本属性\"></a>文本属性</h4><ul>\n<li><code>font-size</code>: 控制字体大小;</li>\n<li><code>font-weight</code>: 控制字体粗细;</li>\n<li><code>text-align</code>: 控制文本的对齐方式;</li>\n<li><code>text-decoration</code>: 控制文本的装饰;</li>\n<li><code>line-height</code>: 控制行高;</li>\n<li><code>letter-spacing</code>: 控制字符间距;</li>\n<li><code>text-transform</code>: 控制文本的大小写;</li>\n</ul>\n<h4 id=\"边框属性\"><a href=\"#边框属性\" class=\"headerlink\" title=\"边框属性\"></a>边框属性</h4><ul>\n<li><code>border</code>: e.g. <code>border: 1px solid red;</code> 简写属性;</li>\n<li><code>border-radius</code>: 控制元素的圆角;</li>\n<li><code>border-style</code>: solid, dashed, dotted…</li>\n</ul>\n<h4 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h4><ul>\n<li><code>overflow</code>: visible, hidden, scroll, auto;</li>\n<li><code>opacity</code>: 控制元素的透明度;</li>\n<li><code>cursor</code>: pointer, default, move, not-allowed…</li>\n</ul>\n<h3 id=\"动感魔法\"><a href=\"#动感魔法\" class=\"headerlink\" title=\"动感魔法\"></a>动感魔法</h3><h4 id=\"hover效果\"><a href=\"#hover效果\" class=\"headerlink\" title=\"hover效果\"></a>hover效果</h4><p>通过为class设置<code>:hover</code>伪类，可以为元素添加鼠标悬停时的效果。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-class\">.my-element</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">  <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">  <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">  <span class=\"attribute\">transform</span>: <span class=\"built_in\">scale</span>(<span class=\"number\">1.1</span>);</span><br><span class=\"line\">  <span class=\"attribute\">font-size</span>:<span class=\"number\">20px</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>空格将不会被忽略, 需要确保类名与<code>:hover</code>之间不存在空格;</p>\n</blockquote>\n<p>其他的一些常用的伪类:</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:hover</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">button</span><span class=\"selector-pseudo\">:active</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: green;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">input</span><span class=\"selector-pseudo\">:focus</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">border-color</span>: blue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">a</span><span class=\"selector-pseudo\">:visited</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: purple;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:first-child</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">font-weight</span>: bold;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:last-child</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">font-style</span>: italic;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">li</span><span class=\"selector-pseudo\">:nth-child</span>(<span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: red;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">p</span><span class=\"selector-pseudo\">:only-child</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">color</span>: green;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"selector-tag\">div</span><span class=\"selector-pseudo\">:empty</span> &#123;</span><br><span class=\"line\">      <span class=\"attribute\">background-color</span>: yellow;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Flex\"><a href=\"#Flex\" class=\"headerlink\" title=\"Flex\"></a>Flex</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;!DOCTYPE <span class=\"keyword\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span> <span class=\"attr\">lang</span>=<span class=\"string\">&quot;en&quot;</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">charset</span>=<span class=\"string\">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">meta</span> <span class=\"attr\">name</span>=<span class=\"string\">&quot;viewport&quot;</span> <span class=\"attr\">content</span>=<span class=\"string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">style</span>&gt;</span><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"comment\">/* 定义Flex容器 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-class\">.container</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">display</span>: flex; <span class=\"comment\">/* 将容器设置为Flexbox容器 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      </span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-direction: 定义主轴方向 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* row: 水平从左到右（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* row-reverse: 水平从右到左 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* column: 垂直从上到下 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* column-reverse: 垂直从下到上 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex-direction</span>: row; <span class=\"comment\">/* 可以改为row-reverse, column, column-reverse */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-wrap: 定义是否换行 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* nowrap: 不换行（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* wrap: 换行 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* wrap-reverse: 反向换行 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex-wrap</span>: wrap; <span class=\"comment\">/* 可以改为nowrap, wrap-reverse */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-flow: flex-direction 和 flex-wrap 的简写 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt;; */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex-flow</span>: row wrap; <span class=\"comment\">/* 可以改为column nowrap等组合 */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* justify-content: 定义在主轴上的对齐方式 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-start: 起始对齐（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-end: 末端对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* center: 居中对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-between: 两端对齐，项目之间间隔相等 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-around: 项目之间间隔相等，项目两边有半个间隔 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-evenly: 项目之间间隔相等，项目两边有完整间隔 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">justify-content</span>: space-between; <span class=\"comment\">/* 可以改为flex-start, flex-end, center, space-around, space-evenly */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* align-items: 定义在交叉轴上的对齐方式 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* stretch: 拉伸适应容器（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-start: 交叉轴起始对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-end: 交叉轴末端对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* center: 交叉轴居中对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* baseline: 项目基线对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">align-items</span>: center; <span class=\"comment\">/* 可以改为flex-start, flex-end, stretch, baseline */</span></span></span><br><span class=\"line\"><span class=\"language-css\"></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* align-content: 定义多行的内容在交叉轴上的对齐方式（适用于多行时） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* stretch: 拉伸适应容器（默认） */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-start: 交叉轴起始对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* flex-end: 交叉轴末端对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* center: 交叉轴居中对齐 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-between: 多行两端对齐，行之间间隔相等 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"comment\">/* space-around: 多行之间间隔相等，行两边有半个间隔 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">align-content</span>: space-between; <span class=\"comment\">/* 可以改为flex-start, flex-end, center, space-around */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      </span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">height</span>: <span class=\"number\">100vh</span>; <span class=\"comment\">/* 设置容器高度 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">background-color</span>: <span class=\"number\">#f0f0f0</span>; <span class=\"comment\">/* 设置容器背景颜色 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">    </span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"comment\">/* 定义Flex项目 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">    <span class=\"selector-class\">.item</span> &#123;</span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex</span>: <span class=\"number\">1</span>; <span class=\"comment\">/* 设置项目的flex属性，项目平分空间 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">padding</span>: <span class=\"number\">20px</span>; <span class=\"comment\">/* 设置项目内边距 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">background-color</span>: lightblue; <span class=\"comment\">/* 设置项目背景颜色 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">margin</span>: <span class=\"number\">10px</span>; <span class=\"comment\">/* 设置项目外边距 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">text-align</span>: center; <span class=\"comment\">/* 设置项目文本居中 */</span></span></span><br><span class=\"line\"><span class=\"language-css\">      <span class=\"attribute\">flex-grow</span>: <span class=\"number\">1</span>;<span class=\"comment\">/*尝试向flex容器扩展空间*/</span></span></span><br><span class=\"line\"><span class=\"language-css\">    &#125;</span></span><br><span class=\"line\"><span class=\"language-css\">  </span><span class=\"tag\">&lt;/<span class=\"name\">style</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;container&quot;</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>Item 1<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>Item 2<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">class</span>=<span class=\"string\">&quot;item&quot;</span>&gt;</span>Item 3<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n","_processedHighlight":true},{"title":"cpp学习记录","date":"2025-02-14T12:21:21.000Z","excerpt":"围绕zju-OOP课堂内容扩展的cpp学习笔记","mathjax":true,"thumbnail":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094812819.png?imageSlim","_content":"#### 导论\n编译时, 从`c`的`gcc`转变为了`g++`.\n\nOOP的三大特点:\n\n- 封装\n- 继承\n- 多态\n\n# 基本语法\n在C语言中,我们主要使用`malloc()`和`free()`来进行动态内存管理。但这种方式存在一些问题:\n- 它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;\n- 容易发生内存泄漏.\n\n为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了`new`和`delete`.\n\nnew的基本语法十分直观:\n```cpp\nType* pointer = new Type;           // 分配单个对象\nType* pointer = new Type[size];     // 分配对象数组\n```\n\n可以在创建时进行初始化:\n```cpp\nint* p1 = new int(5);              // 初始化为5\nstring* p2 = new string(\"hello\");   // 初始化为\"hello\"\n```\n\n也可以根据变量进行动态的内存分配:\n```cpp\nint size;\ncin >> size;\nint* arr = new int[size];  // 根据输入分配内存\n```\n\n> [!NOTE]\n>\n> Use `delete ［］` if `new ［］` was used to allocate an array.\n\n\n\n# 输入输出流\n\n通过包含头文件 -- `#include <iostream>` 来使用输入输出流 `cin` 和 `cout`.\n\n```cpp\n#include <iostream>\n\nusing namespace std;\nint main(){\n    int age; \n    cin >> age;\n    cout << \"You are \" << age << \" years old\" << endl;\n    // endl 是换行符\n    return 0;\n}\n```\n\n- `cin`读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:\n```cpp\nstring str=\"Hello world!\";\nofstream fout(\"out.txt\");\nfout<<str<<endl;\n\nifstream fin(\"out.txt\");\nstring str1,str2;\n\n// 读取文件中的两个字符串\nfin>>str1>>str2; \n\ncout << str1 << endl << str2 << endl;\n// 输出:\n// Hello\n// world!\n\nreturn 0;\n```\n\n\n## 文件流\n\n### 输入输出流基础\n- 头文件: `#include <fstream>`\n- 类: `ifstream`(输入流), `ofstream`(输出流)\n```cpp\n#include <fstream>  // 需要包含这个头文件\nusing namespace std;\n\n// 文件输出（写入文件）\nofstream outFile(\"output.txt\");\noutFile << \"Hello World\" << endl;\noutFile.close();\n\n// 文件输入（读取文件）\nifstream inFile(\"input.txt\"); \nstring line;\ngetline(inFile, line);\ninFile.close();\n```\n  - 写入文件时, 如果没有文件, 会自动创建.\n\n\n### 常用操作示例\n\n1. **写入文件**\n```cpp\nofstream outFile;\noutFile.open(\"test.txt\");  // 打开文件\nif (outFile.is_open()) {   // 检查是否成功打开\n    outFile << \"第一行\" << endl;\n    outFile << \"第二行\" << endl;\n    outFile.close();       // 完成后关闭文件\n}\n```\n\n2. **读取文件 **\n```cpp\nifstream inFile(\"test.txt\");\nstring line;\nwhile (getline(inFile, line)) {  // 逐行读取\n    cout << line << endl;\n}\ninFile.close();\n```\n\n3. **以追加模式打开文件**\n```cpp\nofstream outFile(\"test.txt\", ios::app);  // app 表示追加模式\noutFile << \"这行会被添加到文件末尾\" << endl;\noutFile.close();\n```\n\n\n### 文件打开模式\n\n- `ios::in` - 读取模式\n- `ios::out` - 写入模式\n- `ios::app` - 追加模式\n- `ios::ate` - 打开文件后立即定位到文件末尾\n- `ios::binary` - 二进制模式\n- `ios::trunc` - 如果文件存在则**截断**文件\n  - 如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.\n```cpp\n// 假设 test.txt 原本内容是:\n// Hello World\n// This is a test\n\n// 使用 trunc 模式打开\nofstream outFile(\"test.txt\", ios::out | ios::trunc);  \noutFile << \"新的内容\" << endl;\noutFile.close();\n\n// 现在 test.txt 的内容只有:\n// 新的内容\n```\n>  或直接用 `ios::out`，因为out默认包含trunc\n\n\n- 使用位或运算符`|`来同时指定多个模式:\n```cpp\n// 组合使用打开模式\nofstream outFile(\"test.txt\", ios::out | ios::app);\n```\n\n### 错误处理\n\n```cpp\nifstream inFile(\"nonexistent.txt\");\nif (!inFile) {\n    cerr << \"无法打开文件！\" << endl;\n    return 1;\n}\n\n// 或者使用is_open()\nif (!inFile.is_open()) {\n    cerr << \"无法打开文件！\" << endl;\n    return 1;\n}\n```\n\n# 变量\n## String\n需要先引入指定的头文件:\n```cpp\n#include <string>\n```\n\n- 定义时可以使用等号或者用括号包裹字符串:\n```cpp\nstring name = \"John\"; \n// string name(\"John\");\n```\n\n---\n\n### stringstream\n`stringstream` 表示**双向**字符串流:\n- 需要导入头文件`#include <sstream>`;\n- `istringstream` 表示**输入**字符串流\n  - 作用: 将字符串转换成一个类似于输入流的对象;\n  - 内部维护了一个字符串和一个位置指针;\n  - 每次读取时, 位置指针向后移动, 且自动跳过空白字符.\n- `ostringstream` 表示**输出**字符串流.\n\n\n#### 字符串分词\n自动以**空白字符**(空格、制表符\\t、换行符\\n等)分割字符串;\n\n```cpp\n#include <string>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nint main(){\n    string name ( \"Xiao Ming\");\n\n    // 使用括号包字符串\n    istringstream is (name); \n    string s;\n    while (is>>s){\n        cout << s << endl;\n    }\n}\n```\n> `>>` 表示从输入流中读取数据;\n>\n> 注意字符串流也是一种类型, 作用的对象是字符串.\n\nOutput:\n```shell\nXiao Ming\nXiao\nMing\n```\n\n包含更多分词的字符串:\n```cpp\n#include <string>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nint main(){\n    string words = \"hello \\n world! \\t I am \\n here!\";\n    stringstream is (words);\n    \n    string word;\n    int count  = 1;\n    while(is >> word){\n        cout << \"Word \" << count << \": \" << word << endl;\n        count++;\n    }\n}\n```\nOutput:\n```shell\nWord 1: hello\nWord 2: world!\nWord 3: I\nWord 4: am\nWord 5: here!\n```\n\n#### 字符串拼接\n```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ostringstream oss;\n    string name = \"Alice\";\n    int age = 25;\n    \n    oss << \"Name: \" << name << \", Age: \" << age;\n    string result = oss.str();\n    cout << result << endl;\n}\n```\nOutput:\n```shell\nName: Alice, Age: 25\n```\n> 通过`.str()`方法可以对象转换为字符串类型, 从而**格式化输出**.\n\n<br>\n\n`.str(\"\")`方法可以**清空**字符串流:\n\n```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ostringstream oss;\n    string name = \"Alice\";\n    int age = 25;\n    \n    oss << \"Name: \" << name << \", Age: \" << age;\n    oss.str(\"\");\n    string result = oss.str();\n    cout << result << \"Nothing\" << endl;\n}\n```\nOutput:\n```shell\nNothing\n```\n\n### Getline\n**基本语法:**\n```cpp\ngetline(istream& is, string& str, char delim = '\\n');\n```\n- `is`: 输入流（通常是cin;\n- `str`: 存储结果的字符串;\n- `delim`: 分隔符, 默认为换行符`\\n`.\n\n**Example**:\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string line;\n    \n    cout << \"请输入一行文本：\";\n    getline(cin, line);  // 读取整行，包括空格\n    cout << \"你输入的是：\" << line << endl;\n    \n    // 使用自定义分隔符\n    string data;\n    cout << \"请输入内容（用,分隔）：\";\n    getline(cin, data, ',');  // 读取直到遇到逗号\n    cout << \"读取到逗号前的内容：\" << data << endl;\n}\n```\n\n### cin\n**特点**:\n- 以空白字符（空格、制表符、换行符）为分隔符;\n- **忽略**前导空白字符;\n- 遇到空白字符就停止读取.\n\n\n通常需要与`getchar()`方法配合来清除缓冲区当中的`\\n`字符:\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int number;\n    string line;\n    \n    cout << \"输入一个数字：\";\n    cin >> number;\n    \n    //清除输入缓冲区中的换行符\n    getchar(); // or cin.ignore(); \n   \n    cout << \"输入一行文本：\";\n    getline(cin, line);  // 现在可以正确读取整行\n    \n    cout << \"数字：\" << number << endl;\n    cout << \"文本：\" << line << endl;\n}\n```\n> 如果输入`8 \\n`, 则`getchar()`读取空格, 文本为空.\n\n### Alter String\n**outline** : 常用的字符串方法(成员函数):\n\n```cpp\ninsert(size_t pos, const string& s);\nerase (size_t pos = 0, size_tlen = npos);\nappend (const string& str);\nreplace (size_t pos,size_t len,const string& str);\n```\n\n---\n#### 常用方法\n\n- `insert(int pos, string str)` 在指定位置插入字符串\n```cpp\nstring str = \"Hello World\";\n// 在位置5处插入字符串\nstr.insert(5, \" Beautiful\");\ncout << str << endl;  // 结果: \"Hello Beautiful World\"\n\n// 在字符串末尾插入内容\nstr.insert(str.length(), \"!\");\ncout << str << endl;  // 结果: \"Hello Beautiful World!\"\n\n// 插入单个字符（使用string构造）\nstr.insert(0, \">\");\ncout << str << endl;  // 结果: \">Hello Beautiful World!\"\n```\n\n---\n- `erase(int pos, int length)` 删除从指定位置开始的若干个字符\n```cpp\nstring str = \"Hello Beautiful World!\";\n\n// 删除从下标6开始的9个字符\nstr.erase(6, 9); \ncout << str << endl;  // 结果: \"Hello World!\"\n\n// 删除从某个位置开始到末尾的所有字符\nstr.erase(5);\ncout << str << endl;  // 结果: \"Hello\"\n```\n> `length`参数省略, 则删除从`pos`位置开始到字符串末尾的所有字符.\n\n\n---\n\n- `replace (int pos, int length, string)` 替换指定位置的字符串\n```cpp\n// 从位置6开始，替换5个字符为\"C++\"\nstring str = \"Hello World!\";\nstr.replace(6, 5, \"C++\");\ncout << str << endl;  // 结果: \"Hello C++!\"\n```\n\n\n---\n\n\n- `append (const string& str);`\n```cpp\n// 添加整个字符串\nstring1.append(string2);\n\n// 添加指定位置的字符(索引从开始)\nstring1.append(string2, start, length);\n\n// 重复字符的添加\nstring1.append(count, char);\n\n```\n\n除此之外, 还存在着使用$\\underline{迭代器}$的用法: \n> 类似于指针, 指向容器(如字符串、数组等)的特定位置.\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string source = \"World!\";\n    string target = \"Hello \";\n    \n    // 添加source中的部分字符（从开始到结束）\n    target.append(source.begin(), source.end());\n    cout << target << endl;  // 输出: Hello World!\n    \n    // 只添加部分字符\n    string target2 = \"Hello \";\n    target2.append(source.begin(), source.begin() + 5);  // 只添加\"World\"，不包含\"!\"\n    cout << target2 << endl;  // 输出: Hello World\n    \n    return 0;\n}\n```\n1. `begin()`方法返回字符串的第一个字符的迭代器, `end()`方法返回字符串最后一个字符的**下一个**位置的迭代器;\n2. 迭代器的范围是**左闭右开**.\n\n---\n\n#### 其他方法\n\n- `find(string, int pos)` 从指定的位置开始寻找字符串位置\n```cpp\nstring str = \"Hello World Hello\";\n// 从位置0开始查找\"Hello\"\ncout << str.find(\"Hello\", 0) << endl;     // 结果: 0\n// 从位置1开始查找\"Hello\"\ncout << str.find(\"Hello\", 1) << endl;     // 结果: 12\n// 查找不存在的字符串\ncout << str.find(\"Python\") << endl;       // 结果: string::npos\n```\n  - `string::npos`是`size_t`类型的最大值;\n  - 可以使用`str.find(\"Python\") == string::npos`作为判断条件, 检查是否找到字符串.\n\n---\n\n- `compare(string)` 字符串比较\n```cpp\nstring str1 = \"Hello\";\nstring str2 = \"Hello\";\nstring str3 = \"World\";\n\ncout << str1.compare(str2) << endl;  // 结果: 0  (相等)\ncout << str1.compare(str3) << endl;  // 结果: -15 (str1 < str3) \ncout << str3.compare(str1) << endl;  // 结果: 15  (str3 > str1)\n```\n  - 按照字典序比较得到结果\n\n---\n\n- `to_string(int)` 将数字转换成字符串\n```cpp\nint num = 123;\nstring str = to_string(num);\ncout << str << endl;          // 结果: \"123\"\ncout << str + \"456\" << endl;  // 结果: \"123456\"\n```\n  - 字符串之间可以通过`+`直接拼接.\n\n---\n\n- `stoi(string)` 将字符串转换成整数\n```cpp\nstring str = \"123\";\nint num = stoi(str);\ncout << num + 456 << endl;    // 结果: 579\n// 注意：字符串必须是合法的数字格式\n// string str = \"abc\"; \n// int num = stoi(str);  // 这会抛出异常\n```\n  - 字符串必须是合法的数字格式;\n  - ` int num = stoi(\"abc\");`  将会抛出异常\n\n---\n\n### 构造函数\n**Outline:**\n```cpp\nstring(const char *cp, int len);\nstring(const string& s2, int pos);\nstring(const string& s2, int pos, int len);\n```\n\n---\n\n- `string(const char *cp, int len)` 字符数组创建字符串\n```cpp\nstring str1(\"Hello World\", 5);\ncout << str1 << endl;\n// 输出: Hello\n```\n\n- `string(const string& s2, int pos)` 从现有字符串创建新字符串，从指定位置到末尾\n```cpp\nstring s2 = \"Hello World\";\nstring str2(s2, 6);\ncout << str2 << endl;\n// 输出: World\n```\n\n- `string(const string& s2, int pos, int len)` 从现有字符串创建新字符串，指定起始位置和长度\n```cpp\nstring s3 = \"Hello World\";\nstring str3(s3, 6, 3);\ncout << str3 << endl;\n// 输出: Wor\n```\n\n- `string(int length, char c)` 用指定长度的字符c初始化字符串\n```cpp\nstring str4(5, '*');\ncout << str4 << endl;\n// 输出: *****\n\n// 实际应用示例\nint num = 432;\nstring str = to_string(num);\ncout << string(5 - str.length(), '0') + str << endl;\n// 输出: 00432\n```\n\n\n### 成员函数\n\n```cpp\n// 提取子字符串\nsubstr(int pos, int len);\nstring str = \"Hello World\";\nstring sub = str.substr(6, 3);  // 结果: \"Wor\"\n```\n\n```cpp\n// 字符串赋值\nassign();\nstring str1 = \"Hello\";\nstring str2;\nstr2.assign(str1);  // str2现在是 \"Hello\"\n```\n\n\n```cpp\n// 在指定位置插入字符串\n    string str1 = \"hello\";\n    string str2 = \"world\";\n    str1.insert(3, str2);\n    cout << str1 << endl;\n// 结果: helworldlo \n```\n\n```cpp\n// 删除指定位置的指定长度的字符\nerase(int pos, int len);\nstring str = \"Hello World\";\nstr.erase(5, 6);  // 结果: \"Hello\"\n```\n\n**Notice：**\n1. 所有位置索引都是从0开始计数\n2. 如果指定的长度超过字符串实际长度，会自动调整到实际可用长度\n3. 使用这些函数时要注意检查参数的有效性，避免越界访问\n4. `.assign(str, pos, len)`: 相比于直接赋值, `assign`还提供了精确控制赋值的方法, 也就是指定内容字符串的起始位置和长度.\n\n---\n### Substr\n在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. `substr()`方法可以精确地获取字符串片段.\n\n`substr`即substring的缩写, 表示子字符串.\n\n**基本语法**\n```cpp\nstring substr(int pos, int len) ;\n```\n参数分别表示截取的起始下标以及要截取的长度(如果省略`len`将截取到字符串的末尾).\n\n**e.g.**:\n```cpp\nstring email = \"user.name@example.com\";\n\n// 获取用户名的部分\nint atPos = email.find('@');\nstring username = email.substr(0, atPos); // result: \"user.name\"\n\n// 获取域名部分\nstring domain =  email.substr(atPos + 1); // result: \"example.com\"\n\n// 获取顶级域名(最后一个.之后的部分)\nint lastDotPos = email.rfind('.');\nstring topLevelDomain = email.substr(lastDotPos + 1); // result: \"com\"\n```\n- `rfind()`方法: 会从字符串的**末尾向前**搜索，从而返回要查找的字符或子字符串此时第一次出现的位置。如果没有找到，则返回 string::npos.\n\n---\n\n# Function\n\n## Default arguments\n\n要点:\n\n- 默认值必须在函数原型中从右到左地给出, 否则在调用的时候无法分辨;\n\n- 默认值只能出现在函数原型 或者 将声明和定义放在一起, 下面的情况会报错:\n\n  ```cpp\n  void f(int i, int j = 10);\n  int main()\n  {\n      ...\n  }\n  void f(int i, int j = 10){\n      ...\n  }\n  ```\n\n\n\n\n\n\n\n# Group\n\n**选择的标准:**\n\n- 一般情况 $\\Rightarrow$ `vector`;\n- 程序需要对元素进行**随机访问** $\\Rightarrow$ `vector` or `deque`;\n- 程序需要在容器**中间插入**元素 $\\Rightarrow$ `list` or `forward_list`;\n- 程序需要在容器的**首尾插入**元素 $\\Rightarrow$ `deque`;\n- 容器中的元素**相对较小**但是数量较多 $\\nRightarrow$ `list` nor `forward_list`.\n  - 否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.\n\n\n\n## Pair\n\n### 基本介绍\n\n#### 1. 基本概念\npair 是 C++ 标准库提供的模板类，用于<u>将两个不同类型的值组合成一个对象</u>。它定义在 `<utility>` 头文件中。\n\n#### 2. 创建与初始化\n```cpp\n// 默认构造\nstd::pair<std::string, int> p1;\n\n// 直接初始化\nstd::pair<std::string, int> p2(\"tag\", 10);\n\n// 使用make_pair\nauto p3 = std::make_pair(\"data\", 5);\n\n// 统一初始化\nstd::pair<std::string, int> p4{\"value\", 8};\n```\n\n#### 3. 访问元素\n```cpp\n// 传统访问方式\nstd::cout << p2.first << \": \" << p2.second << endl;\n\n// 结构化绑定(C++17)\nauto [key, val] = p3;\nstd::cout << key << \": \" << val << endl;\n```\n\n#### 4. 常用操作\n```cpp\n// 比较操作\nif (p1 == p2) {...}\nif (p1 < p2) {...}  // 先比较first，再比较second\n\n// 交换内容\np1.swap(p2);\nstd::swap(p1, p2);\n```\n\n#### 5. 实际应用示例\n```cpp\n// 作为函数返回值\nstd::pair<bool, string> checkInput(const string& input) {\n    if (input.empty()) {\n        return {false, \"输入不能为空\"};\n    }\n    return {true, \"\"};\n}\n\n// 在容器中使用\nvector<pair<string, int>> dataList = {\n    {\"item1\", 10},\n    {\"item2\", 20},\n    {\"item3\", 30}\n};\n\n// 与map配合使用\nmap<string, pair<int, double>> complexData;\n```\n\n#### 6. 注意事项\n1. pair 的元素可以是任意类型，包括自定义类型\n2. 使用结构化绑定需要C++17或更高标准\n3. pair 常用于需要返回多个值的函数\n4. 在性能敏感场景要注意构造和拷贝开销\n\n\n\n## Set\n\n**集合**: 用于存储一组不允许重复的元素, 且会自动排序.\n\n可以使用的方法包括:\n\n1. `.insert( )`: 插入元素;\n\n2. `.erase()`: 删除元素. 如果输入是元素值, 那么返回1/0表示是否成功删除; 如果输入是迭代器, 那么返回的是**下一个元素的迭代器**.\n\n3. `.find( )`: 寻找元素, 如果找到 返回对应的 **迭代器**. 否则返回 `.end( )`;\n\n   \n\n## Vector\n\n存储元素在**连续的内存空间**中, 支持**随机访问**.\n- 可以动态增长, 适合存储**未知数量**的元素;\n- 通过下标访问元素的时间复杂度为 O(1);\n- 在末尾插入和删除元素的时间复杂度为 O(1);\n- 在中间插入和删除元素的时间复杂度为 O(n);\n- **使用场景**: 需要随机访问、排序、内存连续存储的场景.\n\n**语法**:\n- 使用 `.end()`返回一个指向容器**末尾后一个位置**的迭代器:\n  ```c++\n  auto it = find(vec.begin(), vec.end(), value);  // 查找 value\n    if (it != vec.end()) {         // 如果找到了（即没有返回 end()）\n        vec.erase(it);             // 则删除找到的元素\n    }\n  ```\n- 使用 `.push_back()`在末尾插入元素, 或者使用`.emplace_back()`在末尾原位构造元素(更加高效);\n  ```c++\n  vec.push_back(10);\n  vec.emplace_back(20); //更加高效\n  ```\n  > `emplace_back`方法**直接**在容器的**内存空间中构造**对象, 相比于`push_back`而言更加**高效**.\n- `.erase()`方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;\n  \n    ```c++\n     vec.erase(vec.begin() + 1);       // 删除第二个元素\n     vec.erase(vec.begin(), vec.begin() + 3); // 删除前三个元素\n     vec.clear();                      // 清空整个 vector\n    ```\n    > `vec.clear();` 将会清空整个vector.\n    >\n    > 和`insert`需要的参数一样, 都需要**迭代器**而非索引来定位.\n- `vec[i]`的形式访问, 使用`vec.at(i)`的方式可以在越界时抛出异常;\n- `.begin()`和`.end()`获取迭代器, 使用范围for循环遍历元素;\n    ```c++\n     cout << \"Vector elements:\" << endl;\n     for (int num : vec) {\n        cout << num << \" \";\n     }\n     cout << endl;\n    \n    //使用迭代器遍历\n    for (auto it = vec.begin(); it != vec.end(); ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n    ```\n- `.size()`获取`vector`的大小, `.empty()`判断`vector`是否为空;\n  ```c++\n  cout << \"Vector size: \" << vec.size() << endl;\n  if (vec.empty()) {\n      cout << \"Vector is empty.\" << endl;\n  }\n  ```\n- 使用`sort()`对`vector`进行排序, 使用`find()`查找元素;\n  ```c++\n  sort(vec.begin(), vec.end());   // 排序\n  auto it = find(vec.begin(), vec.end(), 5); // 查找 5\n  ```\n  \n- `insert` 插入的位置是指定的迭代器位置之前一个;\n\n### Reserve\n为了避免频繁地扩展内存, 可以通过`reserve`预先分配合适的空间, 同时通过`.reszie()`调整大小;\n```cpp\nvector<string> v2;\nv2.reserve(1000);  // 一次性分配 1000 个元素的空间\n\nv2.resize(v2.size() + v2.size()/2); // 调整大小为原来的 1.5 倍\n```\n\n`reserve`只分配空间而不创建元素,`resize`将同时分配元素(默认值):\n\n```cpp\nvector<string> vec;\n// reserve: 只分配空间，不创建元素\nvec.reserve(10);  \ncout << \"The capacity with reserve: \" << vec.capacity() << endl;\ncout << \"The size with reserve: \" << vec.size() << endl;    \n\n// resize: 分配空间并创建元素\nvec.resize(10);   \ncout << \"The capacity with resize: \" << vec.capacity() << endl;\ncout << \"The size with resize: \" << vec.size() << endl;   \n```\n\n**Output**:\n```shell\nThe capacity with reserve: 10\nThe size with reserve: 0\nThe capacity with resize: 10\nThe size with resize: 10\n```\n> [!important]\n>\n> `.push_back()`的实际作用是在容器索引的`size`处插入元素.\n>\n>  而`reserve`不会影响容器的`size`,  初始化和`resize`会影响并且填充默认值:\n\n**e.g.  验证:**\n\n```cpp\nint main() {\n    vector<int> vec(10);\n    \n    // 打印初始状态\n    cout << \"初始状态：\\n\";\n    cout << \"size: \" << vec.size() << \", capacity: \" << vec.capacity() << \"\\n\\n\";\n    \n    // 预留5个空间\n    vec.reserve(15);\n    cout << \"reserve(15) 后：\\n\";\n    cout << \"size: \" << vec.size() << \", capacity: \" << vec.capacity() << \"\\n\\n\";\n    \n    vec[20] =20;\n\n    // 添加元素并观察\n    cout << \"添加元素过程：\\n\";\n    for(int i = 1; i <= 6; i++) {\n        vec.push_back(i);\n        cout << \"添加 \" << i << \" 后 - \";\n        cout << \"size: \" << vec.size() \n             << \", capacity: \" << vec.capacity()\n             << \", 元素: \";\n        for(int x : vec) cout << x << \" \";\n        cout << \"\\n\";\n    }\n    \n    return 0;\n}\n\n```\n\n**Output:**\n\n```shell\n初始状态：\nsize: 10, capacity: 10\n\nreserve(15) 后：\nsize: 10, capacity: 15\n\n添加元素过程：\n添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 \n添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 \n添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 \n添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 \n添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 \n添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 \n```\n\n1. 此处的 `vector<int> vec(10);`初始化了10个默认值的`int`类型的元素;\n2. `vec[20] = 20;`没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;\n   1. 如果换成`vec.at(20) = 20`将会在编译时报错;\n3. 可以发现, `reserve`的作用就是避免了多次自动扩容.\n\n> `reserve`的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素**copy**到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.\n\n\n\n### Resize\n\n用法的枚举:\n\n1. `resize(n)`: 将vector的大小调整为n, 如果大于当前值, 则在末尾添加具有默认值的新元素;\n\n2. `resize(n, val)`: 同样调整大小, 但是指定了默认值为新的 `val`;\n\n3. 对于二维向量的内存分配也是类似的:\n\n   ```cpp\n   \tvector<vector<int>> m;  //二维码向量;\n     ...\n     m.resize(r,vector<int>(c,0)); //初始化为一个r行c列且初始值为0的矩阵.\n   ```\n\n   \n\n## List\n\n- 在`list`容器当中, 迭代器是双向迭代器;\n  - 双向迭代器不支持大小的比较, 只支持 `==`,`!=`,`++`,`--`;\n  因此, 注意实际的使用:\n```cpp\nlist<int> lst1;\nlist<int>::iterator iter1 = lst1.begin();\nlist<int>::iterator iter2 = lst1.end();\n\n// 正确的写法\nwhile (iter1 != iter2) {\n    // 处理当前元素\n    ++iter1;\n}\n\n// 错误的比较\n// while(iter1 < iter2) \n    \n```\n\n### 有序链表\n```cpp\n#include <iostream>\n#include <list>\n#include <string>\n\n\nusing namespace std;\n\nint main() {\n    list<string> s;\n    string str;\n    list<string> :: iterator p;\n    int count ;\n\n    cout << \"enter the number of the strings:\" << endl;\n\n    cin >> count; \n\n\n    for(int i = 0; i < count; i++){\n        cout << \"enter a string:\" ;\n        cin >>str;\n        \n        p = s.begin();\n        while(p != s.end() && *p <str)\n            p++;\n        s.insert(p,str);\n    }\n    for(p = s.begin(); p!=s.end(); p++)\n        cout << *p << endl;\n    cout << endl;\n    return 0;\n}\n```\n\n**分析:**\n- `while(p != s.end() && *p <str)` 每次输入`str`时, 令迭代器从`list`的开头开始, 进行字典序的比较;\n\n> [!important]\n>\n> 找到插入的位置, 利用`insert()`方法插入到给出迭代器的**前面**!.\n\n\n\n\n\n## Deque\n`deque`即 double-ended queue, **双端队列**.\n\n支持:\n- 在两端快速的插入或删除;\n- 随机访问;\n\n**语法**:\n```cpp\n#include <deque>\ndeque<int> dq;\n\n// 1. 插入操作\ndq.push_back(1);    // 在末尾插入\ndq.push_front(2);   // 在开头插入\ndq.insert(pos, val);// 在指定位置插入\n\n// 2. 删除操作\ndq.pop_back();      // 删除末尾元素\ndq.pop_front();     // 删除首部元素\ndq.erase(pos);      // 删除指定位置元素\n\n// 3. 访问操作\ndq[0];              // 随机访问\ndq.at(1);           // 带边界检查的访问\ndq.front();         // 访问第一个元素\ndq.back();          // 访问最后一个元素\n```\n\n**示例:**\n```cpp\n#include <deque>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    deque<int> dq;\n    \n    // 在两端插入元素\n    dq.push_back(3);\n    dq.push_front(1);\n    dq.push_back(4);\n    dq.push_front(8);\n    \n    // dq ：{8, 1, 3, 4}\n    \n    // 使用随机访问\n    for(size_t i = 0; i < dq.size(); ++i) {\n        cout << dq[i] << \" \";\n    }\n\n}\n\n```\n\n### Forward_list\n`forward_list`即 单项链表.\n\n- 只能向前遍历, 即对应的迭代器不支持`--`而支持`++`.\n- 同时不支持下标访问以及随机访问.\n- 单项链表的设计, 使得内部的每个节点只需要**一个**指针来指向下一个节点, 从而比`list`双向链表更加**节省内存.**\n\n**语法**:\n\n```cpp\n#include <forward_list>\nforward_list<int> fl;\n\n// 1. 插入操作\nfl.push_front(1);           // 在开头插入\nfl.insert_after(pos, val);  // 在指定位置之后插入\n\n// 2. 删除操作\nfl.pop_front();            // 删除第一个元素\nfl.erase_after(pos);       // 删除指定位置之后的元素\n\n// 3. 访问操作\nfl.front();               // 访问第一个元素\n\n// 4. 特殊操作\nfl.before_begin();        // 返回第一个元素之前的迭代器\nfl.begin();               // 返回第一个元素的迭代器\n```\n\n**示例**:\n\n```cpp\n#include <forward_list>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    forward_list<int> fl;\n    \n    // 插入元素\n    fl.push_front(3);\n    fl.push_front(2);\n    fl.push_front(1);\n    \n    // 在特定位置后插入\n    auto it = fl.begin(); // 指向第一个元素\n    fl.insert_after(it, 4); // 在第一个元素后插入4\n    \n    // 遍历打印\n    for(const auto& val : fl) {\n        cout << val << \" \";\n    }\n    // 输出：1 4 2 3\n}\n```\n\n#### 访问前一个元素\n由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合`before_begin()`方法.\n\n```cpp\n// 如果需要访问某个元素的前一个元素，必须从头开始遍历\nauto prev = fl.before_begin();\nauto curr = fl.begin();\nwhile(curr != fl.end() && *curr != target) {\n    ++prev;\n    ++curr;\n}\n```\n\n## Map\n作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键**自动排序**\n- 如果插入重复的key, 将会覆盖原有的value;\n- 通过键查找元素、插入和删除的时间复杂度均为O(log n);\n- **使用场景**: 字典、索引、统计等.\n\n**语法**:\n- 使用 `.end()`返回一个指向容器**末尾后一个位置**的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于`map`当中;\n  ```cpp\n  auto it = ages.find(\"Charlie\");  // 查找 \"Charlie\"\n    if (it != ages.end()) {         // 如果找到了（即没有返回 end()）\n        ages.erase(it);             // 则删除找到的元素\n    }\n  ```\n- 使用下标(键)直接插入,或者通过键值对插入\n  ```cpp\n  ages[\"Alice\"] = 25;\n  ages.insert({\"Bob\", 30});\n  ages.emplace(\"Charlie\", 28); // 使用 emplace 插入 (更高效)\n  ```\n  > `emplace`方法指**直接**在容器的**内存空间中构造**对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于`insert`而言更加**高效**.\n- `.erase()`方法删除指定key的元素, 也可以通过`.find()`找到key对应的迭代器`it`, 然后`erase(it)`.\n  \n    ```cpp\n    ages.erase(\"Bob\");           // 删除键为 \"Bob\" 的元素\n    \n    auto it = ages.find(\"Charlie\");\n    if (it != ages.end()) {\n        ages.erase(it);         // 删除迭代器指向的元素\n    }\n    ```\n    > `ages.clear();` 将会清空整个map.\n- `map[key]`的形式访问, 使用`map.at(key)`的方式可以在key不存在时抛出异常;\n- `.find(key)`查找对应键的元素( 返回**迭代器** ), `.count(key)`返回对应键的元素个数(0 or 1)\n- `.size()`获取map的大小.\n- 迭代器的`->first`和`->second`可以分别访问键和值.\n    ```cpp\n     cout << \"Map elements:\" << endl;\n     for (auto mapIt = ages.begin(); mapIt != ages.end(); ++mapIt) {\n        cout << mapIt->first << \": \" << mapIt->second << endl; // 访问键和值\n     }\n    ```\n\n## Iterator\n迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.\n\n- **标记位置**: `.begin()`和`.end()` 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;\n\n迭代器的分类:\n- 输入迭代器: 支持读取和递增操作;\n  - `istream_iterator`: 用于从输入流读取数据;\n- 输出迭代器: 支持写入和递增操作;\n  - `ostream_iterator`: 用于向输出流写入数据;\n- 前向迭代器: 具有输入、输出迭代器的**所有**功能, 并且可以多次遍历同一个序列;\n  - 比如`forwarf_list`的迭代器:`auto it = flist.begin()` or `forward_list<int>::iterator it = flist.begin()`;\n- 双向迭代器: 在前向迭代器的原有功能上, 同时支持**递减**操作;\n  - 比如双向链表`list`的迭代器.\n    ```cpp\n    #include <iostream>\n    #include <list>\n    using namespace std;\n    \n    int main() {\n        list<int> myList = {10, 20, 30, 40, 50};\n    \n        // 使用双向迭代器正向遍历\n        cout << \"Forward traversal: \";\n        for ( list<int>::iterator it = myList.begin(); it != myList.end(); ++it) {\n            cout << *it << \" \";\n        }\n        cout <<  endl;\n    \n        // 使用双向迭代器逆向遍历\n        cout << \"Reverse traversal: \";\n        for ( list<int>::reverse_iterator rit = myList.rbegin(); rit != myList.rend(); ++rit) {\n            cout << *rit << \" \";\n        }\n        cout <<  endl;\n    \n        return 0;\n        // Forward traversal: 10 20 30 40 50 \n        // Reverse traversal: 50 40 30 20 10 \n    }\n    ```\n    > 1. `reverse_iterator`用于声明逆向遍历的迭代器, 也可以使用`auto`直接声明.\n    > 2. `rbegin()`和`rend()`分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的`++`相当于正向遍历时的`--`操作.\n- 随机访问迭代器: 具有双向迭代器的所有功能, 同时支持**随机访问**, 如`it+n`,`it[n]`.\n  - 比如`vector`的迭代器.\n  ```cpp\n    vector<int> vec = {10, 20, 30, 40, 50};\n    cout << \"Vector elements (random access): \";\n    for (int i = 0; i < vec.size(); ++i) {\n        cout << vec[i] << \" \"; // 使用下标随机访问\n    }\n    cout << endl;\n  ```\n\n另外, 还有一种迭代器称为**插入迭代器**, 比如`back_inserter`\n```cpp\nvector<int> vec = {10, 20, 30, 40, 50};\n\n//结合copy将容器的元素直接插入到另一个容器中\nvector<int> dest = {60,70};\ncopy(vec.begin(), vec.end(), back_inserter(dest)); // 在 dest 末尾插入元素\ncout << \"Copied vector: \";\nfor (int num : dest) {\n    cout << num << \" \";\n}\ncout << endl;\n// Copied vector: 60 70 10 20 30 40 50 \n```\n\n## for-each\nfor-each 循环的语法：\n```cpp\nfor (range_declaration : range_expression) {\n    loop_statement;\n}\n```\n- range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 `auto `关键字让编译器自动推导类型;\n- range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或**字符串**;\n- loop_statement： 循环体，包含要对每个元素执行的语句.\n\ne.g:\n```cpp\n\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    // 使用 for-each 循环遍历 vector\n    for (int num : numbers) {\n        std::cout << num << \" \"; // 输出每个元素\n    }\n    std::cout << std::endl;\n\n    // 使用 auto 关键字自动推导类型\n    for (auto num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // 修改容器中的元素（需要使用引用）\n    for (int &num : numbers) {\n        num *= 2; // 将每个元素乘以 2\n    }\n\n    // 输出修改后的元素\n    for (auto num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n- `for (int &num : numbers)`：使用引用 &，可以直接修改容器中的元素.\n\n### Map的循环\n当range_expression是`map`时, 可以使用`auto`自动推导range_declaration的类型.需要注意是:\n- 用迭代器的方式访问`map`中的键值对的形式是 `it->first`与`it->second`;\n- 在`for-each`循环当中, range_declaration是一个值, 因此使用`.first`与`.second`来访问键和值.\n    ```cpp\n    #include <iostream>\n    #include <vector>\n    #include <map>\n    #include <string>\n    #include <algorithm>\n    \n    using namespace std;\n    \n    int main(){\n        map<string, string> m = {{\"one\", \"1\"}, {\"two\", \"2\"}, {\"three\", \"3\"}};\n        vector<string> vec;\n    \n        for(auto& entry : m){\n            vec.push_back(entry.first + \":\" + entry.second );\n        }\n        copy(vec.begin(), vec.end(), ostream_iterator<string>(cout, \" \"));\n    }\n    ```\n    **Output:**\n    ```shell\n    one:1 three:3 two:2\n    ```\n> 此处由于`map`自动按照键的字典序进行排序, 因此输出时`three`的元素在`two`前;\n\n在上述的示例中, 也可以使用下面的方式进行`vec`的输出:\n```cpp\nfor(const auto& s : vec) {\n    cout << s << \" \";\n}\n```\n此时`auto`会自动推导为`string`类型, 且`&`对数组的元素进行了引用, 使得输出更加高效.\n\n### Pro&Con\n`for-each`循环的优点:\n- 消除了访问数组等越界的风险;\n- 不需要事先初始化迭代器;\n\n`for-each`循环的缺点:\n- 无法获取元素的索引;\n- 只能顺序地遍历.\n\n## typedef\n我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.\n\n而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.\n```cpp\ntypedef old_type new_type;\n```\n\n## Notices\n1. 直接对数组、字符串和`vector`进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;\n2. 对于`vector`, 可以通过`.at() = `的方式进行安全访问, 编译器会进行边界检查. 或者通过`.push_back()` or `.emplace_back`的方式在末尾赋值. 同时注意用`.reserve()`预先分配充分的内存空间.\n3. 避免不经意地向`map`当中插入元素:\n   1. 错误的示范:\n    ```cpp\n    if(foo[\"bob\"] == 1){...}\n    // 设置默认的零值\n    ```\n   2. 使用`.count()`方法正确检查元素是否存在:\n    ```cpp\n    if( foo.count(\"bob\") ){...}\n    ```\n   3. 也可以使用`find()`方法检查元素是否存在:\n   ```cpp\n    auto it = m.find(\"four\");\n   \n    if(it  != m.end()){\n        cout << it->second << endl;\n    }\n    else{\n        cout << \"Not found\" << endl;\n    }\n   ```\n4. 使用`.empty()`方法来检查容器**整体是否为空**, 而非`.count() == 0`的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.\n5. `erase()` 方法会返回**指向**被删除元素的**下一个**元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:\n   \n    ```cpp\n    //Initialize a list\n    list<int> L;\n    list<int>::iterator li = L.begin();\n    \n    // Wrong:\n    L.erase(li);    // 删除元素后，li 变成了无效迭代器\n    ++li;           // 错误, 不能对无效迭代器进行操作\n    \n    // Correct:\n    li = L.erase(li);  // 删除元素后，li 被更新为指向被删除元素的下一个元素\n    ```\n\n# 指针\n- Pointers to Objects\n```cpp\nstring str = \"hello\";\nstring *p = &str;\n```\n\n- Oprators with Pointers\n  - `&`: 取地址;\n  - `*`: 解引用;\n  - `->`: 用于访问对象的成员.\n```cpp\n(*p).length();\n// 等价于\np->length();\n```\n> `length()`即为`string`类的成员函数, 因此可以用`->`来访问.\n\n\n# 常量\n\n## 指针\n> 以`char`为例.\n\n- 指向常量的指针 `const char *p`\n  - 可以改变指针的地址.\n  - 无法通过指针改变对象的值\n- 常量指针 `char * const p`\n  - 指针指向的地址无法改变;\n  - 但是可以通过指针改变对象的值\n  如果需要同时保证地址和值都无法改变, 则需要使用`const char * const p`.\n\n\n\n如果`sp`是指向字符串的指针, 那么这两种的写法是等价的, 注意`.`的优先级高于`*`, 因此括号不可忽略.\n\n```cpp\nsp->length();\n(*sp).length();\n```\n\n\n\n# Class\n\n### `::`\n\n`::` resolver: 作用域解析运算符\n\n- 作用: \n\n  - 访问全局的作用域\n    当局部变量和全局变量同名时, 可以使用 `::` 来访问全局变量\n\n    ```cpp\n    int value = 10; // 全局变量\n    \n    void function() {\n        int value = 20; // 局部变量\n        cout << value;    // 输出 20（局部变量）\n        cout << ::value;  // 输出 10（全局变量）\n    }\n    ```\n\n  - 访问命名空间中的成员\n\n    ```cpp\n    namespace Math {\n        const double PI = 3.14159;\n    }\n    \n    double circumference = 2 * Math::PI * radius; // 使用命名空间中的常量\n    ```\n\n- 语法:\n\n  - `<class_name> :: <function_name>`\n  - `::<function_name>`  全局作用域\n\n\n\ne.g. \n\n```cpp\nvoid S::f() {\n    ::f();  // Would be recursive otherwise!\n    ::a++;  // Select the global a\n    a--;    // The a at class scope\n}\n```\n\n> `S::f()`: 定义了属于类S的成员函数f;\n>\n> `::f()`:表示调用全局作用域中的函数 `f()`, 默认为递归调用当前的成员函数;\n>\n> `::a++`表示将全局作用域的 `a` 自增, `a--`则访问并递减类作用域中的成员变量 `a`.\n\n\n\n### `this`\n\n`this`指针是成员函数的隐藏参数. 指向**当前对象的实例**.\n\n```cpp\nvoid Point::move(int dx, int dy);\n//等价于\nvoid Point::move(Point *this, int dx, int dy);\n```\n\n当调用成员函数时, 对象的地址会自动作为 `this`参数传递.\n\n\n\n在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 `this`:\n\ne.g\n\n```cpp\nclass Point {\nprivate:\n    int x, y;\n    \npublic:\n    // 移动点的位置\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n    \n    // 打印点的坐标\n    void print() {\n        std::cout << \"Point at (\" << x << \", \" << y << \")\" << std::endl;\n    }\n    \n    // 组合以上两个功能的函数\n    void move_and_print(int dx, int dy) {\n        move(dx, dy);  // 等同于 this->move(dx, dy)\n        print();       // 等同于 this->print()\n    }\n};\n```\n\n> 但是也可以显式指定 `this->move`, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.\n\n\n\n### 封装特性\n\n在OOP中, Object = Attributes + Services, 即数据和操作被**封装**在一起, 构成一个完整的对象.\n\n\n\n### 声明与定义\n\n我们应当在头文件中声明对象的成员及其 `public`,`private`和 `protected`等属性, 并且在 `cpp`文件中给出具体的定义:\n\n> 最好为每个类都建立如此对应的头文件和源文件 `cpp`.\n\ne.g. \n\n```cpp\n// Student.h - 类的声明\n#ifndef STUDENT_H\n#define STUDENT_H\n\n#include <string>\nusing namespace std;  // 在头文件中使用\n\nclass Student {\nprivate:\n    // 数据成员\n    string name;     \n    int id;\n    float gpa;\n    \npublic:\n    // 构造函数原型\n    Student(const string& name, int id);\n    \n    // 成员函数原型\n    void setName(const string& newName);\n    string getName() const;\n    void calculateGPA();\n    bool isEligibleForScholarship() const;\n};\n\n#endif // STUDENT_H\n\n```\n\n```cpp\n// Student.cpp - 成员函数的定义\n#include \"Student.h\"\nusing namespace std;  // 在源文件中使用\n\n// 构造函数实现\nStudent::Student(const string& name, int id) {\n    this->name = name;\n    this->id = id;\n    this->gpa = 0.0;\n}\n\n// 成员函数实现\nvoid Student::setName(const string& newName) {\n    name = newName;\n}\n\nstring Student::getName() const {\n    return name;\n}\n\nvoid Student::calculateGPA() {\n    // 实现GPA计算逻辑\n    // ...\n}\n\nbool Student::isEligibleForScholarship() const {\n    return gpa >= 3.5;\n}\n```\n\n> ` Student::getName() `指的就是类 `Student`中的成员函数 `getName()`.\n\n\n\n具体来说, `.h`头文件当中应该有:\n\n- 外部变量的声明\n  e.g. `extern int globalCounter;  // 仅声明，不定义`\n\n- 函数原型\n  e.g. `int calculateSum(int a, int b);  // 函数声明，不包含实现`\n\n- 类/结构体的声明\n  e.g.\n\n  ```cpp\n  class Student;  // 前向声明\n  \n  // 或完整类声明（不含成员函数定义）\n  class Rectangle {\n  private:\n      double width;\n      double height;\n  public:\n      Rectangle(double w, double h);\n      double getArea() const;\n  };\n  ```\n\n\n\n回顾 `#include`: 将被引用的文件插入 `.cpp` 文件当中\n\n- `#include \"xx.h\"`: 首先在当前目录下寻找;\n\n- `#include <xx.h>`: 直接在指定的目录中寻找\n\n  > 等价于 `#include <xx>`.\n\n\n\n为了避免在多个 `.cpp` 文件中重复引用相同的头文件, 可以通过 `#ifndef`等标记来判断是否需要引用当前的头文件:\n\n```cpp\n#ifndef HEADER_FLAG\n#define HEADER_FLAG\n\n#endif \n```\n\n> `HEADER_FLAG`一般使用完全大写来方便标识, 但是也可以大小写混合.\n\ne.g. \n\n```cpp\n// 文件: vector.h\n#ifndef VECTOR_H\n#define VECTOR_H\n// ...\n#endif // VECTOR_H\n```\n\n## 生命周期管理\n\n当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.\n\n为了确保这些工作不被遗忘, `cpp`的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.\n\n### 构造函数\n\n构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.\n\n- 语法: \n\n```cpp\nclass ClassName {\npublic:\n    // 默认构造函数\n    ClassName();\n    \n    // 带参数的构造函数\n    ClassName(参数列表);\n    \n    // 拷贝构造函数\n    ClassName(const ClassName& other);\n    \n};\n```\n\n> 1. **默认构造函数**：不带参数或所有参数都有默认值;\n> 2. **带参数的构造函数**：接受一个或多个参数;\n> 3. **拷贝构造函数**：从同类型的另一个对象创建新对象.\n\n\n\n- 构造函数初始化列表\n\n  ```cpp\n  Point::Point(int xx, int yy) :x(xx), y(yy) {\n    ...\n  }\n  ```\n\n  > 构造函数时, 传递参数并直接赋值给内部的成员变量 `x` , `y`.\n\n\n\n- 结构体中的构造函数:\n\n  ```cpp\n  struct Y { \n      float f;     // 浮点型成员变量\n      int i;       // 整型成员变量\n      Y(int a);    // 声明了一个接受int参数的构造函数\n  };\n  ```\n\n  > 1. 此处只是声明了构造函数需要 `int a`作为参数, 但是没有给出具体的实现;\n  > 2. 声明结构体对象(数组)  e.g. `Y y1[] = { Y(1), Y(2), Y(3) };`\n\n\n\n### 默认构造\n\n`auto` default constructor: (自动) 默认构造函数. **当且仅当**不存在任何构造函数时, 程序会自动生成默认构造函数, 不作任何的操作.\n\n`默认构造函数`： 在没有参数的情况下可以调用的构造函数， 称为默认构造函数. 其来源除了上述的程序构造以外, 还包括:\n\n1. 显示定义的无参构造函数;\n2. 定义的所有参数都具有默认值的构造函数.\n\n\n\n- 对于成员变量: 不进行初始化;\n\n### 析构函数\n\n析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 `~`. 当对象超出作用域或被显式删除时，析构函数会自动被调用.\n\n```cpp\nclass ClassName {\npublic:\n    ~ClassName();\n};\n```\n\n- 类似于栈, 优先创建的后析构.\n\n\n\n\n\n运用的示例:\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nclass MyString {\nprivate:\n    char* data;\n\npublic:\n    // 默认构造函数\n    MyString() : data(nullptr) {\n        std::cout << \"默认构造函数调用\" << std::endl;\n    }\n\n    // 带参数的构造函数\n    MyString(const char* str) {\n        if (str) {\n            data = new char[strlen(str) + 1];\n            strcpy(data, str);\n        } else {\n            data = nullptr;\n        }\n        std::cout << \"参数构造函数调用\" << std::endl;\n    }\n\n    // 拷贝构造函数\n    MyString(const MyString& other) {\n        if (other.data) {\n            data = new char[strlen(other.data) + 1];\n            strcpy(data, other.data);\n        } else {\n            data = nullptr;\n        }\n        std::cout << \"拷贝构造函数调用\" << std::endl;\n    }\n\n    // 析构函数\n    ~MyString() {\n        delete[] data;\n        std::cout << \"析构函数调用\" << std::endl;\n    }\n\n    // 打印字符串\n    void print() const {\n        std::cout << (data ? data : \"空字符串\") << std::endl;\n    }\n};\n\nint main() {\n    // 测试各种构造函数\n    MyString s1;                  // 默认构造函数\n    MyString s2(\"Hello\");         // 带参数的构造函数\n    MyString s3 = s2;             // 拷贝构造函数\n    \n    s1.print();\n    s2.print();\n    s3.print();\n    \n    return 0;  // 所有对象在这里被销毁，调用析构函数\n}\n```\n\n\n\n本地对象: \n\n`Field`(字段)指的是在类中定义的变量(成员变量):\n\n- 可以直接被类中的所有方法访问;\n- 生命周期**和类的对象保持一致;**\n\n其他类型数据的生命周期:\n\n- **参数**: 函数执行期间;\n- **局部变量**: 声明的代码块内部.\n\n---\n\n全局对象:\n\n\n\n\n\n> [!NOTE]\n>\n> 如果在类或对象的方法内部定义了一个和成员变量同名的变量, 那么将默认访问这个变量, 只有用 `this->xxx`才能显式访问成员变量. e.g. `int MyClass::count `.\n>\n> ```cpp\n> class MyClass {\n> public:\n>     int value = 10; // 字段\n> \n>     void printValue() {\n>         int value = 20; // 局部变量\n>         std::cout << \"Local value: \" << value << std::endl; // 输出局部变量\n>         std::cout << \"Field value: \" << this->value << std::endl;//使用this指针访问字段\n>     }\n> };\n> ```\n\n\n\n## Access Control\n\n`class`的默认为 `private`, 而 `struct`的默认权限是 `public`.\n\n访问限制符:\n\n### `friend`\n\n在 `class`内部声明友元, 可以使得对应的函数访问自身的成员变量(包括私有和受保护, 也即是所有的变量).\n\n```cpp\nstruct X {\nprivate:\n    int i;\npublic:\n    void initialize();\n    friend void g(X*, int i);\n    friend void Y::y();\n}\n```\n\n\n\n> [!NOTE]\n>\n> **友元关系不具有传递性 !**\n\n\n\n### `protected`\n\n该声明内的成员可以被以下的范围访问:\n\n1. 该类自身的成员函数;\n2. **该类的派生类的成员函数;**\n\ne.g.\n\n```cpp\nclass Base {\nprotected:\n    int protectedVar;\npublic:\n    Base(int val) : protectedVar(val) {}\n};\n\nclass Derived : public Base {\npublic:\n    Derived(int val) : Base(val) {}\n    void accessProtectedVar() {\n        protectedVar = 10; // 派生类可以访问 protectedVar\n    }\n    int getProtectedVar(){\n        return protectedVar;\n    }\n};\n```\n\n> 此处的 `base`就是一个基类, `class Derived : public Base`表明 Derived 是 base的一个派生类.\n>\n> 因此,  派生类可以通过自己的成员函数, 访问基类的 `protected`内的成员变量.\n\n\n\n\n\n\n\n## Static\n\n对于本地变量和全局变量的作用不同, 前者是生命周期, 后者是访问空间.\n\n静态的对象的生命周期是全局, 但是不会跟全局变量一样(一开始就创建), 而是在第一次调用的时候才构造, 且只构造一次.\n\n\n\n- `静态成员变量`由所有的实例**共享**, 初始化的时候不能再添加 `static`标签(否则无法被外文件访问), 必须在类的外部进行初始化, 且需要声明所属于的类;\n\n  > 但是也可以被普通的成员函数所访问.\n\n- `静态成员函数`属于类本身, 因此可以通过类名直接调用, 但是只能访问类的静态成员变量, 因为不存在属于实例的`this`指针. 静态成员函数可以在**类的内部**就定义, 如果在类的外部定义, 也不需要额外的`static`标签;\n\n  ```cpp\n  class MyClass {\n  public:\n      static int count; // 静态成员变量\n      int id;\n  \n      MyClass(int i) : id(i) {\n          count++; // 每次创建对象，count加1\n      }\n  \n      ~MyClass() {\n          count--;\n      }\n  \n      static int getCount() { // 静态成员函数\n          return count;\n      }\n  };\n  \n  int MyClass::count = 0; // 静态成员变量的初始化\n  \n  int main() {\n      std::cout << \"Count: \" << MyClass::getCount() << std::endl; // 通过类名调用静态成员函数\n      MyClass obj1(1);\n      MyClass obj2(2);\n  \n      std::cout << \"Count: \" << MyClass::getCount() << std::endl; // 通过类名调用静态成员函数\n  \n      return 0;\n  }\n  ```\n\n  **Output:**\n\n  ```cpp\n  Count: 0\n  Count: 2\n  ```\n\n\n\n- 函数内部的静态变量只会在调用的时候**初始化一次**, 直到程序结束.\n  e.g. 计数函数的调用次数:\n\n  ```cpp\n  void f(){\n    static int num_calls = 0;\n    ...\n    num_calls += 1;\n  }\n  ```\n\n- `extern`关键字用于声明变量或函数在其他文件中定义. 告诉编译器从而允许跨文件的访问.\n\n  > 但是这种跨文件访问只能作用于**非静态**的全局变量, i.e. 全局变量加上`static`声明之后, 将其作用域限制在了当前文件的内部.\n\n- 函数内部的静态对象, 其构造函数只会在定义的时候调用一次. 并且析构函数当退出程序时调用. 即使采取条件构造, 也只会在第一次条件满足的时候构造.\n\n\n\n- 静态成员的使用:\n\n  - 通过类名: `<class_name>::<static member`\n\n  - 通过实例名: `<ob variable>.<static member>`\n\n    > 让人误以为是类的对象变量, 不建议这样使用.\n\n\n\n\n\n## Reference\n\n引用（Reference）是一个非常重要的特性。它的引入是为了解决一些特定场景下的问题：\n\n- **<u>避免不必要的拷贝</u>**：在某些情况下，传递大型对象或结构体给函数时，如果直接传递拷贝会导致性能下降。引用允许我们传递对象的别名，而不需要拷贝整个对象。\n- **<u>简化代码</u>**：引用可以使代码更简洁，特别是在函数返回值和参数传递时。例如，通过引用返回一个对象可以避免构造临时对象。\n- **<u>指针的安全替代</u>**：引用提供了指针的功能，但避免了指针容易导致的错误，如空指针解引用或野指针。\n\n\n\n**基本语法**: \n\n引用是一个变量的别名，它在**声明时必须被初始化**，并且一旦初始化后就**<u>不能再指向其他</u>**对象.\n\n```cpp\nint a = 10;\nint& ref = a;  // ref 是 a 的引用\n```\n\n- `int&` 表示引用类型，`ref` 是 `a` 的引用。\n- 引用必须在声明时初始化，并且不能重新引用到另一个对象。\n- 无法对引用进行引用;\n- **不允许**存在 **以引用为元素的数组**\n\n\n\ne.g.\n\n```cpp\n#include <iostream>\n\nint main() {\n    int a = 10;\n    int& ref = a;  // ref 是 a 的引用\n\n    std::cout << \"Original value of a: \" << a << std::endl;\n    std::cout << \"Value of ref: \" << ref << std::endl;\n\n    ref = 20;  // 修改引用会影响原变量\n\n    std::cout << \"After modifying ref, value of a: \" << a << std::endl;\n    std::cout << \"Value of ref: \" << ref << std::endl;\n\n    return 0;\n}\n```\n\n在这个例子中：\n\n- `ref` 是 `a` 的引用，修改 `ref` 的值会影响 `a` 的值。\n- 通过引用，我们可以访问和修改原始变量 `a` 的值，而不需要直接操作 `a`。\n\n\n\n引用可以作为函数的形参, 此时**函数内部的形参作为实参的引用可以改变实参的值**.\n\n引用的绑定必须是一个具有明确地址的左值 ,而不能是临时产生的右值:\n\n```cpp\nvoid func(int &);\nfunc (i * 3); // Warning or error!\n```\n\n\n\n#### 指针与引用\n\n- 限制:\n\n  - 无法获得指针的引用;\n\n    ```cpp\n    int &*p;// illegal\n    ```\n\n  - 但是可以获得**指向引用的指针**\n\n    ```cpp\n    void f(int *&p);\n    ```\n\n 可以如此理解, 引用实际上是对象的别名. 用于修改对象的值. 但是为了修改指针, 可以直接使用指针的指针 `**`.\n\n此外, 引用并非独立的对象, 而是直接 **绑定**. 因此 `int& ref = a;`  `&ref`就是 a的地址.\n\n\n\n#### 右值引用\n\n左值是指具有明确地址的变量或者引用, 右值是计算过程中的中间结果或者字面量 (e.g.`10`).等不可寻址的值;\n\n> 涉及到计算的基本都是右值, 但是这四种的计算结果依旧是左值: `*`,`.`,`[]`和 `->`.\n\n右值一般在计算结束后就消失了, 如果我们希望延长其生命周期, 就可以使用 **右值引用**.\n\n- **格式**: `<tyep> && <ref_name> = <right_value>`\n\n  ```cpp\n  int x=20; // left-value \n  int&& rx = x * 2:\n  ```\n\n- TIps:\n\n  - 右值引用在初始化之后就可以正常赋值;\n  - 右值引用无法使用左值进行赋值.\n\n\n\n#### 引用参数与函数重载\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nvoid fun(int& lref){\n   cout << \"lref = \" << lref << endl;\n}\n\nvoid fun(int&& rref){\n   cout << \"rref = \" << rref << endl;\n}\n\nint main(){\n   int x = 10;\n   fun(x);\n   fun(10);\n}\n```\n\n**Output**:\n\n```cpp\nlref = 10\nrref = 10\n```\n\n> 1. 字面量`10`作为右值, 可以通过右值引用作为函数的参数;\n> 2. 具有明确地址的变量 `x`是左值;\n> 3.  C++ 允许在同一个作用域内声明多个具有相同名称但参数列表不同的函数。这被称为**函数重载**。编译器通过检查函数调用时提供的参数类型和数量来决定调用哪个重载函数。\n\n\n\n另外, 加上`const`之后, `& `的形参也可以接受右值作为实参, 比如: `void fun (const int& clref) {...}`\n\n> 但是如果已经存在右值实参作为形参的同名函数, 将会优先选择后者进行重载.\n\n这是因为普通引用对于右值的修改 make no sense, 而 `const` 引用<u>保证不会修改引用的对象</u>，因此即使是临时对象（右值）也可以安全地绑定到 `const` 引用.\n\n\n\n## Constants\n\n使用 `const`声明常量, 常量的值不可修改.\n\n`const`声明集合的时候, 其中的值在**编译期间不可知**, 因此<u>无法在代码中, 使用常量集合内部的值进行操作.</u>\n\n```cpp\nconst int i[] = {1,2,3};\nfloat f[i[2]]; // Illegal!\n```\n\n\n\n使用`const`对指针类型进行操作的时候:\n\n1. 忽略类似于 `char`之类的类型, 只关注 `const`与 `*`之间的位置关系;\n2. 如果是 `const *p` 意思是指针指向的内容不可通过这个指针进行更改;\n3. 如果是 `* const p`意思是指针指向的对象不可更改, 但是可以通过 `*p` 的方式改写对象的值\n\n\n\n---\n\n关于字符指针与字符数组:\n\n- `char  *p = \"hello\";` 实际上是 `const char *p`, 也就是说不允许修改 `*p`;\n- 而 `char p[] = 'hello';` 则可以通过`*p` 修改.\n\n\n\n---\n\n如果**成员函数**的<u>名称后</u>加了 `const`标记, 意味着:\n\n1. 无法通过该成员函数改变成员变量的值.\n2. 同时无法调用其他 **非const**的成员函数\n3. 实际上, 将其的 `this`指针转换为 `const A* this`, 也就是指向常量的指针\n\n> 因此 `const`修饰的成员函数具有 `this`指针(可访问), 不要与 `static`修饰的静态成员函数混淆! 后者不具有 `this`指针.\n>\n> 注意不要与 `const  type f()`混淆, 这是限制返回的结果无法修改; 而 `type f() const`限制成员函数本身的操作.\n\n\n\n**重载**: 允许根据成员函数是否被 `const`限制, 以及对象本身是否为 `const`来重载成员函数.\n\n```cpp\nclass A {\npublic:\n    void f() const {\n        cout << \"const version\" << endl;\n    }\n    void f() {\n        cout << \"non-const version\" << endl;\n    }\n};\n\nint main() {\n    A a;\n    const A ca;\n\n    a.f();    // 输出: non-const version\n    ca.f();   // 输出: const version\n\n    return 0;\n}\n```\n\n\n\n如果成员变量是 `const`, 那么:\n\n- **必须在对象构造时进行初始化** (无法在构造函数中进行直接赋值):\n\n  ```cpp\n  class A {\n  public:\n      const int i;\n      A(int value) : i(value) {} // 在初始化列表中初始化\n  };\n  ```\n\n\n\n如果在实例化对象的时候,  声明了这个实例是 `const`, 那么就无法调用成员函数中没有在后面声明 `const`的部分.( 即使实际上并没有修改的函数, 也不能通过编译).  —— 只能调用那些被标记为`const`的成员函数。\n\n```cpp\nclass A{\n  ...\n  int get_value();\n  int get_const_value const();\n}\n\nconst A a();\na.get_value; // ERROR, const对象无法调用非const声明的成员函数\na.get_const_value; // ok\n```\n\n\n\n---\n\n![image-20250318120332036](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250318120332036.png?imageSlim)\n\n> 无法用普通的指针来指向 `const`常量.\n>\n> 但是可以用指向常量的指针 来指向非常量的对象.\n\n\n\n---\n\n全局变量的构造在 `main()`之前. 静态本地变量在第一次执行到的时候才发生构造, 且只构造一次.\n\n---\n\n## 动态内存\n\n在 C++ 中，使用 `new` 关键字分配的空间位于 **堆** 上，与栈上的自动变量不同，堆上的内存不会自动释放，需要手动使用 `delete` 来析构以避免内存泄漏。\n\n#### 示例代码\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    // 使用 new 在堆上分配一个整数\n    int* ptr = new int(10);\n    cout << \"值: \" << *ptr << endl;\n\n    // 使用 delete 释放内存\n    delete ptr;\n\n    // 指针置空，避免野指针\n    ptr = nullptr;\n    return 0;\n}\n```\n\n#### 注意事项\n- 每次 `new` 分配的内存都需要对应的 `delete`。\n- 对于数组，使用 `new[]` 分配，释放时用 `delete[]`：\n```cpp\nint* arr = new int[5];  // 分配数组\ndelete[] arr;           // 释放数组\n```\n\n---\n\n## Inline Class\n\n### Delegating Constructor\n\n委托构造函数（Delegating Constructor）是通过一个构造函数调用另一个构造函数来完成初始化的机制, 也就是在初始化列表中调用其他.\n\n相对于委托构造的构造函数, 被称为 *target constructor* 目标构造函数.\n\n目标构造函数的执行先于委托构造函数.\n\n---\n\n#### 什么是委托构造函数？\n- **定义**: 一个构造函数可以在其初始化列表中调用同一个类的另一个构造函数来完成部分或全部初始化工作。\n- **目的**: 避免在多个构造函数中重复编写相同的初始化逻辑，解决代码重复的问题。\n- **限制**: 委托构造函数<u>本身不能在初始化列表中再初始化其他成员变量</u>，只能依赖被调用的构造函数。\n\n\n\n#### 代码示例与分析\n\n考虑将下面的冗余代码通过委托构造函数简化:\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250325120013059.png?imageSlim)\n\n实现: \n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass ClassC {\npublic:\n    int max;\n    int min;\n    int middle;\n\n    // 基础构造函数\n    ClassC(int my_max) {\n        max = (my_max > 0) ? my_max : 10;  // 默认值10\n    }\n\n    // 委托给基础构造函数\n    ClassC(int my_max, int my_min) : ClassC(my_max) {\n        min = (my_min > 0 && my_min < max) ? my_min : 1;  // 默认值1\n    }\n\n    // 委托给第二个构造函数\n    ClassC(int my_max, int my_min, int my_middle) : ClassC(my_max, my_min) {\n        middle = (my_middle < max && my_middle > min) ? my_middle : 5;  // 默认值5\n    }\n};\n\nint main() {\n    ClassC c1{1, 3, 2};\n    cout << \"max: \" << c1.max << \", min: \" << c1.min << \", middle: \" << c1.middle << endl;\n    return 0;\n}\n```\n\n#### 运行结果分析\n- `ClassC c1{1, 3, 2}`:\n  1. 调用 `ClassC(int, int, int)` 构造函数。\n  2. 它委托给 `ClassC(int, int)`，后者再委托给 `ClassC(int)`。\n  3. 初始化顺序：\n     - `max = 1`（因为 1 > 0）。\n     - `min = 1`（因为 3 > max，不满足条件，使用默认值 1）。\n     - `middle = 2`（因为 2 < max 且 2 > min 不成立，但逻辑上仍赋值 2，需检查代码逻辑）。\n\n#### 关键点\n1. **初始化位置**:\n   - 成员变量不能在委托构造函数的初始化列表中直接使用参数初始化，必须通过被委托的构造函数完成。\n   - 如 `ClassC(int my_max, int my_min) : ClassC(my_max)` 中，不能再初始化 `min`，只能在函数体内赋值。\n\n2. **代码重复问题**:\n   - 如果每个构造函数都独立初始化 `max`、`min` 等，会导致重复代码。\n   - 委托构造函数将公共逻辑集中到基础构造函数中。\n\n3. **委托链**:\n   - 可以形成构造函数调用链，如 `ClassC(int, int, int)` → `ClassC(int, int)` → `ClassC(int)`。\n\n4. **限制与解决方法**:\n   - 委托构造函数不能再有其他初始化列表项。\n   - 如果需要更灵活的初始化，可以引入一个私有的辅助构造函数：\n```cpp\nclass ClassC {\nprivate:\n    int max;  \n    int min;\n    void init(int my_max) { max = my_max > 0 ? my_max : 10; }\npublic:\n    ClassC(int my_max) { init(my_max); }\n    ClassC(int my_max, int my_min) : min(my_min) { init(my_max); } // 直接在初始化列表中初始成员变量\t\n};\n```\n\n\n\n\n\n---\n\n### 默认参数\n\n#### 定义\n- 默认参数是在函数声明中为参数指定的默认值，调用时未提供参数则使用默认值。\n- 规则：默认参数必须<u>从右到左设置</u>。\n\n#### 代码示例\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 函数声明\nint harpo(int n, int m = 4, int j = 5);  // 合法\nint chico(int n, int m = 6, int j);       // 非法：j 无默认值\nint groucho(int k = 1, int m = 2, int n = 3);  // 合法\n\nint main() {\n    int beeps;\n    beeps = harpo(2);      // harpo(2, 4, 5) -> 11\n    cout << \"beeps = \" << beeps << endl;\n    beeps = harpo(1, 8);   // harpo(1, 8, 5) -> 14\n    cout << \"beeps = \" << beeps << endl;\n    beeps = harpo(8, 7, 6);  // harpo(8, 7, 6) -> 21\n    cout << \"beeps = \" << beeps << endl;\n    return 0;\n}\n\nint harpo(int n, int m, int j) {\n    return n + m + j;\n}\n```\n\n#### 关键点\n1. **规则**:\n   - 默认参数从右到左设置。\n   - `int harpo(int n, int m = 4, int j = 5)` 合法。\n   - `int chico(int n, int m = 6, int j)` 非法。\n2. **作用**:\n   - 省略参数时自动填充默认值。\n   - 减少函数重载需求。\n3. **注意**:\n   - 默认值在声明中指定，<u>不在定义中</u>。\n   - 不能“跳跃”使用参数，如 `harpo(1, , 6)` 非法。\n\n#### 改进建议\n- 复杂逻辑可考虑函数重载或委托构造函数。\n- 避免过度使用默认参数以保持代码清晰。\n\n---\n\n### 内联函数\n\n> Inline Functions\n\n#### 定义\n- 内联函数是用 `inline` 关键字修饰的函数，编译器会尝试将函数调用替换为函数体代码，减少函数调用的开销。\n\n  > 普通函数的调用需要经历: 压栈、传递参数、跳转到函数地址、返回值处理、出栈等步骤, 由此可见内联函数可以有效提升性能.\n- 适用于小型、频繁调用的函数。\n\n#### 代码示例\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 内联函数定义\ninline int square(int x) {\n    return x * x;\n}\n\nint main() {\n    int num = 5;\n    cout << \"Square of \" << num << \" is \" << square(num) << endl;  // 输出 25\n    return 0;\n}\n```\n\n#### 关键点\n1. **作用**:\n   - 减少函数调用开销（如参数传递、栈帧创建）。\n   - 提高执行效率，适合小型函数。\n2. **使用场景**:\n   - 函数体短小、调用频繁。\n   - 不适合复杂函数（可能导致代码膨胀）。\n3. **注意**:\n   - `inline` 是建议，编译器可能忽略（例如函数过大或包含循环）。\n   - 内联函数定义通常放在头文件中，避免链接错误 (在多个源文件被调用的时候, `inline`的声明可以告诉编译器, 重复的定义是被允许的)\n\n\n\n\n\n> [!NOTE]\n>\n> 1. **Any function you define inside a class declaration is automatically an inline.**\n>\n>    > `class`内部**<u>定义</u>**的函数自动为 `inline`类型. 如果是类外定义(相同的`.h`文件), 那么需要显式声明为内联函数.\n>\n> 2. 内联函数必须在**<u>头文件</u>**中定义，或者在调用它的同一翻译单元中.\n>\n>    > 如果定义在 .cpp 文件中，调用点无法看到定义，编译器无法内联，链接器会报错.\n>\n> 3. 如果决定将类的函数定义写在头文件中, 有以下的两种选择使其成为内联函数;\n>\n>    1. 直接在声明的地方给出完全的定义;\n>    2. 在类外声明 `inline`然后定义.\n>\n> 4. `inline`确实比C语言的 `macro`更好, 因为内联函数实现了对参数的类型检查.\n>\n> 5. 编译器会对声明为 `inline` 的函数进行检查: 如果包含了递归 或者 代码量较大, 编译器依旧不会将其视为 `inline` .\n\n\n\n### inline 变量\n\n> [!NOTE]\n>\n> - 为静态成员变量声明 `inline`, 不必在 `.cpp`中再次声明.\n>\n> - 用于**在头文件中定义具有外部链接的变量**，避免了重复定义的问题.\n\n\n\n在 C++ 传统规则中，**全局变量**（或者 namespace 作用域的变量）在头文件中定义会导致多个翻译单元（编译文件）出现**重复定义错误**。在 C++17 之前，通常的做法是：\n\n```cpp\n// myheader.h\nextern int myVar; // 声明\n\n// mysource.cpp\n#include \"myheader.h\"\nint myVar = 42; // 定义\n```\n\n但在 C++17 之后，可以使用 inline 变量，直接在头文件中定义，而不会导致重复定义错误：\n\n```cpp\n// myheader.h\ninline int myVar = 42;  // C++17 及以上\n```\n\n在任何 `#include \"myheader.h`\" 的地方，myVar 仍然是<u>**同一个变量**</u>。\n\n> 如果希望不同的文件不是一个实例, 需要声明为 静态全局变量.\n\n\n\n\n\n**inline 变量的特点**\n\n​\t1.\t**允许在头文件中定义**，避免 extern 的使用。\n\n​\t2.\t**所有包含它的翻译单元共享同一个变量**（编译时不会创建多个实例）。\n\n​\t3.\t**必须初始化**，否则编译器无法确定变量的值。\n\n\n\n\n\n**示例：多个文件使用 inline 变量**\n\n\n\n假设有以下两个源文件，同时包含 myheader.h，但不会引发重复定义错误：\n\n**头文件 myheader.h**\n\n```cpp\n#ifndef MYHEADER_H\n#define MYHEADER_H\n\n#include <iostream>\n\ninline int globalVar = 100; // inline 变量\n\n#endif\n```\n\n**源文件 file1.cpp**\n\n```cpp\n#include \"myheader.h\"\n\nvoid func1() {\n    std::cout << \"file1.cpp: \" << globalVar << std::endl;\n}\n```\n\n**源文件 file2.cpp**\n\n```cpp\n#include \"myheader.h\"\n\nvoid func2() {\n    std::cout << \"file2.cpp: \" << globalVar << std::endl;\n}\n```\n\n**主程序 main.cpp**\n\n```cpp\n#include \"myheader.h\"\n\nvoid func1();\nvoid func2();\n\nint main() {\n    func1();\n    func2();\n    globalVar += 10;\n    std::cout << \"main.cpp: \" << globalVar << std::endl;\n    return 0;\n}\n```\n\n**编译 & 运行**\n\n```\ng++ file1.cpp file2.cpp main.cpp -o output && ./output\n```\n\n**输出示例：**\n\n```\nfile1.cpp: 100\nfile2.cpp: 100\nmain.cpp: 110\n```\n\n说明：\n\n​\t•\tglobalVar 是**同一个变量**，而不是多个副本。\n\n​\t•\tmain.cpp 修改 globalVar 之后，globalVar 在所有翻译单元中都被更新。\n\n\n\n------\n\n\n\n**inline 变量 vs constexpr 变量**\n\n​\t•\tinline 变量可以是**可变的**，可以修改其值。\n\n​\t•\tconstexpr 变量必须是**编译时常量**，不能修改。\n\n​\t•\tinline constexpr 变量既有 inline 特性，又是编译时常量。\n\n```\ninline constexpr int constantVar = 50; // 不能修改\n```\n\n\n\n### weak\n\n`weak`允许不同的编译单元存在同名的函数, 并且在实际调用的时候, 优先调用不是 `weak`的函数. 从而提供了一种默认的实现.\n\n`weak`关键字可以用于函数、变量与对象等, 与主要使用于函数的 `inline`不同.\n\n如果没有 `weak`标记, 就是强变量.\n\n\n\n- 一般的编译器需要使用 `__attribute__((weak)) ` 来声明:\n\n```cpp\n#include <iostream>\n\n// 声明 weak 变量，提供默认值\n__attribute__((weak)) int globalValue = 42;\n\nint main() {\n    std::cout << \"globalValue = \" << globalValue << std::endl;\n    return 0;\n}\n```\n\n\n\n# Composition\n\n用已有的对象构造新的对象. 称为组合.\n\n可以用 `has-a`的关系来描述.\n\n## 类内对象的初始化\n\n\n\n假设我们有一个 `Person` 类，该类内部包含一个 `std::vector<std::string>` 类型的成员变量，用于存储人的爱好。我们将展示如何在类的构造函数中使用完全初始化和引用初始化来初始化这个成员变量。\n\n### 1. Fully\n\n完全初始化是指在类的构造函数中直接为成员变量赋予初始值。这通常通过成员初始化列表（member initializer list）来完成。\n\n```cpp\nclass Person {\npublic:\n    std::vector<std::string> hobbies;\n\n    // 完全初始化：使用成员初始化列表\n    Person(const std::vector<std::string>& initialHobbies)\n        : hobbies(initialHobbies) { }\n};\n\n```\n\n**解释**\n\n- **成员变量初始化**：在 `Person` 类的构造函数中，我们使用成员初始化列表 `: hobbies(initialHobbies)` 来完全初始化 `hobbies` 成员变量。这意味着 `person1.hobbies` 将拥有 `initialHobbies` 的一个拷贝。\n- **独立性**：`person1.hobbies` 是 `initialHobbies` 的一个独立拷贝，修改 `person1.hobbies` 不会影响 `initialHobbies`，反之亦然。\n\n\n\n### 2. Reference\n\n引用初始化是指将类内部的成员变量声明为引用类型，并在构造函数中将其绑定到另一个对象。这意味着类内的引用将直接指向外部对象，而不是持有其拷贝。\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Person {\npublic:\n    std::vector<std::string>& hobbiesRef;  // 引用类型的成员变量\n\n    // 引用初始化：使用成员初始化列表绑定到外部对象\n    Person(std::vector<std::string>& externalHobbies)\n        : hobbiesRef(externalHobbies) { }\n};\n\n```\n\n**解释**\n\n- **成员变量声明**：`std::vector<std::string>& hobbiesRef;` 声明了一个引用类型的成员变量 `hobbiesRef`，它将引用外部的 `std::vector<std::string>` 对象。\n- **引用绑定**：在构造函数中，通过 `: hobbiesRef(externalHobbies)` 将 `hobbiesRef` 绑定到传入的 `externalHobbies` 对象。这意味着 `person2.hobbiesRef` 和 `sharedHobbies` 指向同一个内存位置。\n- **共享数据**：对 `person2.hobbiesRef` 的修改（如添加新爱好）会直接影响到 `sharedHobbies`，因为它们共享相同的数据。\n\n\n\n### 3. 对比\n\n| 特性             | 完全初始化                       | 引用初始化                                         |\n| ---------------- | -------------------------------- | -------------------------------------------------- |\n| **存储方式**     | 存储外部对象的拷贝               | 存储对外部对象的引用                               |\n| **内存使用**     | 额外占用内存用于拷贝             | 不占用额外内存，直接引用外部对象                   |\n| **数据独立性**   | 修改类内成员不会影响外部对象     | 修改类内成员会影响外部对象                         |\n| **生命周期依赖** | 类内成员独立于外部对象的生命周期 | 类内引用的生命周期必须至少与外部对象相同           |\n| **适用场景**     | 需要独立副本时使用               | 需要与外部对象共享数据时使用, 初始情况下不知道容量 |\n\n#### 注意事项\n\n- **引用必须在构造时初始化**：引用类型的成员变量必须在构造函数的初始化列表中绑定到一个对象，不能在构造函数体内赋值。\n\n  > [!NOTE]\n  >\n  > 因为引用类型的对象必须在初始化的时候绑定, 并且只能绑定一次.\n\n  ```cpp\n  // 错误示例：试图在构造函数体内赋值给引用\n  class Person {\n  public:\n      std::vector<std::string>& hobbiesRef;\n      \n      Person(std::vector<std::string>& externalHobbies) {\n          hobbiesRef = externalHobbies; // 错误：引用必须在初始化时绑定\n      }\n  };\n  ```\n\n- **生命周期管理**：使用引用初始化时，必须确保被引用的对象在使用期间是有效的。如果引用的对象被销毁，引用将变为悬空引用，导致未定义行为。\n\n  ```cpp\n  // 危险示例：悬空引用\n  std::vector<std::string> createHobbies() {\n      std::vector<std::string> temp = {\"Temporary\"};\n      Person person(temp);\n      return temp; // temp 被销毁，person.hobbiesRef 悬空\n  }\n  ```\n\n  为了避免这种情况，通常可以使用智能指针（如 `std::shared_ptr` 或 `std::unique_ptr`）来管理对象的生命周期，或者确保引用的对象在使用期间一直有效。\n\n\n\n#### 总结\n\n> [!NOTE]\n>\n> 1. 如果使用 完全初始化 的方式, 类内必须包含另一个类的完整定义(引用头文件);\n>\n> 2. 如果是引用初始化, 可以直接在这个类的内部预先声明另一个类的存在即可.\n>\n>    ```cpp\n>    class A; // 前向声明\n>    class B{\n>      A* ptr;\n>    }\n>    ```\n\n\n\n\n\n---\n\n## Embedded objects\n\n> [!NOTE]\n>\n> - 对于嵌入对象，如果不用初始化列表，就必须有默认构造函数。\n\n\n\n## namespace\n\n### 命名空间的别名\n\n如果 `namespace`过长, 可以将其重新赋值并使用:\n\n```cpp\nnamespace supercalifragilistic {\n\tvoid f();\n}\nnamespace short = supercalifragilistic;\nshort::f();\n```\n\n\n\n### selection\n\n除了直接在一个命名空间内部嵌套其他, 我们也可以在一个命名空间里选择性地使用其他空间的部分函数:\n\n```cpp\nnamespace mine｛\n\tusing orig::Cat;\t // use Cat class from origvoid ×O）；\n\tvoid x()；\n    void y();\n}\n```\n\n\n\n> [!NOTE]\n>\n> 1. **Multiple namespace declarations add to the same namespace.**\n>    也即是说, 多个 `.h`文件内相同的命名空间会自动的视作一个.\n\n\n\n# Inheritance\n\n> [!NOTE]\n>\n> 1. 继承的对象都具有基类的属性, 但是不一定具有访问的权限. \n>    也就是 **Think of inherited traits as an embedded object**\n> 2. 派生类的构造函数中的初始化列表应当包含基类的构造函数.\n> 3. 由于基类的私有成员无法被子类直接访问, 需要让子类调用基类的public的函数, 从而间接访问.\n> 4. 如果子类和父类含有同名的变量, 将会同时存在, 并且可以在子类中声明 `parent_class:A`来访问父类中的属性A.\n> 5. 子类中一定有部分是父类的对象, 并且处于子类的开头(父类必须首先完成初始化).\n\n#### 初始化列表的常用场景\n\n1. 调用基类的构造函数 (否则调用默认构造函数)\n\n   ```cpp\n   class Base {\n   public:\n       Base(int data) { /* ... */ }\n   };\n   \n   class Derived : public Base {\n   public:\n       Derived(int baseVal) : Base(baseVal) { }\n   };\n   ```\n\n2. 初始化嵌入类\n\n   ```cpp\n   class Member {\n   public:\n       Member(const std::string& str) { /* ... */ }\n   };\n   \n   class Container {\n       Member memberObj;\n   public:\n       Container(const std::string& s) : memberObj(s) { }\n   };\n   ```\n\n   > 需要注意的是, 此处的初始化列表中的嵌入类的构造, 变量名不是类名.\n   >\n   > 如果嵌入类不存在默认的构造函数, 那么初始化列表中的显式构造是必要的.\n\n3. 初始化常量成员:\n\n   ```cpp\n   class MyClass {\n       const int constMember;\n   public:\n       MyClass(int val) : constMember(val) { }\n   };\n   ```\n   \n   > const 成员一旦定义，必须立即初始化，且**只能**在初始化列表中完成，不能在构造函数体内赋值。\n\n\n4. 初始化引用成员\n\n   ```cpp\n   class MyClass {\n       int& refMember;\n   public:\n       MyClass(int& ref) : refMember(ref) { }\n   };\n   ```\n   \n   > 引用成员（如 int& ref）必须在初始化时绑定对象，**不能在构造函数体内赋值**，因此也必须使用初始化列表。\n\n\n\n继承: 基于已有的类来设计新的类，新的类的对象可以被当作已有类的对象.\n\n相比于 *composition*  的 `has-a`关系, 继承是 `is-a`的关系.\n\n同义词:\n\n- 父类、超类、基类\n- 派生类、子类\n\n控制基类成员在派生类中的可见性：\n\n- `public`：基类的 `public` 成员在派生类中仍然是 `public`，`protected` 成员仍然是 `protected`。\n- `protected`：基类的 `public` 和 `protected`成员在派生类中都变为 `protected`。\n- `private`：基类的 `public` 和 `protected` 成员在派生类中都变为 `private`。\n\n> [!NOTE]\n>\n> 此时, 仍旧可以通过子类的方法来访问基类的属性或者方法, 但是无法通过子类直接访问基类~!\n>\n> e.g.\n>\n> ```cpp\n> #include <iostream>\n> \n> class Base\n> {\n> public:\n>     void baseFunction()\n>     {\n>         std::cout << \"Base function called.\" << std::endl;\n>     }\n> };\n> \n> class Derived : private Base\n> {\n> public:\n>     void derivedFunction()\n>     {\n>         baseFunction(); // 在子类内部可以访问基类的成员函数\n>     }\n> };\n> \n> int main()\n> {\n>     Derived d;\n>     d.baseFunction();    // 错误：无法从子类外部访问基类的成员函数\n>     d.derivedFunction(); // 可以调用子类的函数，该函数内部调用了基类的函数\n>     return 0;\n> }\n> ```\n\n\n\n\n\n\n\nclint class 表示这个类要使用另一个类(中的public).\n\n\n\n子类的对象也可以认为是父类的对象。子类不能访问父类的私有变量，但私有变量存在于这个类中\n\n\n\n当调用构造函数时，我们不能调用父类的私有变量，只能用初始化列表的方式调用父类的构造函数。\n\n\n\n赋值的运算符不会被继承:\n\n#### 赋值运算符\n\n赋值运算符是这样形式的方法:\n\n```cpp\nPoint &operator=(const Point &other)\n{\n    cout << \"Point::operator= 被调用\" << endl;\n    if (this != &other)\n    {\n        x = other.x;\n        y = other.y;\n    }\n    return *this;\n}\n```\n\n当我们如此赋值的时候就会发生上述的调用:\n\n```cpp\nPoint p1(1,2);\nPoint p2(3,4);\n\np1 = p2;\n```\n\n可见, 赋值运算符通过引用快速地将右值中的属性赋值给左侧的目标.\n\n但是父类的赋值运算符只会确保自身的属性能够被赋值, 无法确保子类自身的属性可以被正确设置. 因此, 为了安全性, CPP不允许子类自动继承父类的赋值运算符.\n\n> [!NOTE]\n>\n> 然而, 编译器可能为子类自动生成一个赋值运算符.\n>\n> e.g.\n>\n> ```cpp\n> class Point\n> {\n> public:\n>     int x, y;\n>     Point(int x = 0, int y = 0) : x(x), y(y) {}\n> \n>     // 自定义赋值运算符\n>     Point &operator=(const Point &other)\n>     {\n>         cout << \"Point::operator= 被调用\" << endl;\n>         if (this != &other)\n>         {\n>             x = other.x;\n>             y = other.y;\n>         }\n>         return *this;\n>     }\n> };\n> \n> class ColoredPoint : public Point\n> {\n> public:\n>     string color;\n>     ColoredPoint(int x = 0, int y = 0, string color = \"white\") : Point(x, y), color(color) {}\n> \n>     void print() const\n>     {\n>         cout << \"x:\" << x << \", y:\" << y << \", color:\" << color << endl;\n>     }\n> };\n> \n> int main()\n> {\n>     ColoredPoint cp1(1, 2, \"red\");\n>     cp1.print();\n>     ColoredPoint cp2(3, 4, \"blue\");\n>     cp2.print();\n>     cp1 = cp2;\n>     cp1.print();\n> }\n> \n> ```\n>\n> **输出结果**:\n>\n> ```cpp\n> x:1, y:2, color:red\n> x:3, y:4, color:blue\n> Point::operator= 被调用\n> x:3, y:4, color:blue\n> ```\n>\n> 可见, 父类的赋值运算符也被自动地调用了, 这是因为编译器为子类自动生成了一份.\n\n\n\n---\n\n父类的构造是在子类的构造之前。\n\n\n\n### `using`声明\n\n#### 将基类的函数派生使用\n\n必须使用 `using <parentClass>:: func`的方式, 无法忽略 `using`.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base{\n  public: \n  \tvoid f(double){\n      cout << \"double\\n\" << endl;\n    }\n};\n\nclass Derived : Base{\n  public:\n  \tusing Base::f; // 将基类中的私有函数本地使用\n  \tvoid f(int){\n      cout << \"int\\n\"<<endl;\n    }\n};\n\n\nint main() {\n    Derived d;\n    d.f(4);\n    d.f(4.5);\n}\n```\n\n**Output:**\n\n```cpp\nint \n\ndouble\n```\n\n\n\n#### 默认参数值无法通过重载传递\n\n在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免**多重继承时参数值产生冲突或二义性**。默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.\n\n> 如果你在派生类中**重新声明或重载了基类的函数**，那么你不能获得默认参数值，必须通过多个重载模拟默认参数功能.\n\n```cpp\nclass A {\npublic:\n    void f(int a = 3, double b = 2.0);\n};\n\nclass B : public A {\npublic:\n    using A::f;         // ✅ 此时默认参数仍可见\n    void f(int a);      // ❌ 重载后，这个版本没有默认参数\n};\n```\n\n\n\n> 但是使用 `using`声明的父类函数可以获得默认参数值.\n\ne.g.\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass A\n{\npublic:\n    void f(int a = 3, double b = 2.0)\n    {\n        std::cout << \"A::f(\" << a << \", \" << b << \")\" << std::endl;\n    }\n};\n\nclass B : public A\n{\npublic:\n    using A::f; // 继承 A::f 到 B 中\n};\n\nint main()\n{\n    B b;\n    b.f();        // ✅ 是否等价于 f(3, 2.0)？\n    b.f(10);      // ✅ 是否等价于 f(10, 2.0)？\n    b.f(10, 5.5); // ✅ 正常调用\n}\n\n```\n\n- 输出:\n\n  ```cpp\n  A::f(3, 2)\n  A::f(10, 2)\n  A::f(10, 5.5)\n  ```\n\n\n\n#### 解决重写函数的重载问题\n\n子类重新定义 (`override`重写) 了父类的某个函数，就会把父类中对应 `overloaded` 的函数覆盖:\n\n```cpp\n#include <iostream>\n\nclass Base\n{\npublic:\n    // 基类中的重载函数\n    void display(int x)\n    {\n        std::cout << \"Base display(int): \" << x << std::endl;\n    }\n\n    void display(double x)\n    {\n        std::cout << \"Base display(double): \" << x << std::endl;\n    }\n};\n\nclass Derived : public Base\n{\npublic:\n    // 子类重新定义了基类的 display(int)\n    void display(int x)\n    {\n        std::cout << \"Derived display(int): \" << x << std::endl;\n    }\n    using Base::display;\n};\n\nint main()\n{\n    Derived d;\n    d.display(5); // 调用 Derived 的 display(int)\n\n    d.Base::display(5.5); // 或者d.display(5.5);\n    return 0;\n}\n```\n\n> - 注意, CPP中的浮点数可以隐式转换为整型.\n>\n>   - 当将一个浮点数赋值给一个整型变量时，编译器会执行**隐式转换**，将浮点数的值转换为整型。这种转换通常涉及**截断**（truncation），即去掉小数部分，只保留整数部分.\n>\n> - 可以通过 `using `声明重新引入基类中的重载函数: \n>\n>   ```cpp\n>   using Base::display;\n>   ```\n>\n\n\n\n---\n\n# Polymorphism\n\n#### 补充\n\n1. 成员函数（无论是虚函数还是非虚函数）本身不占用类对象的内存空间，因为它们的代码存储在程序的代码段中。只有**成员变量和虚表指针**（如果有虚函数）会占用对象的内存空间:\n\n   ```cpp\n   class A {\n       int i;\n       void f();\n   };\n   ```\n\n   此时的 `sizeof(A)`为4字节.\n\n2. 虚函数指针的大小一般是 <u>8字节</u>. 如果结构体内部存在虚函数指针, 就需要对齐为8字节的倍数.\n\n3. 因为子类的构造在父类的构造之后, 也就是每一个子类对象的前部分都是父类对象. 因此, 我们可以将一个子类对象的指针赋值给父类对象, 只要忽视后续数据结构即可.\n\n4. <u>多态变量</u>: 指向子类对象的基类指针/引用.\n\n5. 如果类内不存在任何成员变量, 它的对象依旧占用 `1` 个字节的空间.\n\n6. 如果一个类将来可能具有子类, 就让其析构函数设置为 `virtual`. —— 任何的类都应该设置它的析构为 `virtual`.\n\n   ```cpp\n   class B: public A{};\n   \n   A* p = new B();\n   delete p;\n   ```\n\n   如果 A 的析构函数不是virtual的, 那么编译器只会调用A的析构函数.\n\n7. 如果父类的构造函数中调用了 `virtual` 的函数, 那么实际上还是调用自己的函数(静态绑定)\n\n   1. 这是因为, 创建一个派生类的对象时, 首先调用父类的构造函数, 然后执行派生类的构造函数;\n   2. 此时, 子类的成员还没有初始化, 父类无法调用其重写版本, 也就无法实现多态.\n\n8. > [!NOTE]\n   >\n   > 深刻理解什么叫做多态! 也就是子类对象的引用或者指针赋值给了父类! 此后调用这个对象时, 虚函数是动态绑定到子类的!\n   >\n   > ```c++\n   > A &ra = b;    // ra是A类型的引用，但指向B类型的对象\n   > ra.f();       // 虽然ra是A类型的引用，但f()会调用B::f()\n   > ```\n\n9. 如果B是A的子类:\n\n   ```c++\n   A *p1 = new B(3);    // p1是A类型的指针，但指向B类型的对象\n   ```\n\n   实际上,  p1指向的对象是B类的对象\n\n\n\n\n\n\n当一个被重写的函数在 Derived::func() 中通过 Base::func() 调用其基类版本时，会发生什么？\n\n- 可以正常调用, 这也正是重写存在的意义——扩充原来的功能, 同时保留.\n\n\n\n- 多态与返回对象类型:\n\n  - 允许重载返回自身的 <u>指针</u> 与 <u>引用</u>, 但是不支持直接返回自身的类型:\n\n  - i.e. \n\n    ```cpp\n    Class Expr｛\n    public:\n      virtual Expr* newExpr （）；\n      virtual Expr& clone （）；\n      virtual Expr Expr self（）；\n    ｝；\n    \n    class BinaryExpr ： public Expr ｛\n    public：\n      virtual BinaryExpr* newExpr （）； //Ok\n      virtual BinaryExpr& clone （）； // Ok\n      virtual BinaryExpr self（）；// Error！\n      ｝；\n    ```\n\n  - 原因: 指针和引用的大小固定, 编译时刻可以确定调用时候所需的空间, 如果按照类型返回, 由于多态的动态绑定是运行时决定调用对应的方法, 所以编译的时候caller不知道要在栈上预留多少的空间.\n\n\n\n\n\n---\n\n- Polymorphism\n  - virtual functions and override\n  - abstract functions and classes\n- Multiple Inheritance\n\n\n\n由于子类具有父类的所有属性, 因此我们可以将一个子类对象看作父类的对象, 并进行对应的操作.\n\n将子类对象看作父类对象的操作, 叫做 <u>upcast</u>. 具体是说, 将子类的指针或者引用赋值给基类的对象.\n\n\n\n现在的问题是, 如果采取传统的继承+重写的方式, 我们在子类内部采取重写父类方法, 可能导致 `静态绑定` static binding:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Animal\n{\npublic:\n    void speak()\n    {\n        cout << \"Animal speaks\" << endl;\n    }\n};\n\nclass Dog : public Animal\n{\npublic:\n    void speak()\n    {\n        cout << \"Dog barks\" << endl;\n    }\n};\n\nint main()\n{\n    Animal *animal = new Dog(); // 注意：父类指针指向子类对象\n    animal->speak();            // 会调用哪个？\n    delete animal;\n    return 0;\n}\n```\n\n- 输出:\n\n  ```cpp\n  Animal speaks\n  ```\n\n\n\n为了解决上述的问题, 我们引入 <u>虚函数</u> 的概念.\n\n## 虚函数\n\n虚函数可以实现 **运行时多态**. 所谓多态, 就是静态+ 动态的绑定.\n\n通过在父类的函数前加上 `virtual`的声明, 我们将其定义为虚函数\n\ne.g.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void speak() {\n        cout << \"Animal speaks\" << endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void speak() override {\n        cout << \"Dog barks\" << endl;\n    }\n};\n\nint main() {\n    Animal* animal = new Dog(); \n    animal->speak(); // 这次会调用哪个？\n    delete animal;\n    return 0;\n}\n```\n\n- 输出:\n\n  ```cpp\n  Dog barks\n  ```\n\n> - `override`声明明确这个函数是重写父类的虚函数, 可以让编译器检查是否存在错误.\n> - 但是上述的关键字也不是必须的.\n\n\n\n### 纯虚函数\n\n~指的是需要强制派生类去实现的函数:\n\n```cpp\nvirtual 返回类型 函数名(...) = 0;\n```\n\n\n\n### 虚函数表\n\n- 定义: 虚函数表（virtual table）是 C++ 为了实现**运行时多态**而采用的一种底层技术手段;\n- 本质:\n  - `vtable`是一个函数指针数组;\n  - 每个类都有自己的vtable\n  - 对象中存在一个隐藏的指针 `vptr`, 指向该类的vtable\n\n#### 内存示意图\n\n假设有如下结构:\n\n```cpp\nclass Base {\npublic:\n    int a;\n    virtual void func();\n};\n```\n\n内存布局的伪结构如下:\n\n```cpp\n+-------------------------+\n| vptr  → 指向vtable     |  ←隐藏成员\n+-------------------------+\n| a : int                |  ←显式成员\n+-------------------------+\n\nvtable (Base):\n[ func 的地址 ]\n\nvtable (Derived):\n[ 重写的 func 的地址 ]\n```\n\n\n\n#### 拓展说明\n\n- vtable是类级别的, 所有该类的对象共享一个vtable;\n- vptr是对象级别的, 隐含于各个对象当中.\n- 如果类没有虚函数, 就不存在上述的~\n\n\n\n## 抽象类\n\n如果一个类中包含至少一个纯虚函数, 那么这个类就是一个抽象类.\n\n抽象类无法被实例化, **只能用来作为基类.**\n\n### 使用抽象类定义接口\n\n用图形绘制的例子来说明抽象类和纯虚函数的使用:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 抽象类\nclass Shape {\npublic:\n    // 纯虚函数，子类必须实现\n    virtual void draw() = 0;\n};\n\n// 派生类：Circle\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        cout << \"Drawing Circle\" << endl;\n    }\n};\n\n// 派生类：Rectangle\nclass Rectangle : public Shape {\npublic:\n    void draw() override {\n        cout << \"Drawing Rectangle\" << endl;\n    }\n};\n\n// 渲染函数：面向抽象类编程\nvoid render(Shape* shape) {\n    shape->draw();\n}\n\nint main() {\n    Circle c;\n    Rectangle r;\n\n    render(&c); // Drawing Circle\n    render(&r); // Drawing Rectangle\n\n    return 0;\n}\n```\n\n\n\n### 继承链\n\n一个抽象类可以有多个纯虚函数, 此时继承的子类可能没有完全实现. \n\n子类的子类, 也就是在继承链上完成了所有纯虚函数的定义的 最末一级的派生类, 才可以被实例化.\n\n```cpp\nclass Animal {\npublic:\n    virtual void speak() = 0;\n    virtual void run() = 0;\n    \n    void breathe() {\n        cout << \"Breathing...\" << endl;\n    }\n};\n```\n\n\n\n## 虚析构函数 \n\n**virtual destructor**: 虚析构函数\n\n同样的, 虚析构函数的作用体现在 `upcast`, 也就是将子类的指针或引用转换为父类的指针或引用的过程. 此时, 如果父类的析构函数不是虚函数, 就会让向上转型之后的对象在析构时调用父类的析构函数.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\npublic:\n    ~Base()\n    {\n        cout << \"Base Destructor\" << endl;\n    }\n};\n\nclass Derived : public Base\n{\npublic:\n    ~Derived()\n    {\n        cout << \"Derived Destructor\" << endl;\n    }\n};\n\nint main()\n{\n    Base *obj = new Derived();\n    delete obj; // 注意这里！\n    return 0;\n}\n```\n\n此时会输出 :  `Base Destructor` , 也就是调用了父类的析构函数.\n\n这是十分危险的, 特别是我们需要确保子类的所有资源都被安全地释放.\n\n因此, 我们可以将父类的析构函数也设置为虚函数:\n\n```cpp\nclass Base {\npublic:\n    virtual ~Base() {\n        cout << \"Base Destructor\" << endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    ~Derived() {\n        cout << \"Derived Destructor\" << endl;\n    }\n};\n```\n\n此时的输出:\n\n```cpp\nDerived Destructor  \nBase Destructor\n```\n\n> 先后调用子类和父类的析构函数.\n\n\n\n## 接口类\n\n> 也被称为 <u>协议类</u>. 其实就像 `swift`的协议一样, 强制要求继承的子类定义某些函数实现.\n\n- 含义:\n  - 只定义接口, 不提供实现的抽象类\n  - 所有的成员函数都是纯虚函数;\n  - 一般不包含任何数据成员.\n\ne.g.\n\n```cpp\nclass Printable {\npublic:\n    virtual void print() = 0;\n    virtual ~Printable() = default; // 记得虚析构函数\n};\n\nclass Document : public Printable {\npublic:\n    void print() override {\n        cout << \"Printing Document\" << endl;\n    }\n};\n```\n\n\n\n## 多重继承\n\n多重继承 *multiple inheritance* 指的是一个类继承自多个基类.\n\ne.g.\n\n```cpp\nclass A {\npublic:\n    void sayA() { cout << \"I am A\" << endl; }\n};\n\nclass B {\npublic:\n    void sayB() { cout << \"I am B\" << endl; }\n};\n\nclass C : public A, public B {\n    // 继承了 A 和 B 的成员\n};\n```\n\n可以将多个类的功能整合到一个类中:\n\n```cpp\nC c;\nc.sayA(); // OK\nc.sayB(); // OK\n```\n\n\n\n### 菱形继承\n\n多重继承中的特例:\n\n```cpp\nclass A {\npublic:\n    int value;\n};\n\nclass B : public A {};\nclass C : public A {};\nclass D : public B, public C {};\n```\n\n继承结构看上去就像菱形:\n\n```cpp\n     A\n   /   \\\n  B     C\n   \\   /\n     D\n```\n\n如果我们直接使用D类:\n\n```cpp\nD d;\nd.value = 10; // ❌ 编译错误：'value' is ambiguous\n```\n\n这是因为D继承自B和C, 而后者又各自具有自己的A子对象. 导致了二义性的问题.\n\n> [!NOTE]\n>\n> 注意此处的二义性的问题, 来自于在D类对象中直接访问A类对象的成员变量!  什么时候产生二义性? 就是判断此时是否存在多个相同名称的变量.\n\n\n\n### 虚继承\n\nC++ 提供了一个机制：**虚继承（virtual inheritance）**，来解决上述问题:\n\n```cpp\nclass B : virtual public A{};\nclass C : virtual public B{};\nclass D :  public B, public C{}\n```\n\n此时, D中只有一个共享的A子对象.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n    int value;\n    void ptr()\n    {\n        cout << \"value: \" << value << endl;\n    }\n};\nclass B : virtual public A {};\nclass C : virtual public A {};\nclass D : public B, public C {};\n\nint main()\n{\n    D d;\n    d.value = 10; // ✅ OK，只有一个 A，二义性消除\n    d.ptr();\n}\n```\n\n此时, B,C不再具有自己的A.\n\n\n\n> [!NOTE]\n>\n> 由于虚继承带来的是“共享”的基类对象，所以：\n>\n> - 虚基类的构造 **必须由最底层派生类负责**\n> - 派生类的构造函数中要**显式初始化**虚基类\n\n\n\n# Copy and Move\n\n#### 补充\n\n- `vptr`只会初始化一次, 然后保持不变. 发生在构造函数的第一步.\n- 循环内部执行构造和析构时, 作用的地址是同一块. 此时将对象的地址传入到vector of `*` 时, 得到的是相同的地址;\n  - 为了避免上述的情况, 我们在循环内部的构造, 需要为对象直接 `new` 一个新的空间.\n\n- `std::move`的作用就是告诉编译器: 这个类型是右值引用, 需要使用移动语义.\n\n\n\n\n\n## C++中的拷贝构造与移动语义\n\n### 拷贝构造函数基础\n\n拷贝构造函数是创建新对象的一种方式，它从现有对象复制数据来初始化新对象。\n\n- 拷贝构造函数的签名：`T::T(const T&)`\n- 如果不提供拷贝构造函数，C++会自动生成一个默认的拷贝构造函数\n- 默认拷贝构造函数执行的是成员级别的拷贝（memberwise copy），而非位级别的拷贝（bitwise copy）\n  - 对于基本类型成员，直接复制值\n  - 对于对象类型成员，调用其拷贝构造函数\n  - **<u>对于指针类型成员</u>**，只复制指针值（浅拷贝），导致两个对象共享同一块内存\n\n### 拷贝构造函数的调用时机\n\n拷贝构造函数在以下情况下会被调用：\n\n1. **按值传递参数时**：当对象作为参数按值传递给函数时\n   \n   ```cpp\n   void func(MyClass obj); // 调用时会触发拷贝构造\n   ```\n   \n2. **对象初始化时**：\n   \n   ```cpp\n   MyClass a;\n   MyClass b = a;    // 初始化，调用拷贝构造函数\n   MyClass c(a);     // 初始化，调用拷贝构造函数\n   ```\n   \n3. **函数返回对象时**：\n   \n   ```cpp\n   MyClass func() {\n       MyClass obj;\n       return obj;   // 可能触发拷贝构造（取决于编译器优化）\n   }\n   ```\n\n\n\n### 拷贝构造函数的最佳实践\n\n- 显式定义拷贝构造函数，不要依赖默认版本\n- 如果类不需要被复制，可以声明私有的拷贝构造函数（不需要定义）\n- 如果类包含指针成员，必须实现<u>深拷贝</u>的拷贝构造函数\n\n#### 深拷贝构造函数\n\n将拷贝的值另外寻找新的内存空间, 而不是指向同一处地址.\n\n- 如果没有显式定义深拷贝构造函数, 观察下面的代码:\n\n```cpp\nStringHolder original(\"Hello World\");\n\n{\n    StringHolder copy = original; // 调用拷贝构造函数\n    std::cout << \"copy包含: \" << copy.getString() << std::endl;\n\n    // 修改copy，如果是浅拷贝，也会影响original\n    copy.setString(\"Modified\");\n    std::cout << \"修改后，copy包含: \" << copy.getString() << std::endl;\n    std::cout << \"修改后，original包含: \" << original.getString() << std::endl;\n\n    // copy在此作用域结束时被销毁\n}\n```\n\n> - `original`的层级在  `copy` 的外面;\n>\n> - 在代码块的内部, 通过浅拷贝构造, 两者的数据共享一个内存空间;\n>\n> - 二者先后析构, 导致 `double free`的问题!\n>\n>   ```bash\n>   02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: Double free of object 0x11f6060c0\n>   02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: *** set a breakpoint in malloc_error_break to debug\n>   ```\n\n\n\n由此, 我们需要如此定义:\n\n```cpp\nclass StringHolder\n{\nprivate:\n    char *data;\n\npublic:\n    // 构造函数\n    StringHolder(const char *str)\n    {\n        if (str)\n        {\n            data = new char[strlen(str) + 1];\n            strcpy(data, str);\n            std::cout << \"构造函数: 为\\\"\" << data << \"\\\"分配内存\" << std::endl;\n        }\n        else\n        {\n            data = nullptr;\n            std::cout << \"构造函数: 创建空字符串\" << std::endl;\n        }\n    }\n\n    // 自定义拷贝构造函数（深拷贝）\n    // 如果复制掉这部分的自定义, 将会调用默认的浅拷贝构造函数, 导致问题:浅拷贝的指针两次释放内存\n    StringHolder(const StringHolder &other)\n    {\n        if (other.data)\n        {\n            data = new char[strlen(other.data) + 1];\n            strcpy(data, other.data);\n            std::cout << \"深拷贝构造函数: 为\\\"\" << data << \"\\\"分配新内存\" << std::endl;\n        }\n        else\n        {\n            data = nullptr;\n            std::cout << \"深拷贝构造函数: 复制空字符串\" << std::endl;\n        }\n    }\n\n    // 析构函数\n    ~StringHolder()\n    {\n        std::cout << \"析构函数: 释放\\\"\" << (data ? data : \"nullptr\") << \"\\\"的内存\" << std::endl;\n        delete[] data;\n    }\n};\n\n```\n\n这样就可以避免上面的问题.\n\n\n\n\n\n### 函数参数和返回值的选择\n\n- **传入参数**：\n  - 按值传递：`void func(Student s)` - 创建新对象，适用于需要存储对象的情况\n    - 如果对象内部的属性存在指针类型的属性, 为了避免浅拷贝, 就需要自定义一个深拷贝构造函数.\n  - 常量引用：`void func(const Student& s)` - 不创建新对象，适用于<u>只读取值</u>的情况\n  - 指针/引用：`void func(Student* s)` 或 `void func(Student& s)` - 适用于需要<u>修改对象</u>的情况\n  \n- **返回值**：\n  - 按值返回：`Student func()` - 返回新创建的对象\n  - 返回指针：`Student* func()` - 注意内存管理问题\n  - 返回引用：`Student& func()` - 注意生命周期问题\n\n## 右值引用与移动语义\n\n#### 左值与右值\n- **左值**：可以出现在赋值号左边的表达式\n  - 变量名、引用\n  - 解引用操作符（*）和下标操作符（[]）的结果\n- **右值**：只能出现在赋值号右边的表达式\n  - 字面量\n  - 表达式结果\n  - 函数返回的临时对象\n\n#### 右值引用\n- 使用 `&&` 声明\n- 可以绑定到右值，延长其生命周期\n- 右值引用变量本身是左值\n- 可以使用 `std::move()` 将左值转换为右值引用\n\n```cpp\nint x = 10;\nint&& rx = x * 2;  // 绑定右值\nrx = 100;          // rx本身是左值，可以被赋值\n```\n\n- 两种可以同时输入左值和右值引用作为参数的方法:\n\n  - 重载\n\n    ```cpp\n    // 重载函数，分别处理左值和右值\n    void process(int& x) {\n        std::cout << \"重载函数 - 处理左值: \" << x << std::endl;\n    }\n    \n    void process(int&& x) {\n        std::cout << \"重载函数 - 处理右值: \" << x << std::endl;\n    }\n    ```\n\n  - `const int& x `\n\n    ```cpp\n    // 接受const左值引用的函数（可以接受左值和右值）\n    void processAny(const int& x) {\n        std::cout << \"处理任意值: \" << x << std::endl;\n    }\n    ```\n\n\n\n\n\n#### 移动构造函数\n\n- 签名：`T::T(T&& other)`, 也就是**将右值引用作为参数的构造函数**\n- 用于\"窃取\"即将销毁的对象的资源，避免不必要的深拷贝\n- 通常将源对象的指针成员置为`nullptr`，防止资源被错误释放\n\n```cpp\nMyClass(MyClass&& other) : \n    ptr{other.ptr} {\n      other.data = 0\n      other.ptr = nullptr;  // 防止源对象析构时释放内存\n}\n```\n\n- 与浅拷贝类似, 但是需要在内部将源对象的指针成员 设置为 `nullptr` , 其他成员设置为有效但是为空的状态\n\n\n\n 标准库容器（如 std::vector）在进行元素移动时会优先选择不会抛异常的移动构造函数，否则会退而求其次选择拷贝构造函数（更慢）。\n\ne.g.\n\n```cpp\nstd::vector<DynamicArray> vec;\nvec.push_back(DynamicArray(5));\n```\n\n> 在这个 push_back 中，如果 DynamicArray 的移动构造函数被标记为 `noexcept`，那么 vector 会使用移动构造（高效）。\n\n\n\n\n\n## 初始化方式\n\nC++11提供了多种初始化对象的方式：\n\n- **小括号初始化**：`MyClass obj(arg1, arg2);`\n- **等号初始化**：`MyClass obj = value;`\n- **大括号初始化**（统一初始化）：`MyClass obj{arg1, arg2};`\n- **列表初始化**：\n  \n  ```cpp\n  int arr[] = {1, 2, 3};\n  MyClass* ptr = new MyClass{arg1, arg2};\n  ```\n\n#### 基本类型的初始化\n\n```cpp\n// 基本类型的初始化方式\nint a = 10;             // 等号初始化\nint b(20);              // 小括号初始化\nint c{30};              // 大括号初始化（C++11）\nint d = {40};           // 等号+大括号初始化（C++11）\nint arr1[] = {1, 2, 3}; // 数组初始化\nint arr2[]{4, 5, 6};    // 数组大括号初始化（C++11）\n```\n\n\n\n#### 对象的初始化\n\n```cpp\n// 对象的初始化方式\nPerson p1(\"张三\", 25);          // 小括号初始化\nPerson p2 = Person(\"李四\", 30); // 等号+临时对象初始化\nPerson p3{\"王五\", 35};          // 大括号初始化（C++11）\nPerson p4 = {\"赵六\", 40};       // 等号+大括号初始化（C++11）\n```\n\n\n\n- 动态分配对象的初始化\n\n  ```cpp\n  // 动态分配对象的初始化方式\n  Person *pp1 = new Person(\"动态张三\", 25); // 传统new\n  Person *pp2 = new Person{\"动态李四\", 30}; // 大括号初始化（C++11）\n  ```\n\n\n\n### 深拷贝与浅拷贝\n\n- **浅拷贝**：默认拷贝构造函数执行的是浅拷贝，只复制指针值，不复制指针指向的内容\n- **深拷贝**：自定义拷贝构造函数可以实现深拷贝，为指针成员分配新内存并复制内容\n\n### 何时使用移动语义\n\n- 类包含动态分配的资源（如指针成员）\n- 对象需要在函数间传递\n- 需要避免不必要的深拷贝操作\n- 使用容器时（如`std::vector`、`std::string`等）\n  - `move`会将一个左值变成右值引用, 从而允许调用移动构造函数!\n  - 使用 `move` 时, 如果存在对应的移动构造函数, 就会优先调用;\n  - 数组的 `push_back`也是如此, 优先调用移动构造函数\n    - 但是我们可以使用 `emplace`来继续优化上述的效率问题——直接将对象存储到数组的末端.\n\n\n\n\n### 总结\n\n- 拷贝构造函数用于创建对象的副本，深拷贝需要自定义实现\n- 移动语义通过右值引用实现**资源的高效转移**，避免不必要的拷贝, 同时**规避了浅拷贝导致的 double free** 的问题.\n- 根据需要选择合适的参数传递和返回值方式\n- 使用`std::move()`可以将左值转换为右值引用，触发移动语义\n\n\n\n---\n\n\n\n# Overloaded Operators\n\n#### 补充\n\n自定义类型的方向转换:  *T* ==> *C*\n\n- 当下面情况存在一种时, 可以发生上述的转换:\n\n  1. C存在以 *T* 作为输入参数的构造函数;\n\n  2. *T* 存在 `operator C(){ }`的成员函数.\n     e.g.\n\n     ```cpp\n     class Rational {\n     public:\n         operator double() const {  // Rational到double的转换\n             return numerator_ / (double)denominator_;\n         }\n     };\n     \n     Rational r(1, 3);\n     double d = r;  // 隐式转换：r => double\n     ```\n\n- 不同同时存在两者的转换(编译器无法知道采取什么方式)\n\n\n\n题目:\n\n- 并非所有运算符都可以用三种方式重载。例如赋值运算符 =、下标运算符 []、函数调用运算符 ()、成员访问运算符 -> **只能**作为成员函数重载;\n\n- 流提取符 >> 和插入符 << 可以被重载\n\n- 运算符 `+` 返回的类型 **不一定** 要与参数类型一致;\n\n- 对于友元函数, 在声明处加上 `friend`标识, 但是在定义处是没有这个标识的. \n\n- > [!NOTE]\n  >\n  > 无法被重载的运算符:\n  >\n  > - 条件运算符: ` ?: `\n  > - 成员指针访问运算符: `.*` \n\n  `new`是可以重载的!\n\n- 运算符的分类:\n\n  - 成员运算符: 在类内部以成员函数形式重载的运算符 ==> 具有隐式的 `this`;\n\n  - 友元运算符: 定义在类外部（在类内部用 `friend` 声明），没有 `this` 指针.\n\n    因此, 一个重载函数只有一个参数时 ==> 二员成员运算符 / 一元友元运算符.\n\n\n\n\n\n\n\n- 隐式转换的尝试是从左到右的:\n  - `1+a`会尝试将类的对象 `a` 尝试转换为int类型.\n\n- 注意类型:\n\n  ```cpp\n  // 前缀++\n  const Integer& Integer::operator++() {\n      *this += 1;  // 先增加\n      return *this;  // 再返回\n  }\n  \n  // 后缀++（参数int未使用，仅用于区分）\n  const Integer Integer::operator++(int) {\n      Integer old(*this);  // 先保存\n      ++(*this);  // 再增加\n      return old;  // 返回旧值\n  }\n  ```\n\n  前缀++的返回是 `&` 类型, 因为比较节省空间和时间. 后缀++的返回是值.\n\n  - `[]` 的返回必须是 `&` 类型, 这样可以作为左值赋值.\n\n\n\n返回类型设计的**总体原则**：\n\n1. 如果运算符需要作为左值（可以出现在赋值左侧），返回非常量引用。\n   1. 否则, 声明为`const`类型, 避免成为左值.\n\n2. 如果运算符创建新对象，返回值（通常是常量值）。\n3. 如果运算符返回布尔结果，直接返回 `bool` 类型。\n4. 如果需要支持链式操作，返回引用。\n\n\n\n全局和成员函数的设计思路:\n\n1. 一元运算符（如 `-a`）应该用**成员函数**，因为只操作一个对象\n2. 赋值相关运算符（`=`, `+=`, `[]`, `->()`与 `->*` 等）必须是成员函数，因为它们需要修改对象状态\n3. 对于二元运算符（如 `+`, `-`, `*`, `/`)建议使用**全局函数**，因为：\n   - 支持操作数的对称转换\n   - 更好地支持与其他类型的互操作\n   - 保持了运算符的自然语义（如 `3 * x` 和 `x * 3` 应该都能工作）\n\n\n\n## C++运算符重载基础\n\n运算符重载是C++的一项强大特性，它允许用户定义的类型像内置类型一样使用各种运算符。本质上，运算符重载是函数调用的另一种形式。\n\n### 可重载与不可重载的运算符\n\nC++允许重载大多数运算符，但以下**运算符不能被重载**：\n\n- `.` (成员访问运算符)\n- `.*` (成员指针访问运算符)\n- `::` (作用域解析运算符)\n- `?:` (条件运算符)\n- `sizeof` (获取类型大小)\n- `typeid` (获取类型信息)\n- 类型转换运算符 (`static_cast`, `dynamic_cast`, `const_cast`, `reinterpret_cast`)\n\n### 运算符重载的限制\n\n1. **只能重载已存在的运算符**\n   - 不能创建新的运算符（如Python中的`**`）\n   - 可以改变运算符的语义（如重载`+`实现减法），但不推荐\n\n2. **运算符必须在类或枚举类型上重载**\n   - 至少有一个操作数必须是用户定义类型\n\n3. **必须保持操作数数量**\n   - 如二元运算符`/`重载后仍必须是二元的\n\n4. **必须保持优先级和结合律**\n   - 运算符的优先级和结合律是固定的，不能被改变\n\n## 运算符重载的实现方式\n\n运算符重载本质上是一个以`operator`关键字为前缀，后跟运算符的特殊函数。\n\n### 成员函数方式\n\n作为类的成员函数实现运算符重载时：\n\n- 第一个操作数（左操作数）隐式为`this`指针\n- 不对接收者（左操作数）执行类型转换\n\n```cpp\nclass A {\npublic:\n    A(int ii) : i(ii) {}\n    int get() { return i; }\n    \n    // 重载+运算符，返回新对象\n    const A operator+(const A& that) const {\n        A c(this->i + that.i);\n        return c;\n    }\nprivate:\n    int i;\n};\n```\n\n使用成员函数重载时，左操作数必须是该类的对象：\n\n- `a + b` 可行（a是A类对象）\n- `a + 9` 可行（9会被隐式转换为A类对象）\n- `9 + a` 不可行（9不是A类对象）\n\n\n\n\n\n> [!NOTE]\n>\n> 隐式转换: 编译器查找是否存在从给出参数作为构造函数的输入, 从而创建一个指定对象的方式:\n>\n> e.g.\n>\n> ```cpp\n> Integer h = a + 7; // 7被隐式转换为Integer\n> ```\n>\n> 上述发生的前提条件是 类 `Integer` 存在对应的构造函数:\n>\n> ```cpp\n> Integer(int val = 0) : value(val)\n> ```\n\n\n\n\n\n\n\n### 全局函数方式\n\n作为全局函数实现运算符重载时：\n\n- 所有操作数都是显式参数\n- 开发者不需要特殊访问类的权限\n- 可能需要声明为友元函数以访问私有成员\n\n```cpp\nclass Integer{\nprivate:\n  int value;\n\n  friend const Integer operator*(const Integer &left, const Integer& right);\n};\n\n// 可以直接在全局函数中访问私有成员\nconst Integer operator*(const Integer &left, const Integer &right)\n{\n    std::cout << \"调用全局函数*运算符: \" << left.value << \" * \" << right.value << std::endl;\n    return Integer(left.value * right.value);\n}\n```\n\n\n\n当然, 全局函数实现的运算符重载, 可以通过调用类的public中的函数接口, 来间接访问内部的私有成员变量:\n\n```cpp\nclass Integer{\n  public: \n  int getValue(){\n    return value;\n  }\n};\n\n// 通过public接口访问内部的私有成员变量.\nconst Integer operator/(const Integer &left, const Integer &right)\n{\n    std::cout << \"调用全局函数/运算符: \" << left.getValue() << \" / \" << right.getValue() << std::endl;\n    if (right.getValue() == 0)\n    {\n        std::cerr << \"错误: 除数不能为零\" << std::endl;\n        return Integer(0);\n    }\n    return Integer(left.getValue() / right.getValue());\n}\n```\n\n\n\n使用全局函数重载时，可以处理左操作数不是该类对象的情况：\n\n- `9 - b` 可行（9会被隐式转换为A类对象）\n- 因为两个操作数都是普通参数，地位平等, 体现了运算符的对称性\n\n\n\n\n\n### 成员函数vs全局函数的选择\n\n- **一元运算符**应该作为成员函数\n- **赋值运算符**（`=`, `()`, `[]`, `->`, `->`）必须是成员函数\n- 其他**二元运算符**最好作为非成员函数（全局函数）\n\n## 参数传递与返回类型\n\n### 参数传递\n\n1. 对于只读参数，使用`const`引用传递（除了内置类型）\n2. 对于不修改对象的成员函数，声明为`const`\n3. 对于全局函数，如果左操作数会被修改，使用引用传递\n\n### 返回类型\n\n根据运算符的预期含义选择返回类型：\n\n1. **算术运算符**（`+`, `-`, `*`, `/`, `%`, `^`, `&`, `|`, `~`）\n\n   ```cpp\n   const T operator X(const T& l, const T& r);\n   ```\n\n   - 返回新对象，不应返回引用（除非返回成员引用）\n   - 返回`const`对象防止`(a+b) = c`这样的操作\n\n2. **逻辑运算符**（`!`, `&&`, `||`, `<`, `<=`, `==`, `>=`, `>`）\n\n   ```cpp\n   bool operator X(const T& l, const T& r);\n   ```\n\n   - 返回布尔值\n\n3. **下标运算符**（`[]`）\n\n   ```cpp\n   E& T::operator[](int index);\n   ```\n\n   - 返回左值（非`const`引用），允许`a[i] = value`操作\n   - 不能返回新对象，否则赋值操作无效\n\n## 特殊运算符重载\n\n### 自增自减运算符\n\nC++区分前缀和后缀自增自减运算符：\n\n```cpp\n// 前缀++\nconst Integer& Integer::operator++() {\n    *this += 1;  // 先增加\n    return *this;  // 再返回\n}\n\n// 后缀++（参数int未使用，仅用于区分）\nconst Integer Integer::operator++(int) {\n    Integer old(*this);  // 先保存\n    ++(*this);  // 再增加\n    return old;  // 返回旧值\n}\n```\n\n调用方式：\n\n- `++x` 调用 `x.operator++()`\n\n  - 返回的是引用, 从而支持链式操作 如:\n\n    ```cpp\n    Counter g = ++(++f); // 可以，因为前缀返回引用\n    ```\n\n- `x++` 调用 `x.operator++(0)`\n\n  - 返回的是临时的对象, 也就是旧值的副本. 声明`const`避免了后缀的链式调用\n\n    ```cpp\n    Counter h = (f++)++; // 不可以，因为后缀返回const值\n    ```\n\n    之所以要防止上述的后缀链式调用, 是因为 对`f++`继续自增将会导致语义的混乱.\n\n\n\n\n\n\n### 下标运算符\n\ne.g.\n\n```cpp\n// 下标运算符（返回左值引用，允许修改）\nint& operator[](int index) {\n    if (index < 0 || index >= size) {\n        std::cerr << \"错误: 下标越界 [\" << index << \"]\" << std::endl;\n        // 返回第一个元素作为应急措施（实际应用中应抛出异常）\n        return data[0];\n    }\n    return data[index];\n}\n\n// 下标运算符的const版本（返回值，不允许修改）\nint operator[](int index) const {\n    if (index < 0 || index >= size) {\n        std::cerr << \"错误: 下标越界 [\" << index << \"]\" << std::endl;\n        // 返回0作为应急措施（实际应用中应抛出异常）\n        return 0;\n    }\n    return data[index];\n}\n```\n\n\n\n\n\n### 关系运算符\n\n关系运算符通常成对实现，可以相互利用：\n\n```cpp\nbool Integer::operator==(const Integer& rhs) const {\n    return i == rhs.i;\n}\n\nbool Integer::operator!=(const Integer& rhs) const {\n    return !(*this == rhs);  // 利用==运算符\n}\n\nbool Integer::operator<(const Integer& rhs) const {\n    return i < rhs.i;\n}\n\nbool Integer::operator>(const Integer& rhs) const {\n    return rhs < *this;  // 利用<运算符\n}\n\nbool Integer::operator<=(const Integer& rhs) const {\n    return !(rhs < *this);  // 利用<运算符\n}\n\nbool Integer::operator>=(const Integer& rhs) const {\n    return !(*this < rhs);  // 利用<运算符\n}\n```\n\n### 流运算符\n\n输入输出流运算符通常实现为全局函数：\n\n```cpp\n// 输出流运算符\nostream& operator<<(ostream& os, const A& a) {\n    os << a.get();\n    return os;  // 返回流对象以支持链式操作\n}\n\n// 输入流运算符\nistream& operator>>(istream& is, A& a) {\n    string line;\n    cin >> line;\n    // 读取a的数据\n    return is;  // 返回流对象以支持链式操作\n}\n```\n\n注意：\n\n- 输出流运算符的第一个参数不能是`const`，因为输出会修改流\n- 输入流运算符的第二个参数不能是`const`，因为需要修改对象\n- 通常需要声明为友元以访问私有成员\n\n### 自定义流操纵符\n\n可以定义自己的流操纵符：\n\n```cpp\nostream& tab(ostream& out) {\n    return out << '\\t';\n}\n\n// 使用：cout << \"Hello\" << tab << \"World!\" << endl;\n```\n\n\n\n\n\n## 赋值运算符与类型转换\n\n### 赋值运算符\n\n赋值运算符有几个重要特点：\n\n- 必须是成员函数\n- 如果不提供，编译器会自动生成（行为类似默认拷贝构造函数）\n- 需要检查自赋值情况\n- 确保为所有数据成员赋值\n- 返回`*this`的引用\n\n```cpp\nA& A::operator=(const A& rhs) {\n    if (this != &rhs) {  // 检查自赋值\n        // 释放当前资源\n        delete[] data;\n        \n        // 分配新资源\n        data = new int[rhs.size];\n        size = rhs.size;\n        \n        // 复制数据\n        for (int i = 0; i < size; i++) {\n            data[i] = rhs.data[i];\n        }\n    }\n    return *this;  // 返回对象引用\n}\n```\n\n### 类型转换\n\n\n\n#### 隐式转换\n\nC++支持两种用户定义的类型转换：\n\n1. **构造函数转换**：从其他类型到当前类型\n\n   ```cpp\n   class PathName {\n       string name;\n   public:\n       PathName(const string& s) : name(s) {}  // string到PathName的转换\n   };\n   \n   string abc(\"abc\");\n   PathName xyz = abc;  // 隐式转换：abc => PathName\n   ```\n\n   可以使用`explicit`关键字禁止隐式转换：\n\n   ```cpp\n   explicit PathName(const string& s);  // 只能用于显式构造\n   ```\n\n2. **转换运算符**：从当前类型到其他类型\n\n   ```cpp\n   class Rational {\n   public:\n       operator double() const {  // Rational到double的转换\n           return numerator_ / (double)denominator_;\n       }\n   };\n   \n   Rational r(1, 3);\n   double d = r;  // 隐式转换：r => double\n   ```\n\n   同样可以使用`explicit`关键字要求显式转换：\n\n   ```cpp\n   explicit operator double() const;\n   double d = (double)r;  // 必须显式转换\n   ```\n\n注意：如果同时提供了从T到C的构造函数和从C到T的转换运算符，编译器可能会产生歧义。\n\n\n\n#### 显式转换\n\n显式转换的外在特点:\n\n- 使用直接初始化语法\n- 明确指出要用构造函数创建对象\n- 转换过程更加清晰可见\n\ne.g.\n\n```cpp\n// 构造函数转换：double到Rational\nRational r1 = 3.14;  // 隐式转换\nRational r2(2.5);    // 显式转换\n```\n\n\n\n如果声明 `explict`, 就必须使用强制的显式转换:\n\n```cpp\n// 如果想要强制显式转换，应该这样声明：\nexplicit Rational(double value) {\n    const int PRECISION = 10000;\n    numerator = static_cast<int>(value * PRECISION);\n    denominator = PRECISION;\n    simplify();\n}\n\nRational r1 = 3.14;        // 错误：不允许隐式转换\nRational r2(2.5);          // 正确：显式构造\nRational r3 = Rational(3.14); // 正确：显式转换\n```\n\n\n\n类型的显式转换:\n\n```cpp\ndouble d2 = static_cast<double>(r2);  // 显式转换\n```\n\n\n\n#### 混合类型的转换\n\n根据运算结果, 自动地将运算的操作数进行类型转换:\n\n```cpp\n// 混合类型运算\nRational r3(1, 2);\ndouble d3 = 0.5;\n\n// 这里会将r3转换为double，然后进行double加法\ndouble result = r3 + d3;\n```\n\n\n\n# Template\n\n## 模板概述\n\n模板是C++中实现**<u>泛型编程</u>**的核心机制，允许我们编写可以处理不同数据类型的代码，而不必为每种类型重复编写相同的逻辑。\n\n- 首先尝试匹配普通的函数, 否则尝试匹配模板函数\n\n\n\n- 函数模板是声明, 而非定义. 是在实际调用时候去 **<u>实例化</u>** 对应类型的函数.\n\n- 必须都放在头文件的实现包含:\n\n  - 函数模板;\n\n  - inline函数\n\n  - 带有default参数的声明.\n\n  - 类模板的成员函数\n\n    ```cpp\n    template<T>\n    int Vector<T>::getSize()const{\n      return size;\n    }\n    ```\n\n    注意, 都需要声明模板类, 并且需要在 `< >`内部声明类.\n\n\n\n- `template<class T>` 和 `template<typename T>` 是等价的, 后者是后来引入的更明确的语法.\n- 类模板的每个成员函数在类外定义时，都必须以`template<class T>`（或`template<typename T>`）开头，即使该成员函数没有直接使用模板参数T.\n\n- `Vector< int (*)>`\n\n## 函数模板\n\n### 基本语法\n\n```cpp\ntemplate<class T>\nvoid swap(T& x, T& y) {\n    T temp = x;\n    x = y;\n    y = temp;\n}\n```\n\n- `template` 关键字引入模板声明\n- `class T` 指定参数化类型名称（`class`在这里表示任何内置类型或用户定义类型）\n- 在模板内部，`T` 被用作类型名称\n\n### 模板实例化\n\n```cpp\nint i = 3, j = 4;\nswap(i, j);  // 使用int类型的swap\n\nfloat k = 4.5, m = 3.7;\nswap(k, m);  // 实例化float类型的swap\n\nstd::string s(\"Hello\"), t(\"World\");\nswap(s, t);  // 实例化std::string类型的swap\n```\n\n编译器会根据传入的参数类型自动生成相应的函数实例。\n\n### 模板匹配规则\n\n- 只使用类型的精确匹配\n- 不应用类型转换操作\n- 即使是隐式转换也会被忽略\n\n```cpp\nswap(int, int);     // 正确\nswap(double, double); // 正确\nswap(int, double);  // 错误！类型不匹配\n```\n\n### 模板函数与普通函数共存\n\n如果同时存在模板函数和普通函数，编译器会优先选择**<u>普通函数</u>**.\n\n\n\n#### 显式指定\n\n可以显式地指定模板参数类型:\n\n```cpp\n// 带有返回值的函数模板\ntemplate <class T>\nT myMax(T a, T b)\n{\n    cout << \"调用模板版本的myMax\" << endl;\n    return (a > b) ? a : b;\n}\n\nint main(){\n  cout << \"myMax<double>(10, 20.5) = \" << myMax<double>(10, 20.5) << endl; \n}\n\n// myMax(10, 20.5);  // 错误：参数类型不一致\n```\n\n\n\n#### 多参数的函数模板\n\n同理的, 我们可以设置多个参数类型, 根据输入的类型来推断:\n\n```cpp\ntemplate <class T1, class T2>\nT1 myMax(T1 a, T2 b)\n{\n    cout << \"调用模板版本的myMax2\" << endl;\n    return (a > b) ? a : b;\n}\n\nint main(){\n  cout <<  myMax(10, 20.5) << endl; \n}\n```\n\n 此时, 上述的函数不需要显式的声明参数类型, 因为存在匹配的模板函数.\n\n同时, 此时根据类型推断, 返回的类型是 `int`, 然后舍弃 20.5的小数部分, 最终的结果是 `20`.\n\n\n\n## 类模板\n\n### 基本语法\n\n此处的 `Vector`是自己定义的.\n\n```cpp\ntemplate<class T>\nclass Vector {\npublic:\n    Vector(int);\n    ~Vector();\n    Vector(const Vector&);\n    Vector& operator=(const Vector&);\n    T& operator[](int);\nprivate:\n    T* m_elements;\n    int m_size;\n};\n```\n\n### 类模板的使用\n\n类模板必须显式指定类型参数：\n\n```cpp\nVector<int> v1(100);\nVector<Complex> v2(256);\nv1[20] = 10;\nv2[20] = v1[20];  // 如果定义了int到Complex的转换，则正确\n```\n\n### 类模板成员函数的定义\n\n所有成员函数定义都需要包含模板声明：\n\n```cpp\ntemplate <class T>\nVector<T>::Vector(int size) : m_size(size) {\n    m_elements = new T[m_size];\n}\n\ntemplate <class T>\nT& Vector<T>::operator[](int indx) {\n    if (indx < m_size && indx >= 0) {\n        return m_elements[indx];\n    } else {\n        // 错误处理\n    }\n}\n```\n\n注意：\n\n- 每个成员函数定义前都要加上 `template <class T>`\n- 类名必须写为 `Vector<T>`\n- 类模板的函数通常在头文件中实现，不需要分离的.cpp文件\n\n## 多参数模板\n\n模板可以使用多个类型参数：\n\n```cpp\ntemplate<class Key, class Value>\nclass HashTable {\n    const Value& lookup(const Key&) const;\n    void install(const Key&, const Value&);\n    // ...\n};\n```\n\n## 嵌套模板\n\n模板可以嵌套使用，因为它们只是新的类型：\n\n```cpp\nVector<Vector<double>> matrix;  // 注意C++11之前需要空格：Vector<Vector<double> >\nVector<int (*)(Vector<double>&, int)> functionPointers;  // 函数指针的向量\n```\n\n\n\n#### 非类型模板参数\n\n~也就是没有使用模板类型的普通参数.\n\n```cpp\ntemplate<class Key, class Value, int TableSize = 10>\nclass HashTable {\n    // ...\n};\n```\n\n其中的 `TableSize` 就是普通的参数. 在编译时就确定了类型.\n\n\n\n\n\n## 模板的局限性与注意事项\n\n1. 模板代码通常放在头文件中，因为编译器需要在编译时看到完整的模板定义\n2. 模板错误通常在实例化时才会被发现，错误信息可能很复杂\n3. 模板可能导致代码膨胀，因为每种类型都会生成一份代码\n4. 模板参数必须支持模板中使用的所有操作\n\n\n\n\n\n# 其他\n\n- 使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.\n  - 另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.\n\n\n\n## 访问控制\n\n### 继承关系中的访问控制\n\n控制基类成员在派生类中的可见性：\n\n- `public`：基类的 `public` 成员在派生类中仍然是 `public`，`protected` 成员仍然是 `protected`。\n- `protected`：基类的 `public` 和 `protected`成员在派生类中都变为 `protected`。\n- `private`：基类的 `public` 和 `protected` 成员在派生类中都变为 `private`。\n\n## 作用域与生存期\n\n本地: 均为本地\n\n全局: 均为全局\n\n静态本地: 作用域是本地, 生存期是全局\n\n静态全局: ~\n\n\n\n## Includes\n\n### Algorithm\n`copy(first, last, result)`:\n- `fisrt`和`last`是输入迭代器, 表示要复制的范围, 左闭右开即`last`应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;\n- `result`是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作\n  - e.g.\n    ```cpp\n    std::vector<int> source = {1, 2, 3, 4, 5};\n    std::vector<int> destination(5); // 确保目标容器有足够的空间\n    \n    std::copy(source.begin(), source.end(), destination.begin());\n    \n    for (int num : destination) {\n        std::cout << num << \" \"; // 输出：1 2 3 4 5\n    }\n    std::cout << std::endl;\n    ```\n- `result`可以直接输出到`cout`中.\n    ```cpp\n    vector<int> vec;\n    \n    for(int i = 0; i < 5; i++){\n        vec.push_back(i);\n    }\n    \n    vec.erase(vec.begin()+2); //删除第三个元素\n    copy(vec.begin(), vec.end(), ostream_iterator<int>(cout, \",\"));\n    cout << endl;\n    // 0,1,3,4,\n    ```\n\n---\n\n- 数组之间**不可以**直接赋值, 但是字符串可以直接赋值\n```cpp\nchar str1[] = \"Hello\";\nchar str2[] = \"World\";\nstr1 = str2;  // 错误，数组之间不可以直接赋值\n\nstring s1 = \"Hello\";\nstring s2 = \"World\";\ns1 = s2;  // 正确，字符串可以直接赋值\n\n```\n\n\n## 深拷贝\n```cpp\nstring s1 = \"Hello\";\nstring s2 = \"World\";\n\ncout << \"初始状态：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：Hello\ncout << \"s2: \" << s2 << endl;  // 输出：World\n\ns1 = s2;  // 赋值操作\n\ncout << \"赋值后：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：World\ncout << \"s2: \" << s2 << endl;  // 输出：World\n\n// 修改 s2 不会影响 s1，因为是深拷贝\ns2 = \"Changed\";\ncout << \"修改 s2 后：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：World\ncout << \"s2: \" << s2 << endl;  // 输出：Changed\n```\n\n## Temp\n```cpp\n// 迭代器\nI.begin();\nI.end();\n\n// Item Access\nV.front();;\nV.back();\n```\n\n## 区分\n### find\n`find`是字符串类的一种方法, 同时也是标准库`algorithm`中的一个函数.\n- `find`方法: 用于在字符串中查找子字符串的位置。\n```cpp\nstring str = \"Hello World\";\nsize_t pos = str.find(\"World\");\nif (pos != string::npos) {\n    cout << \"Found 'World' at position \" << pos << endl;\n}\n```\n- `algorithm`中的`find`函数: 用于在容器（如数组、向量等）中查找元素。\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main() {\n    vector<int> vec = {1, 2, 3, 4, 5};\n    vector<int>::iterator it = find(vec.begin(), vec.end(), 3);\n    if (it != vec.end()) {\n        cout << \"Found 3 at position \" << distance(vec.begin(), it) << endl;\n    }\n}\n// Found 3 at position 2\n```\n> 编译: `g++ -std=c++11 test.cpp -o test`\n\n### erase\n- 对于字符串的方法: `str.erase(pos, len)`\n  - 删除从指定位置开始的指定个数字符\n```cpp\nstring str = \"Hello World\";\nstr.erase(6, 5);\ncout << str << endl;  // 输出: Hello\n```\n\n---\n\n- 对于容器的方法: `erase(pos1, pos2)`\n  - 左闭右开式删除容器当中的元素.\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5, 6};\n    std::cout << \"Original vector: \";\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素\n    vec.erase(vec.begin() + 1, vec.begin() + 4); // 删除 vec[1], vec[2], vec[3]\n\n    std::cout << \"Modified vector: \";\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl; // 输出 \"1 5 6\"\n\n    return 0;\n}\n```\n\n## 不知道放在哪里的代码块\n```cpp\n#include <iostream>\n#include <list>\nusing namespace std;\n\nint main() {\n// 1. 创建并填充链表\nlist<int> L;                      // 创建一个空的整数链表\nfor(int i=1; i<=5; ++i)          // 循环5次\n    L.push_back(i);              // 依次在链表尾部添加数字1,2,3,4,5\n                                 // 此时链表内容为：1,2,3,4,5\n\n// 2. 删除第二个元素\nL.erase( ++L.begin() );          // L.begin()指向第一个元素\n                                 // ++L.begin()指向第二个元素\n                                 // erase删除迭代器指向的元素\n                                 // 此时链表内容为：1,3,4,5\n\n// 3. 打印链表内容\ncopy(                            // 标准库算法，用于复制序列\n    L.begin(),                   // 源序列的起始位置\n    L.end(),                     // 源序列的结束位置\n    ostream_iterator<int>(       // 输出流迭代器\n        cout,                    // 指定输出到标准输出\n        \",\"                      // 每个元素后面追加的分隔符\n    )\n);\ncout << endl;                    // 换行\n\n}\n```\n\n\n\n# 课堂缓冲区\n\n- 私有的边界是 `class`而非对象. 也就是说, **相同类的对象可以直接访问对方的私有属性**.\n\n- 不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们之间没有初始化的依赖.\n- 需要尽可能地避免使用全局变量.\n- 一个良好的习惯: 当成员函数不需要改变成员变量的值时, 在后面加上 `const`的关键字, 确保不会改变;\n\n\n\n```cpp\nchar* s = \"Hello,world！\"；\n```\n\n> 此时的右侧字符串位于 段 `text`, 不可写. `s`本身是一个固定内存的指针.\n\n```cpp\nchar s［］ = \"Hello,world！\"；\n```\n\n> 此时的 `s`是一个大小等于数组内容的对象.\n\n```cpp\nconst int* f();\n// 只能将函数的返回值赋值给一个 const int*\n```\n\n\n\n#### 函数内部的对象的空间分配\n\n编译器在编译的时候计算得到函数内部所有的对象的空间, 在实际进入函数的时候**, 立即分配所有对象的空间;**\n\n- 实际执行到的时候发生构造.\n\n\n\n#### Quiz\n\n静态全局、本地和成员变量都存储于全局数据区.\n\n- 静态成员变量的构造也在 `main()`之前.\n\n# 题目梳理\n\n## HW2\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedundefinedundefinedimage-20250225160042809.png?imageSlim)\n\n- ANS:  B\n- 由于此处的`map`以`char *`作为key, 同时初始化`str`的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.\n\n---\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250225160652522.png?imageSlim)\n\n- 逗号表达式, 从左到右分别计算,最后返回的结果是最右侧的值, 此处为1. \n\n> - `vector<int> v(10);` 创建包含10个元素的容器, 每个元素初始化为 `0`;\n>\n> - `vector <int> v(10, 1);`: 创建包含10个元素的容器, 但是都初始化为 `1`;\n> - `vector <int> v{10, 1};`: 创建包含10,1 这2个元素的容器;\n> - 此外, 还可以使用 `vector <int> v`;创建一个空的容器; \n> - 同时也还可以用 **迭代器**进行初始化: `vector <int> v(arr, arr + 5);`\n\n\n\n## HW3\n\n- 类成员的默认访问权限是 **<u>私有的</u>**, 即不显式声明访问修饰符, 默认为 `private`;\n\n  \n\n## HW4\n\n### 可变大小矩阵:\n\n```cpp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n\nclass Matrix{\nprivate:\n    int r,c;\n    vector<vector<int>> m; // 二维向量, 每个向量元素是一个一维向量\n\npublic:\n    Matrix(int r, int c) : r(r),c(c){\n        m.resize(r, vector<int>(c)); // 分配r个一维向量, 每个一维向量的大小为c\n    }\n\n\t...\n\n    void transform(){\n        vector<vector<int>> new_m(c, vector<int>(r,0)); //\t声明一个临时的二维向量\n        \n    \t// 将矩阵转置, 放入临时的向量\n        for(int i = 0; i < c; i++){\n            for(int j = 0 ; j< r; j++){\n                new_m[i][j] = m[j][i];\n            }\n        }\n\n        swap(r,c); //改变矩阵的行与列\n        m = move(new_m); //使用 move 直接将临时变量的所有权交给m, 避免拷贝\n    }\n};\n```\n\n> 此处值得注意的是 `resize`在二维向量中的使用, 以及 `move`直接给予“所有权”的特性.\n\n\n\n\n\n## HW5\n\n**判断题**: const成员函数不能作用于非const对象\n\n> 答案是 **False**. \n>\n> 题目的意思大致是: 非const对象无法调用 const对象, 实际上是事实是相反的描述. 只需要理解题目的表述即可做出判断.\n\n\n\n## HW6\n\n右值引用本身是一个左值, 可以取地址.\n\n```cpp\nint&& r = 5;\nstd::cout << r; // r 在这里是左值，因为它有名字\n```\n\n\n\n## HW7\n\n\n\n## HW9\n\n1. 因为静态成员函数不能是虚函数，所以它们不能实现多态\n\n   - 静态成员函数不与类的任何具体实例（对象）相关联;\n\n2. 在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序\n\n   ```cpp\n   #include <iostream>\n   \n   // 基类A\n   class A\n   {\n   public:\n       A()\n       {\n           std::cout << \"A的构造函数被调用\" << std::endl;\n       }\n   };\n   \n   // 基类B\n   class B\n   {\n   public:\n       B()\n       {\n           std::cout << \"B的构造函数被调用\" << std::endl;\n       }\n   };\n   \n   // 派生类C，继承自A和B\n   class C : public A, public B\n   {\n   public:\n       // 构造函数中显式调用基类构造函数\n       C() : B(), A()\n       { // 注意：这里虽然B在A之前，但实际调用顺序由类定义决定\n           std::cout << \"C的构造函数被调用\" << std::endl;\n       }\n   };\n   \n   int main()\n   {\n       C c; // 创建C的实例\n       return 0;\n   }\n   ```\n\n   输出:\n\n   ```cpp\n   A的构造函数被调用\n   B的构造函数被调用\n   C的构造函数被调用\n   ```\n\n   由此可见, 虽然在C的初始化列表中声明了B前A后, 但是实际上A优先调用.\n\n3. ~~如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针）~~\n\n   - 这句话的括号内部是错误的.\n\n   - 因为我们依旧可以将其的子类 `upcast`\n\n     ```cpp\n     #include <iostream>\n     using namespace std;\n     \n     class A\n     {\n     public:\n         virtual void ptr() = 0;\n     };\n     \n     class B : public A\n     {\n     public:\n         void ptr() override\n         {\n             cout << \"B\" << endl;\n         }\n     };\n     \n     int main()\n     {\n         A *a = new B();\n         a->ptr();\n         return 0;\n     }\n     ```\n\n\n\n\n\n- 类内的纯虚函数被认为是 `inline`的函数;\n\n- 在创建派生类的对象时, 构造函数的执行顺序为—— 基类对象->对象成员->派生类自身:\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n  \n  class Base\n  {\n  public:\n      Base() { cout << \"Base 构造函数\" << endl; }\n  };\n  \n  class Member\n  {\n  public:\n      Member() { cout << \"Member 构造函数\" << endl; }\n  };\n  \n  class Derived : public Base\n  {\n      Member m;\n  \n  public:\n      Derived() { cout << \"Derived 构造函数\" << endl; }\n  };\n  \n  int main()\n  {\n      Derived d;\n      return 0;\n  }\n  ```\n\n  输出:\n\n  ```cpp\n  Base 构造函数\n  Member 构造函数\n  Derived 构造函数\n  ```\n\n- 私有继承问题: 可以通过方法访问私有继承的public, protected的基类成员(不包括私有成员), 但是无法直接访问.\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n  \n  class Base\n  {\n  private:\n      int a = 1; // 私有\n  protected:\n      int b = 2; // 保护\n  public:\n      int c = 3; // 公有\n  };\n  \n  class Derived : private Base\n  {\n  private:\n      int d = 4; // 派生类自己的私有成员\n  public:\n      void show()\n      {\n          // cout << a;  // ❌ 错误！Base 的私有成员 a，派生类根本不能访问\n          cout << b << endl; // ✅ OK：Base 的 protected 成员，在 Derived 中变成了 private\n          cout << c << endl; // ✅ OK：Base 的 public 成员，在 Derived 中变成了 private\n          cout << d << endl; // ✅ OK：Derived 的私有成员当然能访问\n      }\n  };\n  \n  int main()\n  {\n      Derived d;\n      d.show();\n      // cout << d.b; // ❌ 错误！Base 的 protected 成员，在 Derived 中变成了 private\n      return 0;\n  }\n  ```\n\n- 虚函数也具有 `this` 指针.\n\n- 在构造函数中调用虚函数，不是动态联编\n\n  - 原因是：**对象还未完全构造完成（或已经开始析构）时，虚函数表（vtable）可能尚未指向最终派生类**.\n  - 所以，在构造函数中调用虚函数时，**只会调用当前类中该函数的版本**，不会发生多态。\n\n\n\n#### 虚析构函数\n\n- 为了在多重继承的时候, 可以正确的调用各个阶段的析构函数, 我们需要声明基类的析构为虚函数, 然后在子类中重写:\n\n```cpp\nvirtual ~CRAFT()\n{\n    cout << \"销毁航行器(速度: \" << speed << \")\" << endl;\n}\n\n...\n\n~PLANE() override\n{\n    cout << \"销毁飞机(翼展: \" << width << \")\" << endl;\n}\n```\n\n\n\n- 菱形继承的时候, 注意 `virtual public`的声明 以及 在底层的子类中的初始化列表的顺序!\n\n  ```cpp\n  SEAPLANE(float speed, float width, float depth) : CRAFT(speed), PLANE(speed, width), SHIP(speed, depth)\n  {\n    ...\n  }\n  ```\n\n\n\n\n\n## HW10\n\n- 判断: 对象间赋值将调用拷贝构造函数。  \n  - 错误. 对象间的赋值调用的是 <u>拷贝复赋值运算符</u>. \n\n#### 异常类\n\n![image-20250423094724267](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250423094724267.png?imageSlim)\n\n- **A**是错误的。C++允许自定义异常类，可以继承标准异常类如std::exception。\n- **B**是正确的，C++异常机制会在异常抛出前自动销毁局部对象。\n- **C**是正确的，抛出异常时对象会被拷贝（或移动）到catch块中。\n- **D**是正确的，在catch块中可以使用对象引用来接收异常对象。\n\n\n\n#### 赋值运算符重载\n\n- 语法:\n\n  ```cpp\n  类名& operator=(const 类名& 对象名)\n  ```\n\n- 特点:\n\n  - 返回类型是类的引用（为了支持连续赋值 a=b=c）\n  - 参数是const引用（防止修改原对象）\n  - 通常需要先释放自己的资源，再复制数据\n\ne.g.\n\n```cpp\nArray& operator=(const Array& a) {\n    if (this != &a) {  // 防止自赋值\n        delete[] data;  // 释放原有内存\n        size = a.size;  // 复制大小\n        data = new int[size];  // 分配新内存\n        for (int i = 0; i < size; i++) {  // 复制数据\n            data[i] = a.data[i];\n        }\n    }\n    return *this;  // 返回对象自身的引用\n}\n```\n\n\n\n## W12\n\n- 建立类模板对象的实例化过程为: `模板类-对象`.\n  - 编译器根据提供的模板参数将类模板实例化为一个具体的模板类（也称为实例化类或特化类），然后才能创建该模板类的对象。\n  - 类模板的使用实际上是将类模板实例化成一个 `类`\n- 类模板与模板类\n  - 类模板是类的蓝图或规范，它本身不是一个类\n  - 模板类（或实例化类、特化类）是使用具体的类型参数实例化类模板后得到的具体的类。\n- 类模板和函数模板的实例化的时期 -- 均为`编译时期`\n  - 函数模板在编译时期检查定义中的基本语法;\n  - 尝试调用某一个函数模板时, 编译器根据实际的参数类型来推导模板参数类型/或者由显式指定类型得到, 如果合法就生成函数实例(i.e. ***模板函数***), 这个过程就是模板实例化(生成代码).\n- 除了使用构造函数, 还可以直接调用 `make_pair` 让编译器自动推导类型来创建pair对象;\n- \n\n\n\n## L3\n\n> [!NOTE]\n>\n> 1. 内联函数在 **<u>编译时展开</u>**, 而不是运行时.\n> 2. 内联函数的声明以及最终的生效与否, 是由 **<u>编译器</u>** 决定的. 也就是说, 无论是否存在 inline 的声明, 编译器最终决定函数的类型.\n\n\n\n### C++ 初始化列表与成员变量初始化\n\n> [!NOTE]\n>\n> - `int`和自己定义的类都是cpp的类, 所以可以直接在初始化列表中用 `:class_instance{input},...{}`来初始化类内的类对象.\n> - 推荐使用 `{}`来初始化, 不会产生是函数的歧义.\n\n\n\n#### 1. 构造顺序\n- 在 C++ 中，**成员变量的初始化顺序由它们在类中声明的顺序决定**，而不是在初始化列表中的顺序。\n- 初始化列表用于 **直接初始化** 成员变量，而不是在构造函数体内先创建未初始化的对象再赋值。\n\n#### 2. 为什么必须使用初始化列表？\n- **成员变量在进入构造函数体之前就已经完成了初始化**，不能在构造函数体内赋值来替代初始化。\n- **如果成员变量是一个没有默认构造函数的对象**，必须在初始化列表中显式调用其构造函数，否则编译会报错。\n- 在构造函数体内赋值，意味着：\n  1. 先调用默认构造函数创建对象（如果 `NumberDisplay` 没有默认构造函数，这一步会失败）。\n  2. 然后使用赋值运算符进行赋值，而赋值运算与初始化是不同的过程。\n\n#### 3. 示例代码\n#### ❌ 错误示例（可能会编译失败）\n```cpp\nclass NumberDisplay {\npublic:\n    NumberDisplay(int max) { /* 初始化代码 */ }\n};\n\nclass Clock {\nprivate:\n    NumberDisplay hour_display;\n    NumberDisplay minute_display;\n    NumberDisplay second_display;\n    \npublic:\n    Clock(int hour, int minute, int second) { // ❌ 错误：NumberDisplay 没有默认构造函数\n        hour_display = NumberDisplay(24);     // 不能这样赋值\n        minute_display = NumberDisplay(60);\n        second_display = NumberDisplay(60);\n    }\n};\n\n\n\n```\n#### **✅ 正确示例**\n\n```cpp\nclass Clock {\nprivate:\n    NumberDisplay hour_display;\n    NumberDisplay minute_display;\n    NumberDisplay second_display;\n    \npublic:\n    // 使用初始化列表\n    Clock(int hour, int minute, int second)\n        : hour_display(24), minute_display(60), second_display(60) {\n        // 构造函数体内的代码可以进行额外的赋值操作\n    }\n};\n```\n\n\n\n**4. 结论**\n\n​\t•\t**所有成员变量都会在构造函数体执行前被初始化**，不能依赖在构造函数体内赋值。\n\n​\t•\t**如果成员变量是没有默认构造函数的对象**，必须使用初始化列表进行初始化，否则会导致编译错误。\n\n​\t•\t**初始化列表的顺序应与成员变量的声明顺序一致**，否则可能会导致未定义行为。\n\n\n\n\n\n\n\n\n\n## Project\n\n### P1\n\n```cpp\ncout << \"\\\"\" << value << \"\\\"\";\n```\n\n如果要输出引号, 需要加入 `\\`来进行转义!\n\n\n\n#### 使用匿名函数来排序\n\n```cpp\nsort(sortedRecords.begin(), sortedRecords.end(),\n     [](const Record& a, const Record& b) {\n         if (a.qso_date != b.qso_date) return a.qso_date < b.qso_date;\n         return a.time_on < b.time_on;\n     });\n```\n\n`sort`是 `algorithm`头文件中的库函数, 支持原地排序.\n\n第三个参数是一个函数, 返回 `true`表示这个函数的第一个参数应该排在第二个参数的前面.\n\n比如此处, 使用了匿名函数 `[]`, 同时比较 `date`, 当 \n\n```cpp\nreturn a.qso_date < b.qso_date;\n```\n\n指的是当前者的时间较小, 应该排在前面, 因此是升序.\n\n> 不要因为语句太长而忘记末尾的 `;`.\n\n\n\n### P2\n\n#### 思路分析\n\n- 整体设计:\n  - 程序随机生成一组设置, 然后用户开始输入\n  - 大概率, 用户不可避免地会失败, 此时应当让用户选择是否继续参与这场游戏, 否则程序生成下一组的设置;\n- 房间:\n  - monster所在;\n  - princess所在\n  - lobby;\n  - 普通的room\n  - 具有毒药的房间(接触后限制之后行动的次数)\n  - 解药房间(可以解除中毒的状态)\n  - 地图房间(接触后可以通过输入 `map`来显示当前的位置)\n- 房间个数: \n  - 每次都将上述的因素都加入, 不太合适, 因此需要用户输入游戏的类型/难度;\n  - 经典模式: 只会产生monster, princess,lobby和普通房间. 房间的个数较少;\n  - 挑战模式:  加入毒药, 解药和地图因素; 房间个数较多.\n\n\n\n## 刷题\n\n- Destructors can not be overloaded.\n  - 因为析构函数没有任何的参数和返回类型, 无法重载.\n\n- **类的成员函数可以访问同类的私有成员，即使是其他对象的成员。** 回顾类的私有边界不是相对于对象的, 而是类. \n\n- cpp中, 构造函数一定不能是 `virtual` 的! \n\n- 静态变量需要再类的外部定义, 但是静态函数不一定.\n\n- “In C++， struct is actually the same thing as class， except for minor differences in usage.”\n  - 这句话是正确的, 注意结构体也是支持继承的. 只是默认的继承方式也是 `public`. \n\n- In C++, inheritance allows a derived class to directly access all of the functions and data of its base class.（T/F）\n  - 错误的. 对于 `public` 类型的继承, 依旧无法直接访问父类的私有成员, 只能通过子类的方法来间接访问.\n\n\n\n- 下面的代码段, 能够能够通过编译, 但是存在运行时的错误(越界访问):\n\n  ```c++\n  int main() { vector<float> v; v[0] = 2.5; }\n  ```\n\n  - 编译器在编译时候, 检查的主要是程序的语法和类型;\n  - 越界访问的问题存在于运行时检测.\n\n- 64位系统系统环境, 按照8个字节进行对齐:\n\n  ```c++\n  // 参考的类定义方式\n  class A1\n  {\n  public:\n      int i;\n      void f(){}\n  };\n  \n  // 其他的类型定义\n  \n  ```\n\n  Output:\n\n  ```c++\n  Size of A1 (non - virtual function with int member): 4 bytes\n  Size of A2 (virtual function with int member): 16 bytes\n  Size of A3 (non - virtual function without int member): 1 bytes\n  Size of A4 (virtual function without int member): 8 bytes\n  Size of B (derived from A1): 8 bytes\n  ```\n\n  主要注意2点:\n\n  1. 没有任何成员的类, 也占用1个字节的大小;\n\n  2. 4+8 将会对齐得到16个字节的空间大小.\n\n     > [!NOTE]\n     >\n     > `void*` 和 `int*` 的大小相同! (题目通常给出 `int*`的大小, 然后给出虚函数)\n\n\n\n- `malloc` 不会调用对象的构造函数, 仅仅分配内存, 并不涉及对象的初始化;\n\n  - `new`会调用构造函数\n\n  - `malloc` 需要显式地类型转换:\n\n    ```c++\n    class MyClass {\n    public:\n        MyClass() { std::cout << \"Constructor called!\" << std::endl; }\n    };\n    \n    MyClass* p1 = new MyClass();  // 输出 \"Constructor called!\"\n    MyClass* p2 = (MyClass*)malloc(sizeof(MyClass));  // 无输出，构造函数未调用\n    ```\n\n- `new` 是CPP的运算符, 可以重载; `malloc`是标准库的函数, 无法重载.\n- 每个类最多具有一个析构函数\n\n\n\n#### 重载问题\n\n在 `::`, `()` 和 `->`中, 只有 `->`可以被重载:\n\n```c++\n#include <iostream>\n\nclass MyClass {\npublic:\n    void sayHello() {\n        std::cout << \"Hello from MyClass!\" << std::endl;\n    }\n};\n\nclass MyPtr {\nprivate:\n    MyClass* ptr;  // 内部存储一个原生指针\n\npublic:\n    // 构造函数\n    MyPtr(MyClass* p) : ptr(p) {}\n\n    // 重载 -> 运算符\n    MyClass* operator->() {\n        return ptr;  // 返回原生指针，使得可以继续用 -> 访问成员\n    }\n};\n\nint main() {\n    MyClass obj;\n    MyPtr myPtr(&obj);  // 用 MyPtr 包装 MyClass 对象\n\n    myPtr->sayHello();  // 调用 MyClass 的成员函数\n\n    return 0;\n}\n```\n\n \n\n#### new与对象转换\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass B;\n\nclass A\n{\nprotected:\n    int x;\n\npublic:\n    A(int x = 0) : x(x) {}\n    operator B();\n    int getx() { return x; }\n};\n\nclass B : public A\n{\npublic:\n    B(int x = 0) : A(x) { this->x++; }\n    B(const B &b) : A(b.x) { this->x++; }\n};\n\nA::operator B() { return *new B(x + 1); } // 特别注意此处\n\nint main()\n{\n    A *p1 = new B(3); // new的时候触发B的构造函数, 自增\n    A *p2 = new A(9);\n    B b0 = *p1; // 发生了A类对象向B类对象的转化, 详见下面两行:\n    // *p1 将要转化的时候,  先传入x+1作为B的初始化参数输入,\n    // 然后new将触发B的构造函数, 最后返回, 返回结果用于初始化b0, 继续触发拷贝构造函数\n    B &r = b0;\n    B b1 = b0;  // 发生了 B类对象的拷贝构造, b1的x为8, 但是不会改变b0的x=7\n    B b2 = *p2; // 这一步的转换与上面的同理. 也是+3\n    cout << p1->getx() << endl;\n    cout << p2->getx() << endl;\n    cout << b0.getx() << endl;\n    cout << r.getx() << endl;\n    cout << b1.getx() << endl;\n    cout << b2.getx() << endl;\n}\n```\n\n解题过程中的关键步骤已经写在注释当中, 最后的输出是:\n\n```c++\n4\n9\n7\n7\n8\n12\n```\n\n梳理考察的重要知识点:\n\n1. upcast的时候, 是子类的属性赋值给父类, 包括虚函数表. 因此, 此时看作是父类的对象, 但是虚函数能够动态绑定.\n\n2. `new`和`delete`分别自动调用类的构造函数和析构函数;\n\n3. `A::operator B()` 形式表示A类对象如何转换成B类型对象的, 在发生转换的时候自动调用这部分的函数.\n\n   ```c++\n   A *p1 = new B(3); // 拷贝构造的时候直接自增为4\n   A *p2 = new A(9);\n   ```\n\n   注意上面的指针都指向A类的对象.\n\n\n\n#### 链式的析构顺序\n\n- 构造顺序: 父类->成员对象-> 自身\n- 析构顺序: 自身-> 成员对象-> 父类\n\n下面的这道题目涉及的类的关系如下:\n\n1. P是父类, S是子类;\n2. P内部有两个P类型的指针成员.\n\n```c++\n#include <iostream>\nusing namespace std;\n\n// 1. 先声明基类 P\nclass P\n{\npublic:\n    static bool flag; // 静态成员声明\n    int x;            // 数据成员\n    P *left, *right;  // 指针成员\n\n    // 构造函数\n    P(P *left = nullptr, P *right = nullptr)\n        : x(0), left(left), right(right) {}\n\n    // 虚析构函数（因为有继承关系，应该是虚函数）\n    ~P()\n    {\n        if (flag)\n        {\n            if (left != nullptr)\n            {\n                delete left;\n            }\n            if (right != nullptr)\n            {\n                delete right;\n            }\n        }\n        else\n        {\n            if (right != nullptr)\n            {\n                delete right;\n            }\n            if (left != nullptr)\n            {\n                delete left;\n            }\n        }\n        cout << \"P\" << x;\n    }\n};\n\n// 2. 静态成员的定义（必须在类外定义）\nbool P::flag = false;\n\n// 3. 派生类 S\nclass S : public P\n{\npublic:\n    // 构造函数，调用基类构造函数\n    S(P *left = nullptr, P *right = nullptr) : P(left, right) {}\n\n    // 析构函数\n    ~S()\n    {\n        cout << \"S\" << x;\n    }\n};\n\nint main()\n{\n    S *p1 = new S;\n    p1->x = 1; // 设置第一个节点的值\n    S *p2 = new S;\n    p2->x = 2;   // 设置第二个节点的值\n    S s(p1, p2); // 创建根节点，连接p1和p2\n    s.x = 3;     // 设置根节点的值/\n    return 0;    // 程序结束时析构对象\n}\n\n```\n\n最终的输出:\n\n1. 析构s, 首先析构子类自身, 调用s的析构函数, 输出s;\n2. 然后析构父类, 父类是P, 析构的时候直接调用自身的析构函数, 一词析构右指针和左指针;\n3. 执行到末尾, 输出自身的P3.\n\nOutput:\n\n```c++\nS3P2P1P3\n```\n\n\n\n\n\n\n\n#### 操作符的重载\n\n```c++\n#include <iostream>\n#include <iomanip>\n\n#define MAXN 110\n\n/* Your answer will be inserted here. Feel free to add anything needed here.*/\n\nclass vec\n{\nprivate:\n    int first, second;\n\npublic:\n    vec(int a, int b) : first(a), second(b) {}\n    //  < 的重载\n    bool operator<(const vec &other) const\n    {\n        return second < other.second;\n    }\n\n    // 类型转换的重载\n    operator double() const\n    {\n        return static_cast<double>(first);\n    }\n\n    // 输出的重载\n    friend std::ostream &operator<<(std::ostream &os, const vec &v)\n    {\n        return os << \"(\" << v.first << \",\" << v.second << \")\";\n    }\n};\nvoid printArrayInfo(vec **arr, int n)\n{\n    vec *maxv = arr[0], *minv = arr[0];\n    double avg = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vec *val = arr[i];\n        if (*val < *minv)\n            minv = val;\n        if (*maxv < *val)\n            maxv = val;\n        avg = avg + static_cast<double>(*val);\n    }\n    avg /= n;\n    std::cout << std::fixed << std::setprecision(2) << \"min = \" << *minv << \", max = \" << *maxv << \", avg = \" << avg << std::endl;\n}\n\nint main()\n{\n    vec *pool[MAXN];\n    int n;\n    int a, b;\n    std::cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        std::cin >> a >> b;\n        pool[i] = new vec(a, b);\n    }\n    printArrayInfo(pool, n);\n    return 0;\n}\n```\n\n\n\n#### 菱形继承与二义性问题\n\n并不是菱形继承的操作都会导致二义性, 要从本质--访问的操作是否导致无法区分正确的单独对象?\n\n```c++\n#include <iostream>\nusing namespace std;\nclass A\n{\npublic:\n    int x;\n    A() : x(6) {}\n    int fun()\n    {\n        return x;\n    }\n};\nclass B : public A\n{\npublic:\n    int fun()\n    {\n        return A::fun() + x;\n    }\n};\nclass C : public A\n{\npublic:\n    int fun()\n    {\n        return A::fun() + x;\n    }\n};\nclass D : public B, public C\n{\npublic:\n    int fun()\n    {\n        return B::fun() + C::fun();\n    }\n};\nint main()\n{\n    D d;\n    cout << d.fun();\n    // cout << d.A::fun(); 存在二义性的问题, 因为在D当中分别存在来自于B和C的这个函数!\n}\n```\n\n在上面代码中, D是菱形继承, 但是可以直接访问d的fun, 因为在d的fun中涉及的是B和C自己的fun. 而后者又能够直接调用自己的继承自A的fun\n\n- 无法直接调用 `d.A::fun()`, 参见注释.\n\n# 最后的枚举\n\n\n\n\n\n\n\n#### 转换运算符\n\n`A::operator B()`的含义： 定义了如何将 `A` 类型的对象转换为 `B` 类型的对象。\n\n- `A::` 表示这是 `A` 类的成员函数\n- `operator B` 表示这是一个到 `B` 类型的转换运算符\n- `()` 表示这是一个函数\n\n```c++\n// A 具有一个成员变量且在构造函数中可以赋值\n\nA::operator B() { return *new B(x + 1); }\n```\n\n- `new B(x + 1)` 创建一个新的 `B` 对象，其中 `x` 是 `A` 类的成员变量\n- `*` 解引用这个新创建的对象\n- 返回这个 `B` 类型的对象\n\n> [!NOTE]\n>\n> 注意, 这只是决定了B类对象的如何构造, 并不会影响A类对象本身.\n\n调用的场景: 需要将A类型的对象转换为B类型的对象 e.g.——\n\n```c++\nA a(5);\nB b = a;  // 这里会自动调用 A::operator B()\n```\n\n\n\n## const相关\n\n### 对象与方法的对应\n\nC++在选择成员函数时会考虑对象的const属性：\n\n- const对象只能调用const成员函数 \n\n- 非const对象优先调用非const版本，如果没有非const版本才会调用const版本\n\n- > [!NOTE]\n  >\n  > 函数定义的顺序并不会影响调用的选择!\n\ne.g.\n\n```c++\n#include <iostream>\nusing namespace std;\nclass MyClass\n{\npublic:\n    MyClass(int x) : val(x) {}\n\n    void Print()\n    {\n        cout << 2 << endl\n             << val << endl;\n    }\n\n    void Print() const { cout << 1 << endl\n                              << val << endl; }\n\nprivate:\n    int val;\n};\nint main()\n{\n    const MyClass obj1(10);\n    MyClass obj2(20);\n    obj1.Print();\n    obj2.Print();\n    return 0;\n}\n```\n\noutput:\n\n```c++\n1\n10\n2\n20\n```\n\n\n\n\n\n## 初始化先后的问题\n\nC++中对象的初始化和销毁顺序遵循特定的规则，这对于理解程序行为和避免内存问题至关重要\n\n### 初始化列表\n\n### 类的构造与析构顺序\n\n在C++中，对象的构造和析构顺序遵循以下规则：\n\n1. **构造顺序**：\n   \n   - 基类先于派生类构造\n   - 成员变量按声明顺序构造\n   - 基类构造完成后，才执行派生类构造函数体\n   - > [!NOTE]\n     >\n     > 对象在调用构造函数之前, 首先完成内部成员对象的构造\n   \n2. **析构顺序**：\n   \n   - 与构造顺序相反\n   - 先执行派生类析构函数体\n   - 然后按声明顺序的逆序析构成员变量\n   - 最后析构基类\n\n#### 示例分析\n\n```c++\nint main()\n{\n    Child c;\n}\n```\n\n##### 类层次结构\n\n```\nX (基础类)\n↑\nY (继承自X)\n\nParent (包含X成员)\n↑\nChild (继承自Parent，包含Y成员)\n```\n\n##### 构造过程分析\n\n当创建`Child`对象时，构造顺序为：\n\n1. 首先构造基类`Parent`\n   - 在`Parent`构造前，先构造其成员`x`（调用`X::X()`）\n   - 然后执行`Parent`构造函数体（输出\"Parent::Parent()\"）\n2. 基类构造完成后，构造`Child`的成员`y`\n   - 在构造`y`前，先构造其基类部分（调用`X::X()`）\n   - 然后执行`Y`构造函数体（输出\"Y::Y()\"）\n3. 最后执行`Child`构造函数体（输出\"Child::Child()\"）\n\n##### 析构过程分析\n\n当`Child`对象离开作用域时，析构顺序为：\n\n1. 首先执行`Child`析构函数体（输出\"Child::~Child()\"）\n2. 然后析构成员`y`\n   - 先执行`Y`析构函数体（输出\"Y::~Y()\"）\n   - 然后析构其基类部分（调用`X::~X()`）\n3. 最后析构基类`Parent`\n   - 先执行`Parent`析构函数体（输出\"Parent::~Parent()\"）\n   - 然后析构其成员`x`（调用`X::~X()`）\n\n#### 预期输出\n\n执行`test.cpp`程序时，预期输出为：\n\n```\nX::X()              // Parent的成员x构造\nParent::Parent()    // Parent构造函数体\nX::X()              // Y的基类部分构造\nY::Y()              // Y构造函数体\nChild::Child()      // Child构造函数体\nChild::~Child()     // Child析构函数体\nY::~Y()             // Y析构函数体\nX::~X()             // Y的基类部分析构\nParent::~Parent()   // Parent析构函数体\nX::~X()             // Parent的成员x析构\n```\n\n#### 重要注意事项\n\n1. **虚析构函数**：当使用多态时，基类应该有虚析构函数，确保正确调用派生类析构函数。\n\n2. **成员初始化列表**：推荐使用成员初始化列表而非在构造函数体内赋值，这样可以直接初始化而非先默认构造再赋值。\n\n3. **异常安全**：构造过程中如果抛出异常，已构造的成员会被正确析构，但未完全构造的对象不会调用析构函数。\n\n4. **RAII原则**：资源获取即初始化，在构造函数中获取资源，在析构函数中释放资源，确保资源管理安全。\n\n#### 实际应用\n\n理解对象生命周期对以下场景尤为重要：\n\n1. **资源管理**：确保资源在不再需要时被释放\n2. **依赖关系处理**：确保依赖对象在被依赖对象之前构造，之后析构\n3. **继承层次设计**：合理设计基类和派生类的构造和析构行为\n","source":"_posts/编程语言/cpp学习记录.md","raw":"---\ntitle: cpp学习记录\ndate: 2025-02-14 20:21:21\ntags: \ncategories: \n- 编程语言\n- 学习笔记\nexcerpt: 围绕zju-OOP课堂内容扩展的cpp学习笔记\nmathjax: true\nthumbnail: https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094812819.png?imageSlim\n---\n#### 导论\n编译时, 从`c`的`gcc`转变为了`g++`.\n\nOOP的三大特点:\n\n- 封装\n- 继承\n- 多态\n\n# 基本语法\n在C语言中,我们主要使用`malloc()`和`free()`来进行动态内存管理。但这种方式存在一些问题:\n- 它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;\n- 容易发生内存泄漏.\n\n为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了`new`和`delete`.\n\nnew的基本语法十分直观:\n```cpp\nType* pointer = new Type;           // 分配单个对象\nType* pointer = new Type[size];     // 分配对象数组\n```\n\n可以在创建时进行初始化:\n```cpp\nint* p1 = new int(5);              // 初始化为5\nstring* p2 = new string(\"hello\");   // 初始化为\"hello\"\n```\n\n也可以根据变量进行动态的内存分配:\n```cpp\nint size;\ncin >> size;\nint* arr = new int[size];  // 根据输入分配内存\n```\n\n> [!NOTE]\n>\n> Use `delete ［］` if `new ［］` was used to allocate an array.\n\n\n\n# 输入输出流\n\n通过包含头文件 -- `#include <iostream>` 来使用输入输出流 `cin` 和 `cout`.\n\n```cpp\n#include <iostream>\n\nusing namespace std;\nint main(){\n    int age; \n    cin >> age;\n    cout << \"You are \" << age << \" years old\" << endl;\n    // endl 是换行符\n    return 0;\n}\n```\n\n- `cin`读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:\n```cpp\nstring str=\"Hello world!\";\nofstream fout(\"out.txt\");\nfout<<str<<endl;\n\nifstream fin(\"out.txt\");\nstring str1,str2;\n\n// 读取文件中的两个字符串\nfin>>str1>>str2; \n\ncout << str1 << endl << str2 << endl;\n// 输出:\n// Hello\n// world!\n\nreturn 0;\n```\n\n\n## 文件流\n\n### 输入输出流基础\n- 头文件: `#include <fstream>`\n- 类: `ifstream`(输入流), `ofstream`(输出流)\n```cpp\n#include <fstream>  // 需要包含这个头文件\nusing namespace std;\n\n// 文件输出（写入文件）\nofstream outFile(\"output.txt\");\noutFile << \"Hello World\" << endl;\noutFile.close();\n\n// 文件输入（读取文件）\nifstream inFile(\"input.txt\"); \nstring line;\ngetline(inFile, line);\ninFile.close();\n```\n  - 写入文件时, 如果没有文件, 会自动创建.\n\n\n### 常用操作示例\n\n1. **写入文件**\n```cpp\nofstream outFile;\noutFile.open(\"test.txt\");  // 打开文件\nif (outFile.is_open()) {   // 检查是否成功打开\n    outFile << \"第一行\" << endl;\n    outFile << \"第二行\" << endl;\n    outFile.close();       // 完成后关闭文件\n}\n```\n\n2. **读取文件 **\n```cpp\nifstream inFile(\"test.txt\");\nstring line;\nwhile (getline(inFile, line)) {  // 逐行读取\n    cout << line << endl;\n}\ninFile.close();\n```\n\n3. **以追加模式打开文件**\n```cpp\nofstream outFile(\"test.txt\", ios::app);  // app 表示追加模式\noutFile << \"这行会被添加到文件末尾\" << endl;\noutFile.close();\n```\n\n\n### 文件打开模式\n\n- `ios::in` - 读取模式\n- `ios::out` - 写入模式\n- `ios::app` - 追加模式\n- `ios::ate` - 打开文件后立即定位到文件末尾\n- `ios::binary` - 二进制模式\n- `ios::trunc` - 如果文件存在则**截断**文件\n  - 如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.\n```cpp\n// 假设 test.txt 原本内容是:\n// Hello World\n// This is a test\n\n// 使用 trunc 模式打开\nofstream outFile(\"test.txt\", ios::out | ios::trunc);  \noutFile << \"新的内容\" << endl;\noutFile.close();\n\n// 现在 test.txt 的内容只有:\n// 新的内容\n```\n>  或直接用 `ios::out`，因为out默认包含trunc\n\n\n- 使用位或运算符`|`来同时指定多个模式:\n```cpp\n// 组合使用打开模式\nofstream outFile(\"test.txt\", ios::out | ios::app);\n```\n\n### 错误处理\n\n```cpp\nifstream inFile(\"nonexistent.txt\");\nif (!inFile) {\n    cerr << \"无法打开文件！\" << endl;\n    return 1;\n}\n\n// 或者使用is_open()\nif (!inFile.is_open()) {\n    cerr << \"无法打开文件！\" << endl;\n    return 1;\n}\n```\n\n# 变量\n## String\n需要先引入指定的头文件:\n```cpp\n#include <string>\n```\n\n- 定义时可以使用等号或者用括号包裹字符串:\n```cpp\nstring name = \"John\"; \n// string name(\"John\");\n```\n\n---\n\n### stringstream\n`stringstream` 表示**双向**字符串流:\n- 需要导入头文件`#include <sstream>`;\n- `istringstream` 表示**输入**字符串流\n  - 作用: 将字符串转换成一个类似于输入流的对象;\n  - 内部维护了一个字符串和一个位置指针;\n  - 每次读取时, 位置指针向后移动, 且自动跳过空白字符.\n- `ostringstream` 表示**输出**字符串流.\n\n\n#### 字符串分词\n自动以**空白字符**(空格、制表符\\t、换行符\\n等)分割字符串;\n\n```cpp\n#include <string>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nint main(){\n    string name ( \"Xiao Ming\");\n\n    // 使用括号包字符串\n    istringstream is (name); \n    string s;\n    while (is>>s){\n        cout << s << endl;\n    }\n}\n```\n> `>>` 表示从输入流中读取数据;\n>\n> 注意字符串流也是一种类型, 作用的对象是字符串.\n\nOutput:\n```shell\nXiao Ming\nXiao\nMing\n```\n\n包含更多分词的字符串:\n```cpp\n#include <string>\n#include <iostream>\n#include <sstream>\n\nusing namespace std;\nint main(){\n    string words = \"hello \\n world! \\t I am \\n here!\";\n    stringstream is (words);\n    \n    string word;\n    int count  = 1;\n    while(is >> word){\n        cout << \"Word \" << count << \": \" << word << endl;\n        count++;\n    }\n}\n```\nOutput:\n```shell\nWord 1: hello\nWord 2: world!\nWord 3: I\nWord 4: am\nWord 5: here!\n```\n\n#### 字符串拼接\n```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ostringstream oss;\n    string name = \"Alice\";\n    int age = 25;\n    \n    oss << \"Name: \" << name << \", Age: \" << age;\n    string result = oss.str();\n    cout << result << endl;\n}\n```\nOutput:\n```shell\nName: Alice, Age: 25\n```\n> 通过`.str()`方法可以对象转换为字符串类型, 从而**格式化输出**.\n\n<br>\n\n`.str(\"\")`方法可以**清空**字符串流:\n\n```cpp\n#include <sstream>\n#include <string>\n#include <iostream>\n\nusing namespace std;\n\nint main() {\n    ostringstream oss;\n    string name = \"Alice\";\n    int age = 25;\n    \n    oss << \"Name: \" << name << \", Age: \" << age;\n    oss.str(\"\");\n    string result = oss.str();\n    cout << result << \"Nothing\" << endl;\n}\n```\nOutput:\n```shell\nNothing\n```\n\n### Getline\n**基本语法:**\n```cpp\ngetline(istream& is, string& str, char delim = '\\n');\n```\n- `is`: 输入流（通常是cin;\n- `str`: 存储结果的字符串;\n- `delim`: 分隔符, 默认为换行符`\\n`.\n\n**Example**:\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string line;\n    \n    cout << \"请输入一行文本：\";\n    getline(cin, line);  // 读取整行，包括空格\n    cout << \"你输入的是：\" << line << endl;\n    \n    // 使用自定义分隔符\n    string data;\n    cout << \"请输入内容（用,分隔）：\";\n    getline(cin, data, ',');  // 读取直到遇到逗号\n    cout << \"读取到逗号前的内容：\" << data << endl;\n}\n```\n\n### cin\n**特点**:\n- 以空白字符（空格、制表符、换行符）为分隔符;\n- **忽略**前导空白字符;\n- 遇到空白字符就停止读取.\n\n\n通常需要与`getchar()`方法配合来清除缓冲区当中的`\\n`字符:\n```cpp\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    int number;\n    string line;\n    \n    cout << \"输入一个数字：\";\n    cin >> number;\n    \n    //清除输入缓冲区中的换行符\n    getchar(); // or cin.ignore(); \n   \n    cout << \"输入一行文本：\";\n    getline(cin, line);  // 现在可以正确读取整行\n    \n    cout << \"数字：\" << number << endl;\n    cout << \"文本：\" << line << endl;\n}\n```\n> 如果输入`8 \\n`, 则`getchar()`读取空格, 文本为空.\n\n### Alter String\n**outline** : 常用的字符串方法(成员函数):\n\n```cpp\ninsert(size_t pos, const string& s);\nerase (size_t pos = 0, size_tlen = npos);\nappend (const string& str);\nreplace (size_t pos,size_t len,const string& str);\n```\n\n---\n#### 常用方法\n\n- `insert(int pos, string str)` 在指定位置插入字符串\n```cpp\nstring str = \"Hello World\";\n// 在位置5处插入字符串\nstr.insert(5, \" Beautiful\");\ncout << str << endl;  // 结果: \"Hello Beautiful World\"\n\n// 在字符串末尾插入内容\nstr.insert(str.length(), \"!\");\ncout << str << endl;  // 结果: \"Hello Beautiful World!\"\n\n// 插入单个字符（使用string构造）\nstr.insert(0, \">\");\ncout << str << endl;  // 结果: \">Hello Beautiful World!\"\n```\n\n---\n- `erase(int pos, int length)` 删除从指定位置开始的若干个字符\n```cpp\nstring str = \"Hello Beautiful World!\";\n\n// 删除从下标6开始的9个字符\nstr.erase(6, 9); \ncout << str << endl;  // 结果: \"Hello World!\"\n\n// 删除从某个位置开始到末尾的所有字符\nstr.erase(5);\ncout << str << endl;  // 结果: \"Hello\"\n```\n> `length`参数省略, 则删除从`pos`位置开始到字符串末尾的所有字符.\n\n\n---\n\n- `replace (int pos, int length, string)` 替换指定位置的字符串\n```cpp\n// 从位置6开始，替换5个字符为\"C++\"\nstring str = \"Hello World!\";\nstr.replace(6, 5, \"C++\");\ncout << str << endl;  // 结果: \"Hello C++!\"\n```\n\n\n---\n\n\n- `append (const string& str);`\n```cpp\n// 添加整个字符串\nstring1.append(string2);\n\n// 添加指定位置的字符(索引从开始)\nstring1.append(string2, start, length);\n\n// 重复字符的添加\nstring1.append(count, char);\n\n```\n\n除此之外, 还存在着使用$\\underline{迭代器}$的用法: \n> 类似于指针, 指向容器(如字符串、数组等)的特定位置.\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main() {\n    string source = \"World!\";\n    string target = \"Hello \";\n    \n    // 添加source中的部分字符（从开始到结束）\n    target.append(source.begin(), source.end());\n    cout << target << endl;  // 输出: Hello World!\n    \n    // 只添加部分字符\n    string target2 = \"Hello \";\n    target2.append(source.begin(), source.begin() + 5);  // 只添加\"World\"，不包含\"!\"\n    cout << target2 << endl;  // 输出: Hello World\n    \n    return 0;\n}\n```\n1. `begin()`方法返回字符串的第一个字符的迭代器, `end()`方法返回字符串最后一个字符的**下一个**位置的迭代器;\n2. 迭代器的范围是**左闭右开**.\n\n---\n\n#### 其他方法\n\n- `find(string, int pos)` 从指定的位置开始寻找字符串位置\n```cpp\nstring str = \"Hello World Hello\";\n// 从位置0开始查找\"Hello\"\ncout << str.find(\"Hello\", 0) << endl;     // 结果: 0\n// 从位置1开始查找\"Hello\"\ncout << str.find(\"Hello\", 1) << endl;     // 结果: 12\n// 查找不存在的字符串\ncout << str.find(\"Python\") << endl;       // 结果: string::npos\n```\n  - `string::npos`是`size_t`类型的最大值;\n  - 可以使用`str.find(\"Python\") == string::npos`作为判断条件, 检查是否找到字符串.\n\n---\n\n- `compare(string)` 字符串比较\n```cpp\nstring str1 = \"Hello\";\nstring str2 = \"Hello\";\nstring str3 = \"World\";\n\ncout << str1.compare(str2) << endl;  // 结果: 0  (相等)\ncout << str1.compare(str3) << endl;  // 结果: -15 (str1 < str3) \ncout << str3.compare(str1) << endl;  // 结果: 15  (str3 > str1)\n```\n  - 按照字典序比较得到结果\n\n---\n\n- `to_string(int)` 将数字转换成字符串\n```cpp\nint num = 123;\nstring str = to_string(num);\ncout << str << endl;          // 结果: \"123\"\ncout << str + \"456\" << endl;  // 结果: \"123456\"\n```\n  - 字符串之间可以通过`+`直接拼接.\n\n---\n\n- `stoi(string)` 将字符串转换成整数\n```cpp\nstring str = \"123\";\nint num = stoi(str);\ncout << num + 456 << endl;    // 结果: 579\n// 注意：字符串必须是合法的数字格式\n// string str = \"abc\"; \n// int num = stoi(str);  // 这会抛出异常\n```\n  - 字符串必须是合法的数字格式;\n  - ` int num = stoi(\"abc\");`  将会抛出异常\n\n---\n\n### 构造函数\n**Outline:**\n```cpp\nstring(const char *cp, int len);\nstring(const string& s2, int pos);\nstring(const string& s2, int pos, int len);\n```\n\n---\n\n- `string(const char *cp, int len)` 字符数组创建字符串\n```cpp\nstring str1(\"Hello World\", 5);\ncout << str1 << endl;\n// 输出: Hello\n```\n\n- `string(const string& s2, int pos)` 从现有字符串创建新字符串，从指定位置到末尾\n```cpp\nstring s2 = \"Hello World\";\nstring str2(s2, 6);\ncout << str2 << endl;\n// 输出: World\n```\n\n- `string(const string& s2, int pos, int len)` 从现有字符串创建新字符串，指定起始位置和长度\n```cpp\nstring s3 = \"Hello World\";\nstring str3(s3, 6, 3);\ncout << str3 << endl;\n// 输出: Wor\n```\n\n- `string(int length, char c)` 用指定长度的字符c初始化字符串\n```cpp\nstring str4(5, '*');\ncout << str4 << endl;\n// 输出: *****\n\n// 实际应用示例\nint num = 432;\nstring str = to_string(num);\ncout << string(5 - str.length(), '0') + str << endl;\n// 输出: 00432\n```\n\n\n### 成员函数\n\n```cpp\n// 提取子字符串\nsubstr(int pos, int len);\nstring str = \"Hello World\";\nstring sub = str.substr(6, 3);  // 结果: \"Wor\"\n```\n\n```cpp\n// 字符串赋值\nassign();\nstring str1 = \"Hello\";\nstring str2;\nstr2.assign(str1);  // str2现在是 \"Hello\"\n```\n\n\n```cpp\n// 在指定位置插入字符串\n    string str1 = \"hello\";\n    string str2 = \"world\";\n    str1.insert(3, str2);\n    cout << str1 << endl;\n// 结果: helworldlo \n```\n\n```cpp\n// 删除指定位置的指定长度的字符\nerase(int pos, int len);\nstring str = \"Hello World\";\nstr.erase(5, 6);  // 结果: \"Hello\"\n```\n\n**Notice：**\n1. 所有位置索引都是从0开始计数\n2. 如果指定的长度超过字符串实际长度，会自动调整到实际可用长度\n3. 使用这些函数时要注意检查参数的有效性，避免越界访问\n4. `.assign(str, pos, len)`: 相比于直接赋值, `assign`还提供了精确控制赋值的方法, 也就是指定内容字符串的起始位置和长度.\n\n---\n### Substr\n在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. `substr()`方法可以精确地获取字符串片段.\n\n`substr`即substring的缩写, 表示子字符串.\n\n**基本语法**\n```cpp\nstring substr(int pos, int len) ;\n```\n参数分别表示截取的起始下标以及要截取的长度(如果省略`len`将截取到字符串的末尾).\n\n**e.g.**:\n```cpp\nstring email = \"user.name@example.com\";\n\n// 获取用户名的部分\nint atPos = email.find('@');\nstring username = email.substr(0, atPos); // result: \"user.name\"\n\n// 获取域名部分\nstring domain =  email.substr(atPos + 1); // result: \"example.com\"\n\n// 获取顶级域名(最后一个.之后的部分)\nint lastDotPos = email.rfind('.');\nstring topLevelDomain = email.substr(lastDotPos + 1); // result: \"com\"\n```\n- `rfind()`方法: 会从字符串的**末尾向前**搜索，从而返回要查找的字符或子字符串此时第一次出现的位置。如果没有找到，则返回 string::npos.\n\n---\n\n# Function\n\n## Default arguments\n\n要点:\n\n- 默认值必须在函数原型中从右到左地给出, 否则在调用的时候无法分辨;\n\n- 默认值只能出现在函数原型 或者 将声明和定义放在一起, 下面的情况会报错:\n\n  ```cpp\n  void f(int i, int j = 10);\n  int main()\n  {\n      ...\n  }\n  void f(int i, int j = 10){\n      ...\n  }\n  ```\n\n\n\n\n\n\n\n# Group\n\n**选择的标准:**\n\n- 一般情况 $\\Rightarrow$ `vector`;\n- 程序需要对元素进行**随机访问** $\\Rightarrow$ `vector` or `deque`;\n- 程序需要在容器**中间插入**元素 $\\Rightarrow$ `list` or `forward_list`;\n- 程序需要在容器的**首尾插入**元素 $\\Rightarrow$ `deque`;\n- 容器中的元素**相对较小**但是数量较多 $\\nRightarrow$ `list` nor `forward_list`.\n  - 否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.\n\n\n\n## Pair\n\n### 基本介绍\n\n#### 1. 基本概念\npair 是 C++ 标准库提供的模板类，用于<u>将两个不同类型的值组合成一个对象</u>。它定义在 `<utility>` 头文件中。\n\n#### 2. 创建与初始化\n```cpp\n// 默认构造\nstd::pair<std::string, int> p1;\n\n// 直接初始化\nstd::pair<std::string, int> p2(\"tag\", 10);\n\n// 使用make_pair\nauto p3 = std::make_pair(\"data\", 5);\n\n// 统一初始化\nstd::pair<std::string, int> p4{\"value\", 8};\n```\n\n#### 3. 访问元素\n```cpp\n// 传统访问方式\nstd::cout << p2.first << \": \" << p2.second << endl;\n\n// 结构化绑定(C++17)\nauto [key, val] = p3;\nstd::cout << key << \": \" << val << endl;\n```\n\n#### 4. 常用操作\n```cpp\n// 比较操作\nif (p1 == p2) {...}\nif (p1 < p2) {...}  // 先比较first，再比较second\n\n// 交换内容\np1.swap(p2);\nstd::swap(p1, p2);\n```\n\n#### 5. 实际应用示例\n```cpp\n// 作为函数返回值\nstd::pair<bool, string> checkInput(const string& input) {\n    if (input.empty()) {\n        return {false, \"输入不能为空\"};\n    }\n    return {true, \"\"};\n}\n\n// 在容器中使用\nvector<pair<string, int>> dataList = {\n    {\"item1\", 10},\n    {\"item2\", 20},\n    {\"item3\", 30}\n};\n\n// 与map配合使用\nmap<string, pair<int, double>> complexData;\n```\n\n#### 6. 注意事项\n1. pair 的元素可以是任意类型，包括自定义类型\n2. 使用结构化绑定需要C++17或更高标准\n3. pair 常用于需要返回多个值的函数\n4. 在性能敏感场景要注意构造和拷贝开销\n\n\n\n## Set\n\n**集合**: 用于存储一组不允许重复的元素, 且会自动排序.\n\n可以使用的方法包括:\n\n1. `.insert( )`: 插入元素;\n\n2. `.erase()`: 删除元素. 如果输入是元素值, 那么返回1/0表示是否成功删除; 如果输入是迭代器, 那么返回的是**下一个元素的迭代器**.\n\n3. `.find( )`: 寻找元素, 如果找到 返回对应的 **迭代器**. 否则返回 `.end( )`;\n\n   \n\n## Vector\n\n存储元素在**连续的内存空间**中, 支持**随机访问**.\n- 可以动态增长, 适合存储**未知数量**的元素;\n- 通过下标访问元素的时间复杂度为 O(1);\n- 在末尾插入和删除元素的时间复杂度为 O(1);\n- 在中间插入和删除元素的时间复杂度为 O(n);\n- **使用场景**: 需要随机访问、排序、内存连续存储的场景.\n\n**语法**:\n- 使用 `.end()`返回一个指向容器**末尾后一个位置**的迭代器:\n  ```c++\n  auto it = find(vec.begin(), vec.end(), value);  // 查找 value\n    if (it != vec.end()) {         // 如果找到了（即没有返回 end()）\n        vec.erase(it);             // 则删除找到的元素\n    }\n  ```\n- 使用 `.push_back()`在末尾插入元素, 或者使用`.emplace_back()`在末尾原位构造元素(更加高效);\n  ```c++\n  vec.push_back(10);\n  vec.emplace_back(20); //更加高效\n  ```\n  > `emplace_back`方法**直接**在容器的**内存空间中构造**对象, 相比于`push_back`而言更加**高效**.\n- `.erase()`方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;\n  \n    ```c++\n     vec.erase(vec.begin() + 1);       // 删除第二个元素\n     vec.erase(vec.begin(), vec.begin() + 3); // 删除前三个元素\n     vec.clear();                      // 清空整个 vector\n    ```\n    > `vec.clear();` 将会清空整个vector.\n    >\n    > 和`insert`需要的参数一样, 都需要**迭代器**而非索引来定位.\n- `vec[i]`的形式访问, 使用`vec.at(i)`的方式可以在越界时抛出异常;\n- `.begin()`和`.end()`获取迭代器, 使用范围for循环遍历元素;\n    ```c++\n     cout << \"Vector elements:\" << endl;\n     for (int num : vec) {\n        cout << num << \" \";\n     }\n     cout << endl;\n    \n    //使用迭代器遍历\n    for (auto it = vec.begin(); it != vec.end(); ++it) {\n        cout << *it << \" \";\n    }\n    cout << endl;\n    ```\n- `.size()`获取`vector`的大小, `.empty()`判断`vector`是否为空;\n  ```c++\n  cout << \"Vector size: \" << vec.size() << endl;\n  if (vec.empty()) {\n      cout << \"Vector is empty.\" << endl;\n  }\n  ```\n- 使用`sort()`对`vector`进行排序, 使用`find()`查找元素;\n  ```c++\n  sort(vec.begin(), vec.end());   // 排序\n  auto it = find(vec.begin(), vec.end(), 5); // 查找 5\n  ```\n  \n- `insert` 插入的位置是指定的迭代器位置之前一个;\n\n### Reserve\n为了避免频繁地扩展内存, 可以通过`reserve`预先分配合适的空间, 同时通过`.reszie()`调整大小;\n```cpp\nvector<string> v2;\nv2.reserve(1000);  // 一次性分配 1000 个元素的空间\n\nv2.resize(v2.size() + v2.size()/2); // 调整大小为原来的 1.5 倍\n```\n\n`reserve`只分配空间而不创建元素,`resize`将同时分配元素(默认值):\n\n```cpp\nvector<string> vec;\n// reserve: 只分配空间，不创建元素\nvec.reserve(10);  \ncout << \"The capacity with reserve: \" << vec.capacity() << endl;\ncout << \"The size with reserve: \" << vec.size() << endl;    \n\n// resize: 分配空间并创建元素\nvec.resize(10);   \ncout << \"The capacity with resize: \" << vec.capacity() << endl;\ncout << \"The size with resize: \" << vec.size() << endl;   \n```\n\n**Output**:\n```shell\nThe capacity with reserve: 10\nThe size with reserve: 0\nThe capacity with resize: 10\nThe size with resize: 10\n```\n> [!important]\n>\n> `.push_back()`的实际作用是在容器索引的`size`处插入元素.\n>\n>  而`reserve`不会影响容器的`size`,  初始化和`resize`会影响并且填充默认值:\n\n**e.g.  验证:**\n\n```cpp\nint main() {\n    vector<int> vec(10);\n    \n    // 打印初始状态\n    cout << \"初始状态：\\n\";\n    cout << \"size: \" << vec.size() << \", capacity: \" << vec.capacity() << \"\\n\\n\";\n    \n    // 预留5个空间\n    vec.reserve(15);\n    cout << \"reserve(15) 后：\\n\";\n    cout << \"size: \" << vec.size() << \", capacity: \" << vec.capacity() << \"\\n\\n\";\n    \n    vec[20] =20;\n\n    // 添加元素并观察\n    cout << \"添加元素过程：\\n\";\n    for(int i = 1; i <= 6; i++) {\n        vec.push_back(i);\n        cout << \"添加 \" << i << \" 后 - \";\n        cout << \"size: \" << vec.size() \n             << \", capacity: \" << vec.capacity()\n             << \", 元素: \";\n        for(int x : vec) cout << x << \" \";\n        cout << \"\\n\";\n    }\n    \n    return 0;\n}\n\n```\n\n**Output:**\n\n```shell\n初始状态：\nsize: 10, capacity: 10\n\nreserve(15) 后：\nsize: 10, capacity: 15\n\n添加元素过程：\n添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 \n添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 \n添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 \n添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 \n添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 \n添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 \n```\n\n1. 此处的 `vector<int> vec(10);`初始化了10个默认值的`int`类型的元素;\n2. `vec[20] = 20;`没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;\n   1. 如果换成`vec.at(20) = 20`将会在编译时报错;\n3. 可以发现, `reserve`的作用就是避免了多次自动扩容.\n\n> `reserve`的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素**copy**到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.\n\n\n\n### Resize\n\n用法的枚举:\n\n1. `resize(n)`: 将vector的大小调整为n, 如果大于当前值, 则在末尾添加具有默认值的新元素;\n\n2. `resize(n, val)`: 同样调整大小, 但是指定了默认值为新的 `val`;\n\n3. 对于二维向量的内存分配也是类似的:\n\n   ```cpp\n   \tvector<vector<int>> m;  //二维码向量;\n     ...\n     m.resize(r,vector<int>(c,0)); //初始化为一个r行c列且初始值为0的矩阵.\n   ```\n\n   \n\n## List\n\n- 在`list`容器当中, 迭代器是双向迭代器;\n  - 双向迭代器不支持大小的比较, 只支持 `==`,`!=`,`++`,`--`;\n  因此, 注意实际的使用:\n```cpp\nlist<int> lst1;\nlist<int>::iterator iter1 = lst1.begin();\nlist<int>::iterator iter2 = lst1.end();\n\n// 正确的写法\nwhile (iter1 != iter2) {\n    // 处理当前元素\n    ++iter1;\n}\n\n// 错误的比较\n// while(iter1 < iter2) \n    \n```\n\n### 有序链表\n```cpp\n#include <iostream>\n#include <list>\n#include <string>\n\n\nusing namespace std;\n\nint main() {\n    list<string> s;\n    string str;\n    list<string> :: iterator p;\n    int count ;\n\n    cout << \"enter the number of the strings:\" << endl;\n\n    cin >> count; \n\n\n    for(int i = 0; i < count; i++){\n        cout << \"enter a string:\" ;\n        cin >>str;\n        \n        p = s.begin();\n        while(p != s.end() && *p <str)\n            p++;\n        s.insert(p,str);\n    }\n    for(p = s.begin(); p!=s.end(); p++)\n        cout << *p << endl;\n    cout << endl;\n    return 0;\n}\n```\n\n**分析:**\n- `while(p != s.end() && *p <str)` 每次输入`str`时, 令迭代器从`list`的开头开始, 进行字典序的比较;\n\n> [!important]\n>\n> 找到插入的位置, 利用`insert()`方法插入到给出迭代器的**前面**!.\n\n\n\n\n\n## Deque\n`deque`即 double-ended queue, **双端队列**.\n\n支持:\n- 在两端快速的插入或删除;\n- 随机访问;\n\n**语法**:\n```cpp\n#include <deque>\ndeque<int> dq;\n\n// 1. 插入操作\ndq.push_back(1);    // 在末尾插入\ndq.push_front(2);   // 在开头插入\ndq.insert(pos, val);// 在指定位置插入\n\n// 2. 删除操作\ndq.pop_back();      // 删除末尾元素\ndq.pop_front();     // 删除首部元素\ndq.erase(pos);      // 删除指定位置元素\n\n// 3. 访问操作\ndq[0];              // 随机访问\ndq.at(1);           // 带边界检查的访问\ndq.front();         // 访问第一个元素\ndq.back();          // 访问最后一个元素\n```\n\n**示例:**\n```cpp\n#include <deque>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    deque<int> dq;\n    \n    // 在两端插入元素\n    dq.push_back(3);\n    dq.push_front(1);\n    dq.push_back(4);\n    dq.push_front(8);\n    \n    // dq ：{8, 1, 3, 4}\n    \n    // 使用随机访问\n    for(size_t i = 0; i < dq.size(); ++i) {\n        cout << dq[i] << \" \";\n    }\n\n}\n\n```\n\n### Forward_list\n`forward_list`即 单项链表.\n\n- 只能向前遍历, 即对应的迭代器不支持`--`而支持`++`.\n- 同时不支持下标访问以及随机访问.\n- 单项链表的设计, 使得内部的每个节点只需要**一个**指针来指向下一个节点, 从而比`list`双向链表更加**节省内存.**\n\n**语法**:\n\n```cpp\n#include <forward_list>\nforward_list<int> fl;\n\n// 1. 插入操作\nfl.push_front(1);           // 在开头插入\nfl.insert_after(pos, val);  // 在指定位置之后插入\n\n// 2. 删除操作\nfl.pop_front();            // 删除第一个元素\nfl.erase_after(pos);       // 删除指定位置之后的元素\n\n// 3. 访问操作\nfl.front();               // 访问第一个元素\n\n// 4. 特殊操作\nfl.before_begin();        // 返回第一个元素之前的迭代器\nfl.begin();               // 返回第一个元素的迭代器\n```\n\n**示例**:\n\n```cpp\n#include <forward_list>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    forward_list<int> fl;\n    \n    // 插入元素\n    fl.push_front(3);\n    fl.push_front(2);\n    fl.push_front(1);\n    \n    // 在特定位置后插入\n    auto it = fl.begin(); // 指向第一个元素\n    fl.insert_after(it, 4); // 在第一个元素后插入4\n    \n    // 遍历打印\n    for(const auto& val : fl) {\n        cout << val << \" \";\n    }\n    // 输出：1 4 2 3\n}\n```\n\n#### 访问前一个元素\n由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合`before_begin()`方法.\n\n```cpp\n// 如果需要访问某个元素的前一个元素，必须从头开始遍历\nauto prev = fl.before_begin();\nauto curr = fl.begin();\nwhile(curr != fl.end() && *curr != target) {\n    ++prev;\n    ++curr;\n}\n```\n\n## Map\n作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键**自动排序**\n- 如果插入重复的key, 将会覆盖原有的value;\n- 通过键查找元素、插入和删除的时间复杂度均为O(log n);\n- **使用场景**: 字典、索引、统计等.\n\n**语法**:\n- 使用 `.end()`返回一个指向容器**末尾后一个位置**的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于`map`当中;\n  ```cpp\n  auto it = ages.find(\"Charlie\");  // 查找 \"Charlie\"\n    if (it != ages.end()) {         // 如果找到了（即没有返回 end()）\n        ages.erase(it);             // 则删除找到的元素\n    }\n  ```\n- 使用下标(键)直接插入,或者通过键值对插入\n  ```cpp\n  ages[\"Alice\"] = 25;\n  ages.insert({\"Bob\", 30});\n  ages.emplace(\"Charlie\", 28); // 使用 emplace 插入 (更高效)\n  ```\n  > `emplace`方法指**直接**在容器的**内存空间中构造**对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于`insert`而言更加**高效**.\n- `.erase()`方法删除指定key的元素, 也可以通过`.find()`找到key对应的迭代器`it`, 然后`erase(it)`.\n  \n    ```cpp\n    ages.erase(\"Bob\");           // 删除键为 \"Bob\" 的元素\n    \n    auto it = ages.find(\"Charlie\");\n    if (it != ages.end()) {\n        ages.erase(it);         // 删除迭代器指向的元素\n    }\n    ```\n    > `ages.clear();` 将会清空整个map.\n- `map[key]`的形式访问, 使用`map.at(key)`的方式可以在key不存在时抛出异常;\n- `.find(key)`查找对应键的元素( 返回**迭代器** ), `.count(key)`返回对应键的元素个数(0 or 1)\n- `.size()`获取map的大小.\n- 迭代器的`->first`和`->second`可以分别访问键和值.\n    ```cpp\n     cout << \"Map elements:\" << endl;\n     for (auto mapIt = ages.begin(); mapIt != ages.end(); ++mapIt) {\n        cout << mapIt->first << \": \" << mapIt->second << endl; // 访问键和值\n     }\n    ```\n\n## Iterator\n迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.\n\n- **标记位置**: `.begin()`和`.end()` 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;\n\n迭代器的分类:\n- 输入迭代器: 支持读取和递增操作;\n  - `istream_iterator`: 用于从输入流读取数据;\n- 输出迭代器: 支持写入和递增操作;\n  - `ostream_iterator`: 用于向输出流写入数据;\n- 前向迭代器: 具有输入、输出迭代器的**所有**功能, 并且可以多次遍历同一个序列;\n  - 比如`forwarf_list`的迭代器:`auto it = flist.begin()` or `forward_list<int>::iterator it = flist.begin()`;\n- 双向迭代器: 在前向迭代器的原有功能上, 同时支持**递减**操作;\n  - 比如双向链表`list`的迭代器.\n    ```cpp\n    #include <iostream>\n    #include <list>\n    using namespace std;\n    \n    int main() {\n        list<int> myList = {10, 20, 30, 40, 50};\n    \n        // 使用双向迭代器正向遍历\n        cout << \"Forward traversal: \";\n        for ( list<int>::iterator it = myList.begin(); it != myList.end(); ++it) {\n            cout << *it << \" \";\n        }\n        cout <<  endl;\n    \n        // 使用双向迭代器逆向遍历\n        cout << \"Reverse traversal: \";\n        for ( list<int>::reverse_iterator rit = myList.rbegin(); rit != myList.rend(); ++rit) {\n            cout << *rit << \" \";\n        }\n        cout <<  endl;\n    \n        return 0;\n        // Forward traversal: 10 20 30 40 50 \n        // Reverse traversal: 50 40 30 20 10 \n    }\n    ```\n    > 1. `reverse_iterator`用于声明逆向遍历的迭代器, 也可以使用`auto`直接声明.\n    > 2. `rbegin()`和`rend()`分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的`++`相当于正向遍历时的`--`操作.\n- 随机访问迭代器: 具有双向迭代器的所有功能, 同时支持**随机访问**, 如`it+n`,`it[n]`.\n  - 比如`vector`的迭代器.\n  ```cpp\n    vector<int> vec = {10, 20, 30, 40, 50};\n    cout << \"Vector elements (random access): \";\n    for (int i = 0; i < vec.size(); ++i) {\n        cout << vec[i] << \" \"; // 使用下标随机访问\n    }\n    cout << endl;\n  ```\n\n另外, 还有一种迭代器称为**插入迭代器**, 比如`back_inserter`\n```cpp\nvector<int> vec = {10, 20, 30, 40, 50};\n\n//结合copy将容器的元素直接插入到另一个容器中\nvector<int> dest = {60,70};\ncopy(vec.begin(), vec.end(), back_inserter(dest)); // 在 dest 末尾插入元素\ncout << \"Copied vector: \";\nfor (int num : dest) {\n    cout << num << \" \";\n}\ncout << endl;\n// Copied vector: 60 70 10 20 30 40 50 \n```\n\n## for-each\nfor-each 循环的语法：\n```cpp\nfor (range_declaration : range_expression) {\n    loop_statement;\n}\n```\n- range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 `auto `关键字让编译器自动推导类型;\n- range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或**字符串**;\n- loop_statement： 循环体，包含要对每个元素执行的语句.\n\ne.g:\n```cpp\n\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> numbers = {1, 2, 3, 4, 5};\n\n    // 使用 for-each 循环遍历 vector\n    for (int num : numbers) {\n        std::cout << num << \" \"; // 输出每个元素\n    }\n    std::cout << std::endl;\n\n    // 使用 auto 关键字自动推导类型\n    for (auto num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    // 修改容器中的元素（需要使用引用）\n    for (int &num : numbers) {\n        num *= 2; // 将每个元素乘以 2\n    }\n\n    // 输出修改后的元素\n    for (auto num : numbers) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```\n- `for (int &num : numbers)`：使用引用 &，可以直接修改容器中的元素.\n\n### Map的循环\n当range_expression是`map`时, 可以使用`auto`自动推导range_declaration的类型.需要注意是:\n- 用迭代器的方式访问`map`中的键值对的形式是 `it->first`与`it->second`;\n- 在`for-each`循环当中, range_declaration是一个值, 因此使用`.first`与`.second`来访问键和值.\n    ```cpp\n    #include <iostream>\n    #include <vector>\n    #include <map>\n    #include <string>\n    #include <algorithm>\n    \n    using namespace std;\n    \n    int main(){\n        map<string, string> m = {{\"one\", \"1\"}, {\"two\", \"2\"}, {\"three\", \"3\"}};\n        vector<string> vec;\n    \n        for(auto& entry : m){\n            vec.push_back(entry.first + \":\" + entry.second );\n        }\n        copy(vec.begin(), vec.end(), ostream_iterator<string>(cout, \" \"));\n    }\n    ```\n    **Output:**\n    ```shell\n    one:1 three:3 two:2\n    ```\n> 此处由于`map`自动按照键的字典序进行排序, 因此输出时`three`的元素在`two`前;\n\n在上述的示例中, 也可以使用下面的方式进行`vec`的输出:\n```cpp\nfor(const auto& s : vec) {\n    cout << s << \" \";\n}\n```\n此时`auto`会自动推导为`string`类型, 且`&`对数组的元素进行了引用, 使得输出更加高效.\n\n### Pro&Con\n`for-each`循环的优点:\n- 消除了访问数组等越界的风险;\n- 不需要事先初始化迭代器;\n\n`for-each`循环的缺点:\n- 无法获取元素的索引;\n- 只能顺序地遍历.\n\n## typedef\n我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.\n\n而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.\n```cpp\ntypedef old_type new_type;\n```\n\n## Notices\n1. 直接对数组、字符串和`vector`进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;\n2. 对于`vector`, 可以通过`.at() = `的方式进行安全访问, 编译器会进行边界检查. 或者通过`.push_back()` or `.emplace_back`的方式在末尾赋值. 同时注意用`.reserve()`预先分配充分的内存空间.\n3. 避免不经意地向`map`当中插入元素:\n   1. 错误的示范:\n    ```cpp\n    if(foo[\"bob\"] == 1){...}\n    // 设置默认的零值\n    ```\n   2. 使用`.count()`方法正确检查元素是否存在:\n    ```cpp\n    if( foo.count(\"bob\") ){...}\n    ```\n   3. 也可以使用`find()`方法检查元素是否存在:\n   ```cpp\n    auto it = m.find(\"four\");\n   \n    if(it  != m.end()){\n        cout << it->second << endl;\n    }\n    else{\n        cout << \"Not found\" << endl;\n    }\n   ```\n4. 使用`.empty()`方法来检查容器**整体是否为空**, 而非`.count() == 0`的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.\n5. `erase()` 方法会返回**指向**被删除元素的**下一个**元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:\n   \n    ```cpp\n    //Initialize a list\n    list<int> L;\n    list<int>::iterator li = L.begin();\n    \n    // Wrong:\n    L.erase(li);    // 删除元素后，li 变成了无效迭代器\n    ++li;           // 错误, 不能对无效迭代器进行操作\n    \n    // Correct:\n    li = L.erase(li);  // 删除元素后，li 被更新为指向被删除元素的下一个元素\n    ```\n\n# 指针\n- Pointers to Objects\n```cpp\nstring str = \"hello\";\nstring *p = &str;\n```\n\n- Oprators with Pointers\n  - `&`: 取地址;\n  - `*`: 解引用;\n  - `->`: 用于访问对象的成员.\n```cpp\n(*p).length();\n// 等价于\np->length();\n```\n> `length()`即为`string`类的成员函数, 因此可以用`->`来访问.\n\n\n# 常量\n\n## 指针\n> 以`char`为例.\n\n- 指向常量的指针 `const char *p`\n  - 可以改变指针的地址.\n  - 无法通过指针改变对象的值\n- 常量指针 `char * const p`\n  - 指针指向的地址无法改变;\n  - 但是可以通过指针改变对象的值\n  如果需要同时保证地址和值都无法改变, 则需要使用`const char * const p`.\n\n\n\n如果`sp`是指向字符串的指针, 那么这两种的写法是等价的, 注意`.`的优先级高于`*`, 因此括号不可忽略.\n\n```cpp\nsp->length();\n(*sp).length();\n```\n\n\n\n# Class\n\n### `::`\n\n`::` resolver: 作用域解析运算符\n\n- 作用: \n\n  - 访问全局的作用域\n    当局部变量和全局变量同名时, 可以使用 `::` 来访问全局变量\n\n    ```cpp\n    int value = 10; // 全局变量\n    \n    void function() {\n        int value = 20; // 局部变量\n        cout << value;    // 输出 20（局部变量）\n        cout << ::value;  // 输出 10（全局变量）\n    }\n    ```\n\n  - 访问命名空间中的成员\n\n    ```cpp\n    namespace Math {\n        const double PI = 3.14159;\n    }\n    \n    double circumference = 2 * Math::PI * radius; // 使用命名空间中的常量\n    ```\n\n- 语法:\n\n  - `<class_name> :: <function_name>`\n  - `::<function_name>`  全局作用域\n\n\n\ne.g. \n\n```cpp\nvoid S::f() {\n    ::f();  // Would be recursive otherwise!\n    ::a++;  // Select the global a\n    a--;    // The a at class scope\n}\n```\n\n> `S::f()`: 定义了属于类S的成员函数f;\n>\n> `::f()`:表示调用全局作用域中的函数 `f()`, 默认为递归调用当前的成员函数;\n>\n> `::a++`表示将全局作用域的 `a` 自增, `a--`则访问并递减类作用域中的成员变量 `a`.\n\n\n\n### `this`\n\n`this`指针是成员函数的隐藏参数. 指向**当前对象的实例**.\n\n```cpp\nvoid Point::move(int dx, int dy);\n//等价于\nvoid Point::move(Point *this, int dx, int dy);\n```\n\n当调用成员函数时, 对象的地址会自动作为 `this`参数传递.\n\n\n\n在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 `this`:\n\ne.g\n\n```cpp\nclass Point {\nprivate:\n    int x, y;\n    \npublic:\n    // 移动点的位置\n    void move(int dx, int dy) {\n        x += dx;\n        y += dy;\n    }\n    \n    // 打印点的坐标\n    void print() {\n        std::cout << \"Point at (\" << x << \", \" << y << \")\" << std::endl;\n    }\n    \n    // 组合以上两个功能的函数\n    void move_and_print(int dx, int dy) {\n        move(dx, dy);  // 等同于 this->move(dx, dy)\n        print();       // 等同于 this->print()\n    }\n};\n```\n\n> 但是也可以显式指定 `this->move`, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.\n\n\n\n### 封装特性\n\n在OOP中, Object = Attributes + Services, 即数据和操作被**封装**在一起, 构成一个完整的对象.\n\n\n\n### 声明与定义\n\n我们应当在头文件中声明对象的成员及其 `public`,`private`和 `protected`等属性, 并且在 `cpp`文件中给出具体的定义:\n\n> 最好为每个类都建立如此对应的头文件和源文件 `cpp`.\n\ne.g. \n\n```cpp\n// Student.h - 类的声明\n#ifndef STUDENT_H\n#define STUDENT_H\n\n#include <string>\nusing namespace std;  // 在头文件中使用\n\nclass Student {\nprivate:\n    // 数据成员\n    string name;     \n    int id;\n    float gpa;\n    \npublic:\n    // 构造函数原型\n    Student(const string& name, int id);\n    \n    // 成员函数原型\n    void setName(const string& newName);\n    string getName() const;\n    void calculateGPA();\n    bool isEligibleForScholarship() const;\n};\n\n#endif // STUDENT_H\n\n```\n\n```cpp\n// Student.cpp - 成员函数的定义\n#include \"Student.h\"\nusing namespace std;  // 在源文件中使用\n\n// 构造函数实现\nStudent::Student(const string& name, int id) {\n    this->name = name;\n    this->id = id;\n    this->gpa = 0.0;\n}\n\n// 成员函数实现\nvoid Student::setName(const string& newName) {\n    name = newName;\n}\n\nstring Student::getName() const {\n    return name;\n}\n\nvoid Student::calculateGPA() {\n    // 实现GPA计算逻辑\n    // ...\n}\n\nbool Student::isEligibleForScholarship() const {\n    return gpa >= 3.5;\n}\n```\n\n> ` Student::getName() `指的就是类 `Student`中的成员函数 `getName()`.\n\n\n\n具体来说, `.h`头文件当中应该有:\n\n- 外部变量的声明\n  e.g. `extern int globalCounter;  // 仅声明，不定义`\n\n- 函数原型\n  e.g. `int calculateSum(int a, int b);  // 函数声明，不包含实现`\n\n- 类/结构体的声明\n  e.g.\n\n  ```cpp\n  class Student;  // 前向声明\n  \n  // 或完整类声明（不含成员函数定义）\n  class Rectangle {\n  private:\n      double width;\n      double height;\n  public:\n      Rectangle(double w, double h);\n      double getArea() const;\n  };\n  ```\n\n\n\n回顾 `#include`: 将被引用的文件插入 `.cpp` 文件当中\n\n- `#include \"xx.h\"`: 首先在当前目录下寻找;\n\n- `#include <xx.h>`: 直接在指定的目录中寻找\n\n  > 等价于 `#include <xx>`.\n\n\n\n为了避免在多个 `.cpp` 文件中重复引用相同的头文件, 可以通过 `#ifndef`等标记来判断是否需要引用当前的头文件:\n\n```cpp\n#ifndef HEADER_FLAG\n#define HEADER_FLAG\n\n#endif \n```\n\n> `HEADER_FLAG`一般使用完全大写来方便标识, 但是也可以大小写混合.\n\ne.g. \n\n```cpp\n// 文件: vector.h\n#ifndef VECTOR_H\n#define VECTOR_H\n// ...\n#endif // VECTOR_H\n```\n\n## 生命周期管理\n\n当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.\n\n为了确保这些工作不被遗忘, `cpp`的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.\n\n### 构造函数\n\n构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.\n\n- 语法: \n\n```cpp\nclass ClassName {\npublic:\n    // 默认构造函数\n    ClassName();\n    \n    // 带参数的构造函数\n    ClassName(参数列表);\n    \n    // 拷贝构造函数\n    ClassName(const ClassName& other);\n    \n};\n```\n\n> 1. **默认构造函数**：不带参数或所有参数都有默认值;\n> 2. **带参数的构造函数**：接受一个或多个参数;\n> 3. **拷贝构造函数**：从同类型的另一个对象创建新对象.\n\n\n\n- 构造函数初始化列表\n\n  ```cpp\n  Point::Point(int xx, int yy) :x(xx), y(yy) {\n    ...\n  }\n  ```\n\n  > 构造函数时, 传递参数并直接赋值给内部的成员变量 `x` , `y`.\n\n\n\n- 结构体中的构造函数:\n\n  ```cpp\n  struct Y { \n      float f;     // 浮点型成员变量\n      int i;       // 整型成员变量\n      Y(int a);    // 声明了一个接受int参数的构造函数\n  };\n  ```\n\n  > 1. 此处只是声明了构造函数需要 `int a`作为参数, 但是没有给出具体的实现;\n  > 2. 声明结构体对象(数组)  e.g. `Y y1[] = { Y(1), Y(2), Y(3) };`\n\n\n\n### 默认构造\n\n`auto` default constructor: (自动) 默认构造函数. **当且仅当**不存在任何构造函数时, 程序会自动生成默认构造函数, 不作任何的操作.\n\n`默认构造函数`： 在没有参数的情况下可以调用的构造函数， 称为默认构造函数. 其来源除了上述的程序构造以外, 还包括:\n\n1. 显示定义的无参构造函数;\n2. 定义的所有参数都具有默认值的构造函数.\n\n\n\n- 对于成员变量: 不进行初始化;\n\n### 析构函数\n\n析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 `~`. 当对象超出作用域或被显式删除时，析构函数会自动被调用.\n\n```cpp\nclass ClassName {\npublic:\n    ~ClassName();\n};\n```\n\n- 类似于栈, 优先创建的后析构.\n\n\n\n\n\n运用的示例:\n\n```cpp\n#include <iostream>\n#include <cstring>\n\nclass MyString {\nprivate:\n    char* data;\n\npublic:\n    // 默认构造函数\n    MyString() : data(nullptr) {\n        std::cout << \"默认构造函数调用\" << std::endl;\n    }\n\n    // 带参数的构造函数\n    MyString(const char* str) {\n        if (str) {\n            data = new char[strlen(str) + 1];\n            strcpy(data, str);\n        } else {\n            data = nullptr;\n        }\n        std::cout << \"参数构造函数调用\" << std::endl;\n    }\n\n    // 拷贝构造函数\n    MyString(const MyString& other) {\n        if (other.data) {\n            data = new char[strlen(other.data) + 1];\n            strcpy(data, other.data);\n        } else {\n            data = nullptr;\n        }\n        std::cout << \"拷贝构造函数调用\" << std::endl;\n    }\n\n    // 析构函数\n    ~MyString() {\n        delete[] data;\n        std::cout << \"析构函数调用\" << std::endl;\n    }\n\n    // 打印字符串\n    void print() const {\n        std::cout << (data ? data : \"空字符串\") << std::endl;\n    }\n};\n\nint main() {\n    // 测试各种构造函数\n    MyString s1;                  // 默认构造函数\n    MyString s2(\"Hello\");         // 带参数的构造函数\n    MyString s3 = s2;             // 拷贝构造函数\n    \n    s1.print();\n    s2.print();\n    s3.print();\n    \n    return 0;  // 所有对象在这里被销毁，调用析构函数\n}\n```\n\n\n\n本地对象: \n\n`Field`(字段)指的是在类中定义的变量(成员变量):\n\n- 可以直接被类中的所有方法访问;\n- 生命周期**和类的对象保持一致;**\n\n其他类型数据的生命周期:\n\n- **参数**: 函数执行期间;\n- **局部变量**: 声明的代码块内部.\n\n---\n\n全局对象:\n\n\n\n\n\n> [!NOTE]\n>\n> 如果在类或对象的方法内部定义了一个和成员变量同名的变量, 那么将默认访问这个变量, 只有用 `this->xxx`才能显式访问成员变量. e.g. `int MyClass::count `.\n>\n> ```cpp\n> class MyClass {\n> public:\n>     int value = 10; // 字段\n> \n>     void printValue() {\n>         int value = 20; // 局部变量\n>         std::cout << \"Local value: \" << value << std::endl; // 输出局部变量\n>         std::cout << \"Field value: \" << this->value << std::endl;//使用this指针访问字段\n>     }\n> };\n> ```\n\n\n\n## Access Control\n\n`class`的默认为 `private`, 而 `struct`的默认权限是 `public`.\n\n访问限制符:\n\n### `friend`\n\n在 `class`内部声明友元, 可以使得对应的函数访问自身的成员变量(包括私有和受保护, 也即是所有的变量).\n\n```cpp\nstruct X {\nprivate:\n    int i;\npublic:\n    void initialize();\n    friend void g(X*, int i);\n    friend void Y::y();\n}\n```\n\n\n\n> [!NOTE]\n>\n> **友元关系不具有传递性 !**\n\n\n\n### `protected`\n\n该声明内的成员可以被以下的范围访问:\n\n1. 该类自身的成员函数;\n2. **该类的派生类的成员函数;**\n\ne.g.\n\n```cpp\nclass Base {\nprotected:\n    int protectedVar;\npublic:\n    Base(int val) : protectedVar(val) {}\n};\n\nclass Derived : public Base {\npublic:\n    Derived(int val) : Base(val) {}\n    void accessProtectedVar() {\n        protectedVar = 10; // 派生类可以访问 protectedVar\n    }\n    int getProtectedVar(){\n        return protectedVar;\n    }\n};\n```\n\n> 此处的 `base`就是一个基类, `class Derived : public Base`表明 Derived 是 base的一个派生类.\n>\n> 因此,  派生类可以通过自己的成员函数, 访问基类的 `protected`内的成员变量.\n\n\n\n\n\n\n\n## Static\n\n对于本地变量和全局变量的作用不同, 前者是生命周期, 后者是访问空间.\n\n静态的对象的生命周期是全局, 但是不会跟全局变量一样(一开始就创建), 而是在第一次调用的时候才构造, 且只构造一次.\n\n\n\n- `静态成员变量`由所有的实例**共享**, 初始化的时候不能再添加 `static`标签(否则无法被外文件访问), 必须在类的外部进行初始化, 且需要声明所属于的类;\n\n  > 但是也可以被普通的成员函数所访问.\n\n- `静态成员函数`属于类本身, 因此可以通过类名直接调用, 但是只能访问类的静态成员变量, 因为不存在属于实例的`this`指针. 静态成员函数可以在**类的内部**就定义, 如果在类的外部定义, 也不需要额外的`static`标签;\n\n  ```cpp\n  class MyClass {\n  public:\n      static int count; // 静态成员变量\n      int id;\n  \n      MyClass(int i) : id(i) {\n          count++; // 每次创建对象，count加1\n      }\n  \n      ~MyClass() {\n          count--;\n      }\n  \n      static int getCount() { // 静态成员函数\n          return count;\n      }\n  };\n  \n  int MyClass::count = 0; // 静态成员变量的初始化\n  \n  int main() {\n      std::cout << \"Count: \" << MyClass::getCount() << std::endl; // 通过类名调用静态成员函数\n      MyClass obj1(1);\n      MyClass obj2(2);\n  \n      std::cout << \"Count: \" << MyClass::getCount() << std::endl; // 通过类名调用静态成员函数\n  \n      return 0;\n  }\n  ```\n\n  **Output:**\n\n  ```cpp\n  Count: 0\n  Count: 2\n  ```\n\n\n\n- 函数内部的静态变量只会在调用的时候**初始化一次**, 直到程序结束.\n  e.g. 计数函数的调用次数:\n\n  ```cpp\n  void f(){\n    static int num_calls = 0;\n    ...\n    num_calls += 1;\n  }\n  ```\n\n- `extern`关键字用于声明变量或函数在其他文件中定义. 告诉编译器从而允许跨文件的访问.\n\n  > 但是这种跨文件访问只能作用于**非静态**的全局变量, i.e. 全局变量加上`static`声明之后, 将其作用域限制在了当前文件的内部.\n\n- 函数内部的静态对象, 其构造函数只会在定义的时候调用一次. 并且析构函数当退出程序时调用. 即使采取条件构造, 也只会在第一次条件满足的时候构造.\n\n\n\n- 静态成员的使用:\n\n  - 通过类名: `<class_name>::<static member`\n\n  - 通过实例名: `<ob variable>.<static member>`\n\n    > 让人误以为是类的对象变量, 不建议这样使用.\n\n\n\n\n\n## Reference\n\n引用（Reference）是一个非常重要的特性。它的引入是为了解决一些特定场景下的问题：\n\n- **<u>避免不必要的拷贝</u>**：在某些情况下，传递大型对象或结构体给函数时，如果直接传递拷贝会导致性能下降。引用允许我们传递对象的别名，而不需要拷贝整个对象。\n- **<u>简化代码</u>**：引用可以使代码更简洁，特别是在函数返回值和参数传递时。例如，通过引用返回一个对象可以避免构造临时对象。\n- **<u>指针的安全替代</u>**：引用提供了指针的功能，但避免了指针容易导致的错误，如空指针解引用或野指针。\n\n\n\n**基本语法**: \n\n引用是一个变量的别名，它在**声明时必须被初始化**，并且一旦初始化后就**<u>不能再指向其他</u>**对象.\n\n```cpp\nint a = 10;\nint& ref = a;  // ref 是 a 的引用\n```\n\n- `int&` 表示引用类型，`ref` 是 `a` 的引用。\n- 引用必须在声明时初始化，并且不能重新引用到另一个对象。\n- 无法对引用进行引用;\n- **不允许**存在 **以引用为元素的数组**\n\n\n\ne.g.\n\n```cpp\n#include <iostream>\n\nint main() {\n    int a = 10;\n    int& ref = a;  // ref 是 a 的引用\n\n    std::cout << \"Original value of a: \" << a << std::endl;\n    std::cout << \"Value of ref: \" << ref << std::endl;\n\n    ref = 20;  // 修改引用会影响原变量\n\n    std::cout << \"After modifying ref, value of a: \" << a << std::endl;\n    std::cout << \"Value of ref: \" << ref << std::endl;\n\n    return 0;\n}\n```\n\n在这个例子中：\n\n- `ref` 是 `a` 的引用，修改 `ref` 的值会影响 `a` 的值。\n- 通过引用，我们可以访问和修改原始变量 `a` 的值，而不需要直接操作 `a`。\n\n\n\n引用可以作为函数的形参, 此时**函数内部的形参作为实参的引用可以改变实参的值**.\n\n引用的绑定必须是一个具有明确地址的左值 ,而不能是临时产生的右值:\n\n```cpp\nvoid func(int &);\nfunc (i * 3); // Warning or error!\n```\n\n\n\n#### 指针与引用\n\n- 限制:\n\n  - 无法获得指针的引用;\n\n    ```cpp\n    int &*p;// illegal\n    ```\n\n  - 但是可以获得**指向引用的指针**\n\n    ```cpp\n    void f(int *&p);\n    ```\n\n 可以如此理解, 引用实际上是对象的别名. 用于修改对象的值. 但是为了修改指针, 可以直接使用指针的指针 `**`.\n\n此外, 引用并非独立的对象, 而是直接 **绑定**. 因此 `int& ref = a;`  `&ref`就是 a的地址.\n\n\n\n#### 右值引用\n\n左值是指具有明确地址的变量或者引用, 右值是计算过程中的中间结果或者字面量 (e.g.`10`).等不可寻址的值;\n\n> 涉及到计算的基本都是右值, 但是这四种的计算结果依旧是左值: `*`,`.`,`[]`和 `->`.\n\n右值一般在计算结束后就消失了, 如果我们希望延长其生命周期, 就可以使用 **右值引用**.\n\n- **格式**: `<tyep> && <ref_name> = <right_value>`\n\n  ```cpp\n  int x=20; // left-value \n  int&& rx = x * 2:\n  ```\n\n- TIps:\n\n  - 右值引用在初始化之后就可以正常赋值;\n  - 右值引用无法使用左值进行赋值.\n\n\n\n#### 引用参数与函数重载\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nvoid fun(int& lref){\n   cout << \"lref = \" << lref << endl;\n}\n\nvoid fun(int&& rref){\n   cout << \"rref = \" << rref << endl;\n}\n\nint main(){\n   int x = 10;\n   fun(x);\n   fun(10);\n}\n```\n\n**Output**:\n\n```cpp\nlref = 10\nrref = 10\n```\n\n> 1. 字面量`10`作为右值, 可以通过右值引用作为函数的参数;\n> 2. 具有明确地址的变量 `x`是左值;\n> 3.  C++ 允许在同一个作用域内声明多个具有相同名称但参数列表不同的函数。这被称为**函数重载**。编译器通过检查函数调用时提供的参数类型和数量来决定调用哪个重载函数。\n\n\n\n另外, 加上`const`之后, `& `的形参也可以接受右值作为实参, 比如: `void fun (const int& clref) {...}`\n\n> 但是如果已经存在右值实参作为形参的同名函数, 将会优先选择后者进行重载.\n\n这是因为普通引用对于右值的修改 make no sense, 而 `const` 引用<u>保证不会修改引用的对象</u>，因此即使是临时对象（右值）也可以安全地绑定到 `const` 引用.\n\n\n\n## Constants\n\n使用 `const`声明常量, 常量的值不可修改.\n\n`const`声明集合的时候, 其中的值在**编译期间不可知**, 因此<u>无法在代码中, 使用常量集合内部的值进行操作.</u>\n\n```cpp\nconst int i[] = {1,2,3};\nfloat f[i[2]]; // Illegal!\n```\n\n\n\n使用`const`对指针类型进行操作的时候:\n\n1. 忽略类似于 `char`之类的类型, 只关注 `const`与 `*`之间的位置关系;\n2. 如果是 `const *p` 意思是指针指向的内容不可通过这个指针进行更改;\n3. 如果是 `* const p`意思是指针指向的对象不可更改, 但是可以通过 `*p` 的方式改写对象的值\n\n\n\n---\n\n关于字符指针与字符数组:\n\n- `char  *p = \"hello\";` 实际上是 `const char *p`, 也就是说不允许修改 `*p`;\n- 而 `char p[] = 'hello';` 则可以通过`*p` 修改.\n\n\n\n---\n\n如果**成员函数**的<u>名称后</u>加了 `const`标记, 意味着:\n\n1. 无法通过该成员函数改变成员变量的值.\n2. 同时无法调用其他 **非const**的成员函数\n3. 实际上, 将其的 `this`指针转换为 `const A* this`, 也就是指向常量的指针\n\n> 因此 `const`修饰的成员函数具有 `this`指针(可访问), 不要与 `static`修饰的静态成员函数混淆! 后者不具有 `this`指针.\n>\n> 注意不要与 `const  type f()`混淆, 这是限制返回的结果无法修改; 而 `type f() const`限制成员函数本身的操作.\n\n\n\n**重载**: 允许根据成员函数是否被 `const`限制, 以及对象本身是否为 `const`来重载成员函数.\n\n```cpp\nclass A {\npublic:\n    void f() const {\n        cout << \"const version\" << endl;\n    }\n    void f() {\n        cout << \"non-const version\" << endl;\n    }\n};\n\nint main() {\n    A a;\n    const A ca;\n\n    a.f();    // 输出: non-const version\n    ca.f();   // 输出: const version\n\n    return 0;\n}\n```\n\n\n\n如果成员变量是 `const`, 那么:\n\n- **必须在对象构造时进行初始化** (无法在构造函数中进行直接赋值):\n\n  ```cpp\n  class A {\n  public:\n      const int i;\n      A(int value) : i(value) {} // 在初始化列表中初始化\n  };\n  ```\n\n\n\n如果在实例化对象的时候,  声明了这个实例是 `const`, 那么就无法调用成员函数中没有在后面声明 `const`的部分.( 即使实际上并没有修改的函数, 也不能通过编译).  —— 只能调用那些被标记为`const`的成员函数。\n\n```cpp\nclass A{\n  ...\n  int get_value();\n  int get_const_value const();\n}\n\nconst A a();\na.get_value; // ERROR, const对象无法调用非const声明的成员函数\na.get_const_value; // ok\n```\n\n\n\n---\n\n![image-20250318120332036](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250318120332036.png?imageSlim)\n\n> 无法用普通的指针来指向 `const`常量.\n>\n> 但是可以用指向常量的指针 来指向非常量的对象.\n\n\n\n---\n\n全局变量的构造在 `main()`之前. 静态本地变量在第一次执行到的时候才发生构造, 且只构造一次.\n\n---\n\n## 动态内存\n\n在 C++ 中，使用 `new` 关键字分配的空间位于 **堆** 上，与栈上的自动变量不同，堆上的内存不会自动释放，需要手动使用 `delete` 来析构以避免内存泄漏。\n\n#### 示例代码\n```cpp\n#include <iostream>\nusing namespace std;\n\nint main() {\n    // 使用 new 在堆上分配一个整数\n    int* ptr = new int(10);\n    cout << \"值: \" << *ptr << endl;\n\n    // 使用 delete 释放内存\n    delete ptr;\n\n    // 指针置空，避免野指针\n    ptr = nullptr;\n    return 0;\n}\n```\n\n#### 注意事项\n- 每次 `new` 分配的内存都需要对应的 `delete`。\n- 对于数组，使用 `new[]` 分配，释放时用 `delete[]`：\n```cpp\nint* arr = new int[5];  // 分配数组\ndelete[] arr;           // 释放数组\n```\n\n---\n\n## Inline Class\n\n### Delegating Constructor\n\n委托构造函数（Delegating Constructor）是通过一个构造函数调用另一个构造函数来完成初始化的机制, 也就是在初始化列表中调用其他.\n\n相对于委托构造的构造函数, 被称为 *target constructor* 目标构造函数.\n\n目标构造函数的执行先于委托构造函数.\n\n---\n\n#### 什么是委托构造函数？\n- **定义**: 一个构造函数可以在其初始化列表中调用同一个类的另一个构造函数来完成部分或全部初始化工作。\n- **目的**: 避免在多个构造函数中重复编写相同的初始化逻辑，解决代码重复的问题。\n- **限制**: 委托构造函数<u>本身不能在初始化列表中再初始化其他成员变量</u>，只能依赖被调用的构造函数。\n\n\n\n#### 代码示例与分析\n\n考虑将下面的冗余代码通过委托构造函数简化:\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250325120013059.png?imageSlim)\n\n实现: \n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass ClassC {\npublic:\n    int max;\n    int min;\n    int middle;\n\n    // 基础构造函数\n    ClassC(int my_max) {\n        max = (my_max > 0) ? my_max : 10;  // 默认值10\n    }\n\n    // 委托给基础构造函数\n    ClassC(int my_max, int my_min) : ClassC(my_max) {\n        min = (my_min > 0 && my_min < max) ? my_min : 1;  // 默认值1\n    }\n\n    // 委托给第二个构造函数\n    ClassC(int my_max, int my_min, int my_middle) : ClassC(my_max, my_min) {\n        middle = (my_middle < max && my_middle > min) ? my_middle : 5;  // 默认值5\n    }\n};\n\nint main() {\n    ClassC c1{1, 3, 2};\n    cout << \"max: \" << c1.max << \", min: \" << c1.min << \", middle: \" << c1.middle << endl;\n    return 0;\n}\n```\n\n#### 运行结果分析\n- `ClassC c1{1, 3, 2}`:\n  1. 调用 `ClassC(int, int, int)` 构造函数。\n  2. 它委托给 `ClassC(int, int)`，后者再委托给 `ClassC(int)`。\n  3. 初始化顺序：\n     - `max = 1`（因为 1 > 0）。\n     - `min = 1`（因为 3 > max，不满足条件，使用默认值 1）。\n     - `middle = 2`（因为 2 < max 且 2 > min 不成立，但逻辑上仍赋值 2，需检查代码逻辑）。\n\n#### 关键点\n1. **初始化位置**:\n   - 成员变量不能在委托构造函数的初始化列表中直接使用参数初始化，必须通过被委托的构造函数完成。\n   - 如 `ClassC(int my_max, int my_min) : ClassC(my_max)` 中，不能再初始化 `min`，只能在函数体内赋值。\n\n2. **代码重复问题**:\n   - 如果每个构造函数都独立初始化 `max`、`min` 等，会导致重复代码。\n   - 委托构造函数将公共逻辑集中到基础构造函数中。\n\n3. **委托链**:\n   - 可以形成构造函数调用链，如 `ClassC(int, int, int)` → `ClassC(int, int)` → `ClassC(int)`。\n\n4. **限制与解决方法**:\n   - 委托构造函数不能再有其他初始化列表项。\n   - 如果需要更灵活的初始化，可以引入一个私有的辅助构造函数：\n```cpp\nclass ClassC {\nprivate:\n    int max;  \n    int min;\n    void init(int my_max) { max = my_max > 0 ? my_max : 10; }\npublic:\n    ClassC(int my_max) { init(my_max); }\n    ClassC(int my_max, int my_min) : min(my_min) { init(my_max); } // 直接在初始化列表中初始成员变量\t\n};\n```\n\n\n\n\n\n---\n\n### 默认参数\n\n#### 定义\n- 默认参数是在函数声明中为参数指定的默认值，调用时未提供参数则使用默认值。\n- 规则：默认参数必须<u>从右到左设置</u>。\n\n#### 代码示例\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 函数声明\nint harpo(int n, int m = 4, int j = 5);  // 合法\nint chico(int n, int m = 6, int j);       // 非法：j 无默认值\nint groucho(int k = 1, int m = 2, int n = 3);  // 合法\n\nint main() {\n    int beeps;\n    beeps = harpo(2);      // harpo(2, 4, 5) -> 11\n    cout << \"beeps = \" << beeps << endl;\n    beeps = harpo(1, 8);   // harpo(1, 8, 5) -> 14\n    cout << \"beeps = \" << beeps << endl;\n    beeps = harpo(8, 7, 6);  // harpo(8, 7, 6) -> 21\n    cout << \"beeps = \" << beeps << endl;\n    return 0;\n}\n\nint harpo(int n, int m, int j) {\n    return n + m + j;\n}\n```\n\n#### 关键点\n1. **规则**:\n   - 默认参数从右到左设置。\n   - `int harpo(int n, int m = 4, int j = 5)` 合法。\n   - `int chico(int n, int m = 6, int j)` 非法。\n2. **作用**:\n   - 省略参数时自动填充默认值。\n   - 减少函数重载需求。\n3. **注意**:\n   - 默认值在声明中指定，<u>不在定义中</u>。\n   - 不能“跳跃”使用参数，如 `harpo(1, , 6)` 非法。\n\n#### 改进建议\n- 复杂逻辑可考虑函数重载或委托构造函数。\n- 避免过度使用默认参数以保持代码清晰。\n\n---\n\n### 内联函数\n\n> Inline Functions\n\n#### 定义\n- 内联函数是用 `inline` 关键字修饰的函数，编译器会尝试将函数调用替换为函数体代码，减少函数调用的开销。\n\n  > 普通函数的调用需要经历: 压栈、传递参数、跳转到函数地址、返回值处理、出栈等步骤, 由此可见内联函数可以有效提升性能.\n- 适用于小型、频繁调用的函数。\n\n#### 代码示例\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 内联函数定义\ninline int square(int x) {\n    return x * x;\n}\n\nint main() {\n    int num = 5;\n    cout << \"Square of \" << num << \" is \" << square(num) << endl;  // 输出 25\n    return 0;\n}\n```\n\n#### 关键点\n1. **作用**:\n   - 减少函数调用开销（如参数传递、栈帧创建）。\n   - 提高执行效率，适合小型函数。\n2. **使用场景**:\n   - 函数体短小、调用频繁。\n   - 不适合复杂函数（可能导致代码膨胀）。\n3. **注意**:\n   - `inline` 是建议，编译器可能忽略（例如函数过大或包含循环）。\n   - 内联函数定义通常放在头文件中，避免链接错误 (在多个源文件被调用的时候, `inline`的声明可以告诉编译器, 重复的定义是被允许的)\n\n\n\n\n\n> [!NOTE]\n>\n> 1. **Any function you define inside a class declaration is automatically an inline.**\n>\n>    > `class`内部**<u>定义</u>**的函数自动为 `inline`类型. 如果是类外定义(相同的`.h`文件), 那么需要显式声明为内联函数.\n>\n> 2. 内联函数必须在**<u>头文件</u>**中定义，或者在调用它的同一翻译单元中.\n>\n>    > 如果定义在 .cpp 文件中，调用点无法看到定义，编译器无法内联，链接器会报错.\n>\n> 3. 如果决定将类的函数定义写在头文件中, 有以下的两种选择使其成为内联函数;\n>\n>    1. 直接在声明的地方给出完全的定义;\n>    2. 在类外声明 `inline`然后定义.\n>\n> 4. `inline`确实比C语言的 `macro`更好, 因为内联函数实现了对参数的类型检查.\n>\n> 5. 编译器会对声明为 `inline` 的函数进行检查: 如果包含了递归 或者 代码量较大, 编译器依旧不会将其视为 `inline` .\n\n\n\n### inline 变量\n\n> [!NOTE]\n>\n> - 为静态成员变量声明 `inline`, 不必在 `.cpp`中再次声明.\n>\n> - 用于**在头文件中定义具有外部链接的变量**，避免了重复定义的问题.\n\n\n\n在 C++ 传统规则中，**全局变量**（或者 namespace 作用域的变量）在头文件中定义会导致多个翻译单元（编译文件）出现**重复定义错误**。在 C++17 之前，通常的做法是：\n\n```cpp\n// myheader.h\nextern int myVar; // 声明\n\n// mysource.cpp\n#include \"myheader.h\"\nint myVar = 42; // 定义\n```\n\n但在 C++17 之后，可以使用 inline 变量，直接在头文件中定义，而不会导致重复定义错误：\n\n```cpp\n// myheader.h\ninline int myVar = 42;  // C++17 及以上\n```\n\n在任何 `#include \"myheader.h`\" 的地方，myVar 仍然是<u>**同一个变量**</u>。\n\n> 如果希望不同的文件不是一个实例, 需要声明为 静态全局变量.\n\n\n\n\n\n**inline 变量的特点**\n\n​\t1.\t**允许在头文件中定义**，避免 extern 的使用。\n\n​\t2.\t**所有包含它的翻译单元共享同一个变量**（编译时不会创建多个实例）。\n\n​\t3.\t**必须初始化**，否则编译器无法确定变量的值。\n\n\n\n\n\n**示例：多个文件使用 inline 变量**\n\n\n\n假设有以下两个源文件，同时包含 myheader.h，但不会引发重复定义错误：\n\n**头文件 myheader.h**\n\n```cpp\n#ifndef MYHEADER_H\n#define MYHEADER_H\n\n#include <iostream>\n\ninline int globalVar = 100; // inline 变量\n\n#endif\n```\n\n**源文件 file1.cpp**\n\n```cpp\n#include \"myheader.h\"\n\nvoid func1() {\n    std::cout << \"file1.cpp: \" << globalVar << std::endl;\n}\n```\n\n**源文件 file2.cpp**\n\n```cpp\n#include \"myheader.h\"\n\nvoid func2() {\n    std::cout << \"file2.cpp: \" << globalVar << std::endl;\n}\n```\n\n**主程序 main.cpp**\n\n```cpp\n#include \"myheader.h\"\n\nvoid func1();\nvoid func2();\n\nint main() {\n    func1();\n    func2();\n    globalVar += 10;\n    std::cout << \"main.cpp: \" << globalVar << std::endl;\n    return 0;\n}\n```\n\n**编译 & 运行**\n\n```\ng++ file1.cpp file2.cpp main.cpp -o output && ./output\n```\n\n**输出示例：**\n\n```\nfile1.cpp: 100\nfile2.cpp: 100\nmain.cpp: 110\n```\n\n说明：\n\n​\t•\tglobalVar 是**同一个变量**，而不是多个副本。\n\n​\t•\tmain.cpp 修改 globalVar 之后，globalVar 在所有翻译单元中都被更新。\n\n\n\n------\n\n\n\n**inline 变量 vs constexpr 变量**\n\n​\t•\tinline 变量可以是**可变的**，可以修改其值。\n\n​\t•\tconstexpr 变量必须是**编译时常量**，不能修改。\n\n​\t•\tinline constexpr 变量既有 inline 特性，又是编译时常量。\n\n```\ninline constexpr int constantVar = 50; // 不能修改\n```\n\n\n\n### weak\n\n`weak`允许不同的编译单元存在同名的函数, 并且在实际调用的时候, 优先调用不是 `weak`的函数. 从而提供了一种默认的实现.\n\n`weak`关键字可以用于函数、变量与对象等, 与主要使用于函数的 `inline`不同.\n\n如果没有 `weak`标记, 就是强变量.\n\n\n\n- 一般的编译器需要使用 `__attribute__((weak)) ` 来声明:\n\n```cpp\n#include <iostream>\n\n// 声明 weak 变量，提供默认值\n__attribute__((weak)) int globalValue = 42;\n\nint main() {\n    std::cout << \"globalValue = \" << globalValue << std::endl;\n    return 0;\n}\n```\n\n\n\n# Composition\n\n用已有的对象构造新的对象. 称为组合.\n\n可以用 `has-a`的关系来描述.\n\n## 类内对象的初始化\n\n\n\n假设我们有一个 `Person` 类，该类内部包含一个 `std::vector<std::string>` 类型的成员变量，用于存储人的爱好。我们将展示如何在类的构造函数中使用完全初始化和引用初始化来初始化这个成员变量。\n\n### 1. Fully\n\n完全初始化是指在类的构造函数中直接为成员变量赋予初始值。这通常通过成员初始化列表（member initializer list）来完成。\n\n```cpp\nclass Person {\npublic:\n    std::vector<std::string> hobbies;\n\n    // 完全初始化：使用成员初始化列表\n    Person(const std::vector<std::string>& initialHobbies)\n        : hobbies(initialHobbies) { }\n};\n\n```\n\n**解释**\n\n- **成员变量初始化**：在 `Person` 类的构造函数中，我们使用成员初始化列表 `: hobbies(initialHobbies)` 来完全初始化 `hobbies` 成员变量。这意味着 `person1.hobbies` 将拥有 `initialHobbies` 的一个拷贝。\n- **独立性**：`person1.hobbies` 是 `initialHobbies` 的一个独立拷贝，修改 `person1.hobbies` 不会影响 `initialHobbies`，反之亦然。\n\n\n\n### 2. Reference\n\n引用初始化是指将类内部的成员变量声明为引用类型，并在构造函数中将其绑定到另一个对象。这意味着类内的引用将直接指向外部对象，而不是持有其拷贝。\n\n```cpp\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass Person {\npublic:\n    std::vector<std::string>& hobbiesRef;  // 引用类型的成员变量\n\n    // 引用初始化：使用成员初始化列表绑定到外部对象\n    Person(std::vector<std::string>& externalHobbies)\n        : hobbiesRef(externalHobbies) { }\n};\n\n```\n\n**解释**\n\n- **成员变量声明**：`std::vector<std::string>& hobbiesRef;` 声明了一个引用类型的成员变量 `hobbiesRef`，它将引用外部的 `std::vector<std::string>` 对象。\n- **引用绑定**：在构造函数中，通过 `: hobbiesRef(externalHobbies)` 将 `hobbiesRef` 绑定到传入的 `externalHobbies` 对象。这意味着 `person2.hobbiesRef` 和 `sharedHobbies` 指向同一个内存位置。\n- **共享数据**：对 `person2.hobbiesRef` 的修改（如添加新爱好）会直接影响到 `sharedHobbies`，因为它们共享相同的数据。\n\n\n\n### 3. 对比\n\n| 特性             | 完全初始化                       | 引用初始化                                         |\n| ---------------- | -------------------------------- | -------------------------------------------------- |\n| **存储方式**     | 存储外部对象的拷贝               | 存储对外部对象的引用                               |\n| **内存使用**     | 额外占用内存用于拷贝             | 不占用额外内存，直接引用外部对象                   |\n| **数据独立性**   | 修改类内成员不会影响外部对象     | 修改类内成员会影响外部对象                         |\n| **生命周期依赖** | 类内成员独立于外部对象的生命周期 | 类内引用的生命周期必须至少与外部对象相同           |\n| **适用场景**     | 需要独立副本时使用               | 需要与外部对象共享数据时使用, 初始情况下不知道容量 |\n\n#### 注意事项\n\n- **引用必须在构造时初始化**：引用类型的成员变量必须在构造函数的初始化列表中绑定到一个对象，不能在构造函数体内赋值。\n\n  > [!NOTE]\n  >\n  > 因为引用类型的对象必须在初始化的时候绑定, 并且只能绑定一次.\n\n  ```cpp\n  // 错误示例：试图在构造函数体内赋值给引用\n  class Person {\n  public:\n      std::vector<std::string>& hobbiesRef;\n      \n      Person(std::vector<std::string>& externalHobbies) {\n          hobbiesRef = externalHobbies; // 错误：引用必须在初始化时绑定\n      }\n  };\n  ```\n\n- **生命周期管理**：使用引用初始化时，必须确保被引用的对象在使用期间是有效的。如果引用的对象被销毁，引用将变为悬空引用，导致未定义行为。\n\n  ```cpp\n  // 危险示例：悬空引用\n  std::vector<std::string> createHobbies() {\n      std::vector<std::string> temp = {\"Temporary\"};\n      Person person(temp);\n      return temp; // temp 被销毁，person.hobbiesRef 悬空\n  }\n  ```\n\n  为了避免这种情况，通常可以使用智能指针（如 `std::shared_ptr` 或 `std::unique_ptr`）来管理对象的生命周期，或者确保引用的对象在使用期间一直有效。\n\n\n\n#### 总结\n\n> [!NOTE]\n>\n> 1. 如果使用 完全初始化 的方式, 类内必须包含另一个类的完整定义(引用头文件);\n>\n> 2. 如果是引用初始化, 可以直接在这个类的内部预先声明另一个类的存在即可.\n>\n>    ```cpp\n>    class A; // 前向声明\n>    class B{\n>      A* ptr;\n>    }\n>    ```\n\n\n\n\n\n---\n\n## Embedded objects\n\n> [!NOTE]\n>\n> - 对于嵌入对象，如果不用初始化列表，就必须有默认构造函数。\n\n\n\n## namespace\n\n### 命名空间的别名\n\n如果 `namespace`过长, 可以将其重新赋值并使用:\n\n```cpp\nnamespace supercalifragilistic {\n\tvoid f();\n}\nnamespace short = supercalifragilistic;\nshort::f();\n```\n\n\n\n### selection\n\n除了直接在一个命名空间内部嵌套其他, 我们也可以在一个命名空间里选择性地使用其他空间的部分函数:\n\n```cpp\nnamespace mine｛\n\tusing orig::Cat;\t // use Cat class from origvoid ×O）；\n\tvoid x()；\n    void y();\n}\n```\n\n\n\n> [!NOTE]\n>\n> 1. **Multiple namespace declarations add to the same namespace.**\n>    也即是说, 多个 `.h`文件内相同的命名空间会自动的视作一个.\n\n\n\n# Inheritance\n\n> [!NOTE]\n>\n> 1. 继承的对象都具有基类的属性, 但是不一定具有访问的权限. \n>    也就是 **Think of inherited traits as an embedded object**\n> 2. 派生类的构造函数中的初始化列表应当包含基类的构造函数.\n> 3. 由于基类的私有成员无法被子类直接访问, 需要让子类调用基类的public的函数, 从而间接访问.\n> 4. 如果子类和父类含有同名的变量, 将会同时存在, 并且可以在子类中声明 `parent_class:A`来访问父类中的属性A.\n> 5. 子类中一定有部分是父类的对象, 并且处于子类的开头(父类必须首先完成初始化).\n\n#### 初始化列表的常用场景\n\n1. 调用基类的构造函数 (否则调用默认构造函数)\n\n   ```cpp\n   class Base {\n   public:\n       Base(int data) { /* ... */ }\n   };\n   \n   class Derived : public Base {\n   public:\n       Derived(int baseVal) : Base(baseVal) { }\n   };\n   ```\n\n2. 初始化嵌入类\n\n   ```cpp\n   class Member {\n   public:\n       Member(const std::string& str) { /* ... */ }\n   };\n   \n   class Container {\n       Member memberObj;\n   public:\n       Container(const std::string& s) : memberObj(s) { }\n   };\n   ```\n\n   > 需要注意的是, 此处的初始化列表中的嵌入类的构造, 变量名不是类名.\n   >\n   > 如果嵌入类不存在默认的构造函数, 那么初始化列表中的显式构造是必要的.\n\n3. 初始化常量成员:\n\n   ```cpp\n   class MyClass {\n       const int constMember;\n   public:\n       MyClass(int val) : constMember(val) { }\n   };\n   ```\n   \n   > const 成员一旦定义，必须立即初始化，且**只能**在初始化列表中完成，不能在构造函数体内赋值。\n\n\n4. 初始化引用成员\n\n   ```cpp\n   class MyClass {\n       int& refMember;\n   public:\n       MyClass(int& ref) : refMember(ref) { }\n   };\n   ```\n   \n   > 引用成员（如 int& ref）必须在初始化时绑定对象，**不能在构造函数体内赋值**，因此也必须使用初始化列表。\n\n\n\n继承: 基于已有的类来设计新的类，新的类的对象可以被当作已有类的对象.\n\n相比于 *composition*  的 `has-a`关系, 继承是 `is-a`的关系.\n\n同义词:\n\n- 父类、超类、基类\n- 派生类、子类\n\n控制基类成员在派生类中的可见性：\n\n- `public`：基类的 `public` 成员在派生类中仍然是 `public`，`protected` 成员仍然是 `protected`。\n- `protected`：基类的 `public` 和 `protected`成员在派生类中都变为 `protected`。\n- `private`：基类的 `public` 和 `protected` 成员在派生类中都变为 `private`。\n\n> [!NOTE]\n>\n> 此时, 仍旧可以通过子类的方法来访问基类的属性或者方法, 但是无法通过子类直接访问基类~!\n>\n> e.g.\n>\n> ```cpp\n> #include <iostream>\n> \n> class Base\n> {\n> public:\n>     void baseFunction()\n>     {\n>         std::cout << \"Base function called.\" << std::endl;\n>     }\n> };\n> \n> class Derived : private Base\n> {\n> public:\n>     void derivedFunction()\n>     {\n>         baseFunction(); // 在子类内部可以访问基类的成员函数\n>     }\n> };\n> \n> int main()\n> {\n>     Derived d;\n>     d.baseFunction();    // 错误：无法从子类外部访问基类的成员函数\n>     d.derivedFunction(); // 可以调用子类的函数，该函数内部调用了基类的函数\n>     return 0;\n> }\n> ```\n\n\n\n\n\n\n\nclint class 表示这个类要使用另一个类(中的public).\n\n\n\n子类的对象也可以认为是父类的对象。子类不能访问父类的私有变量，但私有变量存在于这个类中\n\n\n\n当调用构造函数时，我们不能调用父类的私有变量，只能用初始化列表的方式调用父类的构造函数。\n\n\n\n赋值的运算符不会被继承:\n\n#### 赋值运算符\n\n赋值运算符是这样形式的方法:\n\n```cpp\nPoint &operator=(const Point &other)\n{\n    cout << \"Point::operator= 被调用\" << endl;\n    if (this != &other)\n    {\n        x = other.x;\n        y = other.y;\n    }\n    return *this;\n}\n```\n\n当我们如此赋值的时候就会发生上述的调用:\n\n```cpp\nPoint p1(1,2);\nPoint p2(3,4);\n\np1 = p2;\n```\n\n可见, 赋值运算符通过引用快速地将右值中的属性赋值给左侧的目标.\n\n但是父类的赋值运算符只会确保自身的属性能够被赋值, 无法确保子类自身的属性可以被正确设置. 因此, 为了安全性, CPP不允许子类自动继承父类的赋值运算符.\n\n> [!NOTE]\n>\n> 然而, 编译器可能为子类自动生成一个赋值运算符.\n>\n> e.g.\n>\n> ```cpp\n> class Point\n> {\n> public:\n>     int x, y;\n>     Point(int x = 0, int y = 0) : x(x), y(y) {}\n> \n>     // 自定义赋值运算符\n>     Point &operator=(const Point &other)\n>     {\n>         cout << \"Point::operator= 被调用\" << endl;\n>         if (this != &other)\n>         {\n>             x = other.x;\n>             y = other.y;\n>         }\n>         return *this;\n>     }\n> };\n> \n> class ColoredPoint : public Point\n> {\n> public:\n>     string color;\n>     ColoredPoint(int x = 0, int y = 0, string color = \"white\") : Point(x, y), color(color) {}\n> \n>     void print() const\n>     {\n>         cout << \"x:\" << x << \", y:\" << y << \", color:\" << color << endl;\n>     }\n> };\n> \n> int main()\n> {\n>     ColoredPoint cp1(1, 2, \"red\");\n>     cp1.print();\n>     ColoredPoint cp2(3, 4, \"blue\");\n>     cp2.print();\n>     cp1 = cp2;\n>     cp1.print();\n> }\n> \n> ```\n>\n> **输出结果**:\n>\n> ```cpp\n> x:1, y:2, color:red\n> x:3, y:4, color:blue\n> Point::operator= 被调用\n> x:3, y:4, color:blue\n> ```\n>\n> 可见, 父类的赋值运算符也被自动地调用了, 这是因为编译器为子类自动生成了一份.\n\n\n\n---\n\n父类的构造是在子类的构造之前。\n\n\n\n### `using`声明\n\n#### 将基类的函数派生使用\n\n必须使用 `using <parentClass>:: func`的方式, 无法忽略 `using`.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base{\n  public: \n  \tvoid f(double){\n      cout << \"double\\n\" << endl;\n    }\n};\n\nclass Derived : Base{\n  public:\n  \tusing Base::f; // 将基类中的私有函数本地使用\n  \tvoid f(int){\n      cout << \"int\\n\"<<endl;\n    }\n};\n\n\nint main() {\n    Derived d;\n    d.f(4);\n    d.f(4.5);\n}\n```\n\n**Output:**\n\n```cpp\nint \n\ndouble\n```\n\n\n\n#### 默认参数值无法通过重载传递\n\n在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免**多重继承时参数值产生冲突或二义性**。默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.\n\n> 如果你在派生类中**重新声明或重载了基类的函数**，那么你不能获得默认参数值，必须通过多个重载模拟默认参数功能.\n\n```cpp\nclass A {\npublic:\n    void f(int a = 3, double b = 2.0);\n};\n\nclass B : public A {\npublic:\n    using A::f;         // ✅ 此时默认参数仍可见\n    void f(int a);      // ❌ 重载后，这个版本没有默认参数\n};\n```\n\n\n\n> 但是使用 `using`声明的父类函数可以获得默认参数值.\n\ne.g.\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass A\n{\npublic:\n    void f(int a = 3, double b = 2.0)\n    {\n        std::cout << \"A::f(\" << a << \", \" << b << \")\" << std::endl;\n    }\n};\n\nclass B : public A\n{\npublic:\n    using A::f; // 继承 A::f 到 B 中\n};\n\nint main()\n{\n    B b;\n    b.f();        // ✅ 是否等价于 f(3, 2.0)？\n    b.f(10);      // ✅ 是否等价于 f(10, 2.0)？\n    b.f(10, 5.5); // ✅ 正常调用\n}\n\n```\n\n- 输出:\n\n  ```cpp\n  A::f(3, 2)\n  A::f(10, 2)\n  A::f(10, 5.5)\n  ```\n\n\n\n#### 解决重写函数的重载问题\n\n子类重新定义 (`override`重写) 了父类的某个函数，就会把父类中对应 `overloaded` 的函数覆盖:\n\n```cpp\n#include <iostream>\n\nclass Base\n{\npublic:\n    // 基类中的重载函数\n    void display(int x)\n    {\n        std::cout << \"Base display(int): \" << x << std::endl;\n    }\n\n    void display(double x)\n    {\n        std::cout << \"Base display(double): \" << x << std::endl;\n    }\n};\n\nclass Derived : public Base\n{\npublic:\n    // 子类重新定义了基类的 display(int)\n    void display(int x)\n    {\n        std::cout << \"Derived display(int): \" << x << std::endl;\n    }\n    using Base::display;\n};\n\nint main()\n{\n    Derived d;\n    d.display(5); // 调用 Derived 的 display(int)\n\n    d.Base::display(5.5); // 或者d.display(5.5);\n    return 0;\n}\n```\n\n> - 注意, CPP中的浮点数可以隐式转换为整型.\n>\n>   - 当将一个浮点数赋值给一个整型变量时，编译器会执行**隐式转换**，将浮点数的值转换为整型。这种转换通常涉及**截断**（truncation），即去掉小数部分，只保留整数部分.\n>\n> - 可以通过 `using `声明重新引入基类中的重载函数: \n>\n>   ```cpp\n>   using Base::display;\n>   ```\n>\n\n\n\n---\n\n# Polymorphism\n\n#### 补充\n\n1. 成员函数（无论是虚函数还是非虚函数）本身不占用类对象的内存空间，因为它们的代码存储在程序的代码段中。只有**成员变量和虚表指针**（如果有虚函数）会占用对象的内存空间:\n\n   ```cpp\n   class A {\n       int i;\n       void f();\n   };\n   ```\n\n   此时的 `sizeof(A)`为4字节.\n\n2. 虚函数指针的大小一般是 <u>8字节</u>. 如果结构体内部存在虚函数指针, 就需要对齐为8字节的倍数.\n\n3. 因为子类的构造在父类的构造之后, 也就是每一个子类对象的前部分都是父类对象. 因此, 我们可以将一个子类对象的指针赋值给父类对象, 只要忽视后续数据结构即可.\n\n4. <u>多态变量</u>: 指向子类对象的基类指针/引用.\n\n5. 如果类内不存在任何成员变量, 它的对象依旧占用 `1` 个字节的空间.\n\n6. 如果一个类将来可能具有子类, 就让其析构函数设置为 `virtual`. —— 任何的类都应该设置它的析构为 `virtual`.\n\n   ```cpp\n   class B: public A{};\n   \n   A* p = new B();\n   delete p;\n   ```\n\n   如果 A 的析构函数不是virtual的, 那么编译器只会调用A的析构函数.\n\n7. 如果父类的构造函数中调用了 `virtual` 的函数, 那么实际上还是调用自己的函数(静态绑定)\n\n   1. 这是因为, 创建一个派生类的对象时, 首先调用父类的构造函数, 然后执行派生类的构造函数;\n   2. 此时, 子类的成员还没有初始化, 父类无法调用其重写版本, 也就无法实现多态.\n\n8. > [!NOTE]\n   >\n   > 深刻理解什么叫做多态! 也就是子类对象的引用或者指针赋值给了父类! 此后调用这个对象时, 虚函数是动态绑定到子类的!\n   >\n   > ```c++\n   > A &ra = b;    // ra是A类型的引用，但指向B类型的对象\n   > ra.f();       // 虽然ra是A类型的引用，但f()会调用B::f()\n   > ```\n\n9. 如果B是A的子类:\n\n   ```c++\n   A *p1 = new B(3);    // p1是A类型的指针，但指向B类型的对象\n   ```\n\n   实际上,  p1指向的对象是B类的对象\n\n\n\n\n\n\n当一个被重写的函数在 Derived::func() 中通过 Base::func() 调用其基类版本时，会发生什么？\n\n- 可以正常调用, 这也正是重写存在的意义——扩充原来的功能, 同时保留.\n\n\n\n- 多态与返回对象类型:\n\n  - 允许重载返回自身的 <u>指针</u> 与 <u>引用</u>, 但是不支持直接返回自身的类型:\n\n  - i.e. \n\n    ```cpp\n    Class Expr｛\n    public:\n      virtual Expr* newExpr （）；\n      virtual Expr& clone （）；\n      virtual Expr Expr self（）；\n    ｝；\n    \n    class BinaryExpr ： public Expr ｛\n    public：\n      virtual BinaryExpr* newExpr （）； //Ok\n      virtual BinaryExpr& clone （）； // Ok\n      virtual BinaryExpr self（）；// Error！\n      ｝；\n    ```\n\n  - 原因: 指针和引用的大小固定, 编译时刻可以确定调用时候所需的空间, 如果按照类型返回, 由于多态的动态绑定是运行时决定调用对应的方法, 所以编译的时候caller不知道要在栈上预留多少的空间.\n\n\n\n\n\n---\n\n- Polymorphism\n  - virtual functions and override\n  - abstract functions and classes\n- Multiple Inheritance\n\n\n\n由于子类具有父类的所有属性, 因此我们可以将一个子类对象看作父类的对象, 并进行对应的操作.\n\n将子类对象看作父类对象的操作, 叫做 <u>upcast</u>. 具体是说, 将子类的指针或者引用赋值给基类的对象.\n\n\n\n现在的问题是, 如果采取传统的继承+重写的方式, 我们在子类内部采取重写父类方法, 可能导致 `静态绑定` static binding:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Animal\n{\npublic:\n    void speak()\n    {\n        cout << \"Animal speaks\" << endl;\n    }\n};\n\nclass Dog : public Animal\n{\npublic:\n    void speak()\n    {\n        cout << \"Dog barks\" << endl;\n    }\n};\n\nint main()\n{\n    Animal *animal = new Dog(); // 注意：父类指针指向子类对象\n    animal->speak();            // 会调用哪个？\n    delete animal;\n    return 0;\n}\n```\n\n- 输出:\n\n  ```cpp\n  Animal speaks\n  ```\n\n\n\n为了解决上述的问题, 我们引入 <u>虚函数</u> 的概念.\n\n## 虚函数\n\n虚函数可以实现 **运行时多态**. 所谓多态, 就是静态+ 动态的绑定.\n\n通过在父类的函数前加上 `virtual`的声明, 我们将其定义为虚函数\n\ne.g.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Animal {\npublic:\n    virtual void speak() {\n        cout << \"Animal speaks\" << endl;\n    }\n};\n\nclass Dog : public Animal {\npublic:\n    void speak() override {\n        cout << \"Dog barks\" << endl;\n    }\n};\n\nint main() {\n    Animal* animal = new Dog(); \n    animal->speak(); // 这次会调用哪个？\n    delete animal;\n    return 0;\n}\n```\n\n- 输出:\n\n  ```cpp\n  Dog barks\n  ```\n\n> - `override`声明明确这个函数是重写父类的虚函数, 可以让编译器检查是否存在错误.\n> - 但是上述的关键字也不是必须的.\n\n\n\n### 纯虚函数\n\n~指的是需要强制派生类去实现的函数:\n\n```cpp\nvirtual 返回类型 函数名(...) = 0;\n```\n\n\n\n### 虚函数表\n\n- 定义: 虚函数表（virtual table）是 C++ 为了实现**运行时多态**而采用的一种底层技术手段;\n- 本质:\n  - `vtable`是一个函数指针数组;\n  - 每个类都有自己的vtable\n  - 对象中存在一个隐藏的指针 `vptr`, 指向该类的vtable\n\n#### 内存示意图\n\n假设有如下结构:\n\n```cpp\nclass Base {\npublic:\n    int a;\n    virtual void func();\n};\n```\n\n内存布局的伪结构如下:\n\n```cpp\n+-------------------------+\n| vptr  → 指向vtable     |  ←隐藏成员\n+-------------------------+\n| a : int                |  ←显式成员\n+-------------------------+\n\nvtable (Base):\n[ func 的地址 ]\n\nvtable (Derived):\n[ 重写的 func 的地址 ]\n```\n\n\n\n#### 拓展说明\n\n- vtable是类级别的, 所有该类的对象共享一个vtable;\n- vptr是对象级别的, 隐含于各个对象当中.\n- 如果类没有虚函数, 就不存在上述的~\n\n\n\n## 抽象类\n\n如果一个类中包含至少一个纯虚函数, 那么这个类就是一个抽象类.\n\n抽象类无法被实例化, **只能用来作为基类.**\n\n### 使用抽象类定义接口\n\n用图形绘制的例子来说明抽象类和纯虚函数的使用:\n\n```cpp\n#include <iostream>\nusing namespace std;\n\n// 抽象类\nclass Shape {\npublic:\n    // 纯虚函数，子类必须实现\n    virtual void draw() = 0;\n};\n\n// 派生类：Circle\nclass Circle : public Shape {\npublic:\n    void draw() override {\n        cout << \"Drawing Circle\" << endl;\n    }\n};\n\n// 派生类：Rectangle\nclass Rectangle : public Shape {\npublic:\n    void draw() override {\n        cout << \"Drawing Rectangle\" << endl;\n    }\n};\n\n// 渲染函数：面向抽象类编程\nvoid render(Shape* shape) {\n    shape->draw();\n}\n\nint main() {\n    Circle c;\n    Rectangle r;\n\n    render(&c); // Drawing Circle\n    render(&r); // Drawing Rectangle\n\n    return 0;\n}\n```\n\n\n\n### 继承链\n\n一个抽象类可以有多个纯虚函数, 此时继承的子类可能没有完全实现. \n\n子类的子类, 也就是在继承链上完成了所有纯虚函数的定义的 最末一级的派生类, 才可以被实例化.\n\n```cpp\nclass Animal {\npublic:\n    virtual void speak() = 0;\n    virtual void run() = 0;\n    \n    void breathe() {\n        cout << \"Breathing...\" << endl;\n    }\n};\n```\n\n\n\n## 虚析构函数 \n\n**virtual destructor**: 虚析构函数\n\n同样的, 虚析构函数的作用体现在 `upcast`, 也就是将子类的指针或引用转换为父类的指针或引用的过程. 此时, 如果父类的析构函数不是虚函数, 就会让向上转型之后的对象在析构时调用父类的析构函数.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base\n{\npublic:\n    ~Base()\n    {\n        cout << \"Base Destructor\" << endl;\n    }\n};\n\nclass Derived : public Base\n{\npublic:\n    ~Derived()\n    {\n        cout << \"Derived Destructor\" << endl;\n    }\n};\n\nint main()\n{\n    Base *obj = new Derived();\n    delete obj; // 注意这里！\n    return 0;\n}\n```\n\n此时会输出 :  `Base Destructor` , 也就是调用了父类的析构函数.\n\n这是十分危险的, 特别是我们需要确保子类的所有资源都被安全地释放.\n\n因此, 我们可以将父类的析构函数也设置为虚函数:\n\n```cpp\nclass Base {\npublic:\n    virtual ~Base() {\n        cout << \"Base Destructor\" << endl;\n    }\n};\n\nclass Derived : public Base {\npublic:\n    ~Derived() {\n        cout << \"Derived Destructor\" << endl;\n    }\n};\n```\n\n此时的输出:\n\n```cpp\nDerived Destructor  \nBase Destructor\n```\n\n> 先后调用子类和父类的析构函数.\n\n\n\n## 接口类\n\n> 也被称为 <u>协议类</u>. 其实就像 `swift`的协议一样, 强制要求继承的子类定义某些函数实现.\n\n- 含义:\n  - 只定义接口, 不提供实现的抽象类\n  - 所有的成员函数都是纯虚函数;\n  - 一般不包含任何数据成员.\n\ne.g.\n\n```cpp\nclass Printable {\npublic:\n    virtual void print() = 0;\n    virtual ~Printable() = default; // 记得虚析构函数\n};\n\nclass Document : public Printable {\npublic:\n    void print() override {\n        cout << \"Printing Document\" << endl;\n    }\n};\n```\n\n\n\n## 多重继承\n\n多重继承 *multiple inheritance* 指的是一个类继承自多个基类.\n\ne.g.\n\n```cpp\nclass A {\npublic:\n    void sayA() { cout << \"I am A\" << endl; }\n};\n\nclass B {\npublic:\n    void sayB() { cout << \"I am B\" << endl; }\n};\n\nclass C : public A, public B {\n    // 继承了 A 和 B 的成员\n};\n```\n\n可以将多个类的功能整合到一个类中:\n\n```cpp\nC c;\nc.sayA(); // OK\nc.sayB(); // OK\n```\n\n\n\n### 菱形继承\n\n多重继承中的特例:\n\n```cpp\nclass A {\npublic:\n    int value;\n};\n\nclass B : public A {};\nclass C : public A {};\nclass D : public B, public C {};\n```\n\n继承结构看上去就像菱形:\n\n```cpp\n     A\n   /   \\\n  B     C\n   \\   /\n     D\n```\n\n如果我们直接使用D类:\n\n```cpp\nD d;\nd.value = 10; // ❌ 编译错误：'value' is ambiguous\n```\n\n这是因为D继承自B和C, 而后者又各自具有自己的A子对象. 导致了二义性的问题.\n\n> [!NOTE]\n>\n> 注意此处的二义性的问题, 来自于在D类对象中直接访问A类对象的成员变量!  什么时候产生二义性? 就是判断此时是否存在多个相同名称的变量.\n\n\n\n### 虚继承\n\nC++ 提供了一个机制：**虚继承（virtual inheritance）**，来解决上述问题:\n\n```cpp\nclass B : virtual public A{};\nclass C : virtual public B{};\nclass D :  public B, public C{}\n```\n\n此时, D中只有一个共享的A子对象.\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass A\n{\npublic:\n    int value;\n    void ptr()\n    {\n        cout << \"value: \" << value << endl;\n    }\n};\nclass B : virtual public A {};\nclass C : virtual public A {};\nclass D : public B, public C {};\n\nint main()\n{\n    D d;\n    d.value = 10; // ✅ OK，只有一个 A，二义性消除\n    d.ptr();\n}\n```\n\n此时, B,C不再具有自己的A.\n\n\n\n> [!NOTE]\n>\n> 由于虚继承带来的是“共享”的基类对象，所以：\n>\n> - 虚基类的构造 **必须由最底层派生类负责**\n> - 派生类的构造函数中要**显式初始化**虚基类\n\n\n\n# Copy and Move\n\n#### 补充\n\n- `vptr`只会初始化一次, 然后保持不变. 发生在构造函数的第一步.\n- 循环内部执行构造和析构时, 作用的地址是同一块. 此时将对象的地址传入到vector of `*` 时, 得到的是相同的地址;\n  - 为了避免上述的情况, 我们在循环内部的构造, 需要为对象直接 `new` 一个新的空间.\n\n- `std::move`的作用就是告诉编译器: 这个类型是右值引用, 需要使用移动语义.\n\n\n\n\n\n## C++中的拷贝构造与移动语义\n\n### 拷贝构造函数基础\n\n拷贝构造函数是创建新对象的一种方式，它从现有对象复制数据来初始化新对象。\n\n- 拷贝构造函数的签名：`T::T(const T&)`\n- 如果不提供拷贝构造函数，C++会自动生成一个默认的拷贝构造函数\n- 默认拷贝构造函数执行的是成员级别的拷贝（memberwise copy），而非位级别的拷贝（bitwise copy）\n  - 对于基本类型成员，直接复制值\n  - 对于对象类型成员，调用其拷贝构造函数\n  - **<u>对于指针类型成员</u>**，只复制指针值（浅拷贝），导致两个对象共享同一块内存\n\n### 拷贝构造函数的调用时机\n\n拷贝构造函数在以下情况下会被调用：\n\n1. **按值传递参数时**：当对象作为参数按值传递给函数时\n   \n   ```cpp\n   void func(MyClass obj); // 调用时会触发拷贝构造\n   ```\n   \n2. **对象初始化时**：\n   \n   ```cpp\n   MyClass a;\n   MyClass b = a;    // 初始化，调用拷贝构造函数\n   MyClass c(a);     // 初始化，调用拷贝构造函数\n   ```\n   \n3. **函数返回对象时**：\n   \n   ```cpp\n   MyClass func() {\n       MyClass obj;\n       return obj;   // 可能触发拷贝构造（取决于编译器优化）\n   }\n   ```\n\n\n\n### 拷贝构造函数的最佳实践\n\n- 显式定义拷贝构造函数，不要依赖默认版本\n- 如果类不需要被复制，可以声明私有的拷贝构造函数（不需要定义）\n- 如果类包含指针成员，必须实现<u>深拷贝</u>的拷贝构造函数\n\n#### 深拷贝构造函数\n\n将拷贝的值另外寻找新的内存空间, 而不是指向同一处地址.\n\n- 如果没有显式定义深拷贝构造函数, 观察下面的代码:\n\n```cpp\nStringHolder original(\"Hello World\");\n\n{\n    StringHolder copy = original; // 调用拷贝构造函数\n    std::cout << \"copy包含: \" << copy.getString() << std::endl;\n\n    // 修改copy，如果是浅拷贝，也会影响original\n    copy.setString(\"Modified\");\n    std::cout << \"修改后，copy包含: \" << copy.getString() << std::endl;\n    std::cout << \"修改后，original包含: \" << original.getString() << std::endl;\n\n    // copy在此作用域结束时被销毁\n}\n```\n\n> - `original`的层级在  `copy` 的外面;\n>\n> - 在代码块的内部, 通过浅拷贝构造, 两者的数据共享一个内存空间;\n>\n> - 二者先后析构, 导致 `double free`的问题!\n>\n>   ```bash\n>   02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: Double free of object 0x11f6060c0\n>   02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: *** set a breakpoint in malloc_error_break to debug\n>   ```\n\n\n\n由此, 我们需要如此定义:\n\n```cpp\nclass StringHolder\n{\nprivate:\n    char *data;\n\npublic:\n    // 构造函数\n    StringHolder(const char *str)\n    {\n        if (str)\n        {\n            data = new char[strlen(str) + 1];\n            strcpy(data, str);\n            std::cout << \"构造函数: 为\\\"\" << data << \"\\\"分配内存\" << std::endl;\n        }\n        else\n        {\n            data = nullptr;\n            std::cout << \"构造函数: 创建空字符串\" << std::endl;\n        }\n    }\n\n    // 自定义拷贝构造函数（深拷贝）\n    // 如果复制掉这部分的自定义, 将会调用默认的浅拷贝构造函数, 导致问题:浅拷贝的指针两次释放内存\n    StringHolder(const StringHolder &other)\n    {\n        if (other.data)\n        {\n            data = new char[strlen(other.data) + 1];\n            strcpy(data, other.data);\n            std::cout << \"深拷贝构造函数: 为\\\"\" << data << \"\\\"分配新内存\" << std::endl;\n        }\n        else\n        {\n            data = nullptr;\n            std::cout << \"深拷贝构造函数: 复制空字符串\" << std::endl;\n        }\n    }\n\n    // 析构函数\n    ~StringHolder()\n    {\n        std::cout << \"析构函数: 释放\\\"\" << (data ? data : \"nullptr\") << \"\\\"的内存\" << std::endl;\n        delete[] data;\n    }\n};\n\n```\n\n这样就可以避免上面的问题.\n\n\n\n\n\n### 函数参数和返回值的选择\n\n- **传入参数**：\n  - 按值传递：`void func(Student s)` - 创建新对象，适用于需要存储对象的情况\n    - 如果对象内部的属性存在指针类型的属性, 为了避免浅拷贝, 就需要自定义一个深拷贝构造函数.\n  - 常量引用：`void func(const Student& s)` - 不创建新对象，适用于<u>只读取值</u>的情况\n  - 指针/引用：`void func(Student* s)` 或 `void func(Student& s)` - 适用于需要<u>修改对象</u>的情况\n  \n- **返回值**：\n  - 按值返回：`Student func()` - 返回新创建的对象\n  - 返回指针：`Student* func()` - 注意内存管理问题\n  - 返回引用：`Student& func()` - 注意生命周期问题\n\n## 右值引用与移动语义\n\n#### 左值与右值\n- **左值**：可以出现在赋值号左边的表达式\n  - 变量名、引用\n  - 解引用操作符（*）和下标操作符（[]）的结果\n- **右值**：只能出现在赋值号右边的表达式\n  - 字面量\n  - 表达式结果\n  - 函数返回的临时对象\n\n#### 右值引用\n- 使用 `&&` 声明\n- 可以绑定到右值，延长其生命周期\n- 右值引用变量本身是左值\n- 可以使用 `std::move()` 将左值转换为右值引用\n\n```cpp\nint x = 10;\nint&& rx = x * 2;  // 绑定右值\nrx = 100;          // rx本身是左值，可以被赋值\n```\n\n- 两种可以同时输入左值和右值引用作为参数的方法:\n\n  - 重载\n\n    ```cpp\n    // 重载函数，分别处理左值和右值\n    void process(int& x) {\n        std::cout << \"重载函数 - 处理左值: \" << x << std::endl;\n    }\n    \n    void process(int&& x) {\n        std::cout << \"重载函数 - 处理右值: \" << x << std::endl;\n    }\n    ```\n\n  - `const int& x `\n\n    ```cpp\n    // 接受const左值引用的函数（可以接受左值和右值）\n    void processAny(const int& x) {\n        std::cout << \"处理任意值: \" << x << std::endl;\n    }\n    ```\n\n\n\n\n\n#### 移动构造函数\n\n- 签名：`T::T(T&& other)`, 也就是**将右值引用作为参数的构造函数**\n- 用于\"窃取\"即将销毁的对象的资源，避免不必要的深拷贝\n- 通常将源对象的指针成员置为`nullptr`，防止资源被错误释放\n\n```cpp\nMyClass(MyClass&& other) : \n    ptr{other.ptr} {\n      other.data = 0\n      other.ptr = nullptr;  // 防止源对象析构时释放内存\n}\n```\n\n- 与浅拷贝类似, 但是需要在内部将源对象的指针成员 设置为 `nullptr` , 其他成员设置为有效但是为空的状态\n\n\n\n 标准库容器（如 std::vector）在进行元素移动时会优先选择不会抛异常的移动构造函数，否则会退而求其次选择拷贝构造函数（更慢）。\n\ne.g.\n\n```cpp\nstd::vector<DynamicArray> vec;\nvec.push_back(DynamicArray(5));\n```\n\n> 在这个 push_back 中，如果 DynamicArray 的移动构造函数被标记为 `noexcept`，那么 vector 会使用移动构造（高效）。\n\n\n\n\n\n## 初始化方式\n\nC++11提供了多种初始化对象的方式：\n\n- **小括号初始化**：`MyClass obj(arg1, arg2);`\n- **等号初始化**：`MyClass obj = value;`\n- **大括号初始化**（统一初始化）：`MyClass obj{arg1, arg2};`\n- **列表初始化**：\n  \n  ```cpp\n  int arr[] = {1, 2, 3};\n  MyClass* ptr = new MyClass{arg1, arg2};\n  ```\n\n#### 基本类型的初始化\n\n```cpp\n// 基本类型的初始化方式\nint a = 10;             // 等号初始化\nint b(20);              // 小括号初始化\nint c{30};              // 大括号初始化（C++11）\nint d = {40};           // 等号+大括号初始化（C++11）\nint arr1[] = {1, 2, 3}; // 数组初始化\nint arr2[]{4, 5, 6};    // 数组大括号初始化（C++11）\n```\n\n\n\n#### 对象的初始化\n\n```cpp\n// 对象的初始化方式\nPerson p1(\"张三\", 25);          // 小括号初始化\nPerson p2 = Person(\"李四\", 30); // 等号+临时对象初始化\nPerson p3{\"王五\", 35};          // 大括号初始化（C++11）\nPerson p4 = {\"赵六\", 40};       // 等号+大括号初始化（C++11）\n```\n\n\n\n- 动态分配对象的初始化\n\n  ```cpp\n  // 动态分配对象的初始化方式\n  Person *pp1 = new Person(\"动态张三\", 25); // 传统new\n  Person *pp2 = new Person{\"动态李四\", 30}; // 大括号初始化（C++11）\n  ```\n\n\n\n### 深拷贝与浅拷贝\n\n- **浅拷贝**：默认拷贝构造函数执行的是浅拷贝，只复制指针值，不复制指针指向的内容\n- **深拷贝**：自定义拷贝构造函数可以实现深拷贝，为指针成员分配新内存并复制内容\n\n### 何时使用移动语义\n\n- 类包含动态分配的资源（如指针成员）\n- 对象需要在函数间传递\n- 需要避免不必要的深拷贝操作\n- 使用容器时（如`std::vector`、`std::string`等）\n  - `move`会将一个左值变成右值引用, 从而允许调用移动构造函数!\n  - 使用 `move` 时, 如果存在对应的移动构造函数, 就会优先调用;\n  - 数组的 `push_back`也是如此, 优先调用移动构造函数\n    - 但是我们可以使用 `emplace`来继续优化上述的效率问题——直接将对象存储到数组的末端.\n\n\n\n\n### 总结\n\n- 拷贝构造函数用于创建对象的副本，深拷贝需要自定义实现\n- 移动语义通过右值引用实现**资源的高效转移**，避免不必要的拷贝, 同时**规避了浅拷贝导致的 double free** 的问题.\n- 根据需要选择合适的参数传递和返回值方式\n- 使用`std::move()`可以将左值转换为右值引用，触发移动语义\n\n\n\n---\n\n\n\n# Overloaded Operators\n\n#### 补充\n\n自定义类型的方向转换:  *T* ==> *C*\n\n- 当下面情况存在一种时, 可以发生上述的转换:\n\n  1. C存在以 *T* 作为输入参数的构造函数;\n\n  2. *T* 存在 `operator C(){ }`的成员函数.\n     e.g.\n\n     ```cpp\n     class Rational {\n     public:\n         operator double() const {  // Rational到double的转换\n             return numerator_ / (double)denominator_;\n         }\n     };\n     \n     Rational r(1, 3);\n     double d = r;  // 隐式转换：r => double\n     ```\n\n- 不同同时存在两者的转换(编译器无法知道采取什么方式)\n\n\n\n题目:\n\n- 并非所有运算符都可以用三种方式重载。例如赋值运算符 =、下标运算符 []、函数调用运算符 ()、成员访问运算符 -> **只能**作为成员函数重载;\n\n- 流提取符 >> 和插入符 << 可以被重载\n\n- 运算符 `+` 返回的类型 **不一定** 要与参数类型一致;\n\n- 对于友元函数, 在声明处加上 `friend`标识, 但是在定义处是没有这个标识的. \n\n- > [!NOTE]\n  >\n  > 无法被重载的运算符:\n  >\n  > - 条件运算符: ` ?: `\n  > - 成员指针访问运算符: `.*` \n\n  `new`是可以重载的!\n\n- 运算符的分类:\n\n  - 成员运算符: 在类内部以成员函数形式重载的运算符 ==> 具有隐式的 `this`;\n\n  - 友元运算符: 定义在类外部（在类内部用 `friend` 声明），没有 `this` 指针.\n\n    因此, 一个重载函数只有一个参数时 ==> 二员成员运算符 / 一元友元运算符.\n\n\n\n\n\n\n\n- 隐式转换的尝试是从左到右的:\n  - `1+a`会尝试将类的对象 `a` 尝试转换为int类型.\n\n- 注意类型:\n\n  ```cpp\n  // 前缀++\n  const Integer& Integer::operator++() {\n      *this += 1;  // 先增加\n      return *this;  // 再返回\n  }\n  \n  // 后缀++（参数int未使用，仅用于区分）\n  const Integer Integer::operator++(int) {\n      Integer old(*this);  // 先保存\n      ++(*this);  // 再增加\n      return old;  // 返回旧值\n  }\n  ```\n\n  前缀++的返回是 `&` 类型, 因为比较节省空间和时间. 后缀++的返回是值.\n\n  - `[]` 的返回必须是 `&` 类型, 这样可以作为左值赋值.\n\n\n\n返回类型设计的**总体原则**：\n\n1. 如果运算符需要作为左值（可以出现在赋值左侧），返回非常量引用。\n   1. 否则, 声明为`const`类型, 避免成为左值.\n\n2. 如果运算符创建新对象，返回值（通常是常量值）。\n3. 如果运算符返回布尔结果，直接返回 `bool` 类型。\n4. 如果需要支持链式操作，返回引用。\n\n\n\n全局和成员函数的设计思路:\n\n1. 一元运算符（如 `-a`）应该用**成员函数**，因为只操作一个对象\n2. 赋值相关运算符（`=`, `+=`, `[]`, `->()`与 `->*` 等）必须是成员函数，因为它们需要修改对象状态\n3. 对于二元运算符（如 `+`, `-`, `*`, `/`)建议使用**全局函数**，因为：\n   - 支持操作数的对称转换\n   - 更好地支持与其他类型的互操作\n   - 保持了运算符的自然语义（如 `3 * x` 和 `x * 3` 应该都能工作）\n\n\n\n## C++运算符重载基础\n\n运算符重载是C++的一项强大特性，它允许用户定义的类型像内置类型一样使用各种运算符。本质上，运算符重载是函数调用的另一种形式。\n\n### 可重载与不可重载的运算符\n\nC++允许重载大多数运算符，但以下**运算符不能被重载**：\n\n- `.` (成员访问运算符)\n- `.*` (成员指针访问运算符)\n- `::` (作用域解析运算符)\n- `?:` (条件运算符)\n- `sizeof` (获取类型大小)\n- `typeid` (获取类型信息)\n- 类型转换运算符 (`static_cast`, `dynamic_cast`, `const_cast`, `reinterpret_cast`)\n\n### 运算符重载的限制\n\n1. **只能重载已存在的运算符**\n   - 不能创建新的运算符（如Python中的`**`）\n   - 可以改变运算符的语义（如重载`+`实现减法），但不推荐\n\n2. **运算符必须在类或枚举类型上重载**\n   - 至少有一个操作数必须是用户定义类型\n\n3. **必须保持操作数数量**\n   - 如二元运算符`/`重载后仍必须是二元的\n\n4. **必须保持优先级和结合律**\n   - 运算符的优先级和结合律是固定的，不能被改变\n\n## 运算符重载的实现方式\n\n运算符重载本质上是一个以`operator`关键字为前缀，后跟运算符的特殊函数。\n\n### 成员函数方式\n\n作为类的成员函数实现运算符重载时：\n\n- 第一个操作数（左操作数）隐式为`this`指针\n- 不对接收者（左操作数）执行类型转换\n\n```cpp\nclass A {\npublic:\n    A(int ii) : i(ii) {}\n    int get() { return i; }\n    \n    // 重载+运算符，返回新对象\n    const A operator+(const A& that) const {\n        A c(this->i + that.i);\n        return c;\n    }\nprivate:\n    int i;\n};\n```\n\n使用成员函数重载时，左操作数必须是该类的对象：\n\n- `a + b` 可行（a是A类对象）\n- `a + 9` 可行（9会被隐式转换为A类对象）\n- `9 + a` 不可行（9不是A类对象）\n\n\n\n\n\n> [!NOTE]\n>\n> 隐式转换: 编译器查找是否存在从给出参数作为构造函数的输入, 从而创建一个指定对象的方式:\n>\n> e.g.\n>\n> ```cpp\n> Integer h = a + 7; // 7被隐式转换为Integer\n> ```\n>\n> 上述发生的前提条件是 类 `Integer` 存在对应的构造函数:\n>\n> ```cpp\n> Integer(int val = 0) : value(val)\n> ```\n\n\n\n\n\n\n\n### 全局函数方式\n\n作为全局函数实现运算符重载时：\n\n- 所有操作数都是显式参数\n- 开发者不需要特殊访问类的权限\n- 可能需要声明为友元函数以访问私有成员\n\n```cpp\nclass Integer{\nprivate:\n  int value;\n\n  friend const Integer operator*(const Integer &left, const Integer& right);\n};\n\n// 可以直接在全局函数中访问私有成员\nconst Integer operator*(const Integer &left, const Integer &right)\n{\n    std::cout << \"调用全局函数*运算符: \" << left.value << \" * \" << right.value << std::endl;\n    return Integer(left.value * right.value);\n}\n```\n\n\n\n当然, 全局函数实现的运算符重载, 可以通过调用类的public中的函数接口, 来间接访问内部的私有成员变量:\n\n```cpp\nclass Integer{\n  public: \n  int getValue(){\n    return value;\n  }\n};\n\n// 通过public接口访问内部的私有成员变量.\nconst Integer operator/(const Integer &left, const Integer &right)\n{\n    std::cout << \"调用全局函数/运算符: \" << left.getValue() << \" / \" << right.getValue() << std::endl;\n    if (right.getValue() == 0)\n    {\n        std::cerr << \"错误: 除数不能为零\" << std::endl;\n        return Integer(0);\n    }\n    return Integer(left.getValue() / right.getValue());\n}\n```\n\n\n\n使用全局函数重载时，可以处理左操作数不是该类对象的情况：\n\n- `9 - b` 可行（9会被隐式转换为A类对象）\n- 因为两个操作数都是普通参数，地位平等, 体现了运算符的对称性\n\n\n\n\n\n### 成员函数vs全局函数的选择\n\n- **一元运算符**应该作为成员函数\n- **赋值运算符**（`=`, `()`, `[]`, `->`, `->`）必须是成员函数\n- 其他**二元运算符**最好作为非成员函数（全局函数）\n\n## 参数传递与返回类型\n\n### 参数传递\n\n1. 对于只读参数，使用`const`引用传递（除了内置类型）\n2. 对于不修改对象的成员函数，声明为`const`\n3. 对于全局函数，如果左操作数会被修改，使用引用传递\n\n### 返回类型\n\n根据运算符的预期含义选择返回类型：\n\n1. **算术运算符**（`+`, `-`, `*`, `/`, `%`, `^`, `&`, `|`, `~`）\n\n   ```cpp\n   const T operator X(const T& l, const T& r);\n   ```\n\n   - 返回新对象，不应返回引用（除非返回成员引用）\n   - 返回`const`对象防止`(a+b) = c`这样的操作\n\n2. **逻辑运算符**（`!`, `&&`, `||`, `<`, `<=`, `==`, `>=`, `>`）\n\n   ```cpp\n   bool operator X(const T& l, const T& r);\n   ```\n\n   - 返回布尔值\n\n3. **下标运算符**（`[]`）\n\n   ```cpp\n   E& T::operator[](int index);\n   ```\n\n   - 返回左值（非`const`引用），允许`a[i] = value`操作\n   - 不能返回新对象，否则赋值操作无效\n\n## 特殊运算符重载\n\n### 自增自减运算符\n\nC++区分前缀和后缀自增自减运算符：\n\n```cpp\n// 前缀++\nconst Integer& Integer::operator++() {\n    *this += 1;  // 先增加\n    return *this;  // 再返回\n}\n\n// 后缀++（参数int未使用，仅用于区分）\nconst Integer Integer::operator++(int) {\n    Integer old(*this);  // 先保存\n    ++(*this);  // 再增加\n    return old;  // 返回旧值\n}\n```\n\n调用方式：\n\n- `++x` 调用 `x.operator++()`\n\n  - 返回的是引用, 从而支持链式操作 如:\n\n    ```cpp\n    Counter g = ++(++f); // 可以，因为前缀返回引用\n    ```\n\n- `x++` 调用 `x.operator++(0)`\n\n  - 返回的是临时的对象, 也就是旧值的副本. 声明`const`避免了后缀的链式调用\n\n    ```cpp\n    Counter h = (f++)++; // 不可以，因为后缀返回const值\n    ```\n\n    之所以要防止上述的后缀链式调用, 是因为 对`f++`继续自增将会导致语义的混乱.\n\n\n\n\n\n\n### 下标运算符\n\ne.g.\n\n```cpp\n// 下标运算符（返回左值引用，允许修改）\nint& operator[](int index) {\n    if (index < 0 || index >= size) {\n        std::cerr << \"错误: 下标越界 [\" << index << \"]\" << std::endl;\n        // 返回第一个元素作为应急措施（实际应用中应抛出异常）\n        return data[0];\n    }\n    return data[index];\n}\n\n// 下标运算符的const版本（返回值，不允许修改）\nint operator[](int index) const {\n    if (index < 0 || index >= size) {\n        std::cerr << \"错误: 下标越界 [\" << index << \"]\" << std::endl;\n        // 返回0作为应急措施（实际应用中应抛出异常）\n        return 0;\n    }\n    return data[index];\n}\n```\n\n\n\n\n\n### 关系运算符\n\n关系运算符通常成对实现，可以相互利用：\n\n```cpp\nbool Integer::operator==(const Integer& rhs) const {\n    return i == rhs.i;\n}\n\nbool Integer::operator!=(const Integer& rhs) const {\n    return !(*this == rhs);  // 利用==运算符\n}\n\nbool Integer::operator<(const Integer& rhs) const {\n    return i < rhs.i;\n}\n\nbool Integer::operator>(const Integer& rhs) const {\n    return rhs < *this;  // 利用<运算符\n}\n\nbool Integer::operator<=(const Integer& rhs) const {\n    return !(rhs < *this);  // 利用<运算符\n}\n\nbool Integer::operator>=(const Integer& rhs) const {\n    return !(*this < rhs);  // 利用<运算符\n}\n```\n\n### 流运算符\n\n输入输出流运算符通常实现为全局函数：\n\n```cpp\n// 输出流运算符\nostream& operator<<(ostream& os, const A& a) {\n    os << a.get();\n    return os;  // 返回流对象以支持链式操作\n}\n\n// 输入流运算符\nistream& operator>>(istream& is, A& a) {\n    string line;\n    cin >> line;\n    // 读取a的数据\n    return is;  // 返回流对象以支持链式操作\n}\n```\n\n注意：\n\n- 输出流运算符的第一个参数不能是`const`，因为输出会修改流\n- 输入流运算符的第二个参数不能是`const`，因为需要修改对象\n- 通常需要声明为友元以访问私有成员\n\n### 自定义流操纵符\n\n可以定义自己的流操纵符：\n\n```cpp\nostream& tab(ostream& out) {\n    return out << '\\t';\n}\n\n// 使用：cout << \"Hello\" << tab << \"World!\" << endl;\n```\n\n\n\n\n\n## 赋值运算符与类型转换\n\n### 赋值运算符\n\n赋值运算符有几个重要特点：\n\n- 必须是成员函数\n- 如果不提供，编译器会自动生成（行为类似默认拷贝构造函数）\n- 需要检查自赋值情况\n- 确保为所有数据成员赋值\n- 返回`*this`的引用\n\n```cpp\nA& A::operator=(const A& rhs) {\n    if (this != &rhs) {  // 检查自赋值\n        // 释放当前资源\n        delete[] data;\n        \n        // 分配新资源\n        data = new int[rhs.size];\n        size = rhs.size;\n        \n        // 复制数据\n        for (int i = 0; i < size; i++) {\n            data[i] = rhs.data[i];\n        }\n    }\n    return *this;  // 返回对象引用\n}\n```\n\n### 类型转换\n\n\n\n#### 隐式转换\n\nC++支持两种用户定义的类型转换：\n\n1. **构造函数转换**：从其他类型到当前类型\n\n   ```cpp\n   class PathName {\n       string name;\n   public:\n       PathName(const string& s) : name(s) {}  // string到PathName的转换\n   };\n   \n   string abc(\"abc\");\n   PathName xyz = abc;  // 隐式转换：abc => PathName\n   ```\n\n   可以使用`explicit`关键字禁止隐式转换：\n\n   ```cpp\n   explicit PathName(const string& s);  // 只能用于显式构造\n   ```\n\n2. **转换运算符**：从当前类型到其他类型\n\n   ```cpp\n   class Rational {\n   public:\n       operator double() const {  // Rational到double的转换\n           return numerator_ / (double)denominator_;\n       }\n   };\n   \n   Rational r(1, 3);\n   double d = r;  // 隐式转换：r => double\n   ```\n\n   同样可以使用`explicit`关键字要求显式转换：\n\n   ```cpp\n   explicit operator double() const;\n   double d = (double)r;  // 必须显式转换\n   ```\n\n注意：如果同时提供了从T到C的构造函数和从C到T的转换运算符，编译器可能会产生歧义。\n\n\n\n#### 显式转换\n\n显式转换的外在特点:\n\n- 使用直接初始化语法\n- 明确指出要用构造函数创建对象\n- 转换过程更加清晰可见\n\ne.g.\n\n```cpp\n// 构造函数转换：double到Rational\nRational r1 = 3.14;  // 隐式转换\nRational r2(2.5);    // 显式转换\n```\n\n\n\n如果声明 `explict`, 就必须使用强制的显式转换:\n\n```cpp\n// 如果想要强制显式转换，应该这样声明：\nexplicit Rational(double value) {\n    const int PRECISION = 10000;\n    numerator = static_cast<int>(value * PRECISION);\n    denominator = PRECISION;\n    simplify();\n}\n\nRational r1 = 3.14;        // 错误：不允许隐式转换\nRational r2(2.5);          // 正确：显式构造\nRational r3 = Rational(3.14); // 正确：显式转换\n```\n\n\n\n类型的显式转换:\n\n```cpp\ndouble d2 = static_cast<double>(r2);  // 显式转换\n```\n\n\n\n#### 混合类型的转换\n\n根据运算结果, 自动地将运算的操作数进行类型转换:\n\n```cpp\n// 混合类型运算\nRational r3(1, 2);\ndouble d3 = 0.5;\n\n// 这里会将r3转换为double，然后进行double加法\ndouble result = r3 + d3;\n```\n\n\n\n# Template\n\n## 模板概述\n\n模板是C++中实现**<u>泛型编程</u>**的核心机制，允许我们编写可以处理不同数据类型的代码，而不必为每种类型重复编写相同的逻辑。\n\n- 首先尝试匹配普通的函数, 否则尝试匹配模板函数\n\n\n\n- 函数模板是声明, 而非定义. 是在实际调用时候去 **<u>实例化</u>** 对应类型的函数.\n\n- 必须都放在头文件的实现包含:\n\n  - 函数模板;\n\n  - inline函数\n\n  - 带有default参数的声明.\n\n  - 类模板的成员函数\n\n    ```cpp\n    template<T>\n    int Vector<T>::getSize()const{\n      return size;\n    }\n    ```\n\n    注意, 都需要声明模板类, 并且需要在 `< >`内部声明类.\n\n\n\n- `template<class T>` 和 `template<typename T>` 是等价的, 后者是后来引入的更明确的语法.\n- 类模板的每个成员函数在类外定义时，都必须以`template<class T>`（或`template<typename T>`）开头，即使该成员函数没有直接使用模板参数T.\n\n- `Vector< int (*)>`\n\n## 函数模板\n\n### 基本语法\n\n```cpp\ntemplate<class T>\nvoid swap(T& x, T& y) {\n    T temp = x;\n    x = y;\n    y = temp;\n}\n```\n\n- `template` 关键字引入模板声明\n- `class T` 指定参数化类型名称（`class`在这里表示任何内置类型或用户定义类型）\n- 在模板内部，`T` 被用作类型名称\n\n### 模板实例化\n\n```cpp\nint i = 3, j = 4;\nswap(i, j);  // 使用int类型的swap\n\nfloat k = 4.5, m = 3.7;\nswap(k, m);  // 实例化float类型的swap\n\nstd::string s(\"Hello\"), t(\"World\");\nswap(s, t);  // 实例化std::string类型的swap\n```\n\n编译器会根据传入的参数类型自动生成相应的函数实例。\n\n### 模板匹配规则\n\n- 只使用类型的精确匹配\n- 不应用类型转换操作\n- 即使是隐式转换也会被忽略\n\n```cpp\nswap(int, int);     // 正确\nswap(double, double); // 正确\nswap(int, double);  // 错误！类型不匹配\n```\n\n### 模板函数与普通函数共存\n\n如果同时存在模板函数和普通函数，编译器会优先选择**<u>普通函数</u>**.\n\n\n\n#### 显式指定\n\n可以显式地指定模板参数类型:\n\n```cpp\n// 带有返回值的函数模板\ntemplate <class T>\nT myMax(T a, T b)\n{\n    cout << \"调用模板版本的myMax\" << endl;\n    return (a > b) ? a : b;\n}\n\nint main(){\n  cout << \"myMax<double>(10, 20.5) = \" << myMax<double>(10, 20.5) << endl; \n}\n\n// myMax(10, 20.5);  // 错误：参数类型不一致\n```\n\n\n\n#### 多参数的函数模板\n\n同理的, 我们可以设置多个参数类型, 根据输入的类型来推断:\n\n```cpp\ntemplate <class T1, class T2>\nT1 myMax(T1 a, T2 b)\n{\n    cout << \"调用模板版本的myMax2\" << endl;\n    return (a > b) ? a : b;\n}\n\nint main(){\n  cout <<  myMax(10, 20.5) << endl; \n}\n```\n\n 此时, 上述的函数不需要显式的声明参数类型, 因为存在匹配的模板函数.\n\n同时, 此时根据类型推断, 返回的类型是 `int`, 然后舍弃 20.5的小数部分, 最终的结果是 `20`.\n\n\n\n## 类模板\n\n### 基本语法\n\n此处的 `Vector`是自己定义的.\n\n```cpp\ntemplate<class T>\nclass Vector {\npublic:\n    Vector(int);\n    ~Vector();\n    Vector(const Vector&);\n    Vector& operator=(const Vector&);\n    T& operator[](int);\nprivate:\n    T* m_elements;\n    int m_size;\n};\n```\n\n### 类模板的使用\n\n类模板必须显式指定类型参数：\n\n```cpp\nVector<int> v1(100);\nVector<Complex> v2(256);\nv1[20] = 10;\nv2[20] = v1[20];  // 如果定义了int到Complex的转换，则正确\n```\n\n### 类模板成员函数的定义\n\n所有成员函数定义都需要包含模板声明：\n\n```cpp\ntemplate <class T>\nVector<T>::Vector(int size) : m_size(size) {\n    m_elements = new T[m_size];\n}\n\ntemplate <class T>\nT& Vector<T>::operator[](int indx) {\n    if (indx < m_size && indx >= 0) {\n        return m_elements[indx];\n    } else {\n        // 错误处理\n    }\n}\n```\n\n注意：\n\n- 每个成员函数定义前都要加上 `template <class T>`\n- 类名必须写为 `Vector<T>`\n- 类模板的函数通常在头文件中实现，不需要分离的.cpp文件\n\n## 多参数模板\n\n模板可以使用多个类型参数：\n\n```cpp\ntemplate<class Key, class Value>\nclass HashTable {\n    const Value& lookup(const Key&) const;\n    void install(const Key&, const Value&);\n    // ...\n};\n```\n\n## 嵌套模板\n\n模板可以嵌套使用，因为它们只是新的类型：\n\n```cpp\nVector<Vector<double>> matrix;  // 注意C++11之前需要空格：Vector<Vector<double> >\nVector<int (*)(Vector<double>&, int)> functionPointers;  // 函数指针的向量\n```\n\n\n\n#### 非类型模板参数\n\n~也就是没有使用模板类型的普通参数.\n\n```cpp\ntemplate<class Key, class Value, int TableSize = 10>\nclass HashTable {\n    // ...\n};\n```\n\n其中的 `TableSize` 就是普通的参数. 在编译时就确定了类型.\n\n\n\n\n\n## 模板的局限性与注意事项\n\n1. 模板代码通常放在头文件中，因为编译器需要在编译时看到完整的模板定义\n2. 模板错误通常在实例化时才会被发现，错误信息可能很复杂\n3. 模板可能导致代码膨胀，因为每种类型都会生成一份代码\n4. 模板参数必须支持模板中使用的所有操作\n\n\n\n\n\n# 其他\n\n- 使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.\n  - 另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.\n\n\n\n## 访问控制\n\n### 继承关系中的访问控制\n\n控制基类成员在派生类中的可见性：\n\n- `public`：基类的 `public` 成员在派生类中仍然是 `public`，`protected` 成员仍然是 `protected`。\n- `protected`：基类的 `public` 和 `protected`成员在派生类中都变为 `protected`。\n- `private`：基类的 `public` 和 `protected` 成员在派生类中都变为 `private`。\n\n## 作用域与生存期\n\n本地: 均为本地\n\n全局: 均为全局\n\n静态本地: 作用域是本地, 生存期是全局\n\n静态全局: ~\n\n\n\n## Includes\n\n### Algorithm\n`copy(first, last, result)`:\n- `fisrt`和`last`是输入迭代器, 表示要复制的范围, 左闭右开即`last`应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;\n- `result`是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作\n  - e.g.\n    ```cpp\n    std::vector<int> source = {1, 2, 3, 4, 5};\n    std::vector<int> destination(5); // 确保目标容器有足够的空间\n    \n    std::copy(source.begin(), source.end(), destination.begin());\n    \n    for (int num : destination) {\n        std::cout << num << \" \"; // 输出：1 2 3 4 5\n    }\n    std::cout << std::endl;\n    ```\n- `result`可以直接输出到`cout`中.\n    ```cpp\n    vector<int> vec;\n    \n    for(int i = 0; i < 5; i++){\n        vec.push_back(i);\n    }\n    \n    vec.erase(vec.begin()+2); //删除第三个元素\n    copy(vec.begin(), vec.end(), ostream_iterator<int>(cout, \",\"));\n    cout << endl;\n    // 0,1,3,4,\n    ```\n\n---\n\n- 数组之间**不可以**直接赋值, 但是字符串可以直接赋值\n```cpp\nchar str1[] = \"Hello\";\nchar str2[] = \"World\";\nstr1 = str2;  // 错误，数组之间不可以直接赋值\n\nstring s1 = \"Hello\";\nstring s2 = \"World\";\ns1 = s2;  // 正确，字符串可以直接赋值\n\n```\n\n\n## 深拷贝\n```cpp\nstring s1 = \"Hello\";\nstring s2 = \"World\";\n\ncout << \"初始状态：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：Hello\ncout << \"s2: \" << s2 << endl;  // 输出：World\n\ns1 = s2;  // 赋值操作\n\ncout << \"赋值后：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：World\ncout << \"s2: \" << s2 << endl;  // 输出：World\n\n// 修改 s2 不会影响 s1，因为是深拷贝\ns2 = \"Changed\";\ncout << \"修改 s2 后：\" << endl;\ncout << \"s1: \" << s1 << endl;  // 输出：World\ncout << \"s2: \" << s2 << endl;  // 输出：Changed\n```\n\n## Temp\n```cpp\n// 迭代器\nI.begin();\nI.end();\n\n// Item Access\nV.front();;\nV.back();\n```\n\n## 区分\n### find\n`find`是字符串类的一种方法, 同时也是标准库`algorithm`中的一个函数.\n- `find`方法: 用于在字符串中查找子字符串的位置。\n```cpp\nstring str = \"Hello World\";\nsize_t pos = str.find(\"World\");\nif (pos != string::npos) {\n    cout << \"Found 'World' at position \" << pos << endl;\n}\n```\n- `algorithm`中的`find`函数: 用于在容器（如数组、向量等）中查找元素。\n```cpp\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main() {\n    vector<int> vec = {1, 2, 3, 4, 5};\n    vector<int>::iterator it = find(vec.begin(), vec.end(), 3);\n    if (it != vec.end()) {\n        cout << \"Found 3 at position \" << distance(vec.begin(), it) << endl;\n    }\n}\n// Found 3 at position 2\n```\n> 编译: `g++ -std=c++11 test.cpp -o test`\n\n### erase\n- 对于字符串的方法: `str.erase(pos, len)`\n  - 删除从指定位置开始的指定个数字符\n```cpp\nstring str = \"Hello World\";\nstr.erase(6, 5);\ncout << str << endl;  // 输出: Hello\n```\n\n---\n\n- 对于容器的方法: `erase(pos1, pos2)`\n  - 左闭右开式删除容器当中的元素.\n```cpp\n#include <iostream>\n#include <vector>\n\nint main() {\n    std::vector<int> vec = {1, 2, 3, 4, 5, 6};\n    std::cout << \"Original vector: \";\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl;\n\n    // 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素\n    vec.erase(vec.begin() + 1, vec.begin() + 4); // 删除 vec[1], vec[2], vec[3]\n\n    std::cout << \"Modified vector: \";\n    for (int i : vec) {\n        std::cout << i << \" \";\n    }\n    std::cout << std::endl; // 输出 \"1 5 6\"\n\n    return 0;\n}\n```\n\n## 不知道放在哪里的代码块\n```cpp\n#include <iostream>\n#include <list>\nusing namespace std;\n\nint main() {\n// 1. 创建并填充链表\nlist<int> L;                      // 创建一个空的整数链表\nfor(int i=1; i<=5; ++i)          // 循环5次\n    L.push_back(i);              // 依次在链表尾部添加数字1,2,3,4,5\n                                 // 此时链表内容为：1,2,3,4,5\n\n// 2. 删除第二个元素\nL.erase( ++L.begin() );          // L.begin()指向第一个元素\n                                 // ++L.begin()指向第二个元素\n                                 // erase删除迭代器指向的元素\n                                 // 此时链表内容为：1,3,4,5\n\n// 3. 打印链表内容\ncopy(                            // 标准库算法，用于复制序列\n    L.begin(),                   // 源序列的起始位置\n    L.end(),                     // 源序列的结束位置\n    ostream_iterator<int>(       // 输出流迭代器\n        cout,                    // 指定输出到标准输出\n        \",\"                      // 每个元素后面追加的分隔符\n    )\n);\ncout << endl;                    // 换行\n\n}\n```\n\n\n\n# 课堂缓冲区\n\n- 私有的边界是 `class`而非对象. 也就是说, **相同类的对象可以直接访问对方的私有属性**.\n\n- 不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们之间没有初始化的依赖.\n- 需要尽可能地避免使用全局变量.\n- 一个良好的习惯: 当成员函数不需要改变成员变量的值时, 在后面加上 `const`的关键字, 确保不会改变;\n\n\n\n```cpp\nchar* s = \"Hello,world！\"；\n```\n\n> 此时的右侧字符串位于 段 `text`, 不可写. `s`本身是一个固定内存的指针.\n\n```cpp\nchar s［］ = \"Hello,world！\"；\n```\n\n> 此时的 `s`是一个大小等于数组内容的对象.\n\n```cpp\nconst int* f();\n// 只能将函数的返回值赋值给一个 const int*\n```\n\n\n\n#### 函数内部的对象的空间分配\n\n编译器在编译的时候计算得到函数内部所有的对象的空间, 在实际进入函数的时候**, 立即分配所有对象的空间;**\n\n- 实际执行到的时候发生构造.\n\n\n\n#### Quiz\n\n静态全局、本地和成员变量都存储于全局数据区.\n\n- 静态成员变量的构造也在 `main()`之前.\n\n# 题目梳理\n\n## HW2\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedundefinedundefinedimage-20250225160042809.png?imageSlim)\n\n- ANS:  B\n- 由于此处的`map`以`char *`作为key, 同时初始化`str`的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.\n\n---\n\n![](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250225160652522.png?imageSlim)\n\n- 逗号表达式, 从左到右分别计算,最后返回的结果是最右侧的值, 此处为1. \n\n> - `vector<int> v(10);` 创建包含10个元素的容器, 每个元素初始化为 `0`;\n>\n> - `vector <int> v(10, 1);`: 创建包含10个元素的容器, 但是都初始化为 `1`;\n> - `vector <int> v{10, 1};`: 创建包含10,1 这2个元素的容器;\n> - 此外, 还可以使用 `vector <int> v`;创建一个空的容器; \n> - 同时也还可以用 **迭代器**进行初始化: `vector <int> v(arr, arr + 5);`\n\n\n\n## HW3\n\n- 类成员的默认访问权限是 **<u>私有的</u>**, 即不显式声明访问修饰符, 默认为 `private`;\n\n  \n\n## HW4\n\n### 可变大小矩阵:\n\n```cpp\n#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n\nclass Matrix{\nprivate:\n    int r,c;\n    vector<vector<int>> m; // 二维向量, 每个向量元素是一个一维向量\n\npublic:\n    Matrix(int r, int c) : r(r),c(c){\n        m.resize(r, vector<int>(c)); // 分配r个一维向量, 每个一维向量的大小为c\n    }\n\n\t...\n\n    void transform(){\n        vector<vector<int>> new_m(c, vector<int>(r,0)); //\t声明一个临时的二维向量\n        \n    \t// 将矩阵转置, 放入临时的向量\n        for(int i = 0; i < c; i++){\n            for(int j = 0 ; j< r; j++){\n                new_m[i][j] = m[j][i];\n            }\n        }\n\n        swap(r,c); //改变矩阵的行与列\n        m = move(new_m); //使用 move 直接将临时变量的所有权交给m, 避免拷贝\n    }\n};\n```\n\n> 此处值得注意的是 `resize`在二维向量中的使用, 以及 `move`直接给予“所有权”的特性.\n\n\n\n\n\n## HW5\n\n**判断题**: const成员函数不能作用于非const对象\n\n> 答案是 **False**. \n>\n> 题目的意思大致是: 非const对象无法调用 const对象, 实际上是事实是相反的描述. 只需要理解题目的表述即可做出判断.\n\n\n\n## HW6\n\n右值引用本身是一个左值, 可以取地址.\n\n```cpp\nint&& r = 5;\nstd::cout << r; // r 在这里是左值，因为它有名字\n```\n\n\n\n## HW7\n\n\n\n## HW9\n\n1. 因为静态成员函数不能是虚函数，所以它们不能实现多态\n\n   - 静态成员函数不与类的任何具体实例（对象）相关联;\n\n2. 在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序\n\n   ```cpp\n   #include <iostream>\n   \n   // 基类A\n   class A\n   {\n   public:\n       A()\n       {\n           std::cout << \"A的构造函数被调用\" << std::endl;\n       }\n   };\n   \n   // 基类B\n   class B\n   {\n   public:\n       B()\n       {\n           std::cout << \"B的构造函数被调用\" << std::endl;\n       }\n   };\n   \n   // 派生类C，继承自A和B\n   class C : public A, public B\n   {\n   public:\n       // 构造函数中显式调用基类构造函数\n       C() : B(), A()\n       { // 注意：这里虽然B在A之前，但实际调用顺序由类定义决定\n           std::cout << \"C的构造函数被调用\" << std::endl;\n       }\n   };\n   \n   int main()\n   {\n       C c; // 创建C的实例\n       return 0;\n   }\n   ```\n\n   输出:\n\n   ```cpp\n   A的构造函数被调用\n   B的构造函数被调用\n   C的构造函数被调用\n   ```\n\n   由此可见, 虽然在C的初始化列表中声明了B前A后, 但是实际上A优先调用.\n\n3. ~~如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针）~~\n\n   - 这句话的括号内部是错误的.\n\n   - 因为我们依旧可以将其的子类 `upcast`\n\n     ```cpp\n     #include <iostream>\n     using namespace std;\n     \n     class A\n     {\n     public:\n         virtual void ptr() = 0;\n     };\n     \n     class B : public A\n     {\n     public:\n         void ptr() override\n         {\n             cout << \"B\" << endl;\n         }\n     };\n     \n     int main()\n     {\n         A *a = new B();\n         a->ptr();\n         return 0;\n     }\n     ```\n\n\n\n\n\n- 类内的纯虚函数被认为是 `inline`的函数;\n\n- 在创建派生类的对象时, 构造函数的执行顺序为—— 基类对象->对象成员->派生类自身:\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n  \n  class Base\n  {\n  public:\n      Base() { cout << \"Base 构造函数\" << endl; }\n  };\n  \n  class Member\n  {\n  public:\n      Member() { cout << \"Member 构造函数\" << endl; }\n  };\n  \n  class Derived : public Base\n  {\n      Member m;\n  \n  public:\n      Derived() { cout << \"Derived 构造函数\" << endl; }\n  };\n  \n  int main()\n  {\n      Derived d;\n      return 0;\n  }\n  ```\n\n  输出:\n\n  ```cpp\n  Base 构造函数\n  Member 构造函数\n  Derived 构造函数\n  ```\n\n- 私有继承问题: 可以通过方法访问私有继承的public, protected的基类成员(不包括私有成员), 但是无法直接访问.\n\n  ```cpp\n  #include <iostream>\n  using namespace std;\n  \n  class Base\n  {\n  private:\n      int a = 1; // 私有\n  protected:\n      int b = 2; // 保护\n  public:\n      int c = 3; // 公有\n  };\n  \n  class Derived : private Base\n  {\n  private:\n      int d = 4; // 派生类自己的私有成员\n  public:\n      void show()\n      {\n          // cout << a;  // ❌ 错误！Base 的私有成员 a，派生类根本不能访问\n          cout << b << endl; // ✅ OK：Base 的 protected 成员，在 Derived 中变成了 private\n          cout << c << endl; // ✅ OK：Base 的 public 成员，在 Derived 中变成了 private\n          cout << d << endl; // ✅ OK：Derived 的私有成员当然能访问\n      }\n  };\n  \n  int main()\n  {\n      Derived d;\n      d.show();\n      // cout << d.b; // ❌ 错误！Base 的 protected 成员，在 Derived 中变成了 private\n      return 0;\n  }\n  ```\n\n- 虚函数也具有 `this` 指针.\n\n- 在构造函数中调用虚函数，不是动态联编\n\n  - 原因是：**对象还未完全构造完成（或已经开始析构）时，虚函数表（vtable）可能尚未指向最终派生类**.\n  - 所以，在构造函数中调用虚函数时，**只会调用当前类中该函数的版本**，不会发生多态。\n\n\n\n#### 虚析构函数\n\n- 为了在多重继承的时候, 可以正确的调用各个阶段的析构函数, 我们需要声明基类的析构为虚函数, 然后在子类中重写:\n\n```cpp\nvirtual ~CRAFT()\n{\n    cout << \"销毁航行器(速度: \" << speed << \")\" << endl;\n}\n\n...\n\n~PLANE() override\n{\n    cout << \"销毁飞机(翼展: \" << width << \")\" << endl;\n}\n```\n\n\n\n- 菱形继承的时候, 注意 `virtual public`的声明 以及 在底层的子类中的初始化列表的顺序!\n\n  ```cpp\n  SEAPLANE(float speed, float width, float depth) : CRAFT(speed), PLANE(speed, width), SHIP(speed, depth)\n  {\n    ...\n  }\n  ```\n\n\n\n\n\n## HW10\n\n- 判断: 对象间赋值将调用拷贝构造函数。  \n  - 错误. 对象间的赋值调用的是 <u>拷贝复赋值运算符</u>. \n\n#### 异常类\n\n![image-20250423094724267](https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250423094724267.png?imageSlim)\n\n- **A**是错误的。C++允许自定义异常类，可以继承标准异常类如std::exception。\n- **B**是正确的，C++异常机制会在异常抛出前自动销毁局部对象。\n- **C**是正确的，抛出异常时对象会被拷贝（或移动）到catch块中。\n- **D**是正确的，在catch块中可以使用对象引用来接收异常对象。\n\n\n\n#### 赋值运算符重载\n\n- 语法:\n\n  ```cpp\n  类名& operator=(const 类名& 对象名)\n  ```\n\n- 特点:\n\n  - 返回类型是类的引用（为了支持连续赋值 a=b=c）\n  - 参数是const引用（防止修改原对象）\n  - 通常需要先释放自己的资源，再复制数据\n\ne.g.\n\n```cpp\nArray& operator=(const Array& a) {\n    if (this != &a) {  // 防止自赋值\n        delete[] data;  // 释放原有内存\n        size = a.size;  // 复制大小\n        data = new int[size];  // 分配新内存\n        for (int i = 0; i < size; i++) {  // 复制数据\n            data[i] = a.data[i];\n        }\n    }\n    return *this;  // 返回对象自身的引用\n}\n```\n\n\n\n## W12\n\n- 建立类模板对象的实例化过程为: `模板类-对象`.\n  - 编译器根据提供的模板参数将类模板实例化为一个具体的模板类（也称为实例化类或特化类），然后才能创建该模板类的对象。\n  - 类模板的使用实际上是将类模板实例化成一个 `类`\n- 类模板与模板类\n  - 类模板是类的蓝图或规范，它本身不是一个类\n  - 模板类（或实例化类、特化类）是使用具体的类型参数实例化类模板后得到的具体的类。\n- 类模板和函数模板的实例化的时期 -- 均为`编译时期`\n  - 函数模板在编译时期检查定义中的基本语法;\n  - 尝试调用某一个函数模板时, 编译器根据实际的参数类型来推导模板参数类型/或者由显式指定类型得到, 如果合法就生成函数实例(i.e. ***模板函数***), 这个过程就是模板实例化(生成代码).\n- 除了使用构造函数, 还可以直接调用 `make_pair` 让编译器自动推导类型来创建pair对象;\n- \n\n\n\n## L3\n\n> [!NOTE]\n>\n> 1. 内联函数在 **<u>编译时展开</u>**, 而不是运行时.\n> 2. 内联函数的声明以及最终的生效与否, 是由 **<u>编译器</u>** 决定的. 也就是说, 无论是否存在 inline 的声明, 编译器最终决定函数的类型.\n\n\n\n### C++ 初始化列表与成员变量初始化\n\n> [!NOTE]\n>\n> - `int`和自己定义的类都是cpp的类, 所以可以直接在初始化列表中用 `:class_instance{input},...{}`来初始化类内的类对象.\n> - 推荐使用 `{}`来初始化, 不会产生是函数的歧义.\n\n\n\n#### 1. 构造顺序\n- 在 C++ 中，**成员变量的初始化顺序由它们在类中声明的顺序决定**，而不是在初始化列表中的顺序。\n- 初始化列表用于 **直接初始化** 成员变量，而不是在构造函数体内先创建未初始化的对象再赋值。\n\n#### 2. 为什么必须使用初始化列表？\n- **成员变量在进入构造函数体之前就已经完成了初始化**，不能在构造函数体内赋值来替代初始化。\n- **如果成员变量是一个没有默认构造函数的对象**，必须在初始化列表中显式调用其构造函数，否则编译会报错。\n- 在构造函数体内赋值，意味着：\n  1. 先调用默认构造函数创建对象（如果 `NumberDisplay` 没有默认构造函数，这一步会失败）。\n  2. 然后使用赋值运算符进行赋值，而赋值运算与初始化是不同的过程。\n\n#### 3. 示例代码\n#### ❌ 错误示例（可能会编译失败）\n```cpp\nclass NumberDisplay {\npublic:\n    NumberDisplay(int max) { /* 初始化代码 */ }\n};\n\nclass Clock {\nprivate:\n    NumberDisplay hour_display;\n    NumberDisplay minute_display;\n    NumberDisplay second_display;\n    \npublic:\n    Clock(int hour, int minute, int second) { // ❌ 错误：NumberDisplay 没有默认构造函数\n        hour_display = NumberDisplay(24);     // 不能这样赋值\n        minute_display = NumberDisplay(60);\n        second_display = NumberDisplay(60);\n    }\n};\n\n\n\n```\n#### **✅ 正确示例**\n\n```cpp\nclass Clock {\nprivate:\n    NumberDisplay hour_display;\n    NumberDisplay minute_display;\n    NumberDisplay second_display;\n    \npublic:\n    // 使用初始化列表\n    Clock(int hour, int minute, int second)\n        : hour_display(24), minute_display(60), second_display(60) {\n        // 构造函数体内的代码可以进行额外的赋值操作\n    }\n};\n```\n\n\n\n**4. 结论**\n\n​\t•\t**所有成员变量都会在构造函数体执行前被初始化**，不能依赖在构造函数体内赋值。\n\n​\t•\t**如果成员变量是没有默认构造函数的对象**，必须使用初始化列表进行初始化，否则会导致编译错误。\n\n​\t•\t**初始化列表的顺序应与成员变量的声明顺序一致**，否则可能会导致未定义行为。\n\n\n\n\n\n\n\n\n\n## Project\n\n### P1\n\n```cpp\ncout << \"\\\"\" << value << \"\\\"\";\n```\n\n如果要输出引号, 需要加入 `\\`来进行转义!\n\n\n\n#### 使用匿名函数来排序\n\n```cpp\nsort(sortedRecords.begin(), sortedRecords.end(),\n     [](const Record& a, const Record& b) {\n         if (a.qso_date != b.qso_date) return a.qso_date < b.qso_date;\n         return a.time_on < b.time_on;\n     });\n```\n\n`sort`是 `algorithm`头文件中的库函数, 支持原地排序.\n\n第三个参数是一个函数, 返回 `true`表示这个函数的第一个参数应该排在第二个参数的前面.\n\n比如此处, 使用了匿名函数 `[]`, 同时比较 `date`, 当 \n\n```cpp\nreturn a.qso_date < b.qso_date;\n```\n\n指的是当前者的时间较小, 应该排在前面, 因此是升序.\n\n> 不要因为语句太长而忘记末尾的 `;`.\n\n\n\n### P2\n\n#### 思路分析\n\n- 整体设计:\n  - 程序随机生成一组设置, 然后用户开始输入\n  - 大概率, 用户不可避免地会失败, 此时应当让用户选择是否继续参与这场游戏, 否则程序生成下一组的设置;\n- 房间:\n  - monster所在;\n  - princess所在\n  - lobby;\n  - 普通的room\n  - 具有毒药的房间(接触后限制之后行动的次数)\n  - 解药房间(可以解除中毒的状态)\n  - 地图房间(接触后可以通过输入 `map`来显示当前的位置)\n- 房间个数: \n  - 每次都将上述的因素都加入, 不太合适, 因此需要用户输入游戏的类型/难度;\n  - 经典模式: 只会产生monster, princess,lobby和普通房间. 房间的个数较少;\n  - 挑战模式:  加入毒药, 解药和地图因素; 房间个数较多.\n\n\n\n## 刷题\n\n- Destructors can not be overloaded.\n  - 因为析构函数没有任何的参数和返回类型, 无法重载.\n\n- **类的成员函数可以访问同类的私有成员，即使是其他对象的成员。** 回顾类的私有边界不是相对于对象的, 而是类. \n\n- cpp中, 构造函数一定不能是 `virtual` 的! \n\n- 静态变量需要再类的外部定义, 但是静态函数不一定.\n\n- “In C++， struct is actually the same thing as class， except for minor differences in usage.”\n  - 这句话是正确的, 注意结构体也是支持继承的. 只是默认的继承方式也是 `public`. \n\n- In C++, inheritance allows a derived class to directly access all of the functions and data of its base class.（T/F）\n  - 错误的. 对于 `public` 类型的继承, 依旧无法直接访问父类的私有成员, 只能通过子类的方法来间接访问.\n\n\n\n- 下面的代码段, 能够能够通过编译, 但是存在运行时的错误(越界访问):\n\n  ```c++\n  int main() { vector<float> v; v[0] = 2.5; }\n  ```\n\n  - 编译器在编译时候, 检查的主要是程序的语法和类型;\n  - 越界访问的问题存在于运行时检测.\n\n- 64位系统系统环境, 按照8个字节进行对齐:\n\n  ```c++\n  // 参考的类定义方式\n  class A1\n  {\n  public:\n      int i;\n      void f(){}\n  };\n  \n  // 其他的类型定义\n  \n  ```\n\n  Output:\n\n  ```c++\n  Size of A1 (non - virtual function with int member): 4 bytes\n  Size of A2 (virtual function with int member): 16 bytes\n  Size of A3 (non - virtual function without int member): 1 bytes\n  Size of A4 (virtual function without int member): 8 bytes\n  Size of B (derived from A1): 8 bytes\n  ```\n\n  主要注意2点:\n\n  1. 没有任何成员的类, 也占用1个字节的大小;\n\n  2. 4+8 将会对齐得到16个字节的空间大小.\n\n     > [!NOTE]\n     >\n     > `void*` 和 `int*` 的大小相同! (题目通常给出 `int*`的大小, 然后给出虚函数)\n\n\n\n- `malloc` 不会调用对象的构造函数, 仅仅分配内存, 并不涉及对象的初始化;\n\n  - `new`会调用构造函数\n\n  - `malloc` 需要显式地类型转换:\n\n    ```c++\n    class MyClass {\n    public:\n        MyClass() { std::cout << \"Constructor called!\" << std::endl; }\n    };\n    \n    MyClass* p1 = new MyClass();  // 输出 \"Constructor called!\"\n    MyClass* p2 = (MyClass*)malloc(sizeof(MyClass));  // 无输出，构造函数未调用\n    ```\n\n- `new` 是CPP的运算符, 可以重载; `malloc`是标准库的函数, 无法重载.\n- 每个类最多具有一个析构函数\n\n\n\n#### 重载问题\n\n在 `::`, `()` 和 `->`中, 只有 `->`可以被重载:\n\n```c++\n#include <iostream>\n\nclass MyClass {\npublic:\n    void sayHello() {\n        std::cout << \"Hello from MyClass!\" << std::endl;\n    }\n};\n\nclass MyPtr {\nprivate:\n    MyClass* ptr;  // 内部存储一个原生指针\n\npublic:\n    // 构造函数\n    MyPtr(MyClass* p) : ptr(p) {}\n\n    // 重载 -> 运算符\n    MyClass* operator->() {\n        return ptr;  // 返回原生指针，使得可以继续用 -> 访问成员\n    }\n};\n\nint main() {\n    MyClass obj;\n    MyPtr myPtr(&obj);  // 用 MyPtr 包装 MyClass 对象\n\n    myPtr->sayHello();  // 调用 MyClass 的成员函数\n\n    return 0;\n}\n```\n\n \n\n#### new与对象转换\n\n```c++\n#include <iostream>\nusing namespace std;\n\nclass B;\n\nclass A\n{\nprotected:\n    int x;\n\npublic:\n    A(int x = 0) : x(x) {}\n    operator B();\n    int getx() { return x; }\n};\n\nclass B : public A\n{\npublic:\n    B(int x = 0) : A(x) { this->x++; }\n    B(const B &b) : A(b.x) { this->x++; }\n};\n\nA::operator B() { return *new B(x + 1); } // 特别注意此处\n\nint main()\n{\n    A *p1 = new B(3); // new的时候触发B的构造函数, 自增\n    A *p2 = new A(9);\n    B b0 = *p1; // 发生了A类对象向B类对象的转化, 详见下面两行:\n    // *p1 将要转化的时候,  先传入x+1作为B的初始化参数输入,\n    // 然后new将触发B的构造函数, 最后返回, 返回结果用于初始化b0, 继续触发拷贝构造函数\n    B &r = b0;\n    B b1 = b0;  // 发生了 B类对象的拷贝构造, b1的x为8, 但是不会改变b0的x=7\n    B b2 = *p2; // 这一步的转换与上面的同理. 也是+3\n    cout << p1->getx() << endl;\n    cout << p2->getx() << endl;\n    cout << b0.getx() << endl;\n    cout << r.getx() << endl;\n    cout << b1.getx() << endl;\n    cout << b2.getx() << endl;\n}\n```\n\n解题过程中的关键步骤已经写在注释当中, 最后的输出是:\n\n```c++\n4\n9\n7\n7\n8\n12\n```\n\n梳理考察的重要知识点:\n\n1. upcast的时候, 是子类的属性赋值给父类, 包括虚函数表. 因此, 此时看作是父类的对象, 但是虚函数能够动态绑定.\n\n2. `new`和`delete`分别自动调用类的构造函数和析构函数;\n\n3. `A::operator B()` 形式表示A类对象如何转换成B类型对象的, 在发生转换的时候自动调用这部分的函数.\n\n   ```c++\n   A *p1 = new B(3); // 拷贝构造的时候直接自增为4\n   A *p2 = new A(9);\n   ```\n\n   注意上面的指针都指向A类的对象.\n\n\n\n#### 链式的析构顺序\n\n- 构造顺序: 父类->成员对象-> 自身\n- 析构顺序: 自身-> 成员对象-> 父类\n\n下面的这道题目涉及的类的关系如下:\n\n1. P是父类, S是子类;\n2. P内部有两个P类型的指针成员.\n\n```c++\n#include <iostream>\nusing namespace std;\n\n// 1. 先声明基类 P\nclass P\n{\npublic:\n    static bool flag; // 静态成员声明\n    int x;            // 数据成员\n    P *left, *right;  // 指针成员\n\n    // 构造函数\n    P(P *left = nullptr, P *right = nullptr)\n        : x(0), left(left), right(right) {}\n\n    // 虚析构函数（因为有继承关系，应该是虚函数）\n    ~P()\n    {\n        if (flag)\n        {\n            if (left != nullptr)\n            {\n                delete left;\n            }\n            if (right != nullptr)\n            {\n                delete right;\n            }\n        }\n        else\n        {\n            if (right != nullptr)\n            {\n                delete right;\n            }\n            if (left != nullptr)\n            {\n                delete left;\n            }\n        }\n        cout << \"P\" << x;\n    }\n};\n\n// 2. 静态成员的定义（必须在类外定义）\nbool P::flag = false;\n\n// 3. 派生类 S\nclass S : public P\n{\npublic:\n    // 构造函数，调用基类构造函数\n    S(P *left = nullptr, P *right = nullptr) : P(left, right) {}\n\n    // 析构函数\n    ~S()\n    {\n        cout << \"S\" << x;\n    }\n};\n\nint main()\n{\n    S *p1 = new S;\n    p1->x = 1; // 设置第一个节点的值\n    S *p2 = new S;\n    p2->x = 2;   // 设置第二个节点的值\n    S s(p1, p2); // 创建根节点，连接p1和p2\n    s.x = 3;     // 设置根节点的值/\n    return 0;    // 程序结束时析构对象\n}\n\n```\n\n最终的输出:\n\n1. 析构s, 首先析构子类自身, 调用s的析构函数, 输出s;\n2. 然后析构父类, 父类是P, 析构的时候直接调用自身的析构函数, 一词析构右指针和左指针;\n3. 执行到末尾, 输出自身的P3.\n\nOutput:\n\n```c++\nS3P2P1P3\n```\n\n\n\n\n\n\n\n#### 操作符的重载\n\n```c++\n#include <iostream>\n#include <iomanip>\n\n#define MAXN 110\n\n/* Your answer will be inserted here. Feel free to add anything needed here.*/\n\nclass vec\n{\nprivate:\n    int first, second;\n\npublic:\n    vec(int a, int b) : first(a), second(b) {}\n    //  < 的重载\n    bool operator<(const vec &other) const\n    {\n        return second < other.second;\n    }\n\n    // 类型转换的重载\n    operator double() const\n    {\n        return static_cast<double>(first);\n    }\n\n    // 输出的重载\n    friend std::ostream &operator<<(std::ostream &os, const vec &v)\n    {\n        return os << \"(\" << v.first << \",\" << v.second << \")\";\n    }\n};\nvoid printArrayInfo(vec **arr, int n)\n{\n    vec *maxv = arr[0], *minv = arr[0];\n    double avg = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        vec *val = arr[i];\n        if (*val < *minv)\n            minv = val;\n        if (*maxv < *val)\n            maxv = val;\n        avg = avg + static_cast<double>(*val);\n    }\n    avg /= n;\n    std::cout << std::fixed << std::setprecision(2) << \"min = \" << *minv << \", max = \" << *maxv << \", avg = \" << avg << std::endl;\n}\n\nint main()\n{\n    vec *pool[MAXN];\n    int n;\n    int a, b;\n    std::cin >> n;\n    for (int i = 0; i < n; i++)\n    {\n        std::cin >> a >> b;\n        pool[i] = new vec(a, b);\n    }\n    printArrayInfo(pool, n);\n    return 0;\n}\n```\n\n\n\n#### 菱形继承与二义性问题\n\n并不是菱形继承的操作都会导致二义性, 要从本质--访问的操作是否导致无法区分正确的单独对象?\n\n```c++\n#include <iostream>\nusing namespace std;\nclass A\n{\npublic:\n    int x;\n    A() : x(6) {}\n    int fun()\n    {\n        return x;\n    }\n};\nclass B : public A\n{\npublic:\n    int fun()\n    {\n        return A::fun() + x;\n    }\n};\nclass C : public A\n{\npublic:\n    int fun()\n    {\n        return A::fun() + x;\n    }\n};\nclass D : public B, public C\n{\npublic:\n    int fun()\n    {\n        return B::fun() + C::fun();\n    }\n};\nint main()\n{\n    D d;\n    cout << d.fun();\n    // cout << d.A::fun(); 存在二义性的问题, 因为在D当中分别存在来自于B和C的这个函数!\n}\n```\n\n在上面代码中, D是菱形继承, 但是可以直接访问d的fun, 因为在d的fun中涉及的是B和C自己的fun. 而后者又能够直接调用自己的继承自A的fun\n\n- 无法直接调用 `d.A::fun()`, 参见注释.\n\n# 最后的枚举\n\n\n\n\n\n\n\n#### 转换运算符\n\n`A::operator B()`的含义： 定义了如何将 `A` 类型的对象转换为 `B` 类型的对象。\n\n- `A::` 表示这是 `A` 类的成员函数\n- `operator B` 表示这是一个到 `B` 类型的转换运算符\n- `()` 表示这是一个函数\n\n```c++\n// A 具有一个成员变量且在构造函数中可以赋值\n\nA::operator B() { return *new B(x + 1); }\n```\n\n- `new B(x + 1)` 创建一个新的 `B` 对象，其中 `x` 是 `A` 类的成员变量\n- `*` 解引用这个新创建的对象\n- 返回这个 `B` 类型的对象\n\n> [!NOTE]\n>\n> 注意, 这只是决定了B类对象的如何构造, 并不会影响A类对象本身.\n\n调用的场景: 需要将A类型的对象转换为B类型的对象 e.g.——\n\n```c++\nA a(5);\nB b = a;  // 这里会自动调用 A::operator B()\n```\n\n\n\n## const相关\n\n### 对象与方法的对应\n\nC++在选择成员函数时会考虑对象的const属性：\n\n- const对象只能调用const成员函数 \n\n- 非const对象优先调用非const版本，如果没有非const版本才会调用const版本\n\n- > [!NOTE]\n  >\n  > 函数定义的顺序并不会影响调用的选择!\n\ne.g.\n\n```c++\n#include <iostream>\nusing namespace std;\nclass MyClass\n{\npublic:\n    MyClass(int x) : val(x) {}\n\n    void Print()\n    {\n        cout << 2 << endl\n             << val << endl;\n    }\n\n    void Print() const { cout << 1 << endl\n                              << val << endl; }\n\nprivate:\n    int val;\n};\nint main()\n{\n    const MyClass obj1(10);\n    MyClass obj2(20);\n    obj1.Print();\n    obj2.Print();\n    return 0;\n}\n```\n\noutput:\n\n```c++\n1\n10\n2\n20\n```\n\n\n\n\n\n## 初始化先后的问题\n\nC++中对象的初始化和销毁顺序遵循特定的规则，这对于理解程序行为和避免内存问题至关重要\n\n### 初始化列表\n\n### 类的构造与析构顺序\n\n在C++中，对象的构造和析构顺序遵循以下规则：\n\n1. **构造顺序**：\n   \n   - 基类先于派生类构造\n   - 成员变量按声明顺序构造\n   - 基类构造完成后，才执行派生类构造函数体\n   - > [!NOTE]\n     >\n     > 对象在调用构造函数之前, 首先完成内部成员对象的构造\n   \n2. **析构顺序**：\n   \n   - 与构造顺序相反\n   - 先执行派生类析构函数体\n   - 然后按声明顺序的逆序析构成员变量\n   - 最后析构基类\n\n#### 示例分析\n\n```c++\nint main()\n{\n    Child c;\n}\n```\n\n##### 类层次结构\n\n```\nX (基础类)\n↑\nY (继承自X)\n\nParent (包含X成员)\n↑\nChild (继承自Parent，包含Y成员)\n```\n\n##### 构造过程分析\n\n当创建`Child`对象时，构造顺序为：\n\n1. 首先构造基类`Parent`\n   - 在`Parent`构造前，先构造其成员`x`（调用`X::X()`）\n   - 然后执行`Parent`构造函数体（输出\"Parent::Parent()\"）\n2. 基类构造完成后，构造`Child`的成员`y`\n   - 在构造`y`前，先构造其基类部分（调用`X::X()`）\n   - 然后执行`Y`构造函数体（输出\"Y::Y()\"）\n3. 最后执行`Child`构造函数体（输出\"Child::Child()\"）\n\n##### 析构过程分析\n\n当`Child`对象离开作用域时，析构顺序为：\n\n1. 首先执行`Child`析构函数体（输出\"Child::~Child()\"）\n2. 然后析构成员`y`\n   - 先执行`Y`析构函数体（输出\"Y::~Y()\"）\n   - 然后析构其基类部分（调用`X::~X()`）\n3. 最后析构基类`Parent`\n   - 先执行`Parent`析构函数体（输出\"Parent::~Parent()\"）\n   - 然后析构其成员`x`（调用`X::~X()`）\n\n#### 预期输出\n\n执行`test.cpp`程序时，预期输出为：\n\n```\nX::X()              // Parent的成员x构造\nParent::Parent()    // Parent构造函数体\nX::X()              // Y的基类部分构造\nY::Y()              // Y构造函数体\nChild::Child()      // Child构造函数体\nChild::~Child()     // Child析构函数体\nY::~Y()             // Y析构函数体\nX::~X()             // Y的基类部分析构\nParent::~Parent()   // Parent析构函数体\nX::~X()             // Parent的成员x析构\n```\n\n#### 重要注意事项\n\n1. **虚析构函数**：当使用多态时，基类应该有虚析构函数，确保正确调用派生类析构函数。\n\n2. **成员初始化列表**：推荐使用成员初始化列表而非在构造函数体内赋值，这样可以直接初始化而非先默认构造再赋值。\n\n3. **异常安全**：构造过程中如果抛出异常，已构造的成员会被正确析构，但未完全构造的对象不会调用析构函数。\n\n4. **RAII原则**：资源获取即初始化，在构造函数中获取资源，在析构函数中释放资源，确保资源管理安全。\n\n#### 实际应用\n\n理解对象生命周期对以下场景尤为重要：\n\n1. **资源管理**：确保资源在不再需要时被释放\n2. **依赖关系处理**：确保依赖对象在被依赖对象之前构造，之后析构\n3. **继承层次设计**：合理设计基类和派生类的构造和析构行为\n","slug":"编程语言/cpp学习记录","published":1,"updated":"2025-05-09T01:48:28.191Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ag000p2xqg2xo846pm","content":"<h4 id=\"导论\"><a href=\"#导论\" class=\"headerlink\" title=\"导论\"></a>导论</h4><p>编译时, 从<code>c</code>的<code>gcc</code>转变为了<code>g++</code>.</p>\n<p>OOP的三大特点:</p>\n<ul>\n<li>封装</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><p>在C语言中,我们主要使用<code>malloc()</code>和<code>free()</code>来进行动态内存管理。但这种方式存在一些问题:</p>\n<ul>\n<li>它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;</li>\n<li>容易发生内存泄漏.</li>\n</ul>\n<p>为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了<code>new</code>和<code>delete</code>.</p>\n<p>new的基本语法十分直观:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type* pointer = <span class=\"keyword\">new</span> Type;           <span class=\"comment\">// 分配单个对象</span></span><br><span class=\"line\">Type* pointer = <span class=\"keyword\">new</span> Type[size];     <span class=\"comment\">// 分配对象数组</span></span><br></pre></td></tr></table></figure></div>\n\n<p>可以在创建时进行初始化:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">5</span>);              <span class=\"comment\">// 初始化为5</span></span><br><span class=\"line\">string* p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">\"hello\"</span>);   <span class=\"comment\">// 初始化为\"hello\"</span></span><br></pre></td></tr></table></figure></div>\n\n<p>也可以根据变量进行动态的内存分配:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> size;</span><br><span class=\"line\">cin &gt;&gt; size;</span><br><span class=\"line\"><span class=\"type\">int</span>* arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[size];  <span class=\"comment\">// 根据输入分配内存</span></span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>[!NOTE]</p>\n<p>Use <code>delete ［］</code> if <code>new ［］</code> was used to allocate an array.</p>\n</blockquote>\n<h1 id=\"输入输出流\"><a href=\"#输入输出流\" class=\"headerlink\" title=\"输入输出流\"></a>输入输出流</h1><p>通过包含头文件 – <code>#include &lt;iostream&gt;</code> 来使用输入输出流 <code>cin</code> 和 <code>cout</code>.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> age; </span><br><span class=\"line\">    cin &gt;&gt; age;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"You are \"</span> &lt;&lt; age &lt;&lt; <span class=\"string\">\" years old\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">// endl 是换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><code>cin</code>读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str=<span class=\"string\">\"Hello world!\"</span>;</span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">fout</span><span class=\"params\">(<span class=\"string\">\"out.txt\"</span>)</span></span>;</span><br><span class=\"line\">fout&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">fin</span><span class=\"params\">(<span class=\"string\">\"out.txt\"</span>)</span></span>;</span><br><span class=\"line\">string str1,str2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件中的两个字符串</span></span><br><span class=\"line\">fin&gt;&gt;str1&gt;&gt;str2; </span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出:</span></span><br><span class=\"line\"><span class=\"comment\">// Hello</span></span><br><span class=\"line\"><span class=\"comment\">// world!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></div>\n\n\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><h3 id=\"输入输出流基础\"><a href=\"#输入输出流基础\" class=\"headerlink\" title=\"输入输出流基础\"></a>输入输出流基础</h3><ul>\n<li>头文件: <code>#include &lt;fstream&gt;</code></li>\n<li>类: <code>ifstream</code>(输入流), <code>ofstream</code>(输出流)</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span>  <span class=\"comment\">// 需要包含这个头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件输出（写入文件）</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outFile</span><span class=\"params\">(<span class=\"string\">\"output.txt\"</span>)</span></span>;</span><br><span class=\"line\">outFile &lt;&lt; <span class=\"string\">\"Hello World\"</span> &lt;&lt; endl;</span><br><span class=\"line\">outFile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件输入（读取文件）</span></span><br><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">inFile</span><span class=\"params\">(<span class=\"string\">\"input.txt\"</span>)</span></span>; </span><br><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(inFile, line);</span><br><span class=\"line\">inFile.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>写入文件时, 如果没有文件, 会自动创建.</li>\n</ul>\n<h3 id=\"常用操作示例\"><a href=\"#常用操作示例\" class=\"headerlink\" title=\"常用操作示例\"></a>常用操作示例</h3><ol>\n<li><strong>写入文件</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream outFile;</span><br><span class=\"line\">outFile.<span class=\"built_in\">open</span>(<span class=\"string\">\"test.txt\"</span>);  <span class=\"comment\">// 打开文件</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (outFile.<span class=\"built_in\">is_open</span>()) {   <span class=\"comment\">// 检查是否成功打开</span></span><br><span class=\"line\">    outFile &lt;&lt; <span class=\"string\">\"第一行\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    outFile &lt;&lt; <span class=\"string\">\"第二行\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    outFile.<span class=\"built_in\">close</span>();       <span class=\"comment\">// 完成后关闭文件</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"2\">\n<li>**读取文件 **</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">inFile</span><span class=\"params\">(<span class=\"string\">\"test.txt\"</span>)</span></span>;</span><br><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"built_in\">getline</span>(inFile, line)) {  <span class=\"comment\">// 逐行读取</span></span><br><span class=\"line\">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\">inFile.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure></div>\n\n<ol start=\"3\">\n<li><strong>以追加模式打开文件</strong></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outFile</span><span class=\"params\">(<span class=\"string\">\"test.txt\"</span>, ios::app)</span></span>;  <span class=\"comment\">// app 表示追加模式</span></span><br><span class=\"line\">outFile &lt;&lt; <span class=\"string\">\"这行会被添加到文件末尾\"</span> &lt;&lt; endl;</span><br><span class=\"line\">outFile.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure></div>\n\n\n<h3 id=\"文件打开模式\"><a href=\"#文件打开模式\" class=\"headerlink\" title=\"文件打开模式\"></a>文件打开模式</h3><ul>\n<li><code>ios::in</code> - 读取模式</li>\n<li><code>ios::out</code> - 写入模式</li>\n<li><code>ios::app</code> - 追加模式</li>\n<li><code>ios::ate</code> - 打开文件后立即定位到文件末尾</li>\n<li><code>ios::binary</code> - 二进制模式</li>\n<li><code>ios::trunc</code> - 如果文件存在则<strong>截断</strong>文件<ul>\n<li>如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设 test.txt 原本内容是:</span></span><br><span class=\"line\"><span class=\"comment\">// Hello World</span></span><br><span class=\"line\"><span class=\"comment\">// This is a test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 trunc 模式打开</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outFile</span><span class=\"params\">(<span class=\"string\">\"test.txt\"</span>, ios::out | ios::trunc)</span></span>;  </span><br><span class=\"line\">outFile &lt;&lt; <span class=\"string\">\"新的内容\"</span> &lt;&lt; endl;</span><br><span class=\"line\">outFile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在 test.txt 的内容只有:</span></span><br><span class=\"line\"><span class=\"comment\">// 新的内容</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p> 或直接用 <code>ios::out</code>，因为out默认包含trunc</p>\n</blockquote>\n<ul>\n<li>使用位或运算符<code>|</code>来同时指定多个模式:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组合使用打开模式</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outFile</span><span class=\"params\">(<span class=\"string\">\"test.txt\"</span>, ios::out | ios::app)</span></span>;</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">inFile</span><span class=\"params\">(<span class=\"string\">\"nonexistent.txt\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!inFile) {</span><br><span class=\"line\">    cerr &lt;&lt; <span class=\"string\">\"无法打开文件！\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用is_open()</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!inFile.<span class=\"built_in\">is_open</span>()) {</span><br><span class=\"line\">    cerr &lt;&lt; <span class=\"string\">\"无法打开文件！\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>需要先引入指定的头文件:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>定义时可以使用等号或者用括号包裹字符串:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string name = <span class=\"string\">\"John\"</span>; </span><br><span class=\"line\"><span class=\"comment\">// string name(\"John\");</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h3 id=\"stringstream\"><a href=\"#stringstream\" class=\"headerlink\" title=\"stringstream\"></a>stringstream</h3><p><code>stringstream</code> 表示<strong>双向</strong>字符串流:</p>\n<ul>\n<li>需要导入头文件<code>#include &lt;sstream&gt;</code>;</li>\n<li><code>istringstream</code> 表示<strong>输入</strong>字符串流<ul>\n<li>作用: 将字符串转换成一个类似于输入流的对象;</li>\n<li>内部维护了一个字符串和一个位置指针;</li>\n<li>每次读取时, 位置指针向后移动, 且自动跳过空白字符.</li>\n</ul>\n</li>\n<li><code>ostringstream</code> 表示<strong>输出</strong>字符串流.</li>\n</ul>\n<h4 id=\"字符串分词\"><a href=\"#字符串分词\" class=\"headerlink\" title=\"字符串分词\"></a>字符串分词</h4><p>自动以<strong>空白字符</strong>(空格、制表符\\t、换行符\\n等)分割字符串;</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">name</span> <span class=\"params\">( <span class=\"string\">\"Xiao Ming\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用括号包字符串</span></span><br><span class=\"line\">    <span class=\"function\">istringstream <span class=\"title\">is</span> <span class=\"params\">(name)</span></span>; </span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (is&gt;&gt;s){</span><br><span class=\"line\">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>&gt;&gt;</code> 表示从输入流中读取数据;</p>\n<p>注意字符串流也是一种类型, 作用的对象是字符串.</p>\n</blockquote>\n<p>Output:</p>\n<div class=\"code-container\" data-rel=\"Shell\"><figure class=\"iseeu highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Xiao Ming</span><br><span class=\"line\">Xiao</span><br><span class=\"line\">Ming</span><br></pre></td></tr></table></figure></div>\n\n<p>包含更多分词的字符串:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string words = <span class=\"string\">\"hello \\n world! \\t I am \\n here!\"</span>;</span><br><span class=\"line\">    <span class=\"function\">stringstream <span class=\"title\">is</span> <span class=\"params\">(words)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    string word;</span><br><span class=\"line\">    <span class=\"type\">int</span> count  = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(is &gt;&gt; word){</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Word \"</span> &lt;&lt; count &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<p>Output:</p>\n<div class=\"code-container\" data-rel=\"Shell\"><figure class=\"iseeu highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Word 1: hello</span><br><span class=\"line\">Word 2: world!</span><br><span class=\"line\">Word 3: I</span><br><span class=\"line\">Word 4: am</span><br><span class=\"line\">Word 5: here!</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    ostringstream oss;</span><br><span class=\"line\">    string name = <span class=\"string\">\"Alice\"</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    oss &lt;&lt; <span class=\"string\">\"Name: \"</span> &lt;&lt; name &lt;&lt; <span class=\"string\">\", Age: \"</span> &lt;&lt; age;</span><br><span class=\"line\">    string result = oss.<span class=\"built_in\">str</span>();</span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<p>Output:</p>\n<div class=\"code-container\" data-rel=\"Shell\"><figure class=\"iseeu highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Name: Alice, Age: 25</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>通过<code>.str()</code>方法可以对象转换为字符串类型, 从而<strong>格式化输出</strong>.</p>\n</blockquote>\n<br>\n\n<p><code>.str(\"\")</code>方法可以<strong>清空</strong>字符串流:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    ostringstream oss;</span><br><span class=\"line\">    string name = <span class=\"string\">\"Alice\"</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    oss &lt;&lt; <span class=\"string\">\"Name: \"</span> &lt;&lt; name &lt;&lt; <span class=\"string\">\", Age: \"</span> &lt;&lt; age;</span><br><span class=\"line\">    oss.<span class=\"built_in\">str</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    string result = oss.<span class=\"built_in\">str</span>();</span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; <span class=\"string\">\"Nothing\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<p>Output:</p>\n<div class=\"code-container\" data-rel=\"Shell\"><figure class=\"iseeu highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nothing</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Getline\"><a href=\"#Getline\" class=\"headerlink\" title=\"Getline\"></a>Getline</h3><p><strong>基本语法:</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">getline</span>(istream&amp; is, string&amp; str, <span class=\"type\">char</span> delim = <span class=\"string\">'\\n'</span>);</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>is</code>: 输入流（通常是cin;</li>\n<li><code>str</code>: 存储结果的字符串;</li>\n<li><code>delim</code>: 分隔符, 默认为换行符<code>\\n</code>.</li>\n</ul>\n<p><strong>Example</strong>:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"请输入一行文本：\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin, line);  <span class=\"comment\">// 读取整行，包括空格</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"你输入的是：\"</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用自定义分隔符</span></span><br><span class=\"line\">    string data;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"请输入内容（用,分隔）：\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin, data, <span class=\"string\">','</span>);  <span class=\"comment\">// 读取直到遇到逗号</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"读取到逗号前的内容：\"</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"cin\"><a href=\"#cin\" class=\"headerlink\" title=\"cin\"></a>cin</h3><p><strong>特点</strong>:</p>\n<ul>\n<li>以空白字符（空格、制表符、换行符）为分隔符;</li>\n<li><strong>忽略</strong>前导空白字符;</li>\n<li>遇到空白字符就停止读取.</li>\n</ul>\n<p>通常需要与<code>getchar()</code>方法配合来清除缓冲区当中的<code>\\n</code>字符:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> number;</span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"输入一个数字：\"</span>;</span><br><span class=\"line\">    cin &gt;&gt; number;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//清除输入缓冲区中的换行符</span></span><br><span class=\"line\">    <span class=\"built_in\">getchar</span>(); <span class=\"comment\">// or cin.ignore(); </span></span><br><span class=\"line\">   </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"输入一行文本：\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin, line);  <span class=\"comment\">// 现在可以正确读取整行</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"数字：\"</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"文本：\"</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>如果输入<code>8 \\n</code>, 则<code>getchar()</code>读取空格, 文本为空.</p>\n</blockquote>\n<h3 id=\"Alter-String\"><a href=\"#Alter-String\" class=\"headerlink\" title=\"Alter String\"></a>Alter String</h3><p><strong>outline</strong> : 常用的字符串方法(成员函数):</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">insert</span>(<span class=\"type\">size_t</span> pos, <span class=\"type\">const</span> string&amp; s);</span><br><span class=\"line\"><span class=\"built_in\">erase</span> (<span class=\"type\">size_t</span> pos = <span class=\"number\">0</span>, size_tlen = npos);</span><br><span class=\"line\"><span class=\"built_in\">append</span> (<span class=\"type\">const</span> string&amp; str);</span><br><span class=\"line\"><span class=\"built_in\">replace</span> (<span class=\"type\">size_t</span> pos,<span class=\"type\">size_t</span> len,<span class=\"type\">const</span> string&amp; str);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li><code>insert(int pos, string str)</code> 在指定位置插入字符串</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 在位置5处插入字符串</span></span><br><span class=\"line\">str.<span class=\"built_in\">insert</span>(<span class=\"number\">5</span>, <span class=\"string\">\" Beautiful\"</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello Beautiful World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在字符串末尾插入内容</span></span><br><span class=\"line\">str.<span class=\"built_in\">insert</span>(str.<span class=\"built_in\">length</span>(), <span class=\"string\">\"!\"</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello Beautiful World!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入单个字符（使用string构造）</span></span><br><span class=\"line\">str.<span class=\"built_in\">insert</span>(<span class=\"number\">0</span>, <span class=\"string\">\"&gt;\"</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"&gt;Hello Beautiful World!\"</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<ul>\n<li><code>erase(int pos, int length)</code> 删除从指定位置开始的若干个字符</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello Beautiful World!\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除从下标6开始的9个字符</span></span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">6</span>, <span class=\"number\">9</span>); </span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello World!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除从某个位置开始到末尾的所有字符</span></span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello\"</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>length</code>参数省略, 则删除从<code>pos</code>位置开始到字符串末尾的所有字符.</p>\n</blockquote>\n<hr>\n<ul>\n<li><code>replace (int pos, int length, string)</code> 替换指定位置的字符串</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从位置6开始，替换5个字符为\"C++\"</span></span><br><span class=\"line\">string str = <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">str.<span class=\"built_in\">replace</span>(<span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"string\">\"C++\"</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello C++!\"</span></span><br></pre></td></tr></table></figure></div>\n\n\n<hr>\n<ul>\n<li><code>append (const string&amp; str);</code></li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加整个字符串</span></span><br><span class=\"line\">string<span class=\"number\">1.</span><span class=\"built_in\">append</span>(string2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加指定位置的字符(索引从开始)</span></span><br><span class=\"line\">string<span class=\"number\">1.</span><span class=\"built_in\">append</span>(string2, start, length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重复字符的添加</span></span><br><span class=\"line\">string<span class=\"number\">1.</span><span class=\"built_in\">append</span>(count, <span class=\"type\">char</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>除此之外, 还存在着使用<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">迭</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">代</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">器</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container>的用法: </p>\n<blockquote>\n<p>类似于指针, 指向容器(如字符串、数组等)的特定位置.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    string source = <span class=\"string\">\"World!\"</span>;</span><br><span class=\"line\">    string target = <span class=\"string\">\"Hello \"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加source中的部分字符（从开始到结束）</span></span><br><span class=\"line\">    target.<span class=\"built_in\">append</span>(source.<span class=\"built_in\">begin</span>(), source.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    cout &lt;&lt; target &lt;&lt; endl;  <span class=\"comment\">// 输出: Hello World!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 只添加部分字符</span></span><br><span class=\"line\">    string target2 = <span class=\"string\">\"Hello \"</span>;</span><br><span class=\"line\">    target<span class=\"number\">2.</span><span class=\"built_in\">append</span>(source.<span class=\"built_in\">begin</span>(), source.<span class=\"built_in\">begin</span>() + <span class=\"number\">5</span>);  <span class=\"comment\">// 只添加\"World\"，不包含\"!\"</span></span><br><span class=\"line\">    cout &lt;&lt; target2 &lt;&lt; endl;  <span class=\"comment\">// 输出: Hello World</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<ol>\n<li><code>begin()</code>方法返回字符串的第一个字符的迭代器, <code>end()</code>方法返回字符串最后一个字符的<strong>下一个</strong>位置的迭代器;</li>\n<li>迭代器的范围是<strong>左闭右开</strong>.</li>\n</ol>\n<hr>\n<h4 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h4><ul>\n<li><code>find(string, int pos)</code> 从指定的位置开始寻找字符串位置</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello World Hello\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 从位置0开始查找\"Hello\"</span></span><br><span class=\"line\">cout &lt;&lt; str.<span class=\"built_in\">find</span>(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">0</span>) &lt;&lt; endl;     <span class=\"comment\">// 结果: 0</span></span><br><span class=\"line\"><span class=\"comment\">// 从位置1开始查找\"Hello\"</span></span><br><span class=\"line\">cout &lt;&lt; str.<span class=\"built_in\">find</span>(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">1</span>) &lt;&lt; endl;     <span class=\"comment\">// 结果: 12</span></span><br><span class=\"line\"><span class=\"comment\">// 查找不存在的字符串</span></span><br><span class=\"line\">cout &lt;&lt; str.<span class=\"built_in\">find</span>(<span class=\"string\">\"Python\"</span>) &lt;&lt; endl;       <span class=\"comment\">// 结果: string::npos</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>string::npos</code>是<code>size_t</code>类型的最大值;</li>\n<li>可以使用<code>str.find(\"Python\") == string::npos</code>作为判断条件, 检查是否找到字符串.</li>\n</ul>\n<hr>\n<ul>\n<li><code>compare(string)</code> 字符串比较</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string str2 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string str3 = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; str<span class=\"number\">1.</span><span class=\"built_in\">compare</span>(str2) &lt;&lt; endl;  <span class=\"comment\">// 结果: 0  (相等)</span></span><br><span class=\"line\">cout &lt;&lt; str<span class=\"number\">1.</span><span class=\"built_in\">compare</span>(str3) &lt;&lt; endl;  <span class=\"comment\">// 结果: -15 (str1 &lt; str3) </span></span><br><span class=\"line\">cout &lt;&lt; str<span class=\"number\">3.</span><span class=\"built_in\">compare</span>(str1) &lt;&lt; endl;  <span class=\"comment\">// 结果: 15  (str3 &gt; str1)</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>按照字典序比较得到结果</li>\n</ul>\n<hr>\n<ul>\n<li><code>to_string(int)</code> 将数字转换成字符串</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\">string str = <span class=\"built_in\">to_string</span>(num);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;          <span class=\"comment\">// 结果: \"123\"</span></span><br><span class=\"line\">cout &lt;&lt; str + <span class=\"string\">\"456\"</span> &lt;&lt; endl;  <span class=\"comment\">// 结果: \"123456\"</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>字符串之间可以通过<code>+</code>直接拼接.</li>\n</ul>\n<hr>\n<ul>\n<li><code>stoi(string)</code> 将字符串转换成整数</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"built_in\">stoi</span>(str);</span><br><span class=\"line\">cout &lt;&lt; num + <span class=\"number\">456</span> &lt;&lt; endl;    <span class=\"comment\">// 结果: 579</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：字符串必须是合法的数字格式</span></span><br><span class=\"line\"><span class=\"comment\">// string str = \"abc\"; </span></span><br><span class=\"line\"><span class=\"comment\">// int num = stoi(str);  // 这会抛出异常</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>字符串必须是合法的数字格式;</li>\n<li><code> int num = stoi(\"abc\");</code>  将会抛出异常</li>\n</ul>\n<hr>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><strong>Outline:</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> *cp, <span class=\"type\">int</span> len);</span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"type\">const</span> string&amp; s2, <span class=\"type\">int</span> pos);</span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"type\">const</span> string&amp; s2, <span class=\"type\">int</span> pos, <span class=\"type\">int</span> len);</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<ul>\n<li><code>string(const char *cp, int len)</code> 字符数组创建字符串</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">str1</span><span class=\"params\">(<span class=\"string\">\"Hello World\"</span>, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: Hello</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><code>string(const string&amp; s2, int pos)</code> 从现有字符串创建新字符串，从指定位置到末尾</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s2 = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">str2</span><span class=\"params\">(s2, <span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: World</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><code>string(const string&amp; s2, int pos, int len)</code> 从现有字符串创建新字符串，指定起始位置和长度</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s3 = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">str3</span><span class=\"params\">(s3, <span class=\"number\">6</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: Wor</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><code>string(int length, char c)</code> 用指定长度的字符c初始化字符串</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">str4</span><span class=\"params\">(<span class=\"number\">5</span>, <span class=\"string\">'*'</span>)</span></span>;</span><br><span class=\"line\">cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: *****</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际应用示例</span></span><br><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"number\">432</span>;</span><br><span class=\"line\">string str = <span class=\"built_in\">to_string</span>(num);</span><br><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">string</span>(<span class=\"number\">5</span> - str.<span class=\"built_in\">length</span>(), <span class=\"string\">'0'</span>) + str &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: 00432</span></span><br></pre></td></tr></table></figure></div>\n\n\n<h3 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h3><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提取子字符串</span></span><br><span class=\"line\"><span class=\"built_in\">substr</span>(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> len);</span><br><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\">string sub = str.<span class=\"built_in\">substr</span>(<span class=\"number\">6</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 结果: \"Wor\"</span></span><br></pre></td></tr></table></figure></div>\n\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串赋值</span></span><br><span class=\"line\"><span class=\"built_in\">assign</span>();</span><br><span class=\"line\">string str1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string str2;</span><br><span class=\"line\">str<span class=\"number\">2.</span><span class=\"built_in\">assign</span>(str1);  <span class=\"comment\">// str2现在是 \"Hello\"</span></span><br></pre></td></tr></table></figure></div>\n\n\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在指定位置插入字符串</span></span><br><span class=\"line\">    string str1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    string str2 = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">    str<span class=\"number\">1.</span><span class=\"built_in\">insert</span>(<span class=\"number\">3</span>, str2);</span><br><span class=\"line\">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 结果: helworldlo </span></span><br></pre></td></tr></table></figure></div>\n\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除指定位置的指定长度的字符</span></span><br><span class=\"line\"><span class=\"built_in\">erase</span>(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> len);</span><br><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>);  <span class=\"comment\">// 结果: \"Hello\"</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>Notice：</strong></p>\n<ol>\n<li>所有位置索引都是从0开始计数</li>\n<li>如果指定的长度超过字符串实际长度，会自动调整到实际可用长度</li>\n<li>使用这些函数时要注意检查参数的有效性，避免越界访问</li>\n<li><code>.assign(str, pos, len)</code>: 相比于直接赋值, <code>assign</code>还提供了精确控制赋值的方法, 也就是指定内容字符串的起始位置和长度.</li>\n</ol>\n<hr>\n<h3 id=\"Substr\"><a href=\"#Substr\" class=\"headerlink\" title=\"Substr\"></a>Substr</h3><p>在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. <code>substr()</code>方法可以精确地获取字符串片段.</p>\n<p><code>substr</code>即substring的缩写, 表示子字符串.</p>\n<p><strong>基本语法</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">substr</span><span class=\"params\">(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> len)</span> </span>;</span><br></pre></td></tr></table></figure></div>\n<p>参数分别表示截取的起始下标以及要截取的长度(如果省略<code>len</code>将截取到字符串的末尾).</p>\n<p><strong>e.g.</strong>:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string email = <span class=\"string\">\"user.name@example.com\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取用户名的部分</span></span><br><span class=\"line\"><span class=\"type\">int</span> atPos = email.<span class=\"built_in\">find</span>(<span class=\"string\">'@'</span>);</span><br><span class=\"line\">string username = email.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, atPos); <span class=\"comment\">// result: \"user.name\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取域名部分</span></span><br><span class=\"line\">string domain =  email.<span class=\"built_in\">substr</span>(atPos + <span class=\"number\">1</span>); <span class=\"comment\">// result: \"example.com\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取顶级域名(最后一个.之后的部分)</span></span><br><span class=\"line\"><span class=\"type\">int</span> lastDotPos = email.<span class=\"built_in\">rfind</span>(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">string topLevelDomain = email.<span class=\"built_in\">substr</span>(lastDotPos + <span class=\"number\">1</span>); <span class=\"comment\">// result: \"com\"</span></span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>rfind()</code>方法: 会从字符串的<strong>末尾向前</strong>搜索，从而返回要查找的字符或子字符串此时第一次出现的位置。如果没有找到，则返回 string::npos.</li>\n</ul>\n<hr>\n<h1 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h1><h2 id=\"Default-arguments\"><a href=\"#Default-arguments\" class=\"headerlink\" title=\"Default arguments\"></a>Default arguments</h2><p>要点:</p>\n<ul>\n<li><p>默认值必须在函数原型中从右到左地给出, 否则在调用的时候无法分辨;</p>\n</li>\n<li><p>默认值只能出现在函数原型 或者 将声明和定义放在一起, 下面的情况会报错:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j = <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j = <span class=\"number\">10</span>)</span></span>{</span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h1 id=\"Group\"><a href=\"#Group\" class=\"headerlink\" title=\"Group\"></a>Group</h1><p><strong>选择的标准:</strong></p>\n<ul>\n<li>一般情况 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.054ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.242ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -525 1000 549\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21D2\" d=\"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z\"></path></g></g></g></svg></mjx-container> <code>vector</code>;</li>\n<li>程序需要对元素进行<strong>随机访问</strong> <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.054ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.242ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -525 1000 549\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21D2\" d=\"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z\"></path></g></g></g></svg></mjx-container> <code>vector</code> or <code>deque</code>;</li>\n<li>程序需要在容器<strong>中间插入</strong>元素 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.054ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.242ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -525 1000 549\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21D2\" d=\"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z\"></path></g></g></g></svg></mjx-container> <code>list</code> or <code>forward_list</code>;</li>\n<li>程序需要在容器的<strong>首尾插入</strong>元素 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.054ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.242ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -525 1000 549\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21D2\" d=\"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z\"></path></g></g></g></svg></mjx-container> <code>deque</code>;</li>\n<li>容器中的元素<strong>相对较小</strong>但是数量较多 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.079ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.287ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -534 1000 569\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21CF\" d=\"M346 174Q348 176 378 249T411 325Q411 327 239 327H68Q55 342 55 347Q55 354 68 367H428L459 445Q487 509 494 521T510 534Q517 534 524 527T531 516Q531 515 502 438L471 367H677L666 381Q631 421 605 463T578 516Q578 522 582 523T599 525H615L619 512Q659 437 714 383T812 309T896 272T942 254Q943 246 938 243T911 232Q718 172 619 -13L615 -24L599 -26Q578 -26 578 -17Q578 -11 587 6T617 53T666 118L677 132H373L339 54Q323 12 313 -8T298 -32T288 -35Q280 -35 275 -29T269 -17Q269 -14 298 57T328 132H68Q55 145 55 152Q55 156 56 158T62 165T68 172H206Q346 172 346 174ZM848 249Q763 297 735 318L722 327H455L422 252L391 174Q391 172 557 172H722L735 181Q773 210 819 234L848 249Z\"></path></g></g></g></svg></mjx-container> <code>list</code> nor <code>forward_list</code>.<ul>\n<li>否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pair\"><a href=\"#Pair\" class=\"headerlink\" title=\"Pair\"></a>Pair</h2><h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><h4 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h4><p>pair 是 C++ 标准库提供的模板类，用于<u>将两个不同类型的值组合成一个对象</u>。它定义在 <code>&lt;utility&gt;</code> 头文件中。</p>\n<h4 id=\"2-创建与初始化\"><a href=\"#2-创建与初始化\" class=\"headerlink\" title=\"2. 创建与初始化\"></a>2. 创建与初始化</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认构造</span></span><br><span class=\"line\">std::pair&lt;std::string, <span class=\"type\">int</span>&gt; p1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接初始化</span></span><br><span class=\"line\"><span class=\"function\">std::pair&lt;std::string, <span class=\"type\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"string\">\"tag\"</span>, <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用make_pair</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> p3 = std::<span class=\"built_in\">make_pair</span>(<span class=\"string\">\"data\"</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 统一初始化</span></span><br><span class=\"line\">std::pair&lt;std::string, <span class=\"type\">int</span>&gt; p4{<span class=\"string\">\"value\"</span>, <span class=\"number\">8</span>};</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"3-访问元素\"><a href=\"#3-访问元素\" class=\"headerlink\" title=\"3. 访问元素\"></a>3. 访问元素</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统访问方式</span></span><br><span class=\"line\">std::cout &lt;&lt; p<span class=\"number\">2.f</span>irst &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; p<span class=\"number\">2.</span>second &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构化绑定(C++17)</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> [key, val] = p3;</span><br><span class=\"line\">std::cout &lt;&lt; key &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"4-常用操作\"><a href=\"#4-常用操作\" class=\"headerlink\" title=\"4. 常用操作\"></a>4. 常用操作</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较操作</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (p1 == p2) {...}</span><br><span class=\"line\"><span class=\"keyword\">if</span> (p1 &lt; p2) {...}  <span class=\"comment\">// 先比较first，再比较second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交换内容</span></span><br><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">swap</span>(p2);</span><br><span class=\"line\">std::<span class=\"built_in\">swap</span>(p1, p2);</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"5-实际应用示例\"><a href=\"#5-实际应用示例\" class=\"headerlink\" title=\"5. 实际应用示例\"></a>5. 实际应用示例</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 作为函数返回值</span></span><br><span class=\"line\"><span class=\"function\">std::pair&lt;<span class=\"type\">bool</span>, string&gt; <span class=\"title\">checkInput</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; input)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input.<span class=\"built_in\">empty</span>()) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> {<span class=\"literal\">false</span>, <span class=\"string\">\"输入不能为空\"</span>};</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {<span class=\"literal\">true</span>, <span class=\"string\">\"\"</span>};</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在容器中使用</span></span><br><span class=\"line\">vector&lt;pair&lt;string, <span class=\"type\">int</span>&gt;&gt; dataList = {</span><br><span class=\"line\">    {<span class=\"string\">\"item1\"</span>, <span class=\"number\">10</span>},</span><br><span class=\"line\">    {<span class=\"string\">\"item2\"</span>, <span class=\"number\">20</span>},</span><br><span class=\"line\">    {<span class=\"string\">\"item3\"</span>, <span class=\"number\">30</span>}</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与map配合使用</span></span><br><span class=\"line\">map&lt;string, pair&lt;<span class=\"type\">int</span>, <span class=\"type\">double</span>&gt;&gt; complexData;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"6-注意事项\"><a href=\"#6-注意事项\" class=\"headerlink\" title=\"6. 注意事项\"></a>6. 注意事项</h4><ol>\n<li>pair 的元素可以是任意类型，包括自定义类型</li>\n<li>使用结构化绑定需要C++17或更高标准</li>\n<li>pair 常用于需要返回多个值的函数</li>\n<li>在性能敏感场景要注意构造和拷贝开销</li>\n</ol>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p><strong>集合</strong>: 用于存储一组不允许重复的元素, 且会自动排序.</p>\n<p>可以使用的方法包括:</p>\n<ol>\n<li><p><code>.insert( )</code>: 插入元素;</p>\n</li>\n<li><p><code>.erase()</code>: 删除元素. 如果输入是元素值, 那么返回1/0表示是否成功删除; 如果输入是迭代器, 那么返回的是<strong>下一个元素的迭代器</strong>.</p>\n</li>\n<li><p><code>.find( )</code>: 寻找元素, 如果找到 返回对应的 <strong>迭代器</strong>. 否则返回 <code>.end( )</code>;</p>\n</li>\n</ol>\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h2><p>存储元素在<strong>连续的内存空间</strong>中, 支持<strong>随机访问</strong>.</p>\n<ul>\n<li>可以动态增长, 适合存储<strong>未知数量</strong>的元素;</li>\n<li>通过下标访问元素的时间复杂度为 O(1);</li>\n<li>在末尾插入和删除元素的时间复杂度为 O(1);</li>\n<li>在中间插入和删除元素的时间复杂度为 O(n);</li>\n<li><strong>使用场景</strong>: 需要随机访问、排序、内存连续存储的场景.</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<ul>\n<li><p>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> it = <span class=\"built_in\">find</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), value);  <span class=\"comment\">// 查找 value</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (it != vec.<span class=\"built_in\">end</span>()) {         <span class=\"comment\">// 如果找到了（即没有返回 end()）</span></span><br><span class=\"line\">      vec.<span class=\"built_in\">erase</span>(it);             <span class=\"comment\">// 则删除找到的元素</span></span><br><span class=\"line\">  }</span><br></pre></td></tr></table></figure></div></li>\n<li><p>使用 <code>.push_back()</code>在末尾插入元素, 或者使用<code>.emplace_back()</code>在末尾原位构造元素(更加高效);</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">vec.<span class=\"built_in\">emplace_back</span>(<span class=\"number\">20</span>); <span class=\"comment\">//更加高效</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>emplace_back</code>方法<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象, 相比于<code>push_back</code>而言更加<strong>高效</strong>.</p>\n</blockquote>\n</li>\n<li><p><code>.erase()</code>方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;</p>\n  <div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>);       <span class=\"comment\">// 删除第二个元素</span></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">begin</span>() + <span class=\"number\">3</span>); <span class=\"comment\">// 删除前三个元素</span></span><br><span class=\"line\">vec.<span class=\"built_in\">clear</span>();                      <span class=\"comment\">// 清空整个 vector</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>vec.clear();</code> 将会清空整个vector.</p>\n<p>和<code>insert</code>需要的参数一样, 都需要<strong>迭代器</strong>而非索引来定位.</p>\n</blockquote>\n</li>\n<li><p><code>vec[i]</code>的形式访问, 使用<code>vec.at(i)</code>的方式可以在越界时抛出异常;</p>\n</li>\n<li><p><code>.begin()</code>和<code>.end()</code>获取迭代器, 使用范围for循环遍历元素;</p>\n  <div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> cout &lt;&lt; <span class=\"string\">\"Vector elements:\"</span> &lt;&lt; endl;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : vec) {</span><br><span class=\"line\">    cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用迭代器遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = vec.<span class=\"built_in\">begin</span>(); it != vec.<span class=\"built_in\">end</span>(); ++it) {</span><br><span class=\"line\">    cout &lt;&lt; *it &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div></li>\n<li><p><code>.size()</code>获取<code>vector</code>的大小, <code>.empty()</code>判断<code>vector</code>是否为空;</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"Vector size: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (vec.<span class=\"built_in\">empty</span>()) {</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Vector is empty.\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n<li><p>使用<code>sort()</code>对<code>vector</code>进行排序, 使用<code>find()</code>查找元素;</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>());   <span class=\"comment\">// 排序</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = <span class=\"built_in\">find</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"number\">5</span>); <span class=\"comment\">// 查找 5</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><code>insert</code> 插入的位置是指定的迭代器位置之前一个;</p>\n</li>\n</ul>\n<h3 id=\"Reserve\"><a href=\"#Reserve\" class=\"headerlink\" title=\"Reserve\"></a>Reserve</h3><p>为了避免频繁地扩展内存, 可以通过<code>reserve</code>预先分配合适的空间, 同时通过<code>.reszie()</code>调整大小;</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; v2;</span><br><span class=\"line\">v<span class=\"number\">2.</span><span class=\"built_in\">reserve</span>(<span class=\"number\">1000</span>);  <span class=\"comment\">// 一次性分配 1000 个元素的空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">v<span class=\"number\">2.</span><span class=\"built_in\">resize</span>(v<span class=\"number\">2.</span><span class=\"built_in\">size</span>() + v<span class=\"number\">2.</span><span class=\"built_in\">size</span>()/<span class=\"number\">2</span>); <span class=\"comment\">// 调整大小为原来的 1.5 倍</span></span><br></pre></td></tr></table></figure></div>\n\n<p><code>reserve</code>只分配空间而不创建元素,<code>resize</code>将同时分配元素(默认值):</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; vec;</span><br><span class=\"line\"><span class=\"comment\">// reserve: 只分配空间，不创建元素</span></span><br><span class=\"line\">vec.<span class=\"built_in\">reserve</span>(<span class=\"number\">10</span>);  </span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"The capacity with reserve: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"The size with reserve: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resize: 分配空间并创建元素</span></span><br><span class=\"line\">vec.<span class=\"built_in\">resize</span>(<span class=\"number\">10</span>);   </span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"The capacity with resize: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"The size with resize: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;   </span><br></pre></td></tr></table></figure></div>\n\n<p><strong>Output</strong>:</p>\n<div class=\"code-container\" data-rel=\"Shell\"><figure class=\"iseeu highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The capacity with reserve: 10</span><br><span class=\"line\">The size with reserve: 0</span><br><span class=\"line\">The capacity with resize: 10</span><br><span class=\"line\">The size with resize: 10</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>[!important]</p>\n<p><code>.push_back()</code>的实际作用是在容器索引的<code>size</code>处插入元素.</p>\n<p> 而<code>reserve</code>不会影响容器的<code>size</code>,  初始化和<code>resize</code>会影响并且填充默认值:</p>\n</blockquote>\n<p><strong>e.g.  验证:</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打印初始状态</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"初始状态：\\n\"</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"size: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; <span class=\"string\">\", capacity: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>() &lt;&lt; <span class=\"string\">\"\\n\\n\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 预留5个空间</span></span><br><span class=\"line\">    vec.<span class=\"built_in\">reserve</span>(<span class=\"number\">15</span>);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"reserve(15) 后：\\n\"</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"size: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; <span class=\"string\">\", capacity: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>() &lt;&lt; <span class=\"string\">\"\\n\\n\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vec[<span class=\"number\">20</span>] =<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加元素并观察</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"添加元素过程：\\n\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span>; i++) {</span><br><span class=\"line\">        vec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"添加 \"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" 后 - \"</span>;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"size: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() </span><br><span class=\"line\">             &lt;&lt; <span class=\"string\">\", capacity: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>()</span><br><span class=\"line\">             &lt;&lt; <span class=\"string\">\", 元素: \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> x : vec) cout &lt;&lt; x &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>Output:</strong></p>\n<div class=\"code-container\" data-rel=\"Shell\"><figure class=\"iseeu highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始状态：</span><br><span class=\"line\">size: 10, capacity: 10</span><br><span class=\"line\"></span><br><span class=\"line\">reserve(15) 后：</span><br><span class=\"line\">size: 10, capacity: 15</span><br><span class=\"line\"></span><br><span class=\"line\">添加元素过程：</span><br><span class=\"line\">添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 </span><br><span class=\"line\">添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 </span><br><span class=\"line\">添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 </span><br><span class=\"line\">添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 </span><br><span class=\"line\">添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 </span><br><span class=\"line\">添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 </span><br></pre></td></tr></table></figure></div>\n\n<ol>\n<li>此处的 <code>vector&lt;int&gt; vec(10);</code>初始化了10个默认值的<code>int</code>类型的元素;</li>\n<li><code>vec[20] = 20;</code>没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;<ol>\n<li>如果换成<code>vec.at(20) = 20</code>将会在编译时报错;</li>\n</ol>\n</li>\n<li>可以发现, <code>reserve</code>的作用就是避免了多次自动扩容.</li>\n</ol>\n<blockquote>\n<p><code>reserve</code>的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素<strong>copy</strong>到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.</p>\n</blockquote>\n<h3 id=\"Resize\"><a href=\"#Resize\" class=\"headerlink\" title=\"Resize\"></a>Resize</h3><p>用法的枚举:</p>\n<ol>\n<li><p><code>resize(n)</code>: 将vector的大小调整为n, 如果大于当前值, 则在末尾添加具有默认值的新元素;</p>\n</li>\n<li><p><code>resize(n, val)</code>: 同样调整大小, 但是指定了默认值为新的 <code>val</code>;</p>\n</li>\n<li><p>对于二维向量的内存分配也是类似的:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; m;  <span class=\"comment\">//二维码向量;</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\"> m.<span class=\"built_in\">resize</span>(r,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(c,<span class=\"number\">0</span>)); <span class=\"comment\">//初始化为一个r行c列且初始值为0的矩阵.</span></span><br></pre></td></tr></table></figure></div></li>\n</ol>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><ul>\n<li>在<code>list</code>容器当中, 迭代器是双向迭代器;<ul>\n<li>双向迭代器不支持大小的比较, 只支持 <code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>;<br>因此, 注意实际的使用:</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt; lst1;</span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt;::iterator iter1 = lst<span class=\"number\">1.</span><span class=\"built_in\">begin</span>();</span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt;::iterator iter2 = lst<span class=\"number\">1.</span><span class=\"built_in\">end</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确的写法</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter1 != iter2) {</span><br><span class=\"line\">    <span class=\"comment\">// 处理当前元素</span></span><br><span class=\"line\">    ++iter1;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误的比较</span></span><br><span class=\"line\"><span class=\"comment\">// while(iter1 &lt; iter2) </span></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"有序链表\"><a href=\"#有序链表\" class=\"headerlink\" title=\"有序链表\"></a>有序链表</h3><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    list&lt;string&gt; s;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    list&lt;string&gt; :: iterator p;</span><br><span class=\"line\">    <span class=\"type\">int</span> count ;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"enter the number of the strings:\"</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin &gt;&gt; count; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++){</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"enter a string:\"</span> ;</span><br><span class=\"line\">        cin &gt;&gt;str;</span><br><span class=\"line\">        </span><br><span class=\"line\">        p = s.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != s.<span class=\"built_in\">end</span>() &amp;&amp; *p &lt;str)</span><br><span class=\"line\">            p++;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(p,str);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = s.<span class=\"built_in\">begin</span>(); p!=s.<span class=\"built_in\">end</span>(); p++)</span><br><span class=\"line\">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>分析:</strong></p>\n<ul>\n<li><code>while(p != s.end() &amp;&amp; *p &lt;str)</code> 每次输入<code>str</code>时, 令迭代器从<code>list</code>的开头开始, 进行字典序的比较;</li>\n</ul>\n<blockquote>\n<p>[!important]</p>\n<p>找到插入的位置, 利用<code>insert()</code>方法插入到给出迭代器的<strong>前面</strong>!.</p>\n</blockquote>\n<h2 id=\"Deque\"><a href=\"#Deque\" class=\"headerlink\" title=\"Deque\"></a>Deque</h2><p><code>deque</code>即 double-ended queue, <strong>双端队列</strong>.</p>\n<p>支持:</p>\n<ul>\n<li>在两端快速的插入或删除;</li>\n<li>随机访问;</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;deque&gt;</span></span></span><br><span class=\"line\">deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 插入操作</span></span><br><span class=\"line\">dq.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);    <span class=\"comment\">// 在末尾插入</span></span><br><span class=\"line\">dq.<span class=\"built_in\">push_front</span>(<span class=\"number\">2</span>);   <span class=\"comment\">// 在开头插入</span></span><br><span class=\"line\">dq.<span class=\"built_in\">insert</span>(pos, val);<span class=\"comment\">// 在指定位置插入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 删除操作</span></span><br><span class=\"line\">dq.<span class=\"built_in\">pop_back</span>();      <span class=\"comment\">// 删除末尾元素</span></span><br><span class=\"line\">dq.<span class=\"built_in\">pop_front</span>();     <span class=\"comment\">// 删除首部元素</span></span><br><span class=\"line\">dq.<span class=\"built_in\">erase</span>(pos);      <span class=\"comment\">// 删除指定位置元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 访问操作</span></span><br><span class=\"line\">dq[<span class=\"number\">0</span>];              <span class=\"comment\">// 随机访问</span></span><br><span class=\"line\">dq.<span class=\"built_in\">at</span>(<span class=\"number\">1</span>);           <span class=\"comment\">// 带边界检查的访问</span></span><br><span class=\"line\">dq.<span class=\"built_in\">front</span>();         <span class=\"comment\">// 访问第一个元素</span></span><br><span class=\"line\">dq.<span class=\"built_in\">back</span>();          <span class=\"comment\">// 访问最后一个元素</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>示例:</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;deque&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在两端插入元素</span></span><br><span class=\"line\">    dq.<span class=\"built_in\">push_back</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    dq.<span class=\"built_in\">push_front</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    dq.<span class=\"built_in\">push_back</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    dq.<span class=\"built_in\">push_front</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// dq ：{8, 1, 3, 4}</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用随机访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; dq.<span class=\"built_in\">size</span>(); ++i) {</span><br><span class=\"line\">        cout &lt;&lt; dq[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"Forward-list\"><a href=\"#Forward-list\" class=\"headerlink\" title=\"Forward_list\"></a>Forward_list</h3><p><code>forward_list</code>即 单项链表.</p>\n<ul>\n<li>只能向前遍历, 即对应的迭代器不支持<code>--</code>而支持<code>++</code>.</li>\n<li>同时不支持下标访问以及随机访问.</li>\n<li>单项链表的设计, 使得内部的每个节点只需要<strong>一个</strong>指针来指向下一个节点, 从而比<code>list</code>双向链表更加<strong>节省内存.</strong></li>\n</ul>\n<p><strong>语法</strong>:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;forward_list&gt;</span></span></span><br><span class=\"line\">forward_list&lt;<span class=\"type\">int</span>&gt; fl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 插入操作</span></span><br><span class=\"line\">fl.<span class=\"built_in\">push_front</span>(<span class=\"number\">1</span>);           <span class=\"comment\">// 在开头插入</span></span><br><span class=\"line\">fl.<span class=\"built_in\">insert_after</span>(pos, val);  <span class=\"comment\">// 在指定位置之后插入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 删除操作</span></span><br><span class=\"line\">fl.<span class=\"built_in\">pop_front</span>();            <span class=\"comment\">// 删除第一个元素</span></span><br><span class=\"line\">fl.<span class=\"built_in\">erase_after</span>(pos);       <span class=\"comment\">// 删除指定位置之后的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 访问操作</span></span><br><span class=\"line\">fl.<span class=\"built_in\">front</span>();               <span class=\"comment\">// 访问第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 特殊操作</span></span><br><span class=\"line\">fl.<span class=\"built_in\">before_begin</span>();        <span class=\"comment\">// 返回第一个元素之前的迭代器</span></span><br><span class=\"line\">fl.<span class=\"built_in\">begin</span>();               <span class=\"comment\">// 返回第一个元素的迭代器</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>示例</strong>:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;forward_list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    forward_list&lt;<span class=\"type\">int</span>&gt; fl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 插入元素</span></span><br><span class=\"line\">    fl.<span class=\"built_in\">push_front</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    fl.<span class=\"built_in\">push_front</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    fl.<span class=\"built_in\">push_front</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在特定位置后插入</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = fl.<span class=\"built_in\">begin</span>(); <span class=\"comment\">// 指向第一个元素</span></span><br><span class=\"line\">    fl.<span class=\"built_in\">insert_after</span>(it, <span class=\"number\">4</span>); <span class=\"comment\">// 在第一个元素后插入4</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遍历打印</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; val : fl) {</span><br><span class=\"line\">        cout &lt;&lt; val &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 输出：1 4 2 3</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"访问前一个元素\"><a href=\"#访问前一个元素\" class=\"headerlink\" title=\"访问前一个元素\"></a>访问前一个元素</h4><p>由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合<code>before_begin()</code>方法.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果需要访问某个元素的前一个元素，必须从头开始遍历</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> prev = fl.<span class=\"built_in\">before_begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> curr = fl.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(curr != fl.<span class=\"built_in\">end</span>() &amp;&amp; *curr != target) {</span><br><span class=\"line\">    ++prev;</span><br><span class=\"line\">    ++curr;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键<strong>自动排序</strong></p>\n<ul>\n<li>如果插入重复的key, 将会覆盖原有的value;</li>\n<li>通过键查找元素、插入和删除的时间复杂度均为O(log n);</li>\n<li><strong>使用场景</strong>: 字典、索引、统计等.</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<ul>\n<li><p>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于<code>map</code>当中;</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> it = ages.<span class=\"built_in\">find</span>(<span class=\"string\">\"Charlie\"</span>);  <span class=\"comment\">// 查找 \"Charlie\"</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (it != ages.<span class=\"built_in\">end</span>()) {         <span class=\"comment\">// 如果找到了（即没有返回 end()）</span></span><br><span class=\"line\">      ages.<span class=\"built_in\">erase</span>(it);             <span class=\"comment\">// 则删除找到的元素</span></span><br><span class=\"line\">  }</span><br></pre></td></tr></table></figure></div></li>\n<li><p>使用下标(键)直接插入,或者通过键值对插入</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">\"Alice\"</span>] = <span class=\"number\">25</span>;</span><br><span class=\"line\">ages.<span class=\"built_in\">insert</span>({<span class=\"string\">\"Bob\"</span>, <span class=\"number\">30</span>});</span><br><span class=\"line\">ages.<span class=\"built_in\">emplace</span>(<span class=\"string\">\"Charlie\"</span>, <span class=\"number\">28</span>); <span class=\"comment\">// 使用 emplace 插入 (更高效)</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>emplace</code>方法指<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于<code>insert</code>而言更加<strong>高效</strong>.</p>\n</blockquote>\n</li>\n<li><p><code>.erase()</code>方法删除指定key的元素, 也可以通过<code>.find()</code>找到key对应的迭代器<code>it</code>, 然后<code>erase(it)</code>.</p>\n  <div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages.<span class=\"built_in\">erase</span>(<span class=\"string\">\"Bob\"</span>);           <span class=\"comment\">// 删除键为 \"Bob\" 的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = ages.<span class=\"built_in\">find</span>(<span class=\"string\">\"Charlie\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (it != ages.<span class=\"built_in\">end</span>()) {</span><br><span class=\"line\">    ages.<span class=\"built_in\">erase</span>(it);         <span class=\"comment\">// 删除迭代器指向的元素</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>ages.clear();</code> 将会清空整个map.</p>\n</blockquote>\n</li>\n<li><p><code>map[key]</code>的形式访问, 使用<code>map.at(key)</code>的方式可以在key不存在时抛出异常;</p>\n</li>\n<li><p><code>.find(key)</code>查找对应键的元素( 返回<strong>迭代器</strong> ), <code>.count(key)</code>返回对应键的元素个数(0 or 1)</p>\n</li>\n<li><p><code>.size()</code>获取map的大小.</p>\n</li>\n<li><p>迭代器的<code>-&gt;first</code>和<code>-&gt;second</code>可以分别访问键和值.</p>\n  <div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"Map elements:\"</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> mapIt = ages.<span class=\"built_in\">begin</span>(); mapIt != ages.<span class=\"built_in\">end</span>(); ++mapIt) {</span><br><span class=\"line\">   cout &lt;&lt; mapIt-&gt;first &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; mapIt-&gt;second &lt;&lt; endl; <span class=\"comment\">// 访问键和值</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><p>迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.</p>\n<ul>\n<li><strong>标记位置</strong>: <code>.begin()</code>和<code>.end()</code> 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;</li>\n</ul>\n<p>迭代器的分类:</p>\n<ul>\n<li>输入迭代器: 支持读取和递增操作;<ul>\n<li><code>istream_iterator</code>: 用于从输入流读取数据;</li>\n</ul>\n</li>\n<li>输出迭代器: 支持写入和递增操作;<ul>\n<li><code>ostream_iterator</code>: 用于向输出流写入数据;</li>\n</ul>\n</li>\n<li>前向迭代器: 具有输入、输出迭代器的<strong>所有</strong>功能, 并且可以多次遍历同一个序列;<ul>\n<li>比如<code>forwarf_list</code>的迭代器:<code>auto it = flist.begin()</code> or <code>forward_list&lt;int&gt;::iterator it = flist.begin()</code>;</li>\n</ul>\n</li>\n<li>双向迭代器: 在前向迭代器的原有功能上, 同时支持<strong>递减</strong>操作;<ul>\n<li>比如双向链表<code>list</code>的迭代器.<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    list&lt;<span class=\"type\">int</span>&gt; myList = {<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用双向迭代器正向遍历</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Forward traversal: \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( list&lt;<span class=\"type\">int</span>&gt;::iterator it = myList.<span class=\"built_in\">begin</span>(); it != myList.<span class=\"built_in\">end</span>(); ++it) {</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout &lt;&lt;  endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用双向迭代器逆向遍历</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Reverse traversal: \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( list&lt;<span class=\"type\">int</span>&gt;::reverse_iterator rit = myList.<span class=\"built_in\">rbegin</span>(); rit != myList.<span class=\"built_in\">rend</span>(); ++rit) {</span><br><span class=\"line\">        cout &lt;&lt; *rit &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout &lt;&lt;  endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Forward traversal: 10 20 30 40 50 </span></span><br><span class=\"line\">    <span class=\"comment\">// Reverse traversal: 50 40 30 20 10 </span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<ol>\n<li><code>reverse_iterator</code>用于声明逆向遍历的迭代器, 也可以使用<code>auto</code>直接声明.</li>\n<li><code>rbegin()</code>和<code>rend()</code>分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的<code>++</code>相当于正向遍历时的<code>--</code>操作.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>随机访问迭代器: 具有双向迭代器的所有功能, 同时支持<strong>随机访问</strong>, 如<code>it+n</code>,<code>it[n]</code>.<ul>\n<li>比如<code>vector</code>的迭代器.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; vec = {<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>};</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"Vector elements (random access): \"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; vec.<span class=\"built_in\">size</span>(); ++i) {</span><br><span class=\"line\">    cout &lt;&lt; vec[i] &lt;&lt; <span class=\"string\">\" \"</span>; <span class=\"comment\">// 使用下标随机访问</span></span><br><span class=\"line\">}</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<p>另外, 还有一种迭代器称为<strong>插入迭代器</strong>, 比如<code>back_inserter</code></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; vec = {<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结合copy将容器的元素直接插入到另一个容器中</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; dest = {<span class=\"number\">60</span>,<span class=\"number\">70</span>};</span><br><span class=\"line\"><span class=\"built_in\">copy</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"built_in\">back_inserter</span>(dest)); <span class=\"comment\">// 在 dest 末尾插入元素</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"Copied vector: \"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : dest) {</span><br><span class=\"line\">    cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// Copied vector: 60 70 10 20 30 40 50 </span></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"for-each\"><a href=\"#for-each\" class=\"headerlink\" title=\"for-each\"></a>for-each</h2><p>for-each 循环的语法：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (range_declaration : range_expression) {</span><br><span class=\"line\">    loop_statement;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li>range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 <code>auto </code>关键字让编译器自动推导类型;</li>\n<li>range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或<strong>字符串</strong>;</li>\n<li>loop_statement： 循环体，包含要对每个元素执行的语句.</li>\n</ul>\n<p>e.g:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; numbers = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 for-each 循环遍历 vector</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : numbers) {</span><br><span class=\"line\">        std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>; <span class=\"comment\">// 输出每个元素</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 auto 关键字自动推导类型</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num : numbers) {</span><br><span class=\"line\">        std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 修改容器中的元素（需要使用引用）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> &amp;num : numbers) {</span><br><span class=\"line\">        num *= <span class=\"number\">2</span>; <span class=\"comment\">// 将每个元素乘以 2</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出修改后的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num : numbers) {</span><br><span class=\"line\">        std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>for (int &amp;num : numbers)</code>：使用引用 &amp;，可以直接修改容器中的元素.</li>\n</ul>\n<h3 id=\"Map的循环\"><a href=\"#Map的循环\" class=\"headerlink\" title=\"Map的循环\"></a>Map的循环</h3><p>当range_expression是<code>map</code>时, 可以使用<code>auto</code>自动推导range_declaration的类型.需要注意是:</p>\n<ul>\n<li>用迭代器的方式访问<code>map</code>中的键值对的形式是 <code>it-&gt;first</code>与<code>it-&gt;second</code>;</li>\n<li>在<code>for-each</code>循环当中, range_declaration是一个值, 因此使用<code>.first</code>与<code>.second</code>来访问键和值.  <div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    map&lt;string, string&gt; m = {{<span class=\"string\">\"one\"</span>, <span class=\"string\">\"1\"</span>}, {<span class=\"string\">\"two\"</span>, <span class=\"string\">\"2\"</span>}, {<span class=\"string\">\"three\"</span>, <span class=\"string\">\"3\"</span>}};</span><br><span class=\"line\">    vector&lt;string&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; entry : m){</span><br><span class=\"line\">        vec.<span class=\"built_in\">push_back</span>(entry.first + <span class=\"string\">\":\"</span> + entry.second );</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;string&gt;(cout, <span class=\"string\">\" \"</span>));</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n  <strong>Output:</strong>  <div class=\"code-container\" data-rel=\"Shell\"><figure class=\"iseeu highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one:1 three:3 two:2</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>此处由于<code>map</code>自动按照键的字典序进行排序, 因此输出时<code>three</code>的元素在<code>two</code>前;</p>\n</blockquote>\n</li>\n</ul>\n<p>在上述的示例中, 也可以使用下面的方式进行<code>vec</code>的输出:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; s : vec) {</span><br><span class=\"line\">    cout &lt;&lt; s &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<p>此时<code>auto</code>会自动推导为<code>string</code>类型, 且<code>&amp;</code>对数组的元素进行了引用, 使得输出更加高效.</p>\n<h3 id=\"Pro-Con\"><a href=\"#Pro-Con\" class=\"headerlink\" title=\"Pro&Con\"></a>Pro&amp;Con</h3><p><code>for-each</code>循环的优点:</p>\n<ul>\n<li>消除了访问数组等越界的风险;</li>\n<li>不需要事先初始化迭代器;</li>\n</ul>\n<p><code>for-each</code>循环的缺点:</p>\n<ul>\n<li>无法获取元素的索引;</li>\n<li>只能顺序地遍历.</li>\n</ul>\n<h2 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h2><p>我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.</p>\n<p>而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> old_type new_type;</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"Notices\"><a href=\"#Notices\" class=\"headerlink\" title=\"Notices\"></a>Notices</h2><ol>\n<li><p>直接对数组、字符串和<code>vector</code>进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;</p>\n</li>\n<li><p>对于<code>vector</code>, 可以通过<code>.at() = </code>的方式进行安全访问, 编译器会进行边界检查. 或者通过<code>.push_back()</code> or <code>.emplace_back</code>的方式在末尾赋值. 同时注意用<code>.reserve()</code>预先分配充分的内存空间.</p>\n</li>\n<li><p>避免不经意地向<code>map</code>当中插入元素:</p>\n<ol>\n<li>错误的示范:</li>\n</ol>\n <div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(foo[<span class=\"string\">\"bob\"</span>] == <span class=\"number\">1</span>){...}</span><br><span class=\"line\"><span class=\"comment\">// 设置默认的零值</span></span><br></pre></td></tr></table></figure></div>\n<ol start=\"2\">\n<li>使用<code>.count()</code>方法正确检查元素是否存在:</li>\n</ol>\n <div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( foo.<span class=\"built_in\">count</span>(<span class=\"string\">\"bob\"</span>) ){...}</span><br></pre></td></tr></table></figure></div>\n<ol start=\"3\">\n<li>也可以使用<code>find()</code>方法检查元素是否存在:</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> it = m.<span class=\"built_in\">find</span>(<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">if</span>(it  != m.<span class=\"built_in\">end</span>()){</span><br><span class=\"line\">    cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">else</span>{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Not found\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n<li><p>使用<code>.empty()</code>方法来检查容器<strong>整体是否为空</strong>, 而非<code>.count() == 0</code>的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.</p>\n</li>\n<li><p><code>erase()</code> 方法会返回<strong>指向</strong>被删除元素的<strong>下一个</strong>元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:</p>\n <div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Initialize a list</span></span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt; L;</span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt;::iterator li = L.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Wrong:</span></span><br><span class=\"line\">L.<span class=\"built_in\">erase</span>(li);    <span class=\"comment\">// 删除元素后，li 变成了无效迭代器</span></span><br><span class=\"line\">++li;           <span class=\"comment\">// 错误, 不能对无效迭代器进行操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Correct:</span></span><br><span class=\"line\">li = L.<span class=\"built_in\">erase</span>(li);  <span class=\"comment\">// 删除元素后，li 被更新为指向被删除元素的下一个元素</span></span><br></pre></td></tr></table></figure></div></li>\n</ol>\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><ul>\n<li>Pointers to Objects</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">string *p = &amp;str;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>Oprators with Pointers<ul>\n<li><code>&amp;</code>: 取地址;</li>\n<li><code>*</code>: 解引用;</li>\n<li><code>-&gt;</code>: 用于访问对象的成员.</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*p).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">p-&gt;<span class=\"built_in\">length</span>();</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>length()</code>即为<code>string</code>类的成员函数, 因此可以用<code>-&gt;</code>来访问.</p>\n</blockquote>\n<h1 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h1><h2 id=\"指针-1\"><a href=\"#指针-1\" class=\"headerlink\" title=\"指针\"></a>指针</h2><blockquote>\n<p>以<code>char</code>为例.</p>\n</blockquote>\n<ul>\n<li>指向常量的指针 <code>const char *p</code><ul>\n<li>可以改变指针的地址.</li>\n<li>无法通过指针改变对象的值</li>\n</ul>\n</li>\n<li>常量指针 <code>char * const p</code><ul>\n<li>指针指向的地址无法改变;</li>\n<li>但是可以通过指针改变对象的值<br>如果需要同时保证地址和值都无法改变, 则需要使用<code>const char * const p</code>.</li>\n</ul>\n</li>\n</ul>\n<p>如果<code>sp</code>是指向字符串的指针, 那么这两种的写法是等价的, 注意<code>.</code>的优先级高于<code>*</code>, 因此括号不可忽略.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp-&gt;<span class=\"built_in\">length</span>();</span><br><span class=\"line\">(*sp).<span class=\"built_in\">length</span>();</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"::\"></a><code>::</code></h3><p><code>::</code> resolver: 作用域解析运算符</p>\n<ul>\n<li><p>作用: </p>\n<ul>\n<li><p>访问全局的作用域<br>当局部变量和全局变量同名时, 可以使用 <code>::</code> 来访问全局变量</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> value = <span class=\"number\">10</span>; <span class=\"comment\">// 全局变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> value = <span class=\"number\">20</span>; <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">    cout &lt;&lt; value;    <span class=\"comment\">// 输出 20（局部变量）</span></span><br><span class=\"line\">    cout &lt;&lt; ::value;  <span class=\"comment\">// 输出 10（全局变量）</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>访问命名空间中的成员</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Math {</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> PI = <span class=\"number\">3.14159</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> circumference = <span class=\"number\">2</span> * Math::PI * radius; <span class=\"comment\">// 使用命名空间中的常量</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n<li><p>语法:</p>\n<ul>\n<li><code>&lt;class_name&gt; :: &lt;function_name&gt;</code></li>\n<li><code>::&lt;function_name&gt;</code>  全局作用域</li>\n</ul>\n</li>\n</ul>\n<p>e.g. </p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">S::f</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    ::<span class=\"built_in\">f</span>();  <span class=\"comment\">// Would be recursive otherwise!</span></span><br><span class=\"line\">    ::a++;  <span class=\"comment\">// Select the global a</span></span><br><span class=\"line\">    a--;    <span class=\"comment\">// The a at class scope</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p><code>S::f()</code>: 定义了属于类S的成员函数f;</p>\n<p><code>::f()</code>:表示调用全局作用域中的函数 <code>f()</code>, 默认为递归调用当前的成员函数;</p>\n<p><code>::a++</code>表示将全局作用域的 <code>a</code> 自增, <code>a--</code>则访问并递减类作用域中的成员变量 <code>a</code>.</p>\n</blockquote>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a><code>this</code></h3><p><code>this</code>指针是成员函数的隐藏参数. 指向<strong>当前对象的实例</strong>.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Point::move</span><span class=\"params\">(<span class=\"type\">int</span> dx, <span class=\"type\">int</span> dy)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Point::move</span><span class=\"params\">(Point *<span class=\"keyword\">this</span>, <span class=\"type\">int</span> dx, <span class=\"type\">int</span> dy)</span></span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>当调用成员函数时, 对象的地址会自动作为 <code>this</code>参数传递.</p>\n<p>在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 <code>this</code>:</p>\n<p>e.g</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 移动点的位置</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"type\">int</span> dx, <span class=\"type\">int</span> dy)</span> </span>{</span><br><span class=\"line\">        x += dx;</span><br><span class=\"line\">        y += dy;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打印点的坐标</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Point at (\"</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; y &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 组合以上两个功能的函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move_and_print</span><span class=\"params\">(<span class=\"type\">int</span> dx, <span class=\"type\">int</span> dy)</span> </span>{</span><br><span class=\"line\">        <span class=\"built_in\">move</span>(dx, dy);  <span class=\"comment\">// 等同于 this-&gt;move(dx, dy)</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>();       <span class=\"comment\">// 等同于 this-&gt;print()</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>但是也可以显式指定 <code>this-&gt;move</code>, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.</p>\n</blockquote>\n<h3 id=\"封装特性\"><a href=\"#封装特性\" class=\"headerlink\" title=\"封装特性\"></a>封装特性</h3><p>在OOP中, Object = Attributes + Services, 即数据和操作被<strong>封装</strong>在一起, 构成一个完整的对象.</p>\n<h3 id=\"声明与定义\"><a href=\"#声明与定义\" class=\"headerlink\" title=\"声明与定义\"></a>声明与定义</h3><p>我们应当在头文件中声明对象的成员及其 <code>public</code>,<code>private</code>和 <code>protected</code>等属性, 并且在 <code>cpp</code>文件中给出具体的定义:</p>\n<blockquote>\n<p>最好为每个类都建立如此对应的头文件和源文件 <code>cpp</code>.</p>\n</blockquote>\n<p>e.g. </p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Student.h - 类的声明</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> STUDENT_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STUDENT_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;  <span class=\"comment\">// 在头文件中使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 数据成员</span></span><br><span class=\"line\">    string name;     </span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">float</span> gpa;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数原型</span></span><br><span class=\"line\">    <span class=\"built_in\">Student</span>(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">int</span> id);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 成员函数原型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setName</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; newName)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calculateGPA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEligibleForScholarship</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// STUDENT_H</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Student.cpp - 成员函数的定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"Student.h\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;  <span class=\"comment\">// 在源文件中使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造函数实现</span></span><br><span class=\"line\">Student::<span class=\"built_in\">Student</span>(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">int</span> id) {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;id = id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;gpa = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::setName</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; newName)</span> </span>{</span><br><span class=\"line\">    name = newName;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">Student::getName</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::calculateGPA</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 实现GPA计算逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Student::isEligibleForScholarship</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gpa &gt;= <span class=\"number\">3.5</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p><code>Student::getName()</code>指的就是类 <code>Student</code>中的成员函数 <code>getName()</code>.</p>\n</blockquote>\n<p>具体来说, <code>.h</code>头文件当中应该有:</p>\n<ul>\n<li><p>外部变量的声明<br>e.g. <code>extern int globalCounter;  // 仅声明，不定义</code></p>\n</li>\n<li><p>函数原型<br>e.g. <code>int calculateSum(int a, int b);  // 函数声明，不包含实现</code></p>\n</li>\n<li><p>类/结构体的声明<br>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>;  <span class=\"comment\">// 前向声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或完整类声明（不含成员函数定义）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> width;</span><br><span class=\"line\">    <span class=\"type\">double</span> height;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>(<span class=\"type\">double</span> w, <span class=\"type\">double</span> h);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<p>回顾 <code>#include</code>: 将被引用的文件插入 <code>.cpp</code> 文件当中</p>\n<ul>\n<li><p><code>#include \"xx.h\"</code>: 首先在当前目录下寻找;</p>\n</li>\n<li><p><code>#include &lt;xx.h&gt;</code>: 直接在指定的目录中寻找</p>\n<blockquote>\n<p>等价于 <code>#include &lt;xx&gt;</code>.</p>\n</blockquote>\n</li>\n</ul>\n<p>为了避免在多个 <code>.cpp</code> 文件中重复引用相同的头文件, 可以通过 <code>#ifndef</code>等标记来判断是否需要引用当前的头文件:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> HEADER_FLAG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HEADER_FLAG</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> </span></span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p><code>HEADER_FLAG</code>一般使用完全大写来方便标识, 但是也可以大小写混合.</p>\n</blockquote>\n<p>e.g. </p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件: vector.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> VECTOR_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> VECTOR_H</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// VECTOR_H</span></span></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"生命周期管理\"><a href=\"#生命周期管理\" class=\"headerlink\" title=\"生命周期管理\"></a>生命周期管理</h2><p>当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.</p>\n<p>为了确保这些工作不被遗忘, <code>cpp</code>的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.</p>\n<h3 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.</p>\n<ul>\n<li>语法:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 带参数的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>(参数列表);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>(<span class=\"type\">const</span> ClassName&amp; other);</span><br><span class=\"line\">    </span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ol>\n<li><strong>默认构造函数</strong>：不带参数或所有参数都有默认值;</li>\n<li><strong>带参数的构造函数</strong>：接受一个或多个参数;</li>\n<li><strong>拷贝构造函数</strong>：从同类型的另一个对象创建新对象.</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>构造函数初始化列表</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point::<span class=\"built_in\">Point</span>(<span class=\"type\">int</span> xx, <span class=\"type\">int</span> yy) :<span class=\"built_in\">x</span>(xx), <span class=\"built_in\">y</span>(yy) {</span><br><span class=\"line\">  ...</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>构造函数时, 传递参数并直接赋值给内部的成员变量 <code>x</code> , <code>y</code>.</p>\n</blockquote>\n</li>\n<li><p>结构体中的构造函数:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Y</span> { </span><br><span class=\"line\">    <span class=\"type\">float</span> f;     <span class=\"comment\">// 浮点型成员变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i;       <span class=\"comment\">// 整型成员变量</span></span><br><span class=\"line\">    <span class=\"built_in\">Y</span>(<span class=\"type\">int</span> a);    <span class=\"comment\">// 声明了一个接受int参数的构造函数</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ol>\n<li>此处只是声明了构造函数需要 <code>int a</code>作为参数, 但是没有给出具体的实现;</li>\n<li>声明结构体对象(数组)  e.g. <code>Y y1[] = { Y(1), Y(2), Y(3) };</code></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"默认构造\"><a href=\"#默认构造\" class=\"headerlink\" title=\"默认构造\"></a>默认构造</h3><p><code>auto</code> default constructor: (自动) 默认构造函数. <strong>当且仅当</strong>不存在任何构造函数时, 程序会自动生成默认构造函数, 不作任何的操作.</p>\n<p><code>默认构造函数</code>： 在没有参数的情况下可以调用的构造函数， 称为默认构造函数. 其来源除了上述的程序构造以外, 还包括:</p>\n<ol>\n<li>显示定义的无参构造函数;</li>\n<li>定义的所有参数都具有默认值的构造函数.</li>\n</ol>\n<ul>\n<li>对于成员变量: 不进行初始化;</li>\n</ul>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 <code>~</code>. 当对象超出作用域或被显式删除时，析构函数会自动被调用.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">ClassName</span>();</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>类似于栈, 优先创建的后析构.</li>\n</ul>\n<p>运用的示例:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyString</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span>* data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>() : <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"默认构造函数调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 带参数的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* str) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str) {</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, str);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"参数构造函数调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> MyString&amp; other) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data) {</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"拷贝构造函数调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">MyString</span>() {</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"析构函数调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打印字符串</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; (data ? data : <span class=\"string\">\"空字符串\"</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 测试各种构造函数</span></span><br><span class=\"line\">    MyString s1;                  <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"function\">MyString <span class=\"title\">s2</span><span class=\"params\">(<span class=\"string\">\"Hello\"</span>)</span></span>;         <span class=\"comment\">// 带参数的构造函数</span></span><br><span class=\"line\">    MyString s3 = s2;             <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    s<span class=\"number\">1.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    s<span class=\"number\">2.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    s<span class=\"number\">3.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">// 所有对象在这里被销毁，调用析构函数</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>本地对象: </p>\n<p><code>Field</code>(字段)指的是在类中定义的变量(成员变量):</p>\n<ul>\n<li>可以直接被类中的所有方法访问;</li>\n<li>生命周期<strong>和类的对象保持一致;</strong></li>\n</ul>\n<p>其他类型数据的生命周期:</p>\n<ul>\n<li><strong>参数</strong>: 函数执行期间;</li>\n<li><strong>局部变量</strong>: 声明的代码块内部.</li>\n</ul>\n<hr>\n<p>全局对象:</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>如果在类或对象的方法内部定义了一个和成员变量同名的变量, 那么将默认访问这个变量, 只有用 <code>this-&gt;xxx</code>才能显式访问成员变量. e.g. <code>int MyClass::count </code>.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> value = <span class=\"number\">10</span>; <span class=\"comment\">// 字段</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printValue</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"type\">int</span> value = <span class=\"number\">20</span>; <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Local value: \"</span> &lt;&lt; value &lt;&lt; std::endl; <span class=\"comment\">// 输出局部变量</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Field value: \"</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;value &lt;&lt; std::endl;<span class=\"comment\">//使用this指针访问字段</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div></blockquote>\n<h2 id=\"Access-Control\"><a href=\"#Access-Control\" class=\"headerlink\" title=\"Access Control\"></a>Access Control</h2><p><code>class</code>的默认为 <code>private</code>, 而 <code>struct</code>的默认权限是 <code>public</code>.</p>\n<p>访问限制符:</p>\n<h3 id=\"friend\"><a href=\"#friend\" class=\"headerlink\" title=\"friend\"></a><code>friend</code></h3><p>在 <code>class</code>内部声明友元, 可以使得对应的函数访问自身的成员变量(包括私有和受保护, 也即是所有的变量).</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">X</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">g</span><span class=\"params\">(X*, <span class=\"type\">int</span> i)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Y::y</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<blockquote>\n<p>[!NOTE]</p>\n<p><strong>友元关系不具有传递性 !</strong></p>\n</blockquote>\n<h3 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a><code>protected</code></h3><p>该声明内的成员可以被以下的范围访问:</p>\n<ol>\n<li>该类自身的成员函数;</li>\n<li><strong>该类的派生类的成员函数;</strong></li>\n</ol>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> {</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> protectedVar;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">protectedVar</span>(val) {}</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">Base</span>(val) {}</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">accessProtectedVar</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        protectedVar = <span class=\"number\">10</span>; <span class=\"comment\">// 派生类可以访问 protectedVar</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getProtectedVar</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protectedVar;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>此处的 <code>base</code>就是一个基类, <code>class Derived : public Base</code>表明 Derived 是 base的一个派生类.</p>\n<p>因此,  派生类可以通过自己的成员函数, 访问基类的 <code>protected</code>内的成员变量.</p>\n</blockquote>\n<h2 id=\"Static\"><a href=\"#Static\" class=\"headerlink\" title=\"Static\"></a>Static</h2><p>对于本地变量和全局变量的作用不同, 前者是生命周期, 后者是访问空间.</p>\n<p>静态的对象的生命周期是全局, 但是不会跟全局变量一样(一开始就创建), 而是在第一次调用的时候才构造, 且只构造一次.</p>\n<ul>\n<li><p><code>静态成员变量</code>由所有的实例<strong>共享</strong>, 初始化的时候不能再添加 <code>static</code>标签(否则无法被外文件访问), 必须在类的外部进行初始化, 且需要声明所属于的类;</p>\n<blockquote>\n<p>但是也可以被普通的成员函数所访问.</p>\n</blockquote>\n</li>\n<li><p><code>静态成员函数</code>属于类本身, 因此可以通过类名直接调用, 但是只能访问类的静态成员变量, 因为不存在属于实例的<code>this</code>指针. 静态成员函数可以在<strong>类的内部</strong>就定义, 如果在类的外部定义, 也不需要额外的<code>static</code>标签;</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count; <span class=\"comment\">// 静态成员变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> i) : <span class=\"built_in\">id</span>(i) {</span><br><span class=\"line\">        count++; <span class=\"comment\">// 每次创建对象，count加1</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>() {</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>{ <span class=\"comment\">// 静态成员函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> MyClass::count = <span class=\"number\">0</span>; <span class=\"comment\">// 静态成员变量的初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Count: \"</span> &lt;&lt; MyClass::<span class=\"built_in\">getCount</span>() &lt;&lt; std::endl; <span class=\"comment\">// 通过类名调用静态成员函数</span></span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">obj1</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">obj2</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Count: \"</span> &lt;&lt; MyClass::<span class=\"built_in\">getCount</span>() &lt;&lt; std::endl; <span class=\"comment\">// 通过类名调用静态成员函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>Output:</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Count: <span class=\"number\">0</span></span><br><span class=\"line\">Count: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></div>\n\n\n</li>\n<li><p>函数内部的静态变量只会在调用的时候<strong>初始化一次</strong>, 直到程序结束.<br>e.g. 计数函数的调用次数:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  <span class=\"type\">static</span> <span class=\"type\">int</span> num_calls = <span class=\"number\">0</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  num_calls += <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><code>extern</code>关键字用于声明变量或函数在其他文件中定义. 告诉编译器从而允许跨文件的访问.</p>\n<blockquote>\n<p>但是这种跨文件访问只能作用于<strong>非静态</strong>的全局变量, i.e. 全局变量加上<code>static</code>声明之后, 将其作用域限制在了当前文件的内部.</p>\n</blockquote>\n</li>\n<li><p>函数内部的静态对象, 其构造函数只会在定义的时候调用一次. 并且析构函数当退出程序时调用. 即使采取条件构造, 也只会在第一次条件满足的时候构造.</p>\n</li>\n<li><p>静态成员的使用:</p>\n<ul>\n<li><p>通过类名: <code>&lt;class_name&gt;::&lt;static member</code></p>\n</li>\n<li><p>通过实例名: <code>&lt;ob variable&gt;.&lt;static member&gt;</code></p>\n<blockquote>\n<p>让人误以为是类的对象变量, 不建议这样使用.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>引用（Reference）是一个非常重要的特性。它的引入是为了解决一些特定场景下的问题：</p>\n<ul>\n<li><strong><u>避免不必要的拷贝</u></strong>：在某些情况下，传递大型对象或结构体给函数时，如果直接传递拷贝会导致性能下降。引用允许我们传递对象的别名，而不需要拷贝整个对象。</li>\n<li><strong><u>简化代码</u></strong>：引用可以使代码更简洁，特别是在函数返回值和参数传递时。例如，通过引用返回一个对象可以避免构造临时对象。</li>\n<li><strong><u>指针的安全替代</u></strong>：引用提供了指针的功能，但避免了指针容易导致的错误，如空指针解引用或野指针。</li>\n</ul>\n<p><strong>基本语法</strong>: </p>\n<p>引用是一个变量的别名，它在<strong>声明时必须被初始化</strong>，并且一旦初始化后就**<u>不能再指向其他</u>**对象.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; ref = a;  <span class=\"comment\">// ref 是 a 的引用</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><code>int&amp;</code> 表示引用类型，<code>ref</code> 是 <code>a</code> 的引用。</li>\n<li>引用必须在声明时初始化，并且不能重新引用到另一个对象。</li>\n<li>无法对引用进行引用;</li>\n<li><strong>不允许</strong>存在 <strong>以引用为元素的数组</strong></li>\n</ul>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>&amp; ref = a;  <span class=\"comment\">// ref 是 a 的引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Original value of a: \"</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Value of ref: \"</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    ref = <span class=\"number\">20</span>;  <span class=\"comment\">// 修改引用会影响原变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"After modifying ref, value of a: \"</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Value of ref: \"</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>在这个例子中：</p>\n<ul>\n<li><code>ref</code> 是 <code>a</code> 的引用，修改 <code>ref</code> 的值会影响 <code>a</code> 的值。</li>\n<li>通过引用，我们可以访问和修改原始变量 <code>a</code> 的值，而不需要直接操作 <code>a</code>。</li>\n</ul>\n<p>引用可以作为函数的形参, 此时<strong>函数内部的形参作为实参的引用可以改变实参的值</strong>.</p>\n<p>引用的绑定必须是一个具有明确地址的左值 ,而不能是临时产生的右值:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">func</span> (i * <span class=\"number\">3</span>); <span class=\"comment\">// Warning or error!</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"指针与引用\"><a href=\"#指针与引用\" class=\"headerlink\" title=\"指针与引用\"></a>指针与引用</h4><ul>\n<li><p>限制:</p>\n<ul>\n<li><p>无法获得指针的引用;</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> &amp;*p;<span class=\"comment\">// illegal</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>但是可以获得<strong>指向引用的指针</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> *&amp;p)</span></span>;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n</ul>\n<p> 可以如此理解, 引用实际上是对象的别名. 用于修改对象的值. 但是为了修改指针, 可以直接使用指针的指针 <code>**</code>.</p>\n<p>此外, 引用并非独立的对象, 而是直接 <strong>绑定</strong>. 因此 <code>int&amp; ref = a;</code>  <code>&amp;ref</code>就是 a的地址.</p>\n<h4 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h4><p>左值是指具有明确地址的变量或者引用, 右值是计算过程中的中间结果或者字面量 (e.g.<code>10</code>).等不可寻址的值;</p>\n<blockquote>\n<p>涉及到计算的基本都是右值, 但是这四种的计算结果依旧是左值: <code>*</code>,<code>.</code>,<code>[]</code>和 <code>-&gt;</code>.</p>\n</blockquote>\n<p>右值一般在计算结束后就消失了, 如果我们希望延长其生命周期, 就可以使用 <strong>右值引用</strong>.</p>\n<ul>\n<li><p><strong>格式</strong>: <code>&lt;tyep&gt; &amp;&amp; &lt;ref_name&gt; = &lt;right_value&gt;</code></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x=<span class=\"number\">20</span>; <span class=\"comment\">// left-value </span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rx = x * <span class=\"number\">2</span>:</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>TIps:</p>\n<ul>\n<li>右值引用在初始化之后就可以正常赋值;</li>\n<li>右值引用无法使用左值进行赋值.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"引用参数与函数重载\"><a href=\"#引用参数与函数重载\" class=\"headerlink\" title=\"引用参数与函数重载\"></a>引用参数与函数重载</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"type\">int</span>&amp; lref)</span></span>{</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">\"lref = \"</span> &lt;&lt; lref &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"type\">int</span>&amp;&amp; rref)</span></span>{</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">\"rref = \"</span> &lt;&lt; rref &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">   <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"built_in\">fun</span>(x);</span><br><span class=\"line\">   <span class=\"built_in\">fun</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>Output</strong>:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lref = <span class=\"number\">10</span></span><br><span class=\"line\">rref = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ol>\n<li>字面量<code>10</code>作为右值, 可以通过右值引用作为函数的参数;</li>\n<li>具有明确地址的变量 <code>x</code>是左值;</li>\n<li>C++ 允许在同一个作用域内声明多个具有相同名称但参数列表不同的函数。这被称为<strong>函数重载</strong>。编译器通过检查函数调用时提供的参数类型和数量来决定调用哪个重载函数。</li>\n</ol>\n</blockquote>\n<p>另外, 加上<code>const</code>之后, <code>&amp; </code>的形参也可以接受右值作为实参, 比如: <code>void fun (const int&amp; clref) {...}</code></p>\n<blockquote>\n<p>但是如果已经存在右值实参作为形参的同名函数, 将会优先选择后者进行重载.</p>\n</blockquote>\n<p>这是因为普通引用对于右值的修改 make no sense, 而 <code>const</code> 引用<u>保证不会修改引用的对象</u>，因此即使是临时对象（右值）也可以安全地绑定到 <code>const</code> 引用.</p>\n<h2 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>使用 <code>const</code>声明常量, 常量的值不可修改.</p>\n<p><code>const</code>声明集合的时候, 其中的值在<strong>编译期间不可知</strong>, 因此<u>无法在代码中, 使用常量集合内部的值进行操作.</u></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> i[] = {<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>};</span><br><span class=\"line\"><span class=\"type\">float</span> f[i[<span class=\"number\">2</span>]]; <span class=\"comment\">// Illegal!</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>使用<code>const</code>对指针类型进行操作的时候:</p>\n<ol>\n<li>忽略类似于 <code>char</code>之类的类型, 只关注 <code>const</code>与 <code>*</code>之间的位置关系;</li>\n<li>如果是 <code>const *p</code> 意思是指针指向的内容不可通过这个指针进行更改;</li>\n<li>如果是 <code>* const p</code>意思是指针指向的对象不可更改, 但是可以通过 <code>*p</code> 的方式改写对象的值</li>\n</ol>\n<hr>\n<p>关于字符指针与字符数组:</p>\n<ul>\n<li><code>char  *p = \"hello\";</code> 实际上是 <code>const char *p</code>, 也就是说不允许修改 <code>*p</code>;</li>\n<li>而 <code>char p[] = 'hello';</code> 则可以通过<code>*p</code> 修改.</li>\n</ul>\n<hr>\n<p>如果<strong>成员函数</strong>的<u>名称后</u>加了 <code>const</code>标记, 意味着:</p>\n<ol>\n<li>无法通过该成员函数改变成员变量的值.</li>\n<li>同时无法调用其他 <strong>非const</strong>的成员函数</li>\n<li>实际上, 将其的 <code>this</code>指针转换为 <code>const A* this</code>, 也就是指向常量的指针</li>\n</ol>\n<blockquote>\n<p>因此 <code>const</code>修饰的成员函数具有 <code>this</code>指针(可访问), 不要与 <code>static</code>修饰的静态成员函数混淆! 后者不具有 <code>this</code>指针.</p>\n<p>注意不要与 <code>const  type f()</code>混淆, 这是限制返回的结果无法修改; 而 <code>type f() const</code>限制成员函数本身的操作.</p>\n</blockquote>\n<p><strong>重载</strong>: 允许根据成员函数是否被 <code>const</code>限制, 以及对象本身是否为 <code>const</code>来重载成员函数.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"const version\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"non-const version\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    <span class=\"type\">const</span> A ca;</span><br><span class=\"line\"></span><br><span class=\"line\">    a.<span class=\"built_in\">f</span>();    <span class=\"comment\">// 输出: non-const version</span></span><br><span class=\"line\">    ca.<span class=\"built_in\">f</span>();   <span class=\"comment\">// 输出: const version</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>如果成员变量是 <code>const</code>, 那么:</p>\n<ul>\n<li><p><strong>必须在对象构造时进行初始化</strong> (无法在构造函数中进行直接赋值):</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> value) : <span class=\"built_in\">i</span>(value) {} <span class=\"comment\">// 在初始化列表中初始化</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<p>如果在实例化对象的时候,  声明了这个实例是 <code>const</code>, 那么就无法调用成员函数中没有在后面声明 <code>const</code>的部分.( 即使实际上并没有修改的函数, 也不能通过编译).  —— 只能调用那些被标记为<code>const</code>的成员函数。</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>{</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> get_const_value <span class=\"title\">const</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> A <span class=\"title\">a</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">a.get_value; <span class=\"comment\">// ERROR, const对象无法调用非const声明的成员函数</span></span><br><span class=\"line\">a.get_const_value; <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<hr>\n<p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250318120332036.png?imageSlim\" alt=\"image-20250318120332036\"></p>\n<blockquote>\n<p>无法用普通的指针来指向 <code>const</code>常量.</p>\n<p>但是可以用指向常量的指针 来指向非常量的对象.</p>\n</blockquote>\n<hr>\n<p>全局变量的构造在 <code>main()</code>之前. 静态本地变量在第一次执行到的时候才发生构造, 且只构造一次.</p>\n<hr>\n<h2 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h2><p>在 C++ 中，使用 <code>new</code> 关键字分配的空间位于 <strong>堆</strong> 上，与栈上的自动变量不同，堆上的内存不会自动释放，需要手动使用 <code>delete</code> 来析构以避免内存泄漏。</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 使用 new 在堆上分配一个整数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"值: \"</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 delete 释放内存</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ptr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指针置空，避免野指针</span></span><br><span class=\"line\">    ptr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ul>\n<li>每次 <code>new</code> 分配的内存都需要对应的 <code>delete</code>。</li>\n<li>对于数组，使用 <code>new[]</code> 分配，释放时用 <code>delete[]</code>：</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">5</span>];  <span class=\"comment\">// 分配数组</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span>[] arr;           <span class=\"comment\">// 释放数组</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h2 id=\"Inline-Class\"><a href=\"#Inline-Class\" class=\"headerlink\" title=\"Inline Class\"></a>Inline Class</h2><h3 id=\"Delegating-Constructor\"><a href=\"#Delegating-Constructor\" class=\"headerlink\" title=\"Delegating Constructor\"></a>Delegating Constructor</h3><p>委托构造函数（Delegating Constructor）是通过一个构造函数调用另一个构造函数来完成初始化的机制, 也就是在初始化列表中调用其他.</p>\n<p>相对于委托构造的构造函数, 被称为 <em>target constructor</em> 目标构造函数.</p>\n<p>目标构造函数的执行先于委托构造函数.</p>\n<hr>\n<h4 id=\"什么是委托构造函数？\"><a href=\"#什么是委托构造函数？\" class=\"headerlink\" title=\"什么是委托构造函数？\"></a>什么是委托构造函数？</h4><ul>\n<li><strong>定义</strong>: 一个构造函数可以在其初始化列表中调用同一个类的另一个构造函数来完成部分或全部初始化工作。</li>\n<li><strong>目的</strong>: 避免在多个构造函数中重复编写相同的初始化逻辑，解决代码重复的问题。</li>\n<li><strong>限制</strong>: 委托构造函数<u>本身不能在初始化列表中再初始化其他成员变量</u>，只能依赖被调用的构造函数。</li>\n</ul>\n<h4 id=\"代码示例与分析\"><a href=\"#代码示例与分析\" class=\"headerlink\" title=\"代码示例与分析\"></a>代码示例与分析</h4><p>考虑将下面的冗余代码通过委托构造函数简化:</p>\n<p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250325120013059.png?imageSlim\"></p>\n<p>实现: </p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassC</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> max;</span><br><span class=\"line\">    <span class=\"type\">int</span> min;</span><br><span class=\"line\">    <span class=\"type\">int</span> middle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 基础构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max) {</span><br><span class=\"line\">        max = (my_max &gt; <span class=\"number\">0</span>) ? my_max : <span class=\"number\">10</span>;  <span class=\"comment\">// 默认值10</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 委托给基础构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max, <span class=\"type\">int</span> my_min) : <span class=\"built_in\">ClassC</span>(my_max) {</span><br><span class=\"line\">        min = (my_min &gt; <span class=\"number\">0</span> &amp;&amp; my_min &lt; max) ? my_min : <span class=\"number\">1</span>;  <span class=\"comment\">// 默认值1</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 委托给第二个构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max, <span class=\"type\">int</span> my_min, <span class=\"type\">int</span> my_middle) : <span class=\"built_in\">ClassC</span>(my_max, my_min) {</span><br><span class=\"line\">        middle = (my_middle &lt; max &amp;&amp; my_middle &gt; min) ? my_middle : <span class=\"number\">5</span>;  <span class=\"comment\">// 默认值5</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    ClassC c1{<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>};</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"max: \"</span> &lt;&lt; c<span class=\"number\">1.</span>max &lt;&lt; <span class=\"string\">\", min: \"</span> &lt;&lt; c<span class=\"number\">1.</span>min &lt;&lt; <span class=\"string\">\", middle: \"</span> &lt;&lt; c<span class=\"number\">1.</span>middle &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"运行结果分析\"><a href=\"#运行结果分析\" class=\"headerlink\" title=\"运行结果分析\"></a>运行结果分析</h4><ul>\n<li><code>ClassC c1{1, 3, 2}</code>:<ol>\n<li>调用 <code>ClassC(int, int, int)</code> 构造函数。</li>\n<li>它委托给 <code>ClassC(int, int)</code>，后者再委托给 <code>ClassC(int)</code>。</li>\n<li>初始化顺序：<ul>\n<li><code>max = 1</code>（因为 1 &gt; 0）。</li>\n<li><code>min = 1</code>（因为 3 &gt; max，不满足条件，使用默认值 1）。</li>\n<li><code>middle = 2</code>（因为 2 &lt; max 且 2 &gt; min 不成立，但逻辑上仍赋值 2，需检查代码逻辑）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ol>\n<li><p><strong>初始化位置</strong>:</p>\n<ul>\n<li>成员变量不能在委托构造函数的初始化列表中直接使用参数初始化，必须通过被委托的构造函数完成。</li>\n<li>如 <code>ClassC(int my_max, int my_min) : ClassC(my_max)</code> 中，不能再初始化 <code>min</code>，只能在函数体内赋值。</li>\n</ul>\n</li>\n<li><p><strong>代码重复问题</strong>:</p>\n<ul>\n<li>如果每个构造函数都独立初始化 <code>max</code>、<code>min</code> 等，会导致重复代码。</li>\n<li>委托构造函数将公共逻辑集中到基础构造函数中。</li>\n</ul>\n</li>\n<li><p><strong>委托链</strong>:</p>\n<ul>\n<li>可以形成构造函数调用链，如 <code>ClassC(int, int, int)</code> → <code>ClassC(int, int)</code> → <code>ClassC(int)</code>。</li>\n</ul>\n</li>\n<li><p><strong>限制与解决方法</strong>:</p>\n<ul>\n<li>委托构造函数不能再有其他初始化列表项。</li>\n<li>如果需要更灵活的初始化，可以引入一个私有的辅助构造函数：</li>\n</ul>\n</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassC</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> max;  </span><br><span class=\"line\">    <span class=\"type\">int</span> min;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> my_max)</span> </span>{ max = my_max &gt; <span class=\"number\">0</span> ? my_max : <span class=\"number\">10</span>; }</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max) { <span class=\"built_in\">init</span>(my_max); }</span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max, <span class=\"type\">int</span> my_min) : <span class=\"built_in\">min</span>(my_min) { <span class=\"built_in\">init</span>(my_max); } <span class=\"comment\">// 直接在初始化列表中初始成员变量\t</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n<hr>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><ul>\n<li>默认参数是在函数声明中为参数指定的默认值，调用时未提供参数则使用默认值。</li>\n<li>规则：默认参数必须<u>从右到左设置</u>。</li>\n</ul>\n<h4 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">harpo</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m = <span class=\"number\">4</span>, <span class=\"type\">int</span> j = <span class=\"number\">5</span>)</span></span>;  <span class=\"comment\">// 合法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">chico</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m = <span class=\"number\">6</span>, <span class=\"type\">int</span> j)</span></span>;       <span class=\"comment\">// 非法：j 无默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">groucho</span><span class=\"params\">(<span class=\"type\">int</span> k = <span class=\"number\">1</span>, <span class=\"type\">int</span> m = <span class=\"number\">2</span>, <span class=\"type\">int</span> n = <span class=\"number\">3</span>)</span></span>;  <span class=\"comment\">// 合法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> beeps;</span><br><span class=\"line\">    beeps = <span class=\"built_in\">harpo</span>(<span class=\"number\">2</span>);      <span class=\"comment\">// harpo(2, 4, 5) -&gt; 11</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"beeps = \"</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class=\"line\">    beeps = <span class=\"built_in\">harpo</span>(<span class=\"number\">1</span>, <span class=\"number\">8</span>);   <span class=\"comment\">// harpo(1, 8, 5) -&gt; 14</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"beeps = \"</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class=\"line\">    beeps = <span class=\"built_in\">harpo</span>(<span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>);  <span class=\"comment\">// harpo(8, 7, 6) -&gt; 21</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"beeps = \"</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">harpo</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m, <span class=\"type\">int</span> j)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n + m + j;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"关键点-1\"><a href=\"#关键点-1\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ol>\n<li><strong>规则</strong>:<ul>\n<li>默认参数从右到左设置。</li>\n<li><code>int harpo(int n, int m = 4, int j = 5)</code> 合法。</li>\n<li><code>int chico(int n, int m = 6, int j)</code> 非法。</li>\n</ul>\n</li>\n<li><strong>作用</strong>:<ul>\n<li>省略参数时自动填充默认值。</li>\n<li>减少函数重载需求。</li>\n</ul>\n</li>\n<li><strong>注意</strong>:<ul>\n<li>默认值在声明中指定，<u>不在定义中</u>。</li>\n<li>不能“跳跃”使用参数，如 <code>harpo(1, , 6)</code> 非法。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"改进建议\"><a href=\"#改进建议\" class=\"headerlink\" title=\"改进建议\"></a>改进建议</h4><ul>\n<li>复杂逻辑可考虑函数重载或委托构造函数。</li>\n<li>避免过度使用默认参数以保持代码清晰。</li>\n</ul>\n<hr>\n<h3 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h3><blockquote>\n<p>Inline Functions</p>\n</blockquote>\n<h4 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h4><ul>\n<li><p>内联函数是用 <code>inline</code> 关键字修饰的函数，编译器会尝试将函数调用替换为函数体代码，减少函数调用的开销。</p>\n<blockquote>\n<p>普通函数的调用需要经历: 压栈、传递参数、跳转到函数地址、返回值处理、出栈等步骤, 由此可见内联函数可以有效提升性能.</p>\n</blockquote>\n</li>\n<li><p>适用于小型、频繁调用的函数。</p>\n</li>\n</ul>\n<h4 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 内联函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">5</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Square of \"</span> &lt;&lt; num &lt;&lt; <span class=\"string\">\" is \"</span> &lt;&lt; <span class=\"built_in\">square</span>(num) &lt;&lt; endl;  <span class=\"comment\">// 输出 25</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"关键点-2\"><a href=\"#关键点-2\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ol>\n<li><strong>作用</strong>:<ul>\n<li>减少函数调用开销（如参数传递、栈帧创建）。</li>\n<li>提高执行效率，适合小型函数。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>:<ul>\n<li>函数体短小、调用频繁。</li>\n<li>不适合复杂函数（可能导致代码膨胀）。</li>\n</ul>\n</li>\n<li><strong>注意</strong>:<ul>\n<li><code>inline</code> 是建议，编译器可能忽略（例如函数过大或包含循环）。</li>\n<li>内联函数定义通常放在头文件中，避免链接错误 (在多个源文件被调用的时候, <code>inline</code>的声明可以告诉编译器, 重复的定义是被允许的)</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li><p><strong>Any function you define inside a class declaration is automatically an inline.</strong></p>\n<blockquote>\n<p><code>class</code>内部**<u>定义</u>**的函数自动为 <code>inline</code>类型. 如果是类外定义(相同的<code>.h</code>文件), 那么需要显式声明为内联函数.</p>\n</blockquote>\n</li>\n<li><p>内联函数必须在**<u>头文件</u>**中定义，或者在调用它的同一翻译单元中.</p>\n<blockquote>\n<p>如果定义在 .cpp 文件中，调用点无法看到定义，编译器无法内联，链接器会报错.</p>\n</blockquote>\n</li>\n<li><p>如果决定将类的函数定义写在头文件中, 有以下的两种选择使其成为内联函数;</p>\n<ol>\n<li>直接在声明的地方给出完全的定义;</li>\n<li>在类外声明 <code>inline</code>然后定义.</li>\n</ol>\n</li>\n<li><p><code>inline</code>确实比C语言的 <code>macro</code>更好, 因为内联函数实现了对参数的类型检查.</p>\n</li>\n<li><p>编译器会对声明为 <code>inline</code> 的函数进行检查: 如果包含了递归 或者 代码量较大, 编译器依旧不会将其视为 <code>inline</code> .</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"inline-变量\"><a href=\"#inline-变量\" class=\"headerlink\" title=\"inline 变量\"></a>inline 变量</h3><blockquote>\n<p>[!NOTE]</p>\n<ul>\n<li><p>为静态成员变量声明 <code>inline</code>, 不必在 <code>.cpp</code>中再次声明.</p>\n</li>\n<li><p>用于<strong>在头文件中定义具有外部链接的变量</strong>，避免了重复定义的问题.</p>\n</li>\n</ul>\n</blockquote>\n<p>在 C++ 传统规则中，<strong>全局变量</strong>（或者 namespace 作用域的变量）在头文件中定义会导致多个翻译单元（编译文件）出现<strong>重复定义错误</strong>。在 C++17 之前，通常的做法是：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myheader.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> myVar; <span class=\"comment\">// 声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mysource.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"myheader.h\"</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> myVar = <span class=\"number\">42</span>; <span class=\"comment\">// 定义</span></span><br></pre></td></tr></table></figure></div>\n\n<p>但在 C++17 之后，可以使用 inline 变量，直接在头文件中定义，而不会导致重复定义错误：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myheader.h</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> myVar = <span class=\"number\">42</span>;  <span class=\"comment\">// C++17 及以上</span></span><br></pre></td></tr></table></figure></div>\n\n<p>在任何 <code>#include \"myheader.h</code>“ 的地方，myVar 仍然是<u><strong>同一个变量</strong></u>。</p>\n<blockquote>\n<p>如果希望不同的文件不是一个实例, 需要声明为 静态全局变量.</p>\n</blockquote>\n<p><strong>inline 变量的特点</strong></p>\n<p>​\t1.\t<strong>允许在头文件中定义</strong>，避免 extern 的使用。</p>\n<p>​\t2.\t<strong>所有包含它的翻译单元共享同一个变量</strong>（编译时不会创建多个实例）。</p>\n<p>​\t3.\t<strong>必须初始化</strong>，否则编译器无法确定变量的值。</p>\n<p><strong>示例：多个文件使用 inline 变量</strong></p>\n<p>假设有以下两个源文件，同时包含 myheader.h，但不会引发重复定义错误：</p>\n<p><strong>头文件 myheader.h</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MYHEADER_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MYHEADER_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> globalVar = <span class=\"number\">100</span>; <span class=\"comment\">// inline 变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>源文件 file1.cpp</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"myheader.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"file1.cpp: \"</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>源文件 file2.cpp</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"myheader.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"file2.cpp: \"</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>主程序 main.cpp</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"myheader.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">func1</span>();</span><br><span class=\"line\">    <span class=\"built_in\">func2</span>();</span><br><span class=\"line\">    globalVar += <span class=\"number\">10</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"main.cpp: \"</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>编译 &amp; 运行</strong></p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ file1.cpp file2.cpp main.cpp -o output &amp;&amp; ./output</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>输出示例：</strong></p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file1.cpp: 100</span><br><span class=\"line\">file2.cpp: 100</span><br><span class=\"line\">main.cpp: 110</span><br></pre></td></tr></table></figure></div>\n\n<p>说明：</p>\n<p>​\t•\tglobalVar 是<strong>同一个变量</strong>，而不是多个副本。</p>\n<p>​\t•\tmain.cpp 修改 globalVar 之后，globalVar 在所有翻译单元中都被更新。</p>\n<hr>\n<p><strong>inline 变量 vs constexpr 变量</strong></p>\n<p>​\t•\tinline 变量可以是<strong>可变的</strong>，可以修改其值。</p>\n<p>​\t•\tconstexpr 变量必须是<strong>编译时常量</strong>，不能修改。</p>\n<p>​\t•\tinline constexpr 变量既有 inline 特性，又是编译时常量。</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline constexpr int constantVar = 50; // 不能修改</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"weak\"><a href=\"#weak\" class=\"headerlink\" title=\"weak\"></a>weak</h3><p><code>weak</code>允许不同的编译单元存在同名的函数, 并且在实际调用的时候, 优先调用不是 <code>weak</code>的函数. 从而提供了一种默认的实现.</p>\n<p><code>weak</code>关键字可以用于函数、变量与对象等, 与主要使用于函数的 <code>inline</code>不同.</p>\n<p>如果没有 <code>weak</code>标记, 就是强变量.</p>\n<ul>\n<li>一般的编译器需要使用 <code>__attribute__((weak)) </code> 来声明:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明 weak 变量，提供默认值</span></span><br><span class=\"line\">__attribute__((weak)) <span class=\"type\">int</span> globalValue = <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"globalValue = \"</span> &lt;&lt; globalValue &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h1 id=\"Composition\"><a href=\"#Composition\" class=\"headerlink\" title=\"Composition\"></a>Composition</h1><p>用已有的对象构造新的对象. 称为组合.</p>\n<p>可以用 <code>has-a</code>的关系来描述.</p>\n<h2 id=\"类内对象的初始化\"><a href=\"#类内对象的初始化\" class=\"headerlink\" title=\"类内对象的初始化\"></a>类内对象的初始化</h2><p>假设我们有一个 <code>Person</code> 类，该类内部包含一个 <code>std::vector&lt;std::string&gt;</code> 类型的成员变量，用于存储人的爱好。我们将展示如何在类的构造函数中使用完全初始化和引用初始化来初始化这个成员变量。</p>\n<h3 id=\"1-Fully\"><a href=\"#1-Fully\" class=\"headerlink\" title=\"1. Fully\"></a>1. Fully</h3><p>完全初始化是指在类的构造函数中直接为成员变量赋予初始值。这通常通过成员初始化列表（member initializer list）来完成。</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::vector&lt;std::string&gt; hobbies;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 完全初始化：使用成员初始化列表</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"type\">const</span> std::vector&lt;std::string&gt;&amp; initialHobbies)</span><br><span class=\"line\">        : <span class=\"built_in\">hobbies</span>(initialHobbies) { }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>解释</strong></p>\n<ul>\n<li><strong>成员变量初始化</strong>：在 <code>Person</code> 类的构造函数中，我们使用成员初始化列表 <code>: hobbies(initialHobbies)</code> 来完全初始化 <code>hobbies</code> 成员变量。这意味着 <code>person1.hobbies</code> 将拥有 <code>initialHobbies</code> 的一个拷贝。</li>\n<li><strong>独立性</strong>：<code>person1.hobbies</code> 是 <code>initialHobbies</code> 的一个独立拷贝，修改 <code>person1.hobbies</code> 不会影响 <code>initialHobbies</code>，反之亦然。</li>\n</ul>\n<h3 id=\"2-Reference\"><a href=\"#2-Reference\" class=\"headerlink\" title=\"2. Reference\"></a>2. Reference</h3><p>引用初始化是指将类内部的成员变量声明为引用类型，并在构造函数中将其绑定到另一个对象。这意味着类内的引用将直接指向外部对象，而不是持有其拷贝。</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::vector&lt;std::string&gt;&amp; hobbiesRef;  <span class=\"comment\">// 引用类型的成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 引用初始化：使用成员初始化列表绑定到外部对象</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(std::vector&lt;std::string&gt;&amp; externalHobbies)</span><br><span class=\"line\">        : <span class=\"built_in\">hobbiesRef</span>(externalHobbies) { }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>解释</strong></p>\n<ul>\n<li><strong>成员变量声明</strong>：<code>std::vector&lt;std::string&gt;&amp; hobbiesRef;</code> 声明了一个引用类型的成员变量 <code>hobbiesRef</code>，它将引用外部的 <code>std::vector&lt;std::string&gt;</code> 对象。</li>\n<li><strong>引用绑定</strong>：在构造函数中，通过 <code>: hobbiesRef(externalHobbies)</code> 将 <code>hobbiesRef</code> 绑定到传入的 <code>externalHobbies</code> 对象。这意味着 <code>person2.hobbiesRef</code> 和 <code>sharedHobbies</code> 指向同一个内存位置。</li>\n<li><strong>共享数据</strong>：对 <code>person2.hobbiesRef</code> 的修改（如添加新爱好）会直接影响到 <code>sharedHobbies</code>，因为它们共享相同的数据。</li>\n</ul>\n<h3 id=\"3-对比\"><a href=\"#3-对比\" class=\"headerlink\" title=\"3. 对比\"></a>3. 对比</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>完全初始化</th>\n<th>引用初始化</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>存储方式</strong></td>\n<td>存储外部对象的拷贝</td>\n<td>存储对外部对象的引用</td>\n</tr>\n<tr>\n<td><strong>内存使用</strong></td>\n<td>额外占用内存用于拷贝</td>\n<td>不占用额外内存，直接引用外部对象</td>\n</tr>\n<tr>\n<td><strong>数据独立性</strong></td>\n<td>修改类内成员不会影响外部对象</td>\n<td>修改类内成员会影响外部对象</td>\n</tr>\n<tr>\n<td><strong>生命周期依赖</strong></td>\n<td>类内成员独立于外部对象的生命周期</td>\n<td>类内引用的生命周期必须至少与外部对象相同</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>需要独立副本时使用</td>\n<td>需要与外部对象共享数据时使用, 初始情况下不知道容量</td>\n</tr>\n</tbody></table>\n<h4 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ul>\n<li><p><strong>引用必须在构造时初始化</strong>：引用类型的成员变量必须在构造函数的初始化列表中绑定到一个对象，不能在构造函数体内赋值。</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>因为引用类型的对象必须在初始化的时候绑定, 并且只能绑定一次.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误示例：试图在构造函数体内赋值给引用</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::vector&lt;std::string&gt;&amp; hobbiesRef;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(std::vector&lt;std::string&gt;&amp; externalHobbies) {</span><br><span class=\"line\">        hobbiesRef = externalHobbies; <span class=\"comment\">// 错误：引用必须在初始化时绑定</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><strong>生命周期管理</strong>：使用引用初始化时，必须确保被引用的对象在使用期间是有效的。如果引用的对象被销毁，引用将变为悬空引用，导致未定义行为。</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 危险示例：悬空引用</span></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;std::string&gt; <span class=\"title\">createHobbies</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp = {<span class=\"string\">\"Temporary\"</span>};</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person</span><span class=\"params\">(temp)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp; <span class=\"comment\">// temp 被销毁，person.hobbiesRef 悬空</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>为了避免这种情况，通常可以使用智能指针（如 <code>std::shared_ptr</code> 或 <code>std::unique_ptr</code>）来管理对象的生命周期，或者确保引用的对象在使用期间一直有效。</p>\n</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li><p>如果使用 完全初始化 的方式, 类内必须包含另一个类的完整定义(引用头文件);</p>\n</li>\n<li><p>如果是引用初始化, 可以直接在这个类的内部预先声明另一个类的存在即可.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>; <span class=\"comment\">// 前向声明</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>{</span><br><span class=\"line\">  A* ptr;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"Embedded-objects\"><a href=\"#Embedded-objects\" class=\"headerlink\" title=\"Embedded objects\"></a>Embedded objects</h2><blockquote>\n<p>[!NOTE]</p>\n<ul>\n<li>对于嵌入对象，如果不用初始化列表，就必须有默认构造函数。</li>\n</ul>\n</blockquote>\n<h2 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h2><h3 id=\"命名空间的别名\"><a href=\"#命名空间的别名\" class=\"headerlink\" title=\"命名空间的别名\"></a>命名空间的别名</h3><p>如果 <code>namespace</code>过长, 可以将其重新赋值并使用:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> supercalifragilistic {</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"type\">short</span> = supercalifragilistic;</span><br><span class=\"line\"><span class=\"type\">short</span>::<span class=\"built_in\">f</span>();</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"selection\"><a href=\"#selection\" class=\"headerlink\" title=\"selection\"></a>selection</h3><p>除了直接在一个命名空间内部嵌套其他, 我们也可以在一个命名空间里选择性地使用其他空间的部分函数:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> mine｛</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> orig::Cat;\t <span class=\"comment\">// use Cat class from origvoid ×O）；</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">x</span><span class=\"params\">()</span>；</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"type\">void</span> <span class=\"title\">y</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li><strong>Multiple namespace declarations add to the same namespace.</strong><br>也即是说, 多个 <code>.h</code>文件内相同的命名空间会自动的视作一个.</li>\n</ol>\n</blockquote>\n<h1 id=\"Inheritance\"><a href=\"#Inheritance\" class=\"headerlink\" title=\"Inheritance\"></a>Inheritance</h1><blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li>继承的对象都具有基类的属性, 但是不一定具有访问的权限.<br>也就是 <strong>Think of inherited traits as an embedded object</strong></li>\n<li>派生类的构造函数中的初始化列表应当包含基类的构造函数.</li>\n<li>由于基类的私有成员无法被子类直接访问, 需要让子类调用基类的public的函数, 从而间接访问.</li>\n<li>如果子类和父类含有同名的变量, 将会同时存在, 并且可以在子类中声明 <code>parent_class:A</code>来访问父类中的属性A.</li>\n<li>子类中一定有部分是父类的对象, 并且处于子类的开头(父类必须首先完成初始化).</li>\n</ol>\n</blockquote>\n<h4 id=\"初始化列表的常用场景\"><a href=\"#初始化列表的常用场景\" class=\"headerlink\" title=\"初始化列表的常用场景\"></a>初始化列表的常用场景</h4><ol>\n<li><p>调用基类的构造函数 (否则调用默认构造函数)</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> data) { <span class=\"comment\">/* ... */</span> }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> baseVal) : <span class=\"built_in\">Base</span>(baseVal) { }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>初始化嵌入类</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Member</span>(<span class=\"type\">const</span> std::string&amp; str) { <span class=\"comment\">/* ... */</span> }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Container</span> {</span><br><span class=\"line\">    Member memberObj;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Container</span>(<span class=\"type\">const</span> std::string&amp; s) : <span class=\"built_in\">memberObj</span>(s) { }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>需要注意的是, 此处的初始化列表中的嵌入类的构造, 变量名不是类名.</p>\n<p>如果嵌入类不存在默认的构造函数, 那么初始化列表中的显式构造是必要的.</p>\n</blockquote>\n</li>\n<li><p>初始化常量成员:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> constMember;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">constMember</span>(val) { }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>const 成员一旦定义，必须立即初始化，且<strong>只能</strong>在初始化列表中完成，不能在构造函数体内赋值。</p>\n</blockquote>\n</li>\n<li><p>初始化引用成员</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span>&amp; refMember;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span>&amp; ref) : <span class=\"built_in\">refMember</span>(ref) { }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>引用成员（如 int&amp; ref）必须在初始化时绑定对象，<strong>不能在构造函数体内赋值</strong>，因此也必须使用初始化列表。</p>\n</blockquote>\n</li>\n</ol>\n<p>继承: 基于已有的类来设计新的类，新的类的对象可以被当作已有类的对象.</p>\n<p>相比于 <em>composition</em>  的 <code>has-a</code>关系, 继承是 <code>is-a</code>的关系.</p>\n<p>同义词:</p>\n<ul>\n<li>父类、超类、基类</li>\n<li>派生类、子类</li>\n</ul>\n<p>控制基类成员在派生类中的可见性：</p>\n<ul>\n<li><code>public</code>：基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>，<code>protected</code> 成员仍然是 <code>protected</code>。</li>\n<li><code>protected</code>：基类的 <code>public</code> 和 <code>protected</code>成员在派生类中都变为 <code>protected</code>。</li>\n<li><code>private</code>：基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>此时, 仍旧可以通过子类的方法来访问基类的属性或者方法, 但是无法通过子类直接访问基类~!</p>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">baseFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Base function called.\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">private</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">derivedFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"built_in\">baseFunction</span>(); <span class=\"comment\">// 在子类内部可以访问基类的成员函数</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    d.<span class=\"built_in\">baseFunction</span>();    <span class=\"comment\">// 错误：无法从子类外部访问基类的成员函数</span></span><br><span class=\"line\">    d.<span class=\"built_in\">derivedFunction</span>(); <span class=\"comment\">// 可以调用子类的函数，该函数内部调用了基类的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></blockquote>\n<p>clint class 表示这个类要使用另一个类(中的public).</p>\n<p>子类的对象也可以认为是父类的对象。子类不能访问父类的私有变量，但私有变量存在于这个类中</p>\n<p>当调用构造函数时，我们不能调用父类的私有变量，只能用初始化列表的方式调用父类的构造函数。</p>\n<p>赋值的运算符不会被继承:</p>\n<h4 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h4><p>赋值运算符是这样形式的方法:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point &amp;<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Point &amp;other)</span><br><span class=\"line\">{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Point::operator= 被调用\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        x = other.x;</span><br><span class=\"line\">        y = other.y;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>当我们如此赋值的时候就会发生上述的调用:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Point <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Point <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">p1 = p2;</span><br></pre></td></tr></table></figure></div>\n\n<p>可见, 赋值运算符通过引用快速地将右值中的属性赋值给左侧的目标.</p>\n<p>但是父类的赋值运算符只会确保自身的属性能够被赋值, 无法确保子类自身的属性可以被正确设置. 因此, 为了安全性, CPP不允许子类自动继承父类的赋值运算符.</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>然而, 编译器可能为子类自动生成一个赋值运算符.</p>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>, <span class=\"type\">int</span> y = <span class=\"number\">0</span>) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义赋值运算符</span></span><br><span class=\"line\">    Point &amp;<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Point &amp;other)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Point::operator= 被调用\"</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            x = other.x;</span><br><span class=\"line\">            y = other.y;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ColoredPoint</span> : <span class=\"keyword\">public</span> Point</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    string color;</span><br><span class=\"line\">    <span class=\"built_in\">ColoredPoint</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>, <span class=\"type\">int</span> y = <span class=\"number\">0</span>, string color = <span class=\"string\">\"white\"</span>) : <span class=\"built_in\">Point</span>(x, y), <span class=\"built_in\">color</span>(color) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"x:\"</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\", y:\"</span> &lt;&lt; y &lt;&lt; <span class=\"string\">\", color:\"</span> &lt;&lt; color &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"function\">ColoredPoint <span class=\"title\">cp1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">\"red\"</span>)</span></span>;</span><br><span class=\"line\">    cp<span class=\"number\">1.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    <span class=\"function\">ColoredPoint <span class=\"title\">cp2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">\"blue\"</span>)</span></span>;</span><br><span class=\"line\">    cp<span class=\"number\">2.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    cp1 = cp2;</span><br><span class=\"line\">    cp<span class=\"number\">1.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>输出结果</strong>:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:<span class=\"number\">1</span>, y:<span class=\"number\">2</span>, color:red</span><br><span class=\"line\">x:<span class=\"number\">3</span>, y:<span class=\"number\">4</span>, color:blue</span><br><span class=\"line\">Point::<span class=\"keyword\">operator</span>= 被调用</span><br><span class=\"line\">x:<span class=\"number\">3</span>, y:<span class=\"number\">4</span>, color:blue</span><br></pre></td></tr></table></figure></div>\n\n<p>可见, 父类的赋值运算符也被自动地调用了, 这是因为编译器为子类自动生成了一份.</p>\n</blockquote>\n<hr>\n<p>父类的构造是在子类的构造之前。</p>\n<h3 id=\"using声明\"><a href=\"#using声明\" class=\"headerlink\" title=\"using声明\"></a><code>using</code>声明</h3><h4 id=\"将基类的函数派生使用\"><a href=\"#将基类的函数派生使用\" class=\"headerlink\" title=\"将基类的函数派生使用\"></a>将基类的函数派生使用</h4><p>必须使用 <code>using &lt;parentClass&gt;:: func</code>的方式, 无法忽略 <code>using</code>.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span>{</span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">double</span>)</span></span>{</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">\"double\\n\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : Base{</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  \t<span class=\"keyword\">using</span> Base::f; <span class=\"comment\">// 将基类中的私有函数本地使用</span></span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>{</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">\"int\\n\"</span>&lt;&lt;endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    d.<span class=\"built_in\">f</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    d.<span class=\"built_in\">f</span>(<span class=\"number\">4.5</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p><strong>Output:</strong></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"默认参数值无法通过重载传递\"><a href=\"#默认参数值无法通过重载传递\" class=\"headerlink\" title=\"默认参数值无法通过重载传递\"></a>默认参数值无法通过重载传递</h4><p>在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免<strong>多重继承时参数值产生冲突或二义性</strong>。默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.</p>\n<blockquote>\n<p>如果你在派生类中<strong>重新声明或重载了基类的函数</strong>，那么你不能获得默认参数值，必须通过多个重载模拟默认参数功能.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> a = <span class=\"number\">3</span>, <span class=\"type\">double</span> b = <span class=\"number\">2.0</span>)</span></span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> A::f;         <span class=\"comment\">// ✅ 此时默认参数仍可见</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> a)</span></span>;      <span class=\"comment\">// ❌ 重载后，这个版本没有默认参数</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n\n\n<blockquote>\n<p>但是使用 <code>using</code>声明的父类函数可以获得默认参数值.</p>\n</blockquote>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> a = <span class=\"number\">3</span>, <span class=\"type\">double</span> b = <span class=\"number\">2.0</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"A::f(\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> A::f; <span class=\"comment\">// 继承 A::f 到 B 中</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    B b;</span><br><span class=\"line\">    b.<span class=\"built_in\">f</span>();        <span class=\"comment\">// ✅ 是否等价于 f(3, 2.0)？</span></span><br><span class=\"line\">    b.<span class=\"built_in\">f</span>(<span class=\"number\">10</span>);      <span class=\"comment\">// ✅ 是否等价于 f(10, 2.0)？</span></span><br><span class=\"line\">    b.<span class=\"built_in\">f</span>(<span class=\"number\">10</span>, <span class=\"number\">5.5</span>); <span class=\"comment\">// ✅ 正常调用</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><p>输出:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::<span class=\"built_in\">f</span>(<span class=\"number\">3</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">A::<span class=\"built_in\">f</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">A::<span class=\"built_in\">f</span>(<span class=\"number\">10</span>, <span class=\"number\">5.5</span>)</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h4 id=\"解决重写函数的重载问题\"><a href=\"#解决重写函数的重载问题\" class=\"headerlink\" title=\"解决重写函数的重载问题\"></a>解决重写函数的重载问题</h4><p>子类重新定义 (<code>override</code>重写) 了父类的某个函数，就会把父类中对应 <code>overloaded</code> 的函数覆盖:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 基类中的重载函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Base display(int): \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">double</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Base display(double): \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 子类重新定义了基类的 display(int)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Derived display(int): \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::display;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    d.<span class=\"built_in\">display</span>(<span class=\"number\">5</span>); <span class=\"comment\">// 调用 Derived 的 display(int)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    d.Base::<span class=\"built_in\">display</span>(<span class=\"number\">5.5</span>); <span class=\"comment\">// 或者d.display(5.5);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ul>\n<li><p>注意, CPP中的浮点数可以隐式转换为整型.</p>\n<ul>\n<li>当将一个浮点数赋值给一个整型变量时，编译器会执行<strong>隐式转换</strong>，将浮点数的值转换为整型。这种转换通常涉及<strong>截断</strong>（truncation），即去掉小数部分，只保留整数部分.</li>\n</ul>\n</li>\n<li><p>可以通过 <code>using </code>声明重新引入基类中的重载函数: </p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Base::display;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Polymorphism\"><a href=\"#Polymorphism\" class=\"headerlink\" title=\"Polymorphism\"></a>Polymorphism</h1><h4 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h4><ol>\n<li><p>成员函数（无论是虚函数还是非虚函数）本身不占用类对象的内存空间，因为它们的代码存储在程序的代码段中。只有<strong>成员变量和虚表指针</strong>（如果有虚函数）会占用对象的内存空间:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<p>此时的 <code>sizeof(A)</code>为4字节.</p>\n</li>\n<li><p>虚函数指针的大小一般是 <u>8字节</u>. 如果结构体内部存在虚函数指针, 就需要对齐为8字节的倍数.</p>\n</li>\n<li><p>因为子类的构造在父类的构造之后, 也就是每一个子类对象的前部分都是父类对象. 因此, 我们可以将一个子类对象的指针赋值给父类对象, 只要忽视后续数据结构即可.</p>\n</li>\n<li><p><u>多态变量</u>: 指向子类对象的基类指针/引用.</p>\n</li>\n<li><p>如果类内不存在任何成员变量, 它的对象依旧占用 <code>1</code> 个字节的空间.</p>\n</li>\n<li><p>如果一个类将来可能具有子类, 就让其析构函数设置为 <code>virtual</code>. —— 任何的类都应该设置它的析构为 <code>virtual</code>.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>: <span class=\"keyword\">public</span> A{};</span><br><span class=\"line\"></span><br><span class=\"line\">A* p = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>();</span><br><span class=\"line\"><span class=\"keyword\">delete</span> p;</span><br></pre></td></tr></table></figure></div>\n\n<p>如果 A 的析构函数不是virtual的, 那么编译器只会调用A的析构函数.</p>\n</li>\n<li><p>如果父类的构造函数中调用了 <code>virtual</code> 的函数, 那么实际上还是调用自己的函数(静态绑定)</p>\n<ol>\n<li>这是因为, 创建一个派生类的对象时, 首先调用父类的构造函数, 然后执行派生类的构造函数;</li>\n<li>此时, 子类的成员还没有初始化, 父类无法调用其重写版本, 也就无法实现多态.</li>\n</ol>\n</li>\n<li><blockquote>\n<p>[!NOTE]</p>\n<p>深刻理解什么叫做多态! 也就是子类对象的引用或者指针赋值给了父类! 此后调用这个对象时, 虚函数是动态绑定到子类的!</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A &amp;ra = b;    <span class=\"comment\">// ra是A类型的引用，但指向B类型的对象</span></span><br><span class=\"line\">ra.<span class=\"built_in\">f</span>();       <span class=\"comment\">// 虽然ra是A类型的引用，但f()会调用B::f()</span></span><br></pre></td></tr></table></figure></div></blockquote>\n</li>\n<li><p>如果B是A的子类:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(<span class=\"number\">3</span>);    <span class=\"comment\">// p1是A类型的指针，但指向B类型的对象</span></span><br></pre></td></tr></table></figure></div>\n\n<p>实际上,  p1指向的对象是B类的对象</p>\n</li>\n</ol>\n<p>当一个被重写的函数在 Derived::func() 中通过 Base::func() 调用其基类版本时，会发生什么？</p>\n<ul>\n<li><p>可以正常调用, 这也正是重写存在的意义——扩充原来的功能, 同时保留.</p>\n</li>\n<li><p>多态与返回对象类型:</p>\n<ul>\n<li><p>允许重载返回自身的 <u>指针</u> 与 <u>引用</u>, 但是不支持直接返回自身的类型:</p>\n</li>\n<li><p>i.e. </p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Expr｛</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> Expr* newExpr （）；</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> Expr&amp; clone （）；</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> Expr Expr self（）；</span><br><span class=\"line\">｝；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BinaryExpr</span> ： <span class=\"keyword\">public</span> Expr ｛</span><br><span class=\"line\"><span class=\"keyword\">public</span>：</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> BinaryExpr* newExpr （）； <span class=\"comment\">//Ok</span></span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> BinaryExpr&amp; clone （）； <span class=\"comment\">// Ok</span></span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> BinaryExpr self（）；<span class=\"comment\">// Error！</span></span><br><span class=\"line\">  ｝；</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>原因: 指针和引用的大小固定, 编译时刻可以确定调用时候所需的空间, 如果按照类型返回, 由于多态的动态绑定是运行时决定调用对应的方法, 所以编译的时候caller不知道要在栈上预留多少的空间.</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>Polymorphism<ul>\n<li>virtual functions and override</li>\n<li>abstract functions and classes</li>\n</ul>\n</li>\n<li>Multiple Inheritance</li>\n</ul>\n<p>由于子类具有父类的所有属性, 因此我们可以将一个子类对象看作父类的对象, 并进行对应的操作.</p>\n<p>将子类对象看作父类对象的操作, 叫做 <u>upcast</u>. 具体是说, 将子类的指针或者引用赋值给基类的对象.</p>\n<p>现在的问题是, 如果采取传统的继承+重写的方式, 我们在子类内部采取重写父类方法, 可能导致 <code>静态绑定</code> static binding:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Animal speaks\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Dog barks\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Animal *animal = <span class=\"keyword\">new</span> <span class=\"built_in\">Dog</span>(); <span class=\"comment\">// 注意：父类指针指向子类对象</span></span><br><span class=\"line\">    animal-&gt;<span class=\"built_in\">speak</span>();            <span class=\"comment\">// 会调用哪个？</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> animal;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><p>输出:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal speaks</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<p>为了解决上述的问题, 我们引入 <u>虚函数</u> 的概念.</p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>虚函数可以实现 <strong>运行时多态</strong>. 所谓多态, 就是静态+ 动态的绑定.</p>\n<p>通过在父类的函数前加上 <code>virtual</code>的声明, 我们将其定义为虚函数</p>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Animal speaks\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Dog barks\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    Animal* animal = <span class=\"keyword\">new</span> <span class=\"built_in\">Dog</span>(); </span><br><span class=\"line\">    animal-&gt;<span class=\"built_in\">speak</span>(); <span class=\"comment\">// 这次会调用哪个？</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> animal;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><p>输出:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog barks</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<blockquote>\n<ul>\n<li><code>override</code>声明明确这个函数是重写父类的虚函数, 可以让编译器检查是否存在错误.</li>\n<li>但是上述的关键字也不是必须的.</li>\n</ul>\n</blockquote>\n<h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p>~指的是需要强制派生类去实现的函数:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">virtual</span> 返回类型 函数名(...) = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"虚函数表\"><a href=\"#虚函数表\" class=\"headerlink\" title=\"虚函数表\"></a>虚函数表</h3><ul>\n<li>定义: 虚函数表（virtual table）是 C++ 为了实现<strong>运行时多态</strong>而采用的一种底层技术手段;</li>\n<li>本质:<ul>\n<li><code>vtable</code>是一个函数指针数组;</li>\n<li>每个类都有自己的vtable</li>\n<li>对象中存在一个隐藏的指针 <code>vptr</code>, 指向该类的vtable</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"内存示意图\"><a href=\"#内存示意图\" class=\"headerlink\" title=\"内存示意图\"></a>内存示意图</h4><p>假设有如下结构:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<p>内存布局的伪结构如下:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| vptr  → 指向vtable     |  ←隐藏成员</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| a : <span class=\"type\">int</span>                |  ←显式成员</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vtable</span> (Base):</span><br><span class=\"line\">[ func 的地址 ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vtable</span> (Derived):</span><br><span class=\"line\">[ 重写的 func 的地址 ]</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"拓展说明\"><a href=\"#拓展说明\" class=\"headerlink\" title=\"拓展说明\"></a>拓展说明</h4><ul>\n<li>vtable是类级别的, 所有该类的对象共享一个vtable;</li>\n<li>vptr是对象级别的, 隐含于各个对象当中.</li>\n<li>如果类没有虚函数, 就不存在上述的~</li>\n</ul>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>如果一个类中包含至少一个纯虚函数, 那么这个类就是一个抽象类.</p>\n<p>抽象类无法被实例化, <strong>只能用来作为基类.</strong></p>\n<h3 id=\"使用抽象类定义接口\"><a href=\"#使用抽象类定义接口\" class=\"headerlink\" title=\"使用抽象类定义接口\"></a>使用抽象类定义接口</h3><p>用图形绘制的例子来说明抽象类和纯虚函数的使用:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 纯虚函数，子类必须实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类：Circle</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> : <span class=\"keyword\">public</span> Shape {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Drawing Circle\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类：Rectangle</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> : <span class=\"keyword\">public</span> Shape {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Drawing Rectangle\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 渲染函数：面向抽象类编程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">render</span><span class=\"params\">(Shape* shape)</span> </span>{</span><br><span class=\"line\">    shape-&gt;<span class=\"built_in\">draw</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    Circle c;</span><br><span class=\"line\">    Rectangle r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">render</span>(&amp;c); <span class=\"comment\">// Drawing Circle</span></span><br><span class=\"line\">    <span class=\"built_in\">render</span>(&amp;r); <span class=\"comment\">// Drawing Rectangle</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"继承链\"><a href=\"#继承链\" class=\"headerlink\" title=\"继承链\"></a>继承链</h3><p>一个抽象类可以有多个纯虚函数, 此时继承的子类可能没有完全实现. </p>\n<p>子类的子类, 也就是在继承链上完成了所有纯虚函数的定义的 最末一级的派生类, 才可以被实例化.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">breathe</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Breathing...\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h2 id=\"虚析构函数\"><a href=\"#虚析构函数\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h2><p><strong>virtual destructor</strong>: 虚析构函数</p>\n<p>同样的, 虚析构函数的作用体现在 <code>upcast</code>, 也就是将子类的指针或引用转换为父类的指针或引用的过程. 此时, 如果父类的析构函数不是虚函数, 就会让向上转型之后的对象在析构时调用父类的析构函数.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Base</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Base Destructor\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Derived</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Derived Destructor\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Base *obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> obj; <span class=\"comment\">// 注意这里！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>此时会输出 :  <code>Base Destructor</code> , 也就是调用了父类的析构函数.</p>\n<p>这是十分危险的, 特别是我们需要确保子类的所有资源都被安全地释放.</p>\n<p>因此, 我们可以将父类的析构函数也设置为虚函数:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Base</span>() {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Base Destructor\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Derived</span>() {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Derived Destructor\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<p>此时的输出:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Derived Destructor  </span><br><span class=\"line\">Base Destructor</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>先后调用子类和父类的析构函数.</p>\n</blockquote>\n<h2 id=\"接口类\"><a href=\"#接口类\" class=\"headerlink\" title=\"接口类\"></a>接口类</h2><blockquote>\n<p>也被称为 <u>协议类</u>. 其实就像 <code>swift</code>的协议一样, 强制要求继承的子类定义某些函数实现.</p>\n</blockquote>\n<ul>\n<li>含义:<ul>\n<li>只定义接口, 不提供实现的抽象类</li>\n<li>所有的成员函数都是纯虚函数;</li>\n<li>一般不包含任何数据成员.</li>\n</ul>\n</li>\n</ul>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Printable</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Printable</span>() = <span class=\"keyword\">default</span>; <span class=\"comment\">// 记得虚析构函数</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> : <span class=\"keyword\">public</span> Printable {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Printing Document\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><p>多重继承 <em>multiple inheritance</em> 指的是一个类继承自多个基类.</p>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sayA</span><span class=\"params\">()</span> </span>{ cout &lt;&lt; <span class=\"string\">\"I am A\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sayB</span><span class=\"params\">()</span> </span>{ cout &lt;&lt; <span class=\"string\">\"I am B\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">public</span> A, <span class=\"keyword\">public</span> B {</span><br><span class=\"line\">    <span class=\"comment\">// 继承了 A 和 B 的成员</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<p>可以将多个类的功能整合到一个类中:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C c;</span><br><span class=\"line\">c.<span class=\"built_in\">sayA</span>(); <span class=\"comment\">// OK</span></span><br><span class=\"line\">c.<span class=\"built_in\">sayB</span>(); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"菱形继承\"><a href=\"#菱形继承\" class=\"headerlink\" title=\"菱形继承\"></a>菱形继承</h3><p>多重继承中的特例:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A {};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">public</span> A {};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C {};</span><br></pre></td></tr></table></figure></div>\n\n<p>继承结构看上去就像菱形:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   A</span><br><span class=\"line\"> /   \\</span><br><span class=\"line\">B     C</span><br><span class=\"line\"> \\   /</span><br><span class=\"line\">   D</span><br></pre></td></tr></table></figure></div>\n\n<p>如果我们直接使用D类:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D d;</span><br><span class=\"line\">d.value = <span class=\"number\">10</span>; <span class=\"comment\">// ❌ 编译错误：'value' is ambiguous</span></span><br></pre></td></tr></table></figure></div>\n\n<p>这是因为D继承自B和C, 而后者又各自具有自己的A子对象. 导致了二义性的问题.</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>注意此处的二义性的问题, 来自于在D类对象中直接访问A类对象的成员变量!  什么时候产生二义性? 就是判断此时是否存在多个相同名称的变量.</p>\n</blockquote>\n<h3 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h3><p>C++ 提供了一个机制：<strong>虚继承（virtual inheritance）</strong>，来解决上述问题:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> A{};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> B{};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> :  <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C{}</span><br></pre></td></tr></table></figure></div>\n\n<p>此时, D中只有一个共享的A子对象.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ptr</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"value: \"</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> A {};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> A {};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C {};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    D d;</span><br><span class=\"line\">    d.value = <span class=\"number\">10</span>; <span class=\"comment\">// ✅ OK，只有一个 A，二义性消除</span></span><br><span class=\"line\">    d.<span class=\"built_in\">ptr</span>();</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>此时, B,C不再具有自己的A.</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>由于虚继承带来的是“共享”的基类对象，所以：</p>\n<ul>\n<li>虚基类的构造 <strong>必须由最底层派生类负责</strong></li>\n<li>派生类的构造函数中要<strong>显式初始化</strong>虚基类</li>\n</ul>\n</blockquote>\n<h1 id=\"Copy-and-Move\"><a href=\"#Copy-and-Move\" class=\"headerlink\" title=\"Copy and Move\"></a>Copy and Move</h1><h4 id=\"补充-1\"><a href=\"#补充-1\" class=\"headerlink\" title=\"补充\"></a>补充</h4><ul>\n<li><p><code>vptr</code>只会初始化一次, 然后保持不变. 发生在构造函数的第一步.</p>\n</li>\n<li><p>循环内部执行构造和析构时, 作用的地址是同一块. 此时将对象的地址传入到vector of <code>*</code> 时, 得到的是相同的地址;</p>\n<ul>\n<li>为了避免上述的情况, 我们在循环内部的构造, 需要为对象直接 <code>new</code> 一个新的空间.</li>\n</ul>\n</li>\n<li><p><code>std::move</code>的作用就是告诉编译器: 这个类型是右值引用, 需要使用移动语义.</p>\n</li>\n</ul>\n<h2 id=\"C-中的拷贝构造与移动语义\"><a href=\"#C-中的拷贝构造与移动语义\" class=\"headerlink\" title=\"C++中的拷贝构造与移动语义\"></a>C++中的拷贝构造与移动语义</h2><h3 id=\"拷贝构造函数基础\"><a href=\"#拷贝构造函数基础\" class=\"headerlink\" title=\"拷贝构造函数基础\"></a>拷贝构造函数基础</h3><p>拷贝构造函数是创建新对象的一种方式，它从现有对象复制数据来初始化新对象。</p>\n<ul>\n<li>拷贝构造函数的签名：<code>T::T(const T&amp;)</code></li>\n<li>如果不提供拷贝构造函数，C++会自动生成一个默认的拷贝构造函数</li>\n<li>默认拷贝构造函数执行的是成员级别的拷贝（memberwise copy），而非位级别的拷贝（bitwise copy）<ul>\n<li>对于基本类型成员，直接复制值</li>\n<li>对于对象类型成员，调用其拷贝构造函数</li>\n<li><strong><u>对于指针类型成员</u></strong>，只复制指针值（浅拷贝），导致两个对象共享同一块内存</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"拷贝构造函数的调用时机\"><a href=\"#拷贝构造函数的调用时机\" class=\"headerlink\" title=\"拷贝构造函数的调用时机\"></a>拷贝构造函数的调用时机</h3><p>拷贝构造函数在以下情况下会被调用：</p>\n<ol>\n<li><p><strong>按值传递参数时</strong>：当对象作为参数按值传递给函数时</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(MyClass obj)</span></span>; <span class=\"comment\">// 调用时会触发拷贝构造</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><strong>对象初始化时</strong>：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass a;</span><br><span class=\"line\">MyClass b = a;    <span class=\"comment\">// 初始化，调用拷贝构造函数</span></span><br><span class=\"line\"><span class=\"function\">MyClass <span class=\"title\">c</span><span class=\"params\">(a)</span></span>;     <span class=\"comment\">// 初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><strong>函数返回对象时</strong>：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MyClass <span class=\"title\">func</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    MyClass obj;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;   <span class=\"comment\">// 可能触发拷贝构造（取决于编译器优化）</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n</ol>\n<h3 id=\"拷贝构造函数的最佳实践\"><a href=\"#拷贝构造函数的最佳实践\" class=\"headerlink\" title=\"拷贝构造函数的最佳实践\"></a>拷贝构造函数的最佳实践</h3><ul>\n<li>显式定义拷贝构造函数，不要依赖默认版本</li>\n<li>如果类不需要被复制，可以声明私有的拷贝构造函数（不需要定义）</li>\n<li>如果类包含指针成员，必须实现<u>深拷贝</u>的拷贝构造函数</li>\n</ul>\n<h4 id=\"深拷贝构造函数\"><a href=\"#深拷贝构造函数\" class=\"headerlink\" title=\"深拷贝构造函数\"></a>深拷贝构造函数</h4><p>将拷贝的值另外寻找新的内存空间, 而不是指向同一处地址.</p>\n<ul>\n<li>如果没有显式定义深拷贝构造函数, 观察下面的代码:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">StringHolder <span class=\"title\">original</span><span class=\"params\">(<span class=\"string\">\"Hello World\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">{</span><br><span class=\"line\">    StringHolder copy = original; <span class=\"comment\">// 调用拷贝构造函数</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"copy包含: \"</span> &lt;&lt; copy.<span class=\"built_in\">getString</span>() &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 修改copy，如果是浅拷贝，也会影响original</span></span><br><span class=\"line\">    copy.<span class=\"built_in\">setString</span>(<span class=\"string\">\"Modified\"</span>);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"修改后，copy包含: \"</span> &lt;&lt; copy.<span class=\"built_in\">getString</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"修改后，original包含: \"</span> &lt;&lt; original.<span class=\"built_in\">getString</span>() &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// copy在此作用域结束时被销毁</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ul>\n<li><p><code>original</code>的层级在  <code>copy</code> 的外面;</p>\n</li>\n<li><p>在代码块的内部, 通过浅拷贝构造, 两者的数据共享一个内存空间;</p>\n</li>\n<li><p>二者先后析构, 导致 <code>double free</code>的问题!</p>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: Double free of object 0x11f6060c0</span><br><span class=\"line\">02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: *** <span class=\"built_in\">set</span> a breakpoint <span class=\"keyword\">in</span> malloc_error_break to debug</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</blockquote>\n<p>由此, 我们需要如此定义:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">StringHolder</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span> *data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">StringHolder</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> *str)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, str);</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">\"构造函数: 为\\\"\"</span> &lt;&lt; data &lt;&lt; <span class=\"string\">\"\\\"分配内存\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        {</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">\"构造函数: 创建空字符串\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义拷贝构造函数（深拷贝）</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果复制掉这部分的自定义, 将会调用默认的浅拷贝构造函数, 导致问题:浅拷贝的指针两次释放内存</span></span><br><span class=\"line\">    <span class=\"built_in\">StringHolder</span>(<span class=\"type\">const</span> StringHolder &amp;other)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">\"深拷贝构造函数: 为\\\"\"</span> &lt;&lt; data &lt;&lt; <span class=\"string\">\"\\\"分配新内存\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        {</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">\"深拷贝构造函数: 复制空字符串\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">StringHolder</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"析构函数: 释放\\\"\"</span> &lt;&lt; (data ? data : <span class=\"string\">\"nullptr\"</span>) &lt;&lt; <span class=\"string\">\"\\\"的内存\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>这样就可以避免上面的问题.</p>\n<h3 id=\"函数参数和返回值的选择\"><a href=\"#函数参数和返回值的选择\" class=\"headerlink\" title=\"函数参数和返回值的选择\"></a>函数参数和返回值的选择</h3><ul>\n<li><p><strong>传入参数</strong>：</p>\n<ul>\n<li>按值传递：<code>void func(Student s)</code> - 创建新对象，适用于需要存储对象的情况<ul>\n<li>如果对象内部的属性存在指针类型的属性, 为了避免浅拷贝, 就需要自定义一个深拷贝构造函数.</li>\n</ul>\n</li>\n<li>常量引用：<code>void func(const Student&amp; s)</code> - 不创建新对象，适用于<u>只读取值</u>的情况</li>\n<li>指针/引用：<code>void func(Student* s)</code> 或 <code>void func(Student&amp; s)</code> - 适用于需要<u>修改对象</u>的情况</li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：</p>\n<ul>\n<li>按值返回：<code>Student func()</code> - 返回新创建的对象</li>\n<li>返回指针：<code>Student* func()</code> - 注意内存管理问题</li>\n<li>返回引用：<code>Student&amp; func()</code> - 注意生命周期问题</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"右值引用与移动语义\"><a href=\"#右值引用与移动语义\" class=\"headerlink\" title=\"右值引用与移动语义\"></a>右值引用与移动语义</h2><h4 id=\"左值与右值\"><a href=\"#左值与右值\" class=\"headerlink\" title=\"左值与右值\"></a>左值与右值</h4><ul>\n<li><strong>左值</strong>：可以出现在赋值号左边的表达式<ul>\n<li>变量名、引用</li>\n<li>解引用操作符（*）和下标操作符（[]）的结果</li>\n</ul>\n</li>\n<li><strong>右值</strong>：只能出现在赋值号右边的表达式<ul>\n<li>字面量</li>\n<li>表达式结果</li>\n<li>函数返回的临时对象</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"右值引用-1\"><a href=\"#右值引用-1\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h4><ul>\n<li>使用 <code>&amp;&amp;</code> 声明</li>\n<li>可以绑定到右值，延长其生命周期</li>\n<li>右值引用变量本身是左值</li>\n<li>可以使用 <code>std::move()</code> 将左值转换为右值引用</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rx = x * <span class=\"number\">2</span>;  <span class=\"comment\">// 绑定右值</span></span><br><span class=\"line\">rx = <span class=\"number\">100</span>;          <span class=\"comment\">// rx本身是左值，可以被赋值</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><p>两种可以同时输入左值和右值引用作为参数的方法:</p>\n<ul>\n<li><p>重载</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重载函数，分别处理左值和右值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"type\">int</span>&amp; x)</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"重载函数 - 处理左值: \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"type\">int</span>&amp;&amp; x)</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"重载函数 - 处理右值: \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><code>const int&amp; x </code></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接受const左值引用的函数（可以接受左值和右值）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processAny</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span>&amp; x)</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"处理任意值: \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h4><ul>\n<li>签名：<code>T::T(T&amp;&amp; other)</code>, 也就是<strong>将右值引用作为参数的构造函数</strong></li>\n<li>用于”窃取”即将销毁的对象的资源，避免不必要的深拷贝</li>\n<li>通常将源对象的指针成员置为<code>nullptr</code>，防止资源被错误释放</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">MyClass</span>(MyClass&amp;&amp; other) : </span><br><span class=\"line\">    ptr{other.ptr} {</span><br><span class=\"line\">      other.data = <span class=\"number\">0</span></span><br><span class=\"line\">      other.ptr = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 防止源对象析构时释放内存</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>与浅拷贝类似, 但是需要在内部将源对象的指针成员 设置为 <code>nullptr</code> , 其他成员设置为有效但是为空的状态</li>\n</ul>\n<p> 标准库容器（如 std::vector）在进行元素移动时会优先选择不会抛异常的移动构造函数，否则会退而求其次选择拷贝构造函数（更慢）。</p>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;DynamicArray&gt; vec;</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">DynamicArray</span>(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>在这个 push_back 中，如果 DynamicArray 的移动构造函数被标记为 <code>noexcept</code>，那么 vector 会使用移动构造（高效）。</p>\n</blockquote>\n<h2 id=\"初始化方式\"><a href=\"#初始化方式\" class=\"headerlink\" title=\"初始化方式\"></a>初始化方式</h2><p>C++11提供了多种初始化对象的方式：</p>\n<ul>\n<li><p><strong>小括号初始化</strong>：<code>MyClass obj(arg1, arg2);</code></p>\n</li>\n<li><p><strong>等号初始化</strong>：<code>MyClass obj = value;</code></p>\n</li>\n<li><p><strong>大括号初始化</strong>（统一初始化）：<code>MyClass obj{arg1, arg2};</code></p>\n</li>\n<li><p><strong>列表初始化</strong>：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> arr[] = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>};</span><br><span class=\"line\">MyClass* ptr = <span class=\"keyword\">new</span> MyClass{arg1, arg2};</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h4 id=\"基本类型的初始化\"><a href=\"#基本类型的初始化\" class=\"headerlink\" title=\"基本类型的初始化\"></a>基本类型的初始化</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本类型的初始化方式</span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;             <span class=\"comment\">// 等号初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;              <span class=\"comment\">// 小括号初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> c{<span class=\"number\">30</span>};              <span class=\"comment\">// 大括号初始化（C++11）</span></span><br><span class=\"line\"><span class=\"type\">int</span> d = {<span class=\"number\">40</span>};           <span class=\"comment\">// 等号+大括号初始化（C++11）</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr1[] = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>}; <span class=\"comment\">// 数组初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr2[]{<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>};    <span class=\"comment\">// 数组大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"对象的初始化\"><a href=\"#对象的初始化\" class=\"headerlink\" title=\"对象的初始化\"></a>对象的初始化</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对象的初始化方式</span></span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"string\">\"张三\"</span>, <span class=\"number\">25</span>)</span></span>;          <span class=\"comment\">// 小括号初始化</span></span><br><span class=\"line\">Person p2 = <span class=\"built_in\">Person</span>(<span class=\"string\">\"李四\"</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 等号+临时对象初始化</span></span><br><span class=\"line\">Person p3{<span class=\"string\">\"王五\"</span>, <span class=\"number\">35</span>};          <span class=\"comment\">// 大括号初始化（C++11）</span></span><br><span class=\"line\">Person p4 = {<span class=\"string\">\"赵六\"</span>, <span class=\"number\">40</span>};       <span class=\"comment\">// 等号+大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<ul>\n<li><p>动态分配对象的初始化</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 动态分配对象的初始化方式</span></span><br><span class=\"line\">Person *pp1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Person</span>(<span class=\"string\">\"动态张三\"</span>, <span class=\"number\">25</span>); <span class=\"comment\">// 传统new</span></span><br><span class=\"line\">Person *pp2 = <span class=\"keyword\">new</span> Person{<span class=\"string\">\"动态李四\"</span>, <span class=\"number\">30</span>}; <span class=\"comment\">// 大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h3 id=\"深拷贝与浅拷贝\"><a href=\"#深拷贝与浅拷贝\" class=\"headerlink\" title=\"深拷贝与浅拷贝\"></a>深拷贝与浅拷贝</h3><ul>\n<li><strong>浅拷贝</strong>：默认拷贝构造函数执行的是浅拷贝，只复制指针值，不复制指针指向的内容</li>\n<li><strong>深拷贝</strong>：自定义拷贝构造函数可以实现深拷贝，为指针成员分配新内存并复制内容</li>\n</ul>\n<h3 id=\"何时使用移动语义\"><a href=\"#何时使用移动语义\" class=\"headerlink\" title=\"何时使用移动语义\"></a>何时使用移动语义</h3><ul>\n<li>类包含动态分配的资源（如指针成员）</li>\n<li>对象需要在函数间传递</li>\n<li>需要避免不必要的深拷贝操作</li>\n<li>使用容器时（如<code>std::vector</code>、<code>std::string</code>等）<ul>\n<li><code>move</code>会将一个左值变成右值引用, 从而允许调用移动构造函数!</li>\n<li>使用 <code>move</code> 时, 如果存在对应的移动构造函数, 就会优先调用;</li>\n<li>数组的 <code>push_back</code>也是如此, 优先调用移动构造函数<ul>\n<li>但是我们可以使用 <code>emplace</code>来继续优化上述的效率问题——直接将对象存储到数组的末端.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>拷贝构造函数用于创建对象的副本，深拷贝需要自定义实现</li>\n<li>移动语义通过右值引用实现<strong>资源的高效转移</strong>，避免不必要的拷贝, 同时<strong>规避了浅拷贝导致的 double free</strong> 的问题.</li>\n<li>根据需要选择合适的参数传递和返回值方式</li>\n<li>使用<code>std::move()</code>可以将左值转换为右值引用，触发移动语义</li>\n</ul>\n<hr>\n<h1 id=\"Overloaded-Operators\"><a href=\"#Overloaded-Operators\" class=\"headerlink\" title=\"Overloaded Operators\"></a>Overloaded Operators</h1><h4 id=\"补充-2\"><a href=\"#补充-2\" class=\"headerlink\" title=\"补充\"></a>补充</h4><p>自定义类型的方向转换:  <em>T</em> ==&gt; <em>C</em></p>\n<ul>\n<li><p>当下面情况存在一种时, 可以发生上述的转换:</p>\n<ol>\n<li><p>C存在以 <em>T</em> 作为输入参数的构造函数;</p>\n</li>\n<li><p><em>T</em> 存在 <code>operator C(){ }</code>的成员函数.<br>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rational</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">double</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{  <span class=\"comment\">// Rational到double的转换</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> numerator_ / (<span class=\"type\">double</span>)denominator_;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">double</span> d = r;  <span class=\"comment\">// 隐式转换：r =&gt; double</span></span><br></pre></td></tr></table></figure></div></li>\n</ol>\n</li>\n<li><p>不同同时存在两者的转换(编译器无法知道采取什么方式)</p>\n</li>\n</ul>\n<p>题目:</p>\n<ul>\n<li><p>并非所有运算符都可以用三种方式重载。例如赋值运算符 =、下标运算符 []、函数调用运算符 ()、成员访问运算符 -&gt; <strong>只能</strong>作为成员函数重载;</p>\n</li>\n<li><p>流提取符 &gt;&gt; 和插入符 &lt;&lt; 可以被重载</p>\n</li>\n<li><p>运算符 <code>+</code> 返回的类型 <strong>不一定</strong> 要与参数类型一致;</p>\n</li>\n<li><p>对于友元函数, 在声明处加上 <code>friend</code>标识, 但是在定义处是没有这个标识的. </p>\n</li>\n<li><blockquote>\n<p>[!NOTE]</p>\n<p>无法被重载的运算符:</p>\n<ul>\n<li>条件运算符: <code>?:</code></li>\n<li>成员指针访问运算符: <code>.*</code></li>\n</ul>\n</blockquote>\n<p><code>new</code>是可以重载的!</p>\n</li>\n<li><p>运算符的分类:</p>\n<ul>\n<li><p>成员运算符: 在类内部以成员函数形式重载的运算符 ==&gt; 具有隐式的 <code>this</code>;</p>\n</li>\n<li><p>友元运算符: 定义在类外部（在类内部用 <code>friend</code> 声明），没有 <code>this</code> 指针.</p>\n<p>因此, 一个重载函数只有一个参数时 ==&gt; 二员成员运算符 / 一元友元运算符.</p>\n</li>\n</ul>\n</li>\n<li><p>隐式转换的尝试是从左到右的:</p>\n<ul>\n<li><code>1+a</code>会尝试将类的对象 <code>a</code> 尝试转换为int类型.</li>\n</ul>\n</li>\n<li><p>注意类型:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 前缀++</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer&amp; Integer::<span class=\"keyword\">operator</span>++() {</span><br><span class=\"line\">    *<span class=\"keyword\">this</span> += <span class=\"number\">1</span>;  <span class=\"comment\">// 先增加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 再返回</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后缀++（参数int未使用，仅用于区分）</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer Integer::<span class=\"keyword\">operator</span>++(<span class=\"type\">int</span>) {</span><br><span class=\"line\">    <span class=\"function\">Integer <span class=\"title\">old</span><span class=\"params\">(*<span class=\"keyword\">this</span>)</span></span>;  <span class=\"comment\">// 先保存</span></span><br><span class=\"line\">    ++(*<span class=\"keyword\">this</span>);  <span class=\"comment\">// 再增加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> old;  <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>前缀++的返回是 <code>&amp;</code> 类型, 因为比较节省空间和时间. 后缀++的返回是值.</p>\n<ul>\n<li><code>[]</code> 的返回必须是 <code>&amp;</code> 类型, 这样可以作为左值赋值.</li>\n</ul>\n</li>\n</ul>\n<p>返回类型设计的<strong>总体原则</strong>：</p>\n<ol>\n<li><p>如果运算符需要作为左值（可以出现在赋值左侧），返回非常量引用。</p>\n<ol>\n<li>否则, 声明为<code>const</code>类型, 避免成为左值.</li>\n</ol>\n</li>\n<li><p>如果运算符创建新对象，返回值（通常是常量值）。</p>\n</li>\n<li><p>如果运算符返回布尔结果，直接返回 <code>bool</code> 类型。</p>\n</li>\n<li><p>如果需要支持链式操作，返回引用。</p>\n</li>\n</ol>\n<p>全局和成员函数的设计思路:</p>\n<ol>\n<li>一元运算符（如 <code>-a</code>）应该用<strong>成员函数</strong>，因为只操作一个对象</li>\n<li>赋值相关运算符（<code>=</code>, <code>+=</code>, <code>[]</code>, <code>-&gt;()</code>与 <code>-&gt;*</code> 等）必须是成员函数，因为它们需要修改对象状态</li>\n<li>对于二元运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)建议使用<strong>全局函数</strong>，因为：<ul>\n<li>支持操作数的对称转换</li>\n<li>更好地支持与其他类型的互操作</li>\n<li>保持了运算符的自然语义（如 <code>3 * x</code> 和 <code>x * 3</code> 应该都能工作）</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"C-运算符重载基础\"><a href=\"#C-运算符重载基础\" class=\"headerlink\" title=\"C++运算符重载基础\"></a>C++运算符重载基础</h2><p>运算符重载是C++的一项强大特性，它允许用户定义的类型像内置类型一样使用各种运算符。本质上，运算符重载是函数调用的另一种形式。</p>\n<h3 id=\"可重载与不可重载的运算符\"><a href=\"#可重载与不可重载的运算符\" class=\"headerlink\" title=\"可重载与不可重载的运算符\"></a>可重载与不可重载的运算符</h3><p>C++允许重载大多数运算符，但以下<strong>运算符不能被重载</strong>：</p>\n<ul>\n<li><code>.</code> (成员访问运算符)</li>\n<li><code>.*</code> (成员指针访问运算符)</li>\n<li><code>::</code> (作用域解析运算符)</li>\n<li><code>?:</code> (条件运算符)</li>\n<li><code>sizeof</code> (获取类型大小)</li>\n<li><code>typeid</code> (获取类型信息)</li>\n<li>类型转换运算符 (<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code>)</li>\n</ul>\n<h3 id=\"运算符重载的限制\"><a href=\"#运算符重载的限制\" class=\"headerlink\" title=\"运算符重载的限制\"></a>运算符重载的限制</h3><ol>\n<li><p><strong>只能重载已存在的运算符</strong></p>\n<ul>\n<li>不能创建新的运算符（如Python中的<code>**</code>）</li>\n<li>可以改变运算符的语义（如重载<code>+</code>实现减法），但不推荐</li>\n</ul>\n</li>\n<li><p><strong>运算符必须在类或枚举类型上重载</strong></p>\n<ul>\n<li>至少有一个操作数必须是用户定义类型</li>\n</ul>\n</li>\n<li><p><strong>必须保持操作数数量</strong></p>\n<ul>\n<li>如二元运算符<code>/</code>重载后仍必须是二元的</li>\n</ul>\n</li>\n<li><p><strong>必须保持优先级和结合律</strong></p>\n<ul>\n<li>运算符的优先级和结合律是固定的，不能被改变</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"运算符重载的实现方式\"><a href=\"#运算符重载的实现方式\" class=\"headerlink\" title=\"运算符重载的实现方式\"></a>运算符重载的实现方式</h2><p>运算符重载本质上是一个以<code>operator</code>关键字为前缀，后跟运算符的特殊函数。</p>\n<h3 id=\"成员函数方式\"><a href=\"#成员函数方式\" class=\"headerlink\" title=\"成员函数方式\"></a>成员函数方式</h3><p>作为类的成员函数实现运算符重载时：</p>\n<ul>\n<li>第一个操作数（左操作数）隐式为<code>this</code>指针</li>\n<li>不对接收者（左操作数）执行类型转换</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> ii) : <span class=\"built_in\">i</span>(ii) {}</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> i; }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重载+运算符，返回新对象</span></span><br><span class=\"line\">    <span class=\"type\">const</span> A <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> A&amp; that) <span class=\"type\">const</span> {</span><br><span class=\"line\">        <span class=\"function\">A <span class=\"title\">c</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;i + that.i)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    }</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<p>使用成员函数重载时，左操作数必须是该类的对象：</p>\n<ul>\n<li><code>a + b</code> 可行（a是A类对象）</li>\n<li><code>a + 9</code> 可行（9会被隐式转换为A类对象）</li>\n<li><code>9 + a</code> 不可行（9不是A类对象）</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>隐式转换: 编译器查找是否存在从给出参数作为构造函数的输入, 从而创建一个指定对象的方式:</p>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer h = a + <span class=\"number\">7</span>; <span class=\"comment\">// 7被隐式转换为Integer</span></span><br></pre></td></tr></table></figure></div>\n\n<p>上述发生的前提条件是 类 <code>Integer</code> 存在对应的构造函数:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Integer</span>(<span class=\"type\">int</span> val = <span class=\"number\">0</span>) : <span class=\"built_in\">value</span>(val)</span><br></pre></td></tr></table></figure></div></blockquote>\n<h3 id=\"全局函数方式\"><a href=\"#全局函数方式\" class=\"headerlink\" title=\"全局函数方式\"></a>全局函数方式</h3><p>作为全局函数实现运算符重载时：</p>\n<ul>\n<li>所有操作数都是显式参数</li>\n<li>开发者不需要特殊访问类的权限</li>\n<li>可能需要声明为友元函数以访问私有成员</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Integer</span>{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"type\">const</span> Integer <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> Integer &amp;left, <span class=\"type\">const</span> Integer&amp; right);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以直接在全局函数中访问私有成员</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> Integer &amp;left, <span class=\"type\">const</span> Integer &amp;right)</span><br><span class=\"line\">{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"调用全局函数*运算符: \"</span> &lt;&lt; left.value &lt;&lt; <span class=\"string\">\" * \"</span> &lt;&lt; right.value &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Integer</span>(left.value * right.value);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>当然, 全局函数实现的运算符重载, 可以通过调用类的public中的函数接口, 来间接访问内部的私有成员变量:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Integer</span>{</span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过public接口访问内部的私有成员变量.</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer <span class=\"keyword\">operator</span>/(<span class=\"type\">const</span> Integer &amp;left, <span class=\"type\">const</span> Integer &amp;right)</span><br><span class=\"line\">{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"调用全局函数/运算符: \"</span> &lt;&lt; left.<span class=\"built_in\">getValue</span>() &lt;&lt; <span class=\"string\">\" / \"</span> &lt;&lt; right.<span class=\"built_in\">getValue</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right.<span class=\"built_in\">getValue</span>() == <span class=\"number\">0</span>)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">\"错误: 除数不能为零\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Integer</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Integer</span>(left.<span class=\"built_in\">getValue</span>() / right.<span class=\"built_in\">getValue</span>());</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>使用全局函数重载时，可以处理左操作数不是该类对象的情况：</p>\n<ul>\n<li><code>9 - b</code> 可行（9会被隐式转换为A类对象）</li>\n<li>因为两个操作数都是普通参数，地位平等, 体现了运算符的对称性</li>\n</ul>\n<h3 id=\"成员函数vs全局函数的选择\"><a href=\"#成员函数vs全局函数的选择\" class=\"headerlink\" title=\"成员函数vs全局函数的选择\"></a>成员函数vs全局函数的选择</h3><ul>\n<li><strong>一元运算符</strong>应该作为成员函数</li>\n<li><strong>赋值运算符</strong>（<code>=</code>, <code>()</code>, <code>[]</code>, <code>-&gt;</code>, <code>-&gt;</code>）必须是成员函数</li>\n<li>其他<strong>二元运算符</strong>最好作为非成员函数（全局函数）</li>\n</ul>\n<h2 id=\"参数传递与返回类型\"><a href=\"#参数传递与返回类型\" class=\"headerlink\" title=\"参数传递与返回类型\"></a>参数传递与返回类型</h2><h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><ol>\n<li>对于只读参数，使用<code>const</code>引用传递（除了内置类型）</li>\n<li>对于不修改对象的成员函数，声明为<code>const</code></li>\n<li>对于全局函数，如果左操作数会被修改，使用引用传递</li>\n</ol>\n<h3 id=\"返回类型\"><a href=\"#返回类型\" class=\"headerlink\" title=\"返回类型\"></a>返回类型</h3><p>根据运算符的预期含义选择返回类型：</p>\n<ol>\n<li><p><strong>算术运算符</strong>（<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code>, <code>&amp;</code>, <code>|</code>, <code>~</code>）</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> T <span class=\"keyword\">operator</span> <span class=\"title\">X</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; l, <span class=\"type\">const</span> T&amp; r)</span></span>;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>返回新对象，不应返回引用（除非返回成员引用）</li>\n<li>返回<code>const</code>对象防止<code>(a+b) = c</code>这样的操作</li>\n</ul>\n</li>\n<li><p><strong>逻辑运算符</strong>（<code>!</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>&gt;=</code>, <code>&gt;</code>）</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span> <span class=\"title\">X</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; l, <span class=\"type\">const</span> T&amp; r)</span></span>;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>返回布尔值</li>\n</ul>\n</li>\n<li><p><strong>下标运算符</strong>（<code>[]</code>）</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E&amp; T::<span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index);</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>返回左值（非<code>const</code>引用），允许<code>a[i] = value</code>操作</li>\n<li>不能返回新对象，否则赋值操作无效</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"特殊运算符重载\"><a href=\"#特殊运算符重载\" class=\"headerlink\" title=\"特殊运算符重载\"></a>特殊运算符重载</h2><h3 id=\"自增自减运算符\"><a href=\"#自增自减运算符\" class=\"headerlink\" title=\"自增自减运算符\"></a>自增自减运算符</h3><p>C++区分前缀和后缀自增自减运算符：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 前缀++</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer&amp; Integer::<span class=\"keyword\">operator</span>++() {</span><br><span class=\"line\">    *<span class=\"keyword\">this</span> += <span class=\"number\">1</span>;  <span class=\"comment\">// 先增加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 再返回</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后缀++（参数int未使用，仅用于区分）</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer Integer::<span class=\"keyword\">operator</span>++(<span class=\"type\">int</span>) {</span><br><span class=\"line\">    <span class=\"function\">Integer <span class=\"title\">old</span><span class=\"params\">(*<span class=\"keyword\">this</span>)</span></span>;  <span class=\"comment\">// 先保存</span></span><br><span class=\"line\">    ++(*<span class=\"keyword\">this</span>);  <span class=\"comment\">// 再增加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> old;  <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>调用方式：</p>\n<ul>\n<li><p><code>++x</code> 调用 <code>x.operator++()</code></p>\n<ul>\n<li><p>返回的是引用, 从而支持链式操作 如:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Counter g = ++(++f); <span class=\"comment\">// 可以，因为前缀返回引用</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n<li><p><code>x++</code> 调用 <code>x.operator++(0)</code></p>\n<ul>\n<li><p>返回的是临时的对象, 也就是旧值的副本. 声明<code>const</code>避免了后缀的链式调用</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Counter h = (f++)++; <span class=\"comment\">// 不可以，因为后缀返回const值</span></span><br></pre></td></tr></table></figure></div>\n\n<p>之所以要防止上述的后缀链式调用, 是因为 对<code>f++</code>继续自增将会导致语义的混乱.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"下标运算符\"><a href=\"#下标运算符\" class=\"headerlink\" title=\"下标运算符\"></a>下标运算符</h3><p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下标运算符（返回左值引用，允许修改）</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) {</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">\"错误: 下标越界 [\"</span> &lt;&lt; index &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"comment\">// 返回第一个元素作为应急措施（实际应用中应抛出异常）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[<span class=\"number\">0</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data[index];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下标运算符的const版本（返回值，不允许修改）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) {</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">\"错误: 下标越界 [\"</span> &lt;&lt; index &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"comment\">// 返回0作为应急措施（实际应用中应抛出异常）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data[index];</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>关系运算符通常成对实现，可以相互利用：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i == rhs.i;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>!=(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(*<span class=\"keyword\">this</span> == rhs);  <span class=\"comment\">// 利用==运算符</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i &lt; rhs.i;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rhs &lt; *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 利用&lt;运算符</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>&lt;=(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(rhs &lt; *<span class=\"keyword\">this</span>);  <span class=\"comment\">// 利用&lt;运算符</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>&gt;=(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(*<span class=\"keyword\">this</span> &lt; rhs);  <span class=\"comment\">// 利用&lt;运算符</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"流运算符\"><a href=\"#流运算符\" class=\"headerlink\" title=\"流运算符\"></a>流运算符</h3><p>输入输出流运算符通常实现为全局函数：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出流运算符</span></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; os, <span class=\"type\">const</span> A&amp; a) {</span><br><span class=\"line\">    os &lt;&lt; a.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;  <span class=\"comment\">// 返回流对象以支持链式操作</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输入流运算符</span></span><br><span class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; is, A&amp; a) {</span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    cin &gt;&gt; line;</span><br><span class=\"line\">    <span class=\"comment\">// 读取a的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> is;  <span class=\"comment\">// 返回流对象以支持链式操作</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>注意：</p>\n<ul>\n<li>输出流运算符的第一个参数不能是<code>const</code>，因为输出会修改流</li>\n<li>输入流运算符的第二个参数不能是<code>const</code>，因为需要修改对象</li>\n<li>通常需要声明为友元以访问私有成员</li>\n</ul>\n<h3 id=\"自定义流操纵符\"><a href=\"#自定义流操纵符\" class=\"headerlink\" title=\"自定义流操纵符\"></a>自定义流操纵符</h3><p>可以定义自己的流操纵符：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ostream&amp; <span class=\"title\">tab</span><span class=\"params\">(ostream&amp; out)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out &lt;&lt; <span class=\"string\">'\\t'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用：cout &lt;&lt; \"Hello\" &lt;&lt; tab &lt;&lt; \"World!\" &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n<h2 id=\"赋值运算符与类型转换\"><a href=\"#赋值运算符与类型转换\" class=\"headerlink\" title=\"赋值运算符与类型转换\"></a>赋值运算符与类型转换</h2><h3 id=\"赋值运算符-1\"><a href=\"#赋值运算符-1\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><p>赋值运算符有几个重要特点：</p>\n<ul>\n<li>必须是成员函数</li>\n<li>如果不提供，编译器会自动生成（行为类似默认拷贝构造函数）</li>\n<li>需要检查自赋值情况</li>\n<li>确保为所有数据成员赋值</li>\n<li>返回<code>*this</code>的引用</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A&amp; A::<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> A&amp; rhs) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) {  <span class=\"comment\">// 检查自赋值</span></span><br><span class=\"line\">        <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 分配新资源</span></span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[rhs.size];</span><br><span class=\"line\">        size = rhs.size;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 复制数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {</span><br><span class=\"line\">            data[i] = rhs.data[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 返回对象引用</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><h4 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h4><p>C++支持两种用户定义的类型转换：</p>\n<ol>\n<li><p><strong>构造函数转换</strong>：从其他类型到当前类型</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PathName</span> {</span><br><span class=\"line\">    string name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">PathName</span>(<span class=\"type\">const</span> string&amp; s) : <span class=\"built_in\">name</span>(s) {}  <span class=\"comment\">// string到PathName的转换</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">abc</span><span class=\"params\">(<span class=\"string\">\"abc\"</span>)</span></span>;</span><br><span class=\"line\">PathName xyz = abc;  <span class=\"comment\">// 隐式转换：abc =&gt; PathName</span></span><br></pre></td></tr></table></figure></div>\n\n<p>可以使用<code>explicit</code>关键字禁止隐式转换：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">PathName</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s)</span></span>;  <span class=\"comment\">// 只能用于显式构造</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><strong>转换运算符</strong>：从当前类型到其他类型</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rational</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">double</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{  <span class=\"comment\">// Rational到double的转换</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> numerator_ / (<span class=\"type\">double</span>)denominator_;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">double</span> d = r;  <span class=\"comment\">// 隐式转换：r =&gt; double</span></span><br></pre></td></tr></table></figure></div>\n\n<p>同样可以使用<code>explicit</code>关键字要求显式转换：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"keyword\">operator</span> <span class=\"title\">double</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"><span class=\"type\">double</span> d = (<span class=\"type\">double</span>)r;  <span class=\"comment\">// 必须显式转换</span></span><br></pre></td></tr></table></figure></div></li>\n</ol>\n<p>注意：如果同时提供了从T到C的构造函数和从C到T的转换运算符，编译器可能会产生歧义。</p>\n<h4 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"显式转换\"></a>显式转换</h4><p>显式转换的外在特点:</p>\n<ul>\n<li>使用直接初始化语法</li>\n<li>明确指出要用构造函数创建对象</li>\n<li>转换过程更加清晰可见</li>\n</ul>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数转换：double到Rational</span></span><br><span class=\"line\">Rational r1 = <span class=\"number\">3.14</span>;  <span class=\"comment\">// 隐式转换</span></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r2</span><span class=\"params\">(<span class=\"number\">2.5</span>)</span></span>;    <span class=\"comment\">// 显式转换</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>如果声明 <code>explict</code>, 就必须使用强制的显式转换:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果想要强制显式转换，应该这样声明：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Rational</span><span class=\"params\">(<span class=\"type\">double</span> value)</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> PRECISION = <span class=\"number\">10000</span>;</span><br><span class=\"line\">    numerator = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(value * PRECISION);</span><br><span class=\"line\">    denominator = PRECISION;</span><br><span class=\"line\">    <span class=\"built_in\">simplify</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">Rational r1 = <span class=\"number\">3.14</span>;        <span class=\"comment\">// 错误：不允许隐式转换</span></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r2</span><span class=\"params\">(<span class=\"number\">2.5</span>)</span></span>;          <span class=\"comment\">// 正确：显式构造</span></span><br><span class=\"line\">Rational r3 = <span class=\"built_in\">Rational</span>(<span class=\"number\">3.14</span>); <span class=\"comment\">// 正确：显式转换</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>类型的显式转换:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> d2 = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(r2);  <span class=\"comment\">// 显式转换</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"混合类型的转换\"><a href=\"#混合类型的转换\" class=\"headerlink\" title=\"混合类型的转换\"></a>混合类型的转换</h4><p>根据运算结果, 自动地将运算的操作数进行类型转换:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 混合类型运算</span></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r3</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">double</span> d3 = <span class=\"number\">0.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里会将r3转换为double，然后进行double加法</span></span><br><span class=\"line\"><span class=\"type\">double</span> result = r3 + d3;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h1 id=\"Template\"><a href=\"#Template\" class=\"headerlink\" title=\"Template\"></a>Template</h1><h2 id=\"模板概述\"><a href=\"#模板概述\" class=\"headerlink\" title=\"模板概述\"></a>模板概述</h2><p>模板是C++中实现**<u>泛型编程</u>**的核心机制，允许我们编写可以处理不同数据类型的代码，而不必为每种类型重复编写相同的逻辑。</p>\n<ul>\n<li><p>首先尝试匹配普通的函数, 否则尝试匹配模板函数</p>\n</li>\n<li><p>函数模板是声明, 而非定义. 是在实际调用时候去 <strong><u>实例化</u></strong> 对应类型的函数.</p>\n</li>\n<li><p>必须都放在头文件的实现包含:</p>\n<ul>\n<li><p>函数模板;</p>\n</li>\n<li><p>inline函数</p>\n</li>\n<li><p>带有default参数的声明.</p>\n</li>\n<li><p>类模板的成员函数</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;T&gt;</span><br><span class=\"line\"><span class=\"type\">int</span> Vector&lt;T&gt;::<span class=\"built_in\">getSize</span>()<span class=\"type\">const</span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>注意, 都需要声明模板类, 并且需要在 <code>&lt; &gt;</code>内部声明类.</p>\n</li>\n</ul>\n</li>\n<li><p><code>template&lt;class T&gt;</code> 和 <code>template&lt;typename T&gt;</code> 是等价的, 后者是后来引入的更明确的语法.</p>\n</li>\n<li><p>类模板的每个成员函数在类外定义时，都必须以<code>template&lt;class T&gt;</code>（或<code>template&lt;typename T&gt;</code>）开头，即使该成员函数没有直接使用模板参数T.</p>\n</li>\n<li><p><code>Vector&lt; int (*)&gt;</code></p>\n</li>\n</ul>\n<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><h3 id=\"基本语法-1\"><a href=\"#基本语法-1\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T&amp; x, T&amp; y)</span> </span>{</span><br><span class=\"line\">    T temp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = temp;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><code>template</code> 关键字引入模板声明</li>\n<li><code>class T</code> 指定参数化类型名称（<code>class</code>在这里表示任何内置类型或用户定义类型）</li>\n<li>在模板内部，<code>T</code> 被用作类型名称</li>\n</ul>\n<h3 id=\"模板实例化\"><a href=\"#模板实例化\" class=\"headerlink\" title=\"模板实例化\"></a>模板实例化</h3><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">3</span>, j = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"built_in\">swap</span>(i, j);  <span class=\"comment\">// 使用int类型的swap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> k = <span class=\"number\">4.5</span>, m = <span class=\"number\">3.7</span>;</span><br><span class=\"line\"><span class=\"built_in\">swap</span>(k, m);  <span class=\"comment\">// 实例化float类型的swap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">\"Hello\"</span>)</span>, <span class=\"title\">t</span><span class=\"params\">(<span class=\"string\">\"World\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">swap</span>(s, t);  <span class=\"comment\">// 实例化std::string类型的swap</span></span><br></pre></td></tr></table></figure></div>\n\n<p>编译器会根据传入的参数类型自动生成相应的函数实例。</p>\n<h3 id=\"模板匹配规则\"><a href=\"#模板匹配规则\" class=\"headerlink\" title=\"模板匹配规则\"></a>模板匹配规则</h3><ul>\n<li>只使用类型的精确匹配</li>\n<li>不应用类型转换操作</li>\n<li>即使是隐式转换也会被忽略</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">swap</span>(<span class=\"type\">int</span>, <span class=\"type\">int</span>);     <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"built_in\">swap</span>(<span class=\"type\">double</span>, <span class=\"type\">double</span>); <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"built_in\">swap</span>(<span class=\"type\">int</span>, <span class=\"type\">double</span>);  <span class=\"comment\">// 错误！类型不匹配</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"模板函数与普通函数共存\"><a href=\"#模板函数与普通函数共存\" class=\"headerlink\" title=\"模板函数与普通函数共存\"></a>模板函数与普通函数共存</h3><p>如果同时存在模板函数和普通函数，编译器会优先选择**<u>普通函数</u>**.</p>\n<h4 id=\"显式指定\"><a href=\"#显式指定\" class=\"headerlink\" title=\"显式指定\"></a>显式指定</h4><p>可以显式地指定模板参数类型:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带有返回值的函数模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">myMax</span><span class=\"params\">(T a, T b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"调用模板版本的myMax\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &gt; b) ? a : b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">\"myMax&lt;double&gt;(10, 20.5) = \"</span> &lt;&lt; <span class=\"built_in\">myMax</span>&lt;<span class=\"type\">double</span>&gt;(<span class=\"number\">10</span>, <span class=\"number\">20.5</span>) &lt;&lt; endl; </span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// myMax(10, 20.5);  // 错误：参数类型不一致</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"多参数的函数模板\"><a href=\"#多参数的函数模板\" class=\"headerlink\" title=\"多参数的函数模板\"></a>多参数的函数模板</h4><p>同理的, 我们可以设置多个参数类型, 根据输入的类型来推断:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\"><span class=\"function\">T1 <span class=\"title\">myMax</span><span class=\"params\">(T1 a, T2 b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"调用模板版本的myMax2\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &gt; b) ? a : b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  cout &lt;&lt;  <span class=\"built_in\">myMax</span>(<span class=\"number\">10</span>, <span class=\"number\">20.5</span>) &lt;&lt; endl; </span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p> 此时, 上述的函数不需要显式的声明参数类型, 因为存在匹配的模板函数.</p>\n<p>同时, 此时根据类型推断, 返回的类型是 <code>int</code>, 然后舍弃 20.5的小数部分, 最终的结果是 <code>20</code>.</p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h3 id=\"基本语法-2\"><a href=\"#基本语法-2\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><p>此处的 <code>Vector</code>是自己定义的.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Vector</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Vector</span>(<span class=\"type\">int</span>);</span><br><span class=\"line\">    ~<span class=\"built_in\">Vector</span>();</span><br><span class=\"line\">    <span class=\"built_in\">Vector</span>(<span class=\"type\">const</span> Vector&amp;);</span><br><span class=\"line\">    Vector&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Vector&amp;);</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* m_elements;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_size;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"类模板的使用\"><a href=\"#类模板的使用\" class=\"headerlink\" title=\"类模板的使用\"></a>类模板的使用</h3><p>类模板必须显式指定类型参数：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v1</span><span class=\"params\">(<span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Vector&lt;Complex&gt; <span class=\"title\">v2</span><span class=\"params\">(<span class=\"number\">256</span>)</span></span>;</span><br><span class=\"line\">v1[<span class=\"number\">20</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\">v2[<span class=\"number\">20</span>] = v1[<span class=\"number\">20</span>];  <span class=\"comment\">// 如果定义了int到Complex的转换，则正确</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"类模板成员函数的定义\"><a href=\"#类模板成员函数的定义\" class=\"headerlink\" title=\"类模板成员函数的定义\"></a>类模板成员函数的定义</h3><p>所有成员函数定义都需要包含模板声明：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\">Vector&lt;T&gt;::<span class=\"built_in\">Vector</span>(<span class=\"type\">int</span> size) : <span class=\"built_in\">m_size</span>(size) {</span><br><span class=\"line\">    m_elements = <span class=\"keyword\">new</span> T[m_size];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::<span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> indx) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (indx &lt; m_size &amp;&amp; indx &gt;= <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_elements[indx];</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>注意：</p>\n<ul>\n<li>每个成员函数定义前都要加上 <code>template &lt;class T&gt;</code></li>\n<li>类名必须写为 <code>Vector&lt;T&gt;</code></li>\n<li>类模板的函数通常在头文件中实现，不需要分离的.cpp文件</li>\n</ul>\n<h2 id=\"多参数模板\"><a href=\"#多参数模板\" class=\"headerlink\" title=\"多参数模板\"></a>多参数模板</h2><p>模板可以使用多个类型参数：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Key</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">Value</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HashTable</span> {</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> Value&amp; <span class=\"title\">lookup</span><span class=\"params\">(<span class=\"type\">const</span> Key&amp;)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">install</span><span class=\"params\">(<span class=\"type\">const</span> Key&amp;, <span class=\"type\">const</span> Value&amp;)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"嵌套模板\"><a href=\"#嵌套模板\" class=\"headerlink\" title=\"嵌套模板\"></a>嵌套模板</h2><p>模板可以嵌套使用，因为它们只是新的类型：</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector&lt;Vector&lt;<span class=\"type\">double</span>&gt;&gt; matrix;  <span class=\"comment\">// 注意C++11之前需要空格：Vector&lt;Vector&lt;double&gt; &gt;</span></span><br><span class=\"line\">Vector&lt;<span class=\"built_in\">int</span> (*)(Vector&lt;<span class=\"type\">double</span>&gt;&amp;, <span class=\"type\">int</span>)&gt; functionPointers;  <span class=\"comment\">// 函数指针的向量</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"非类型模板参数\"><a href=\"#非类型模板参数\" class=\"headerlink\" title=\"非类型模板参数\"></a>非类型模板参数</h4><p>~也就是没有使用模板类型的普通参数.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Key</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">Value</span>, <span class=\"type\">int</span> TableSize = <span class=\"number\">10</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> HashTable {</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<p>其中的 <code>TableSize</code> 就是普通的参数. 在编译时就确定了类型.</p>\n<h2 id=\"模板的局限性与注意事项\"><a href=\"#模板的局限性与注意事项\" class=\"headerlink\" title=\"模板的局限性与注意事项\"></a>模板的局限性与注意事项</h2><ol>\n<li>模板代码通常放在头文件中，因为编译器需要在编译时看到完整的模板定义</li>\n<li>模板错误通常在实例化时才会被发现，错误信息可能很复杂</li>\n<li>模板可能导致代码膨胀，因为每种类型都会生成一份代码</li>\n<li>模板参数必须支持模板中使用的所有操作</li>\n</ol>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><ul>\n<li>使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.<ul>\n<li>另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"访问控制\"><a href=\"#访问控制\" class=\"headerlink\" title=\"访问控制\"></a>访问控制</h2><h3 id=\"继承关系中的访问控制\"><a href=\"#继承关系中的访问控制\" class=\"headerlink\" title=\"继承关系中的访问控制\"></a>继承关系中的访问控制</h3><p>控制基类成员在派生类中的可见性：</p>\n<ul>\n<li><code>public</code>：基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>，<code>protected</code> 成员仍然是 <code>protected</code>。</li>\n<li><code>protected</code>：基类的 <code>public</code> 和 <code>protected</code>成员在派生类中都变为 <code>protected</code>。</li>\n<li><code>private</code>：基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>\n</ul>\n<h2 id=\"作用域与生存期\"><a href=\"#作用域与生存期\" class=\"headerlink\" title=\"作用域与生存期\"></a>作用域与生存期</h2><p>本地: 均为本地</p>\n<p>全局: 均为全局</p>\n<p>静态本地: 作用域是本地, 生存期是全局</p>\n<p>静态全局: ~</p>\n<h2 id=\"Includes\"><a href=\"#Includes\" class=\"headerlink\" title=\"Includes\"></a>Includes</h2><h3 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h3><p><code>copy(first, last, result)</code>:</p>\n<ul>\n<li><code>fisrt</code>和<code>last</code>是输入迭代器, 表示要复制的范围, 左闭右开即<code>last</code>应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;</li>\n<li><code>result</code>是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作<ul>\n<li>e.g.<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"type\">int</span>&gt; source = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>};</span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">destination</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>; <span class=\"comment\">// 确保目标容器有足够的空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::<span class=\"built_in\">copy</span>(source.<span class=\"built_in\">begin</span>(), source.<span class=\"built_in\">end</span>(), destination.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : destination) {</span><br><span class=\"line\">    std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>; <span class=\"comment\">// 输出：1 2 3 4 5</span></span><br><span class=\"line\">}</span><br><span class=\"line\">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n<li><code>result</code>可以直接输出到<code>cout</code>中.  <div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++){</span><br><span class=\"line\">    vec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>()<span class=\"number\">+2</span>); <span class=\"comment\">//删除第三个元素</span></span><br><span class=\"line\"><span class=\"built_in\">copy</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">\",\"</span>));</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 0,1,3,4,</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<hr>\n<ul>\n<li>数组之间<strong>不可以</strong>直接赋值, 但是字符串可以直接赋值</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">str1 = str2;  <span class=\"comment\">// 错误，数组之间不可以直接赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">string s1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string s2 = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">s1 = s2;  <span class=\"comment\">// 正确，字符串可以直接赋值</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string s2 = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"初始状态：\"</span> &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s1: \"</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"comment\">// 输出：Hello</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s2: \"</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\"></span><br><span class=\"line\">s1 = s2;  <span class=\"comment\">// 赋值操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"赋值后：\"</span> &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s1: \"</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s2: \"</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改 s2 不会影响 s1，因为是深拷贝</span></span><br><span class=\"line\">s2 = <span class=\"string\">\"Changed\"</span>;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"修改 s2 后：\"</span> &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s1: \"</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s2: \"</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"comment\">// 输出：Changed</span></span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"Temp\"><a href=\"#Temp\" class=\"headerlink\" title=\"Temp\"></a>Temp</h2><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代器</span></span><br><span class=\"line\">I.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">I.<span class=\"built_in\">end</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Item Access</span></span><br><span class=\"line\">V.<span class=\"built_in\">front</span>();;</span><br><span class=\"line\">V.<span class=\"built_in\">back</span>();</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"区分\"><a href=\"#区分\" class=\"headerlink\" title=\"区分\"></a>区分</h2><h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p><code>find</code>是字符串类的一种方法, 同时也是标准库<code>algorithm</code>中的一个函数.</p>\n<ul>\n<li><code>find</code>方法: 用于在字符串中查找子字符串的位置。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> pos = str.<span class=\"built_in\">find</span>(<span class=\"string\">\"World\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pos != string::npos) {</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Found 'World' at position \"</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>algorithm</code>中的<code>find</code>函数: 用于在容器（如数组、向量等）中查找元素。</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; vec = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>};</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt;::iterator it = <span class=\"built_in\">find</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it != vec.<span class=\"built_in\">end</span>()) {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Found 3 at position \"</span> &lt;&lt; <span class=\"built_in\">distance</span>(vec.<span class=\"built_in\">begin</span>(), it) &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// Found 3 at position 2</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>编译: <code>g++ -std=c++11 test.cpp -o test</code></p>\n</blockquote>\n<h3 id=\"erase\"><a href=\"#erase\" class=\"headerlink\" title=\"erase\"></a>erase</h3><ul>\n<li>对于字符串的方法: <code>str.erase(pos, len)</code><ul>\n<li>删除从指定位置开始的指定个数字符</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">6</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 输出: Hello</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<ul>\n<li>对于容器的方法: <code>erase(pos1, pos2)</code><ul>\n<li>左闭右开式删除容器当中的元素.</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; vec = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>};</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Original vector: \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : vec) {</span><br><span class=\"line\">        std::cout &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素</span></span><br><span class=\"line\">    vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>, vec.<span class=\"built_in\">begin</span>() + <span class=\"number\">4</span>); <span class=\"comment\">// 删除 vec[1], vec[2], vec[3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Modified vector: \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : vec) {</span><br><span class=\"line\">        std::cout &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl; <span class=\"comment\">// 输出 \"1 5 6\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"不知道放在哪里的代码块\"><a href=\"#不知道放在哪里的代码块\" class=\"headerlink\" title=\"不知道放在哪里的代码块\"></a>不知道放在哪里的代码块</h2><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建并填充链表</span></span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt; L;                      <span class=\"comment\">// 创建一个空的整数链表</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; ++i)          <span class=\"comment\">// 循环5次</span></span><br><span class=\"line\">    L.<span class=\"built_in\">push_back</span>(i);              <span class=\"comment\">// 依次在链表尾部添加数字1,2,3,4,5</span></span><br><span class=\"line\">                                 <span class=\"comment\">// 此时链表内容为：1,2,3,4,5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 删除第二个元素</span></span><br><span class=\"line\">L.<span class=\"built_in\">erase</span>( ++L.<span class=\"built_in\">begin</span>() );          <span class=\"comment\">// L.begin()指向第一个元素</span></span><br><span class=\"line\">                                 <span class=\"comment\">// ++L.begin()指向第二个元素</span></span><br><span class=\"line\">                                 <span class=\"comment\">// erase删除迭代器指向的元素</span></span><br><span class=\"line\">                                 <span class=\"comment\">// 此时链表内容为：1,3,4,5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 打印链表内容</span></span><br><span class=\"line\"><span class=\"built_in\">copy</span>(                            <span class=\"comment\">// 标准库算法，用于复制序列</span></span><br><span class=\"line\">    L.<span class=\"built_in\">begin</span>(),                   <span class=\"comment\">// 源序列的起始位置</span></span><br><span class=\"line\">    L.<span class=\"built_in\">end</span>(),                     <span class=\"comment\">// 源序列的结束位置</span></span><br><span class=\"line\">    <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(       <span class=\"comment\">// 输出流迭代器</span></span><br><span class=\"line\">        cout,                    <span class=\"comment\">// 指定输出到标准输出</span></span><br><span class=\"line\">        <span class=\"string\">\",\"</span>                      <span class=\"comment\">// 每个元素后面追加的分隔符</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">);</span><br><span class=\"line\">cout &lt;&lt; endl;                    <span class=\"comment\">// 换行</span></span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h1 id=\"课堂缓冲区\"><a href=\"#课堂缓冲区\" class=\"headerlink\" title=\"课堂缓冲区\"></a>课堂缓冲区</h1><ul>\n<li><p>私有的边界是 <code>class</code>而非对象. 也就是说, <strong>相同类的对象可以直接访问对方的私有属性</strong>.</p>\n</li>\n<li><p>不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们之间没有初始化的依赖.</p>\n</li>\n<li><p>需要尽可能地避免使用全局变量.</p>\n</li>\n<li><p>一个良好的习惯: 当成员函数不需要改变成员变量的值时, 在后面加上 <code>const</code>的关键字, 确保不会改变;</p>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* s = <span class=\"string\">\"Hello,world！\"</span>；</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>此时的右侧字符串位于 段 <code>text</code>, 不可写. <code>s</code>本身是一个固定内存的指针.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> s［］ = <span class=\"string\">\"Hello,world！\"</span>；</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>此时的 <code>s</code>是一个大小等于数组内容的对象.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">int</span>* <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 只能将函数的返回值赋值给一个 const int*</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"函数内部的对象的空间分配\"><a href=\"#函数内部的对象的空间分配\" class=\"headerlink\" title=\"函数内部的对象的空间分配\"></a>函数内部的对象的空间分配</h4><p>编译器在编译的时候计算得到函数内部所有的对象的空间, 在实际进入函数的时候**, 立即分配所有对象的空间;**</p>\n<ul>\n<li>实际执行到的时候发生构造.</li>\n</ul>\n<h4 id=\"Quiz\"><a href=\"#Quiz\" class=\"headerlink\" title=\"Quiz\"></a>Quiz</h4><p>静态全局、本地和成员变量都存储于全局数据区.</p>\n<ul>\n<li>静态成员变量的构造也在 <code>main()</code>之前.</li>\n</ul>\n<h1 id=\"题目梳理\"><a href=\"#题目梳理\" class=\"headerlink\" title=\"题目梳理\"></a>题目梳理</h1><h2 id=\"HW2\"><a href=\"#HW2\" class=\"headerlink\" title=\"HW2\"></a>HW2</h2><p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedundefinedundefinedimage-20250225160042809.png?imageSlim\"></p>\n<ul>\n<li>ANS:  B</li>\n<li>由于此处的<code>map</code>以<code>char *</code>作为key, 同时初始化<code>str</code>的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.</li>\n</ul>\n<hr>\n<p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250225160652522.png?imageSlim\"></p>\n<ul>\n<li>逗号表达式, 从左到右分别计算,最后返回的结果是最右侧的值, 此处为1.</li>\n</ul>\n<blockquote>\n<ul>\n<li><p><code>vector&lt;int&gt; v(10);</code> 创建包含10个元素的容器, 每个元素初始化为 <code>0</code>;</p>\n</li>\n<li><p><code>vector &lt;int&gt; v(10, 1);</code>: 创建包含10个元素的容器, 但是都初始化为 <code>1</code>;</p>\n</li>\n<li><p><code>vector &lt;int&gt; v{10, 1};</code>: 创建包含10,1 这2个元素的容器;</p>\n</li>\n<li><p>此外, 还可以使用 <code>vector &lt;int&gt; v</code>;创建一个空的容器; </p>\n</li>\n<li><p>同时也还可以用 <strong>迭代器</strong>进行初始化: <code>vector &lt;int&gt; v(arr, arr + 5);</code></p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"HW3\"><a href=\"#HW3\" class=\"headerlink\" title=\"HW3\"></a>HW3</h2><ul>\n<li>类成员的默认访问权限是 <strong><u>私有的</u></strong>, 即不显式声明访问修饰符, 默认为 <code>private</code>;</li>\n</ul>\n<h2 id=\"HW4\"><a href=\"#HW4\" class=\"headerlink\" title=\"HW4\"></a>HW4</h2><h3 id=\"可变大小矩阵\"><a href=\"#可变大小矩阵\" class=\"headerlink\" title=\"可变大小矩阵:\"></a>可变大小矩阵:</h3><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Matrix</span>{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> r,c;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; m; <span class=\"comment\">// 二维向量, 每个向量元素是一个一维向量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Matrix</span>(<span class=\"type\">int</span> r, <span class=\"type\">int</span> c) : <span class=\"built_in\">r</span>(r),<span class=\"built_in\">c</span>(c){</span><br><span class=\"line\">        m.<span class=\"built_in\">resize</span>(r, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(c)); <span class=\"comment\">// 分配r个一维向量, 每个一维向量的大小为c</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">transform</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">new_m</span>(c, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(r,<span class=\"number\">0</span>)); <span class=\"comment\">//\t声明一个临时的二维向量</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    \t<span class=\"comment\">// 将矩阵转置, 放入临时的向量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; c; i++){</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span> ; j&lt; r; j++){</span><br><span class=\"line\">                new_m[i][j] = m[j][i];</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(r,c); <span class=\"comment\">//改变矩阵的行与列</span></span><br><span class=\"line\">        m = <span class=\"built_in\">move</span>(new_m); <span class=\"comment\">//使用 move 直接将临时变量的所有权交给m, 避免拷贝</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>此处值得注意的是 <code>resize</code>在二维向量中的使用, 以及 <code>move</code>直接给予“所有权”的特性.</p>\n</blockquote>\n<h2 id=\"HW5\"><a href=\"#HW5\" class=\"headerlink\" title=\"HW5\"></a>HW5</h2><p><strong>判断题</strong>: const成员函数不能作用于非const对象</p>\n<blockquote>\n<p>答案是 <strong>False</strong>. </p>\n<p>题目的意思大致是: 非const对象无法调用 const对象, 实际上是事实是相反的描述. 只需要理解题目的表述即可做出判断.</p>\n</blockquote>\n<h2 id=\"HW6\"><a href=\"#HW6\" class=\"headerlink\" title=\"HW6\"></a>HW6</h2><p>右值引用本身是一个左值, 可以取地址.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; r = <span class=\"number\">5</span>;</span><br><span class=\"line\">std::cout &lt;&lt; r; <span class=\"comment\">// r 在这里是左值，因为它有名字</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h2 id=\"HW7\"><a href=\"#HW7\" class=\"headerlink\" title=\"HW7\"></a>HW7</h2><h2 id=\"HW9\"><a href=\"#HW9\" class=\"headerlink\" title=\"HW9\"></a>HW9</h2><ol>\n<li><p>因为静态成员函数不能是虚函数，所以它们不能实现多态</p>\n<ul>\n<li>静态成员函数不与类的任何具体实例（对象）相关联;</li>\n</ul>\n</li>\n<li><p>在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类A</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"A的构造函数被调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类B</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">B</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"B的构造函数被调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类C，继承自A和B</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">public</span> A, <span class=\"keyword\">public</span> B</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数中显式调用基类构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">C</span>() : <span class=\"built_in\">B</span>(), <span class=\"built_in\">A</span>()</span><br><span class=\"line\">    { <span class=\"comment\">// 注意：这里虽然B在A之前，但实际调用顺序由类定义决定</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"C的构造函数被调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    C c; <span class=\"comment\">// 创建C的实例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>输出:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A的构造函数被调用</span><br><span class=\"line\">B的构造函数被调用</span><br><span class=\"line\">C的构造函数被调用</span><br></pre></td></tr></table></figure></div>\n\n<p>由此可见, 虽然在C的初始化列表中声明了B前A后, 但是实际上A优先调用.</p>\n</li>\n<li><p><del>如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针）</del></p>\n<ul>\n<li><p>这句话的括号内部是错误的.</p>\n</li>\n<li><p>因为我们依旧可以将其的子类 <code>upcast</code></p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ptr</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ptr</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    A *a = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>();</span><br><span class=\"line\">    a-&gt;<span class=\"built_in\">ptr</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>类内的纯虚函数被认为是 <code>inline</code>的函数;</p>\n</li>\n<li><p>在创建派生类的对象时, 构造函数的执行顺序为—— 基类对象-&gt;对象成员-&gt;派生类自身:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>() { cout &lt;&lt; <span class=\"string\">\"Base 构造函数\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Member</span>() { cout &lt;&lt; <span class=\"string\">\"Member 构造函数\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\">    Member m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>() { cout &lt;&lt; <span class=\"string\">\"Derived 构造函数\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>输出:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base 构造函数</span><br><span class=\"line\">Member 构造函数</span><br><span class=\"line\">Derived 构造函数</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>私有继承问题: 可以通过方法访问私有继承的public, protected的基类成员(不包括私有成员), 但是无法直接访问.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">1</span>; <span class=\"comment\">// 私有</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">2</span>; <span class=\"comment\">// 保护</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> c = <span class=\"number\">3</span>; <span class=\"comment\">// 公有</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">private</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> d = <span class=\"number\">4</span>; <span class=\"comment\">// 派生类自己的私有成员</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; a;  // ❌ 错误！Base 的私有成员 a，派生类根本不能访问</span></span><br><span class=\"line\">        cout &lt;&lt; b &lt;&lt; endl; <span class=\"comment\">// ✅ OK：Base 的 protected 成员，在 Derived 中变成了 private</span></span><br><span class=\"line\">        cout &lt;&lt; c &lt;&lt; endl; <span class=\"comment\">// ✅ OK：Base 的 public 成员，在 Derived 中变成了 private</span></span><br><span class=\"line\">        cout &lt;&lt; d &lt;&lt; endl; <span class=\"comment\">// ✅ OK：Derived 的私有成员当然能访问</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    d.<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; d.b; // ❌ 错误！Base 的 protected 成员，在 Derived 中变成了 private</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>虚函数也具有 <code>this</code> 指针.</p>\n</li>\n<li><p>在构造函数中调用虚函数，不是动态联编</p>\n<ul>\n<li>原因是：<strong>对象还未完全构造完成（或已经开始析构）时，虚函数表（vtable）可能尚未指向最终派生类</strong>.</li>\n<li>所以，在构造函数中调用虚函数时，<strong>只会调用当前类中该函数的版本</strong>，不会发生多态。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"虚析构函数-1\"><a href=\"#虚析构函数-1\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h4><ul>\n<li>为了在多重继承的时候, 可以正确的调用各个阶段的析构函数, 我们需要声明基类的析构为虚函数, 然后在子类中重写:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">virtual</span> ~<span class=\"built_in\">CRAFT</span>()</span><br><span class=\"line\">{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"销毁航行器(速度: \"</span> &lt;&lt; speed &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">~<span class=\"built_in\">PLANE</span>() <span class=\"keyword\">override</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"销毁飞机(翼展: \"</span> &lt;&lt; width &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<ul>\n<li><p>菱形继承的时候, 注意 <code>virtual public</code>的声明 以及 在底层的子类中的初始化列表的顺序!</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SEAPLANE</span>(<span class=\"type\">float</span> speed, <span class=\"type\">float</span> width, <span class=\"type\">float</span> depth) : <span class=\"built_in\">CRAFT</span>(speed), <span class=\"built_in\">PLANE</span>(speed, width), <span class=\"built_in\">SHIP</span>(speed, depth)</span><br><span class=\"line\">{</span><br><span class=\"line\">  ...</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h2 id=\"HW10\"><a href=\"#HW10\" class=\"headerlink\" title=\"HW10\"></a>HW10</h2><ul>\n<li>判断: 对象间赋值将调用拷贝构造函数。  <ul>\n<li>错误. 对象间的赋值调用的是 <u>拷贝复赋值运算符</u>.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"异常类\"><a href=\"#异常类\" class=\"headerlink\" title=\"异常类\"></a>异常类</h4><p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250423094724267.png?imageSlim\" alt=\"image-20250423094724267\"></p>\n<ul>\n<li><strong>A</strong>是错误的。C++允许自定义异常类，可以继承标准异常类如std::exception。</li>\n<li><strong>B</strong>是正确的，C++异常机制会在异常抛出前自动销毁局部对象。</li>\n<li><strong>C</strong>是正确的，抛出异常时对象会被拷贝（或移动）到catch块中。</li>\n<li><strong>D</strong>是正确的，在catch块中可以使用对象引用来接收异常对象。</li>\n</ul>\n<h4 id=\"赋值运算符重载\"><a href=\"#赋值运算符重载\" class=\"headerlink\" title=\"赋值运算符重载\"></a>赋值运算符重载</h4><ul>\n<li><p>语法:</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> 类名&amp; 对象名)</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>特点:</p>\n<ul>\n<li>返回类型是类的引用（为了支持连续赋值 a=b=c）</li>\n<li>参数是const引用（防止修改原对象）</li>\n<li>通常需要先释放自己的资源，再复制数据</li>\n</ul>\n</li>\n</ul>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Array&amp; a) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;a) {  <span class=\"comment\">// 防止自赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;  <span class=\"comment\">// 释放原有内存</span></span><br><span class=\"line\">        size = a.size;  <span class=\"comment\">// 复制大小</span></span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[size];  <span class=\"comment\">// 分配新内存</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {  <span class=\"comment\">// 复制数据</span></span><br><span class=\"line\">            data[i] = a.data[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 返回对象自身的引用</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h2 id=\"W12\"><a href=\"#W12\" class=\"headerlink\" title=\"W12\"></a>W12</h2><ul>\n<li>建立类模板对象的实例化过程为: <code>模板类-对象</code>.<ul>\n<li>编译器根据提供的模板参数将类模板实例化为一个具体的模板类（也称为实例化类或特化类），然后才能创建该模板类的对象。</li>\n<li>类模板的使用实际上是将类模板实例化成一个 <code>类</code></li>\n</ul>\n</li>\n<li>类模板与模板类<ul>\n<li>类模板是类的蓝图或规范，它本身不是一个类</li>\n<li>模板类（或实例化类、特化类）是使用具体的类型参数实例化类模板后得到的具体的类。</li>\n</ul>\n</li>\n<li>类模板和函数模板的实例化的时期 – 均为<code>编译时期</code><ul>\n<li>函数模板在编译时期检查定义中的基本语法;</li>\n<li>尝试调用某一个函数模板时, 编译器根据实际的参数类型来推导模板参数类型/或者由显式指定类型得到, 如果合法就生成函数实例(i.e. <em><strong>模板函数</strong></em>), 这个过程就是模板实例化(生成代码).</li>\n</ul>\n</li>\n<li>除了使用构造函数, 还可以直接调用 <code>make_pair</code> 让编译器自动推导类型来创建pair对象;</li>\n<li></li>\n</ul>\n<h2 id=\"L3\"><a href=\"#L3\" class=\"headerlink\" title=\"L3\"></a>L3</h2><blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li>内联函数在 <strong><u>编译时展开</u></strong>, 而不是运行时.</li>\n<li>内联函数的声明以及最终的生效与否, 是由 <strong><u>编译器</u></strong> 决定的. 也就是说, 无论是否存在 inline 的声明, 编译器最终决定函数的类型.</li>\n</ol>\n</blockquote>\n<h3 id=\"C-初始化列表与成员变量初始化\"><a href=\"#C-初始化列表与成员变量初始化\" class=\"headerlink\" title=\"C++ 初始化列表与成员变量初始化\"></a>C++ 初始化列表与成员变量初始化</h3><blockquote>\n<p>[!NOTE]</p>\n<ul>\n<li><code>int</code>和自己定义的类都是cpp的类, 所以可以直接在初始化列表中用 <code>:class_instance{input},...{}</code>来初始化类内的类对象.</li>\n<li>推荐使用 <code>{}</code>来初始化, 不会产生是函数的歧义.</li>\n</ul>\n</blockquote>\n<h4 id=\"1-构造顺序\"><a href=\"#1-构造顺序\" class=\"headerlink\" title=\"1. 构造顺序\"></a>1. 构造顺序</h4><ul>\n<li>在 C++ 中，<strong>成员变量的初始化顺序由它们在类中声明的顺序决定</strong>，而不是在初始化列表中的顺序。</li>\n<li>初始化列表用于 <strong>直接初始化</strong> 成员变量，而不是在构造函数体内先创建未初始化的对象再赋值。</li>\n</ul>\n<h4 id=\"2-为什么必须使用初始化列表？\"><a href=\"#2-为什么必须使用初始化列表？\" class=\"headerlink\" title=\"2. 为什么必须使用初始化列表？\"></a>2. 为什么必须使用初始化列表？</h4><ul>\n<li><strong>成员变量在进入构造函数体之前就已经完成了初始化</strong>，不能在构造函数体内赋值来替代初始化。</li>\n<li><strong>如果成员变量是一个没有默认构造函数的对象</strong>，必须在初始化列表中显式调用其构造函数，否则编译会报错。</li>\n<li>在构造函数体内赋值，意味着：<ol>\n<li>先调用默认构造函数创建对象（如果 <code>NumberDisplay</code> 没有默认构造函数，这一步会失败）。</li>\n<li>然后使用赋值运算符进行赋值，而赋值运算与初始化是不同的过程。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"3-示例代码\"><a href=\"#3-示例代码\" class=\"headerlink\" title=\"3. 示例代码\"></a>3. 示例代码</h4><h4 id=\"❌-错误示例（可能会编译失败）\"><a href=\"#❌-错误示例（可能会编译失败）\" class=\"headerlink\" title=\"❌ 错误示例（可能会编译失败）\"></a>❌ 错误示例（可能会编译失败）</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumberDisplay</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NumberDisplay</span>(<span class=\"type\">int</span> max) { <span class=\"comment\">/* 初始化代码 */</span> }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Clock</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    NumberDisplay hour_display;</span><br><span class=\"line\">    NumberDisplay minute_display;</span><br><span class=\"line\">    NumberDisplay second_display;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Clock</span>(<span class=\"type\">int</span> hour, <span class=\"type\">int</span> minute, <span class=\"type\">int</span> second) { <span class=\"comment\">// ❌ 错误：NumberDisplay 没有默认构造函数</span></span><br><span class=\"line\">        hour_display = <span class=\"built_in\">NumberDisplay</span>(<span class=\"number\">24</span>);     <span class=\"comment\">// 不能这样赋值</span></span><br><span class=\"line\">        minute_display = <span class=\"built_in\">NumberDisplay</span>(<span class=\"number\">60</span>);</span><br><span class=\"line\">        second_display = <span class=\"built_in\">NumberDisplay</span>(<span class=\"number\">60</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<h4 id=\"✅-正确示例\"><a href=\"#✅-正确示例\" class=\"headerlink\" title=\"✅ 正确示例\"></a><strong>✅ 正确示例</strong></h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Clock</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    NumberDisplay hour_display;</span><br><span class=\"line\">    NumberDisplay minute_display;</span><br><span class=\"line\">    NumberDisplay second_display;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 使用初始化列表</span></span><br><span class=\"line\">    <span class=\"built_in\">Clock</span>(<span class=\"type\">int</span> hour, <span class=\"type\">int</span> minute, <span class=\"type\">int</span> second)</span><br><span class=\"line\">        : <span class=\"built_in\">hour_display</span>(<span class=\"number\">24</span>), <span class=\"built_in\">minute_display</span>(<span class=\"number\">60</span>), <span class=\"built_in\">second_display</span>(<span class=\"number\">60</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 构造函数体内的代码可以进行额外的赋值操作</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p><strong>4. 结论</strong></p>\n<p>​\t•\t<strong>所有成员变量都会在构造函数体执行前被初始化</strong>，不能依赖在构造函数体内赋值。</p>\n<p>​\t•\t<strong>如果成员变量是没有默认构造函数的对象</strong>，必须使用初始化列表进行初始化，否则会导致编译错误。</p>\n<p>​\t•\t<strong>初始化列表的顺序应与成员变量的声明顺序一致</strong>，否则可能会导致未定义行为。</p>\n<h2 id=\"Project\"><a href=\"#Project\" class=\"headerlink\" title=\"Project\"></a>Project</h2><h3 id=\"P1\"><a href=\"#P1\" class=\"headerlink\" title=\"P1\"></a>P1</h3><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"\\\"\"</span> &lt;&lt; value &lt;&lt; <span class=\"string\">\"\\\"\"</span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>如果要输出引号, 需要加入 <code>\\</code>来进行转义!</p>\n<h4 id=\"使用匿名函数来排序\"><a href=\"#使用匿名函数来排序\" class=\"headerlink\" title=\"使用匿名函数来排序\"></a>使用匿名函数来排序</h4><div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(sortedRecords.<span class=\"built_in\">begin</span>(), sortedRecords.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">     [](<span class=\"type\">const</span> Record&amp; a, <span class=\"type\">const</span> Record&amp; b) {</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (a.qso_date != b.qso_date) <span class=\"keyword\">return</span> a.qso_date &lt; b.qso_date;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> a.time_on &lt; b.time_on;</span><br><span class=\"line\">     });</span><br></pre></td></tr></table></figure></div>\n\n<p><code>sort</code>是 <code>algorithm</code>头文件中的库函数, 支持原地排序.</p>\n<p>第三个参数是一个函数, 返回 <code>true</code>表示这个函数的第一个参数应该排在第二个参数的前面.</p>\n<p>比如此处, 使用了匿名函数 <code>[]</code>, 同时比较 <code>date</code>, 当 </p>\n<div class=\"code-container\" data-rel=\"Cpp\"><figure class=\"iseeu highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> a.qso_date &lt; b.qso_date;</span><br></pre></td></tr></table></figure></div>\n\n<p>指的是当前者的时间较小, 应该排在前面, 因此是升序.</p>\n<blockquote>\n<p>不要因为语句太长而忘记末尾的 <code>;</code>.</p>\n</blockquote>\n<h3 id=\"P2\"><a href=\"#P2\" class=\"headerlink\" title=\"P2\"></a>P2</h3><h4 id=\"思路分析\"><a href=\"#思路分析\" class=\"headerlink\" title=\"思路分析\"></a>思路分析</h4><ul>\n<li>整体设计:<ul>\n<li>程序随机生成一组设置, 然后用户开始输入</li>\n<li>大概率, 用户不可避免地会失败, 此时应当让用户选择是否继续参与这场游戏, 否则程序生成下一组的设置;</li>\n</ul>\n</li>\n<li>房间:<ul>\n<li>monster所在;</li>\n<li>princess所在</li>\n<li>lobby;</li>\n<li>普通的room</li>\n<li>具有毒药的房间(接触后限制之后行动的次数)</li>\n<li>解药房间(可以解除中毒的状态)</li>\n<li>地图房间(接触后可以通过输入 <code>map</code>来显示当前的位置)</li>\n</ul>\n</li>\n<li>房间个数: <ul>\n<li>每次都将上述的因素都加入, 不太合适, 因此需要用户输入游戏的类型/难度;</li>\n<li>经典模式: 只会产生monster, princess,lobby和普通房间. 房间的个数较少;</li>\n<li>挑战模式:  加入毒药, 解药和地图因素; 房间个数较多.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"刷题\"><a href=\"#刷题\" class=\"headerlink\" title=\"刷题\"></a>刷题</h2><ul>\n<li><p>Destructors can not be overloaded.</p>\n<ul>\n<li>因为析构函数没有任何的参数和返回类型, 无法重载.</li>\n</ul>\n</li>\n<li><p><strong>类的成员函数可以访问同类的私有成员，即使是其他对象的成员。</strong> 回顾类的私有边界不是相对于对象的, 而是类. </p>\n</li>\n<li><p>cpp中, 构造函数一定不能是 <code>virtual</code> 的! </p>\n</li>\n<li><p>静态变量需要再类的外部定义, 但是静态函数不一定.</p>\n</li>\n<li><p>“In C++， struct is actually the same thing as class， except for minor differences in usage.”</p>\n<ul>\n<li>这句话是正确的, 注意结构体也是支持继承的. 只是默认的继承方式也是 <code>public</code>.</li>\n</ul>\n</li>\n<li><p>In C++, inheritance allows a derived class to directly access all of the functions and data of its base class.（T/F）</p>\n<ul>\n<li>错误的. 对于 <code>public</code> 类型的继承, 依旧无法直接访问父类的私有成员, 只能通过子类的方法来间接访问.</li>\n</ul>\n</li>\n<li><p>下面的代码段, 能够能够通过编译, 但是存在运行时的错误(越界访问):</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{ vector&lt;<span class=\"type\">float</span>&gt; v; v[<span class=\"number\">0</span>] = <span class=\"number\">2.5</span>; }</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>编译器在编译时候, 检查的主要是程序的语法和类型;</li>\n<li>越界访问的问题存在于运行时检测.</li>\n</ul>\n</li>\n<li><p>64位系统系统环境, 按照8个字节进行对齐:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参考的类定义方式</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A1</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>{}</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他的类型定义</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>Output:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Size of <span class=\"title\">A1</span> <span class=\"params\">(non - <span class=\"keyword\">virtual</span> function with <span class=\"type\">int</span> member)</span>: <span class=\"number\">4</span> bytes</span></span><br><span class=\"line\"><span class=\"function\">Size of A2 (virtual function with int member): <span class=\"number\">16</span> bytes</span></span><br><span class=\"line\"><span class=\"function\">Size of A3 (non - virtual function without int member): <span class=\"number\">1</span> bytes</span></span><br><span class=\"line\"><span class=\"function\">Size of A4 (virtual function without int member): <span class=\"number\">8</span> bytes</span></span><br><span class=\"line\"><span class=\"function\">Size of B (derived from A1): <span class=\"number\">8</span> bytes</span></span><br></pre></td></tr></table></figure></div>\n\n<p>主要注意2点:</p>\n<ol>\n<li><p>没有任何成员的类, 也占用1个字节的大小;</p>\n</li>\n<li><p>4+8 将会对齐得到16个字节的空间大小.</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p><code>void*</code> 和 <code>int*</code> 的大小相同! (题目通常给出 <code>int*</code>的大小, 然后给出虚函数)</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p><code>malloc</code> 不会调用对象的构造函数, 仅仅分配内存, 并不涉及对象的初始化;</p>\n<ul>\n<li><p><code>new</code>会调用构造函数</p>\n</li>\n<li><p><code>malloc</code> 需要显式地类型转换:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>() { std::cout &lt;&lt; <span class=\"string\">\"Constructor called!\"</span> &lt;&lt; std::endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass* p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">MyClass</span>();  <span class=\"comment\">// 输出 \"Constructor called!\"</span></span><br><span class=\"line\">MyClass* p2 = (MyClass*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(MyClass));  <span class=\"comment\">// 无输出，构造函数未调用</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n<li><p><code>new</code> 是CPP的运算符, 可以重载; <code>malloc</code>是标准库的函数, 无法重载.</p>\n</li>\n<li><p>每个类最多具有一个析构函数</p>\n</li>\n</ul>\n<h4 id=\"重载问题\"><a href=\"#重载问题\" class=\"headerlink\" title=\"重载问题\"></a>重载问题</h4><p>在 <code>::</code>, <code>()</code> 和 <code>-&gt;</code>中, 只有 <code>-&gt;</code>可以被重载:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Hello from MyClass!\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyPtr</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    MyClass* ptr;  <span class=\"comment\">// 内部存储一个原生指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyPtr</span>(MyClass* p) : <span class=\"built_in\">ptr</span>(p) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重载 -&gt; 运算符</span></span><br><span class=\"line\">    MyClass* <span class=\"keyword\">operator</span>-&gt;() {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ptr;  <span class=\"comment\">// 返回原生指针，使得可以继续用 -&gt; 访问成员</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    MyClass obj;</span><br><span class=\"line\">    <span class=\"function\">MyPtr <span class=\"title\">myPtr</span><span class=\"params\">(&amp;obj)</span></span>;  <span class=\"comment\">// 用 MyPtr 包装 MyClass 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    myPtr-&gt;<span class=\"built_in\">sayHello</span>();  <span class=\"comment\">// 调用 MyClass 的成员函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"new与对象转换\"><a href=\"#new与对象转换\" class=\"headerlink\" title=\"new与对象转换\"></a>new与对象转换</h4><div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>) : <span class=\"built_in\">x</span>(x) {}</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">B</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getx</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> x; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">B</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>) : <span class=\"built_in\">A</span>(x) { <span class=\"keyword\">this</span>-&gt;x++; }</span><br><span class=\"line\">    <span class=\"built_in\">B</span>(<span class=\"type\">const</span> B &amp;b) : <span class=\"built_in\">A</span>(b.x) { <span class=\"keyword\">this</span>-&gt;x++; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">A::<span class=\"keyword\">operator</span> <span class=\"title\">B</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> *<span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(x + <span class=\"number\">1</span>); } <span class=\"comment\">// 特别注意此处</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    A *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(<span class=\"number\">3</span>); <span class=\"comment\">// new的时候触发B的构造函数, 自增</span></span><br><span class=\"line\">    A *p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">A</span>(<span class=\"number\">9</span>);</span><br><span class=\"line\">    B b0 = *p1; <span class=\"comment\">// 发生了A类对象向B类对象的转化, 详见下面两行:</span></span><br><span class=\"line\">    <span class=\"comment\">// *p1 将要转化的时候,  先传入x+1作为B的初始化参数输入,</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后new将触发B的构造函数, 最后返回, 返回结果用于初始化b0, 继续触发拷贝构造函数</span></span><br><span class=\"line\">    B &amp;r = b0;</span><br><span class=\"line\">    B b1 = b0;  <span class=\"comment\">// 发生了 B类对象的拷贝构造, b1的x为8, 但是不会改变b0的x=7</span></span><br><span class=\"line\">    B b2 = *p2; <span class=\"comment\">// 这一步的转换与上面的同理. 也是+3</span></span><br><span class=\"line\">    cout &lt;&lt; p1-&gt;<span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; p2-&gt;<span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b<span class=\"number\">0.</span><span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; r.<span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b<span class=\"number\">1.</span><span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b<span class=\"number\">2.</span><span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>解题过程中的关键步骤已经写在注释当中, 最后的输出是:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">12</span></span><br></pre></td></tr></table></figure></div>\n\n<p>梳理考察的重要知识点:</p>\n<ol>\n<li><p>upcast的时候, 是子类的属性赋值给父类, 包括虚函数表. 因此, 此时看作是父类的对象, 但是虚函数能够动态绑定.</p>\n</li>\n<li><p><code>new</code>和<code>delete</code>分别自动调用类的构造函数和析构函数;</p>\n</li>\n<li><p><code>A::operator B()</code> 形式表示A类对象如何转换成B类型对象的, 在发生转换的时候自动调用这部分的函数.</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(<span class=\"number\">3</span>); <span class=\"comment\">// 拷贝构造的时候直接自增为4</span></span><br><span class=\"line\">A *p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">A</span>(<span class=\"number\">9</span>);</span><br></pre></td></tr></table></figure></div>\n\n<p>注意上面的指针都指向A类的对象.</p>\n</li>\n</ol>\n<h4 id=\"链式的析构顺序\"><a href=\"#链式的析构顺序\" class=\"headerlink\" title=\"链式的析构顺序\"></a>链式的析构顺序</h4><ul>\n<li>构造顺序: 父类-&gt;成员对象-&gt; 自身</li>\n<li>析构顺序: 自身-&gt; 成员对象-&gt; 父类</li>\n</ul>\n<p>下面的这道题目涉及的类的关系如下:</p>\n<ol>\n<li>P是父类, S是子类;</li>\n<li>P内部有两个P类型的指针成员.</li>\n</ol>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 先声明基类 P</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">P</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">bool</span> flag; <span class=\"comment\">// 静态成员声明</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x;            <span class=\"comment\">// 数据成员</span></span><br><span class=\"line\">    P *left, *right;  <span class=\"comment\">// 指针成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">P</span>(P *left = <span class=\"literal\">nullptr</span>, P *right = <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        : <span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">left</span>(left), <span class=\"built_in\">right</span>(right) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 虚析构函数（因为有继承关系，应该是虚函数）</span></span><br><span class=\"line\">    ~<span class=\"built_in\">P</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> left;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> right;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> right;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> left;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"P\"</span> &lt;&lt; x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 静态成员的定义（必须在类外定义）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> P::flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 派生类 S</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">S</span> : <span class=\"keyword\">public</span> P</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数，调用基类构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">S</span>(P *left = <span class=\"literal\">nullptr</span>, P *right = <span class=\"literal\">nullptr</span>) : <span class=\"built_in\">P</span>(left, right) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">S</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"S\"</span> &lt;&lt; x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    S *p1 = <span class=\"keyword\">new</span> S;</span><br><span class=\"line\">    p1-&gt;x = <span class=\"number\">1</span>; <span class=\"comment\">// 设置第一个节点的值</span></span><br><span class=\"line\">    S *p2 = <span class=\"keyword\">new</span> S;</span><br><span class=\"line\">    p2-&gt;x = <span class=\"number\">2</span>;   <span class=\"comment\">// 设置第二个节点的值</span></span><br><span class=\"line\">    <span class=\"function\">S <span class=\"title\">s</span><span class=\"params\">(p1, p2)</span></span>; <span class=\"comment\">// 创建根节点，连接p1和p2</span></span><br><span class=\"line\">    s.x = <span class=\"number\">3</span>;     <span class=\"comment\">// 设置根节点的值/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 程序结束时析构对象</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<p>最终的输出:</p>\n<ol>\n<li>析构s, 首先析构子类自身, 调用s的析构函数, 输出s;</li>\n<li>然后析构父类, 父类是P, 析构的时候直接调用自身的析构函数, 一词析构右指针和左指针;</li>\n<li>执行到末尾, 输出自身的P3.</li>\n</ol>\n<p>Output:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S3P2P1P3</span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n\n\n<h4 id=\"操作符的重载\"><a href=\"#操作符的重载\" class=\"headerlink\" title=\"操作符的重载\"></a>操作符的重载</h4><div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXN 110</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your answer will be inserted here. Feel free to add anything needed here.*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">vec</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> first, second;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vec</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) : <span class=\"built_in\">first</span>(a), <span class=\"built_in\">second</span>(b) {}</span><br><span class=\"line\">    <span class=\"comment\">//  &lt; 的重载</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> vec &amp;other) <span class=\"type\">const</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> second &lt; other.second;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 类型转换的重载</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">double</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(first);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出的重载</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> std::ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(std::ostream &amp;os, <span class=\"type\">const</span> vec &amp;v)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> os &lt;&lt; <span class=\"string\">\"(\"</span> &lt;&lt; v.first &lt;&lt; <span class=\"string\">\",\"</span> &lt;&lt; v.second &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printArrayInfo</span><span class=\"params\">(vec **arr, <span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    vec *maxv = arr[<span class=\"number\">0</span>], *minv = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">double</span> avg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        vec *val = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*val &lt; *minv)</span><br><span class=\"line\">            minv = val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*maxv &lt; *val)</span><br><span class=\"line\">            maxv = val;</span><br><span class=\"line\">        avg = avg + <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(*val);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    avg /= n;</span><br><span class=\"line\">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class=\"built_in\">setprecision</span>(<span class=\"number\">2</span>) &lt;&lt; <span class=\"string\">\"min = \"</span> &lt;&lt; *minv &lt;&lt; <span class=\"string\">\", max = \"</span> &lt;&lt; *maxv &lt;&lt; <span class=\"string\">\", avg = \"</span> &lt;&lt; avg &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    vec *pool[MAXN];</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> a, b;</span><br><span class=\"line\">    std::cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        pool[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">vec</span>(a, b);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printArrayInfo</span>(pool, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"菱形继承与二义性问题\"><a href=\"#菱形继承与二义性问题\" class=\"headerlink\" title=\"菱形继承与二义性问题\"></a>菱形继承与二义性问题</h4><p>并不是菱形继承的操作都会导致二义性, 要从本质–访问的操作是否导致无法区分正确的单独对象?</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>() : <span class=\"built_in\">x</span>(<span class=\"number\">6</span>) {}</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A::<span class=\"built_in\">fun</span>() + x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A::<span class=\"built_in\">fun</span>() + x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> B::<span class=\"built_in\">fun</span>() + C::<span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    D d;</span><br><span class=\"line\">    cout &lt;&lt; d.<span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; d.A::fun(); 存在二义性的问题, 因为在D当中分别存在来自于B和C的这个函数!</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>在上面代码中, D是菱形继承, 但是可以直接访问d的fun, 因为在d的fun中涉及的是B和C自己的fun. 而后者又能够直接调用自己的继承自A的fun</p>\n<ul>\n<li>无法直接调用 <code>d.A::fun()</code>, 参见注释.</li>\n</ul>\n<h1 id=\"最后的枚举\"><a href=\"#最后的枚举\" class=\"headerlink\" title=\"最后的枚举\"></a>最后的枚举</h1><h4 id=\"转换运算符\"><a href=\"#转换运算符\" class=\"headerlink\" title=\"转换运算符\"></a>转换运算符</h4><p><code>A::operator B()</code>的含义： 定义了如何将 <code>A</code> 类型的对象转换为 <code>B</code> 类型的对象。</p>\n<ul>\n<li><code>A::</code> 表示这是 <code>A</code> 类的成员函数</li>\n<li><code>operator B</code> 表示这是一个到 <code>B</code> 类型的转换运算符</li>\n<li><code>()</code> 表示这是一个函数</li>\n</ul>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A 具有一个成员变量且在构造函数中可以赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">A::<span class=\"keyword\">operator</span> <span class=\"title\">B</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> *<span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(x + <span class=\"number\">1</span>); }</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><code>new B(x + 1)</code> 创建一个新的 <code>B</code> 对象，其中 <code>x</code> 是 <code>A</code> 类的成员变量</li>\n<li><code>*</code> 解引用这个新创建的对象</li>\n<li>返回这个 <code>B</code> 类型的对象</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>注意, 这只是决定了B类对象的如何构造, 并不会影响A类对象本身.</p>\n</blockquote>\n<p>调用的场景: 需要将A类型的对象转换为B类型的对象 e.g.——</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">A <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">B b = a;  <span class=\"comment\">// 这里会自动调用 A::operator B()</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h2 id=\"const相关\"><a href=\"#const相关\" class=\"headerlink\" title=\"const相关\"></a>const相关</h2><h3 id=\"对象与方法的对应\"><a href=\"#对象与方法的对应\" class=\"headerlink\" title=\"对象与方法的对应\"></a>对象与方法的对应</h3><p>C++在选择成员函数时会考虑对象的const属性：</p>\n<ul>\n<li><p>const对象只能调用const成员函数 </p>\n</li>\n<li><p>非const对象优先调用非const版本，如果没有非const版本才会调用const版本</p>\n</li>\n<li><blockquote>\n<p>[!NOTE]</p>\n<p>函数定义的顺序并不会影响调用的选择!</p>\n</blockquote>\n</li>\n</ul>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">2</span> &lt;&lt; endl</span><br><span class=\"line\">             &lt;&lt; val &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{ cout &lt;&lt; <span class=\"number\">1</span> &lt;&lt; endl</span><br><span class=\"line\">                              &lt;&lt; val &lt;&lt; endl; }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> MyClass <span class=\"title\">obj1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">obj2</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">    obj<span class=\"number\">1.</span><span class=\"built_in\">Print</span>();</span><br><span class=\"line\">    obj<span class=\"number\">2.</span><span class=\"built_in\">Print</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p>output:</p>\n<div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">20</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n<h2 id=\"初始化先后的问题\"><a href=\"#初始化先后的问题\" class=\"headerlink\" title=\"初始化先后的问题\"></a>初始化先后的问题</h2><p>C++中对象的初始化和销毁顺序遵循特定的规则，这对于理解程序行为和避免内存问题至关重要</p>\n<h3 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h3><h3 id=\"类的构造与析构顺序\"><a href=\"#类的构造与析构顺序\" class=\"headerlink\" title=\"类的构造与析构顺序\"></a>类的构造与析构顺序</h3><p>在C++中，对象的构造和析构顺序遵循以下规则：</p>\n<ol>\n<li><p><strong>构造顺序</strong>：</p>\n<ul>\n<li>基类先于派生类构造</li>\n<li>成员变量按声明顺序构造</li>\n<li>基类构造完成后，才执行派生类构造函数体</li>\n<li><blockquote>\n<p>[!NOTE]</p>\n<p>对象在调用构造函数之前, 首先完成内部成员对象的构造</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>析构顺序</strong>：</p>\n<ul>\n<li>与构造顺序相反</li>\n<li>先执行派生类析构函数体</li>\n<li>然后按声明顺序的逆序析构成员变量</li>\n<li>最后析构基类</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"示例分析\"><a href=\"#示例分析\" class=\"headerlink\" title=\"示例分析\"></a>示例分析</h4><div class=\"code-container\" data-rel=\"C++\"><figure class=\"iseeu highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Child c;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h5 id=\"类层次结构\"><a href=\"#类层次结构\" class=\"headerlink\" title=\"类层次结构\"></a>类层次结构</h5><div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X (基础类)</span><br><span class=\"line\">↑</span><br><span class=\"line\">Y (继承自X)</span><br><span class=\"line\"></span><br><span class=\"line\">Parent (包含X成员)</span><br><span class=\"line\">↑</span><br><span class=\"line\">Child (继承自Parent，包含Y成员)</span><br></pre></td></tr></table></figure></div>\n\n<h5 id=\"构造过程分析\"><a href=\"#构造过程分析\" class=\"headerlink\" title=\"构造过程分析\"></a>构造过程分析</h5><p>当创建<code>Child</code>对象时，构造顺序为：</p>\n<ol>\n<li>首先构造基类<code>Parent</code><ul>\n<li>在<code>Parent</code>构造前，先构造其成员<code>x</code>（调用<code>X::X()</code>）</li>\n<li>然后执行<code>Parent</code>构造函数体（输出”Parent::Parent()”）</li>\n</ul>\n</li>\n<li>基类构造完成后，构造<code>Child</code>的成员<code>y</code><ul>\n<li>在构造<code>y</code>前，先构造其基类部分（调用<code>X::X()</code>）</li>\n<li>然后执行<code>Y</code>构造函数体（输出”Y::Y()”）</li>\n</ul>\n</li>\n<li>最后执行<code>Child</code>构造函数体（输出”Child::Child()”）</li>\n</ol>\n<h5 id=\"析构过程分析\"><a href=\"#析构过程分析\" class=\"headerlink\" title=\"析构过程分析\"></a>析构过程分析</h5><p>当<code>Child</code>对象离开作用域时，析构顺序为：</p>\n<ol>\n<li>首先执行<code>Child</code>析构函数体（输出”Child::~Child()”）</li>\n<li>然后析构成员<code>y</code><ul>\n<li>先执行<code>Y</code>析构函数体（输出”Y::~Y()”）</li>\n<li>然后析构其基类部分（调用<code>X::~X()</code>）</li>\n</ul>\n</li>\n<li>最后析构基类<code>Parent</code><ul>\n<li>先执行<code>Parent</code>析构函数体（输出”Parent::~Parent()”）</li>\n<li>然后析构其成员<code>x</code>（调用<code>X::~X()</code>）</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"预期输出\"><a href=\"#预期输出\" class=\"headerlink\" title=\"预期输出\"></a>预期输出</h4><p>执行<code>test.cpp</code>程序时，预期输出为：</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X::X()              // Parent的成员x构造</span><br><span class=\"line\">Parent::Parent()    // Parent构造函数体</span><br><span class=\"line\">X::X()              // Y的基类部分构造</span><br><span class=\"line\">Y::Y()              // Y构造函数体</span><br><span class=\"line\">Child::Child()      // Child构造函数体</span><br><span class=\"line\">Child::~Child()     // Child析构函数体</span><br><span class=\"line\">Y::~Y()             // Y析构函数体</span><br><span class=\"line\">X::~X()             // Y的基类部分析构</span><br><span class=\"line\">Parent::~Parent()   // Parent析构函数体</span><br><span class=\"line\">X::~X()             // Parent的成员x析构</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"重要注意事项\"><a href=\"#重要注意事项\" class=\"headerlink\" title=\"重要注意事项\"></a>重要注意事项</h4><ol>\n<li><p><strong>虚析构函数</strong>：当使用多态时，基类应该有虚析构函数，确保正确调用派生类析构函数。</p>\n</li>\n<li><p><strong>成员初始化列表</strong>：推荐使用成员初始化列表而非在构造函数体内赋值，这样可以直接初始化而非先默认构造再赋值。</p>\n</li>\n<li><p><strong>异常安全</strong>：构造过程中如果抛出异常，已构造的成员会被正确析构，但未完全构造的对象不会调用析构函数。</p>\n</li>\n<li><p><strong>RAII原则</strong>：资源获取即初始化，在构造函数中获取资源，在析构函数中释放资源，确保资源管理安全。</p>\n</li>\n</ol>\n<h4 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h4><p>理解对象生命周期对以下场景尤为重要：</p>\n<ol>\n<li><strong>资源管理</strong>：确保资源在不再需要时被释放</li>\n<li><strong>依赖关系处理</strong>：确保依赖对象在被依赖对象之前构造，之后析构</li>\n<li><strong>继承层次设计</strong>：合理设计基类和派生类的构造和析构行为</li>\n</ol>\n","more":"<h4 id=\"导论\"><a href=\"#导论\" class=\"headerlink\" title=\"导论\"></a>导论</h4><p>编译时, 从<code>c</code>的<code>gcc</code>转变为了<code>g++</code>.</p>\n<p>OOP的三大特点:</p>\n<ul>\n<li>封装</li>\n<li>继承</li>\n<li>多态</li>\n</ul>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><p>在C语言中,我们主要使用<code>malloc()</code>和<code>free()</code>来进行动态内存管理。但这种方式存在一些问题:</p>\n<ul>\n<li>它不会调用构造函数和析构函数,返回的是void*指针需要强制类型转换;</li>\n<li>容易发生内存泄漏.</li>\n</ul>\n<p>为了更好地支持面向对象编程并提供更安全的内存管理机制,C++引入了<code>new</code>和<code>delete</code>.</p>\n<p>new的基本语法十分直观:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type* pointer = <span class=\"keyword\">new</span> Type;           <span class=\"comment\">// 分配单个对象</span></span><br><span class=\"line\">Type* pointer = <span class=\"keyword\">new</span> Type[size];     <span class=\"comment\">// 分配对象数组</span></span><br></pre></td></tr></table></figure>\n\n<p>可以在创建时进行初始化:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">5</span>);              <span class=\"comment\">// 初始化为5</span></span><br><span class=\"line\">string* p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">string</span>(<span class=\"string\">\"hello\"</span>);   <span class=\"comment\">// 初始化为\"hello\"</span></span><br></pre></td></tr></table></figure>\n\n<p>也可以根据变量进行动态的内存分配:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> size;</span><br><span class=\"line\">cin &gt;&gt; size;</span><br><span class=\"line\"><span class=\"type\">int</span>* arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[size];  <span class=\"comment\">// 根据输入分配内存</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>[!NOTE]</p>\n<p>Use <code>delete ［］</code> if <code>new ［］</code> was used to allocate an array.</p>\n</blockquote>\n<h1 id=\"输入输出流\"><a href=\"#输入输出流\" class=\"headerlink\" title=\"输入输出流\"></a>输入输出流</h1><p>通过包含头文件 – <code>#include &lt;iostream&gt;</code> 来使用输入输出流 <code>cin</code> 和 <code>cout</code>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> age; </span><br><span class=\"line\">    cin &gt;&gt; age;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"You are \"</span> &lt;&lt; age &lt;&lt; <span class=\"string\">\" years old\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"comment\">// endl 是换行符</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>cin</code>读取字符串时以空白字符（空格、制表符、换行符等）作为分隔符:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str=<span class=\"string\">\"Hello world!\"</span>;</span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">fout</span><span class=\"params\">(<span class=\"string\">\"out.txt\"</span>)</span></span>;</span><br><span class=\"line\">fout&lt;&lt;str&lt;&lt;endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">fin</span><span class=\"params\">(<span class=\"string\">\"out.txt\"</span>)</span></span>;</span><br><span class=\"line\">string str1,str2;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 读取文件中的两个字符串</span></span><br><span class=\"line\">fin&gt;&gt;str1&gt;&gt;str2; </span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl &lt;&lt; str2 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出:</span></span><br><span class=\"line\"><span class=\"comment\">// Hello</span></span><br><span class=\"line\"><span class=\"comment\">// world!</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"文件流\"><a href=\"#文件流\" class=\"headerlink\" title=\"文件流\"></a>文件流</h2><h3 id=\"输入输出流基础\"><a href=\"#输入输出流基础\" class=\"headerlink\" title=\"输入输出流基础\"></a>输入输出流基础</h3><ul>\n<li>头文件: <code>#include &lt;fstream&gt;</code></li>\n<li>类: <code>ifstream</code>(输入流), <code>ofstream</code>(输出流)</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fstream&gt;</span>  <span class=\"comment\">// 需要包含这个头文件</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件输出（写入文件）</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outFile</span><span class=\"params\">(<span class=\"string\">\"output.txt\"</span>)</span></span>;</span><br><span class=\"line\">outFile &lt;&lt; <span class=\"string\">\"Hello World\"</span> &lt;&lt; endl;</span><br><span class=\"line\">outFile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 文件输入（读取文件）</span></span><br><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">inFile</span><span class=\"params\">(<span class=\"string\">\"input.txt\"</span>)</span></span>; </span><br><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"built_in\">getline</span>(inFile, line);</span><br><span class=\"line\">inFile.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure>\n<ul>\n<li>写入文件时, 如果没有文件, 会自动创建.</li>\n</ul>\n<h3 id=\"常用操作示例\"><a href=\"#常用操作示例\" class=\"headerlink\" title=\"常用操作示例\"></a>常用操作示例</h3><ol>\n<li><strong>写入文件</strong></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ofstream outFile;</span><br><span class=\"line\">outFile.<span class=\"built_in\">open</span>(<span class=\"string\">\"test.txt\"</span>);  <span class=\"comment\">// 打开文件</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (outFile.<span class=\"built_in\">is_open</span>()) {   <span class=\"comment\">// 检查是否成功打开</span></span><br><span class=\"line\">    outFile &lt;&lt; <span class=\"string\">\"第一行\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    outFile &lt;&lt; <span class=\"string\">\"第二行\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    outFile.<span class=\"built_in\">close</span>();       <span class=\"comment\">// 完成后关闭文件</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>**读取文件 **</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">inFile</span><span class=\"params\">(<span class=\"string\">\"test.txt\"</span>)</span></span>;</span><br><span class=\"line\">string line;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (<span class=\"built_in\">getline</span>(inFile, line)) {  <span class=\"comment\">// 逐行读取</span></span><br><span class=\"line\">    cout &lt;&lt; line &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\">inFile.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li><strong>以追加模式打开文件</strong></li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outFile</span><span class=\"params\">(<span class=\"string\">\"test.txt\"</span>, ios::app)</span></span>;  <span class=\"comment\">// app 表示追加模式</span></span><br><span class=\"line\">outFile &lt;&lt; <span class=\"string\">\"这行会被添加到文件末尾\"</span> &lt;&lt; endl;</span><br><span class=\"line\">outFile.<span class=\"built_in\">close</span>();</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"文件打开模式\"><a href=\"#文件打开模式\" class=\"headerlink\" title=\"文件打开模式\"></a>文件打开模式</h3><ul>\n<li><code>ios::in</code> - 读取模式</li>\n<li><code>ios::out</code> - 写入模式</li>\n<li><code>ios::app</code> - 追加模式</li>\n<li><code>ios::ate</code> - 打开文件后立即定位到文件末尾</li>\n<li><code>ios::binary</code> - 二进制模式</li>\n<li><code>ios::trunc</code> - 如果文件存在则<strong>截断</strong>文件<ul>\n<li>如果文件已经存在，那么会清空该文件的所有内容，使其变成一个空文件. 然后重新写入内容.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 假设 test.txt 原本内容是:</span></span><br><span class=\"line\"><span class=\"comment\">// Hello World</span></span><br><span class=\"line\"><span class=\"comment\">// This is a test</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 trunc 模式打开</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outFile</span><span class=\"params\">(<span class=\"string\">\"test.txt\"</span>, ios::out | ios::trunc)</span></span>;  </span><br><span class=\"line\">outFile &lt;&lt; <span class=\"string\">\"新的内容\"</span> &lt;&lt; endl;</span><br><span class=\"line\">outFile.<span class=\"built_in\">close</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 现在 test.txt 的内容只有:</span></span><br><span class=\"line\"><span class=\"comment\">// 新的内容</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p> 或直接用 <code>ios::out</code>，因为out默认包含trunc</p>\n</blockquote>\n<ul>\n<li>使用位或运算符<code>|</code>来同时指定多个模式:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 组合使用打开模式</span></span><br><span class=\"line\"><span class=\"function\">ofstream <span class=\"title\">outFile</span><span class=\"params\">(<span class=\"string\">\"test.txt\"</span>, ios::out | ios::app)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ifstream <span class=\"title\">inFile</span><span class=\"params\">(<span class=\"string\">\"nonexistent.txt\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (!inFile) {</span><br><span class=\"line\">    cerr &lt;&lt; <span class=\"string\">\"无法打开文件！\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或者使用is_open()</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!inFile.<span class=\"built_in\">is_open</span>()) {</span><br><span class=\"line\">    cerr &lt;&lt; <span class=\"string\">\"无法打开文件！\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><h2 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h2><p>需要先引入指定的头文件:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>定义时可以使用等号或者用括号包裹字符串:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string name = <span class=\"string\">\"John\"</span>; </span><br><span class=\"line\"><span class=\"comment\">// string name(\"John\");</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h3 id=\"stringstream\"><a href=\"#stringstream\" class=\"headerlink\" title=\"stringstream\"></a>stringstream</h3><p><code>stringstream</code> 表示<strong>双向</strong>字符串流:</p>\n<ul>\n<li>需要导入头文件<code>#include &lt;sstream&gt;</code>;</li>\n<li><code>istringstream</code> 表示<strong>输入</strong>字符串流<ul>\n<li>作用: 将字符串转换成一个类似于输入流的对象;</li>\n<li>内部维护了一个字符串和一个位置指针;</li>\n<li>每次读取时, 位置指针向后移动, 且自动跳过空白字符.</li>\n</ul>\n</li>\n<li><code>ostringstream</code> 表示<strong>输出</strong>字符串流.</li>\n</ul>\n<h4 id=\"字符串分词\"><a href=\"#字符串分词\" class=\"headerlink\" title=\"字符串分词\"></a>字符串分词</h4><p>自动以<strong>空白字符</strong>(空格、制表符\\t、换行符\\n等)分割字符串;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">name</span> <span class=\"params\">( <span class=\"string\">\"Xiao Ming\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用括号包字符串</span></span><br><span class=\"line\">    <span class=\"function\">istringstream <span class=\"title\">is</span> <span class=\"params\">(name)</span></span>; </span><br><span class=\"line\">    string s;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (is&gt;&gt;s){</span><br><span class=\"line\">        cout &lt;&lt; s &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>&gt;&gt;</code> 表示从输入流中读取数据;</p>\n<p>注意字符串流也是一种类型, 作用的对象是字符串.</p>\n</blockquote>\n<p>Output:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Xiao Ming</span><br><span class=\"line\">Xiao</span><br><span class=\"line\">Ming</span><br></pre></td></tr></table></figure>\n\n<p>包含更多分词的字符串:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    string words = <span class=\"string\">\"hello \\n world! \\t I am \\n here!\"</span>;</span><br><span class=\"line\">    <span class=\"function\">stringstream <span class=\"title\">is</span> <span class=\"params\">(words)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    string word;</span><br><span class=\"line\">    <span class=\"type\">int</span> count  = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(is &gt;&gt; word){</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Word \"</span> &lt;&lt; count &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Word 1: hello</span><br><span class=\"line\">Word 2: world!</span><br><span class=\"line\">Word 3: I</span><br><span class=\"line\">Word 4: am</span><br><span class=\"line\">Word 5: here!</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符串拼接\"><a href=\"#字符串拼接\" class=\"headerlink\" title=\"字符串拼接\"></a>字符串拼接</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    ostringstream oss;</span><br><span class=\"line\">    string name = <span class=\"string\">\"Alice\"</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    oss &lt;&lt; <span class=\"string\">\"Name: \"</span> &lt;&lt; name &lt;&lt; <span class=\"string\">\", Age: \"</span> &lt;&lt; age;</span><br><span class=\"line\">    string result = oss.<span class=\"built_in\">str</span>();</span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Name: Alice, Age: 25</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>通过<code>.str()</code>方法可以对象转换为字符串类型, 从而<strong>格式化输出</strong>.</p>\n</blockquote>\n<br>\n\n<p><code>.str(\"\")</code>方法可以<strong>清空</strong>字符串流:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    ostringstream oss;</span><br><span class=\"line\">    string name = <span class=\"string\">\"Alice\"</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> age = <span class=\"number\">25</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    oss &lt;&lt; <span class=\"string\">\"Name: \"</span> &lt;&lt; name &lt;&lt; <span class=\"string\">\", Age: \"</span> &lt;&lt; age;</span><br><span class=\"line\">    oss.<span class=\"built_in\">str</span>(<span class=\"string\">\"\"</span>);</span><br><span class=\"line\">    string result = oss.<span class=\"built_in\">str</span>();</span><br><span class=\"line\">    cout &lt;&lt; result &lt;&lt; <span class=\"string\">\"Nothing\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>Output:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Nothing</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Getline\"><a href=\"#Getline\" class=\"headerlink\" title=\"Getline\"></a>Getline</h3><p><strong>基本语法:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">getline</span>(istream&amp; is, string&amp; str, <span class=\"type\">char</span> delim = <span class=\"string\">'\\n'</span>);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>is</code>: 输入流（通常是cin;</li>\n<li><code>str</code>: 存储结果的字符串;</li>\n<li><code>delim</code>: 分隔符, 默认为换行符<code>\\n</code>.</li>\n</ul>\n<p><strong>Example</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"请输入一行文本：\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin, line);  <span class=\"comment\">// 读取整行，包括空格</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"你输入的是：\"</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用自定义分隔符</span></span><br><span class=\"line\">    string data;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"请输入内容（用,分隔）：\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin, data, <span class=\"string\">','</span>);  <span class=\"comment\">// 读取直到遇到逗号</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"读取到逗号前的内容：\"</span> &lt;&lt; data &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"cin\"><a href=\"#cin\" class=\"headerlink\" title=\"cin\"></a>cin</h3><p><strong>特点</strong>:</p>\n<ul>\n<li>以空白字符（空格、制表符、换行符）为分隔符;</li>\n<li><strong>忽略</strong>前导空白字符;</li>\n<li>遇到空白字符就停止读取.</li>\n</ul>\n<p>通常需要与<code>getchar()</code>方法配合来清除缓冲区当中的<code>\\n</code>字符:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> number;</span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"输入一个数字：\"</span>;</span><br><span class=\"line\">    cin &gt;&gt; number;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//清除输入缓冲区中的换行符</span></span><br><span class=\"line\">    <span class=\"built_in\">getchar</span>(); <span class=\"comment\">// or cin.ignore(); </span></span><br><span class=\"line\">   </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"输入一行文本：\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">getline</span>(cin, line);  <span class=\"comment\">// 现在可以正确读取整行</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"数字：\"</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"文本：\"</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果输入<code>8 \\n</code>, 则<code>getchar()</code>读取空格, 文本为空.</p>\n</blockquote>\n<h3 id=\"Alter-String\"><a href=\"#Alter-String\" class=\"headerlink\" title=\"Alter String\"></a>Alter String</h3><p><strong>outline</strong> : 常用的字符串方法(成员函数):</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">insert</span>(<span class=\"type\">size_t</span> pos, <span class=\"type\">const</span> string&amp; s);</span><br><span class=\"line\"><span class=\"built_in\">erase</span> (<span class=\"type\">size_t</span> pos = <span class=\"number\">0</span>, size_tlen = npos);</span><br><span class=\"line\"><span class=\"built_in\">append</span> (<span class=\"type\">const</span> string&amp; str);</span><br><span class=\"line\"><span class=\"built_in\">replace</span> (<span class=\"type\">size_t</span> pos,<span class=\"type\">size_t</span> len,<span class=\"type\">const</span> string&amp; str);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><ul>\n<li><code>insert(int pos, string str)</code> 在指定位置插入字符串</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 在位置5处插入字符串</span></span><br><span class=\"line\">str.<span class=\"built_in\">insert</span>(<span class=\"number\">5</span>, <span class=\"string\">\" Beautiful\"</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello Beautiful World\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在字符串末尾插入内容</span></span><br><span class=\"line\">str.<span class=\"built_in\">insert</span>(str.<span class=\"built_in\">length</span>(), <span class=\"string\">\"!\"</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello Beautiful World!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 插入单个字符（使用string构造）</span></span><br><span class=\"line\">str.<span class=\"built_in\">insert</span>(<span class=\"number\">0</span>, <span class=\"string\">\"&gt;\"</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"&gt;Hello Beautiful World!\"</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li><code>erase(int pos, int length)</code> 删除从指定位置开始的若干个字符</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello Beautiful World!\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除从下标6开始的9个字符</span></span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">6</span>, <span class=\"number\">9</span>); </span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello World!\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 删除从某个位置开始到末尾的所有字符</span></span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">5</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>length</code>参数省略, 则删除从<code>pos</code>位置开始到字符串末尾的所有字符.</p>\n</blockquote>\n<hr>\n<ul>\n<li><code>replace (int pos, int length, string)</code> 替换指定位置的字符串</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从位置6开始，替换5个字符为\"C++\"</span></span><br><span class=\"line\">string str = <span class=\"string\">\"Hello World!\"</span>;</span><br><span class=\"line\">str.<span class=\"built_in\">replace</span>(<span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"string\">\"C++\"</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 结果: \"Hello C++!\"</span></span><br></pre></td></tr></table></figure>\n\n\n<hr>\n<ul>\n<li><code>append (const string&amp; str);</code></li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 添加整个字符串</span></span><br><span class=\"line\">string<span class=\"number\">1.</span><span class=\"built_in\">append</span>(string2);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 添加指定位置的字符(索引从开始)</span></span><br><span class=\"line\">string<span class=\"number\">1.</span><span class=\"built_in\">append</span>(string2, start, length);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 重复字符的添加</span></span><br><span class=\"line\">string<span class=\"number\">1.</span><span class=\"built_in\">append</span>(count, <span class=\"type\">char</span>);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>除此之外, 还存在着使用<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">迭</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">代</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">器</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container>的用法: </p>\n<blockquote>\n<p>类似于指针, 指向容器(如字符串、数组等)的特定位置.</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    string source = <span class=\"string\">\"World!\"</span>;</span><br><span class=\"line\">    string target = <span class=\"string\">\"Hello \"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 添加source中的部分字符（从开始到结束）</span></span><br><span class=\"line\">    target.<span class=\"built_in\">append</span>(source.<span class=\"built_in\">begin</span>(), source.<span class=\"built_in\">end</span>());</span><br><span class=\"line\">    cout &lt;&lt; target &lt;&lt; endl;  <span class=\"comment\">// 输出: Hello World!</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 只添加部分字符</span></span><br><span class=\"line\">    string target2 = <span class=\"string\">\"Hello \"</span>;</span><br><span class=\"line\">    target<span class=\"number\">2.</span><span class=\"built_in\">append</span>(source.<span class=\"built_in\">begin</span>(), source.<span class=\"built_in\">begin</span>() + <span class=\"number\">5</span>);  <span class=\"comment\">// 只添加\"World\"，不包含\"!\"</span></span><br><span class=\"line\">    cout &lt;&lt; target2 &lt;&lt; endl;  <span class=\"comment\">// 输出: Hello World</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>begin()</code>方法返回字符串的第一个字符的迭代器, <code>end()</code>方法返回字符串最后一个字符的<strong>下一个</strong>位置的迭代器;</li>\n<li>迭代器的范围是<strong>左闭右开</strong>.</li>\n</ol>\n<hr>\n<h4 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h4><ul>\n<li><code>find(string, int pos)</code> 从指定的位置开始寻找字符串位置</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello World Hello\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 从位置0开始查找\"Hello\"</span></span><br><span class=\"line\">cout &lt;&lt; str.<span class=\"built_in\">find</span>(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">0</span>) &lt;&lt; endl;     <span class=\"comment\">// 结果: 0</span></span><br><span class=\"line\"><span class=\"comment\">// 从位置1开始查找\"Hello\"</span></span><br><span class=\"line\">cout &lt;&lt; str.<span class=\"built_in\">find</span>(<span class=\"string\">\"Hello\"</span>, <span class=\"number\">1</span>) &lt;&lt; endl;     <span class=\"comment\">// 结果: 12</span></span><br><span class=\"line\"><span class=\"comment\">// 查找不存在的字符串</span></span><br><span class=\"line\">cout &lt;&lt; str.<span class=\"built_in\">find</span>(<span class=\"string\">\"Python\"</span>) &lt;&lt; endl;       <span class=\"comment\">// 结果: string::npos</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>string::npos</code>是<code>size_t</code>类型的最大值;</li>\n<li>可以使用<code>str.find(\"Python\") == string::npos</code>作为判断条件, 检查是否找到字符串.</li>\n</ul>\n<hr>\n<ul>\n<li><code>compare(string)</code> 字符串比较</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string str2 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string str3 = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; str<span class=\"number\">1.</span><span class=\"built_in\">compare</span>(str2) &lt;&lt; endl;  <span class=\"comment\">// 结果: 0  (相等)</span></span><br><span class=\"line\">cout &lt;&lt; str<span class=\"number\">1.</span><span class=\"built_in\">compare</span>(str3) &lt;&lt; endl;  <span class=\"comment\">// 结果: -15 (str1 &lt; str3) </span></span><br><span class=\"line\">cout &lt;&lt; str<span class=\"number\">3.</span><span class=\"built_in\">compare</span>(str1) &lt;&lt; endl;  <span class=\"comment\">// 结果: 15  (str3 &gt; str1)</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>按照字典序比较得到结果</li>\n</ul>\n<hr>\n<ul>\n<li><code>to_string(int)</code> 将数字转换成字符串</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"number\">123</span>;</span><br><span class=\"line\">string str = <span class=\"built_in\">to_string</span>(num);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;          <span class=\"comment\">// 结果: \"123\"</span></span><br><span class=\"line\">cout &lt;&lt; str + <span class=\"string\">\"456\"</span> &lt;&lt; endl;  <span class=\"comment\">// 结果: \"123456\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>字符串之间可以通过<code>+</code>直接拼接.</li>\n</ul>\n<hr>\n<ul>\n<li><code>stoi(string)</code> 将字符串转换成整数</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"built_in\">stoi</span>(str);</span><br><span class=\"line\">cout &lt;&lt; num + <span class=\"number\">456</span> &lt;&lt; endl;    <span class=\"comment\">// 结果: 579</span></span><br><span class=\"line\"><span class=\"comment\">// 注意：字符串必须是合法的数字格式</span></span><br><span class=\"line\"><span class=\"comment\">// string str = \"abc\"; </span></span><br><span class=\"line\"><span class=\"comment\">// int num = stoi(str);  // 这会抛出异常</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>字符串必须是合法的数字格式;</li>\n<li><code> int num = stoi(\"abc\");</code>  将会抛出异常</li>\n</ul>\n<hr>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p><strong>Outline:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> *cp, <span class=\"type\">int</span> len);</span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"type\">const</span> string&amp; s2, <span class=\"type\">int</span> pos);</span><br><span class=\"line\"><span class=\"built_in\">string</span>(<span class=\"type\">const</span> string&amp; s2, <span class=\"type\">int</span> pos, <span class=\"type\">int</span> len);</span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li><code>string(const char *cp, int len)</code> 字符数组创建字符串</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">str1</span><span class=\"params\">(<span class=\"string\">\"Hello World\"</span>, <span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: Hello</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>string(const string&amp; s2, int pos)</code> 从现有字符串创建新字符串，从指定位置到末尾</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s2 = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">str2</span><span class=\"params\">(s2, <span class=\"number\">6</span>)</span></span>;</span><br><span class=\"line\">cout &lt;&lt; str2 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: World</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>string(const string&amp; s2, int pos, int len)</code> 从现有字符串创建新字符串，指定起始位置和长度</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s3 = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">str3</span><span class=\"params\">(s3, <span class=\"number\">6</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\">cout &lt;&lt; str3 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: Wor</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>string(int length, char c)</code> 用指定长度的字符c初始化字符串</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">str4</span><span class=\"params\">(<span class=\"number\">5</span>, <span class=\"string\">'*'</span>)</span></span>;</span><br><span class=\"line\">cout &lt;&lt; str4 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: *****</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 实际应用示例</span></span><br><span class=\"line\"><span class=\"type\">int</span> num = <span class=\"number\">432</span>;</span><br><span class=\"line\">string str = <span class=\"built_in\">to_string</span>(num);</span><br><span class=\"line\">cout &lt;&lt; <span class=\"built_in\">string</span>(<span class=\"number\">5</span> - str.<span class=\"built_in\">length</span>(), <span class=\"string\">'0'</span>) + str &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 输出: 00432</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"成员函数\"><a href=\"#成员函数\" class=\"headerlink\" title=\"成员函数\"></a>成员函数</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 提取子字符串</span></span><br><span class=\"line\"><span class=\"built_in\">substr</span>(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> len);</span><br><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\">string sub = str.<span class=\"built_in\">substr</span>(<span class=\"number\">6</span>, <span class=\"number\">3</span>);  <span class=\"comment\">// 结果: \"Wor\"</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 字符串赋值</span></span><br><span class=\"line\"><span class=\"built_in\">assign</span>();</span><br><span class=\"line\">string str1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string str2;</span><br><span class=\"line\">str<span class=\"number\">2.</span><span class=\"built_in\">assign</span>(str1);  <span class=\"comment\">// str2现在是 \"Hello\"</span></span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在指定位置插入字符串</span></span><br><span class=\"line\">    string str1 = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">    string str2 = <span class=\"string\">\"world\"</span>;</span><br><span class=\"line\">    str<span class=\"number\">1.</span><span class=\"built_in\">insert</span>(<span class=\"number\">3</span>, str2);</span><br><span class=\"line\">    cout &lt;&lt; str1 &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 结果: helworldlo </span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 删除指定位置的指定长度的字符</span></span><br><span class=\"line\"><span class=\"built_in\">erase</span>(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> len);</span><br><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">5</span>, <span class=\"number\">6</span>);  <span class=\"comment\">// 结果: \"Hello\"</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>Notice：</strong></p>\n<ol>\n<li>所有位置索引都是从0开始计数</li>\n<li>如果指定的长度超过字符串实际长度，会自动调整到实际可用长度</li>\n<li>使用这些函数时要注意检查参数的有效性，避免越界访问</li>\n<li><code>.assign(str, pos, len)</code>: 相比于直接赋值, <code>assign</code>还提供了精确控制赋值的方法, 也就是指定内容字符串的起始位置和长度.</li>\n</ol>\n<hr>\n<h3 id=\"Substr\"><a href=\"#Substr\" class=\"headerlink\" title=\"Substr\"></a>Substr</h3><p>在字符串的处理当中, 我们经常需要从一个较长的字符串中提取部分内容. <code>substr()</code>方法可以精确地获取字符串片段.</p>\n<p><code>substr</code>即substring的缩写, 表示子字符串.</p>\n<p><strong>基本语法</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">string <span class=\"title\">substr</span><span class=\"params\">(<span class=\"type\">int</span> pos, <span class=\"type\">int</span> len)</span> </span>;</span><br></pre></td></tr></table></figure>\n<p>参数分别表示截取的起始下标以及要截取的长度(如果省略<code>len</code>将截取到字符串的末尾).</p>\n<p><strong>e.g.</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string email = <span class=\"string\">\"user.name@example.com\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取用户名的部分</span></span><br><span class=\"line\"><span class=\"type\">int</span> atPos = email.<span class=\"built_in\">find</span>(<span class=\"string\">'@'</span>);</span><br><span class=\"line\">string username = email.<span class=\"built_in\">substr</span>(<span class=\"number\">0</span>, atPos); <span class=\"comment\">// result: \"user.name\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取域名部分</span></span><br><span class=\"line\">string domain =  email.<span class=\"built_in\">substr</span>(atPos + <span class=\"number\">1</span>); <span class=\"comment\">// result: \"example.com\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 获取顶级域名(最后一个.之后的部分)</span></span><br><span class=\"line\"><span class=\"type\">int</span> lastDotPos = email.<span class=\"built_in\">rfind</span>(<span class=\"string\">'.'</span>);</span><br><span class=\"line\">string topLevelDomain = email.<span class=\"built_in\">substr</span>(lastDotPos + <span class=\"number\">1</span>); <span class=\"comment\">// result: \"com\"</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>rfind()</code>方法: 会从字符串的<strong>末尾向前</strong>搜索，从而返回要查找的字符或子字符串此时第一次出现的位置。如果没有找到，则返回 string::npos.</li>\n</ul>\n<hr>\n<h1 id=\"Function\"><a href=\"#Function\" class=\"headerlink\" title=\"Function\"></a>Function</h1><h2 id=\"Default-arguments\"><a href=\"#Default-arguments\" class=\"headerlink\" title=\"Default arguments\"></a>Default arguments</h2><p>要点:</p>\n<ul>\n<li><p>默认值必须在函数原型中从右到左地给出, 否则在调用的时候无法分辨;</p>\n</li>\n<li><p>默认值只能出现在函数原型 或者 将声明和定义放在一起, 下面的情况会报错:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j = <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> i, <span class=\"type\">int</span> j = <span class=\"number\">10</span>)</span></span>{</span><br><span class=\"line\">    ...</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"Group\"><a href=\"#Group\" class=\"headerlink\" title=\"Group\"></a>Group</h1><p><strong>选择的标准:</strong></p>\n<ul>\n<li>一般情况 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.054ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.242ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -525 1000 549\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21D2\" d=\"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z\"></path></g></g></g></svg></mjx-container> <code>vector</code>;</li>\n<li>程序需要对元素进行<strong>随机访问</strong> <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.054ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.242ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -525 1000 549\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21D2\" d=\"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z\"></path></g></g></g></svg></mjx-container> <code>vector</code> or <code>deque</code>;</li>\n<li>程序需要在容器<strong>中间插入</strong>元素 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.054ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.242ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -525 1000 549\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21D2\" d=\"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z\"></path></g></g></g></svg></mjx-container> <code>list</code> or <code>forward_list</code>;</li>\n<li>程序需要在容器的<strong>首尾插入</strong>元素 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.054ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.242ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -525 1000 549\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21D2\" d=\"M580 514Q580 525 596 525Q601 525 604 525T609 525T613 524T615 523T617 520T619 517T622 512Q659 438 720 381T831 300T927 263Q944 258 944 250T935 239T898 228T840 204Q696 134 622 -12Q618 -21 615 -22T600 -24Q580 -24 580 -17Q580 -13 585 0Q620 69 671 123L681 133H70Q56 140 56 153Q56 168 72 173H725L735 181Q774 211 852 250Q851 251 834 259T789 283T735 319L725 327H72Q56 332 56 347Q56 360 70 367H681L671 377Q638 412 609 458T580 514Z\"></path></g></g></g></svg></mjx-container> <code>deque</code>;</li>\n<li>容器中的元素<strong>相对较小</strong>但是数量较多 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.079ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"2.262ex\" height=\"1.287ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -534 1000 569\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"mo\"><path data-c=\"21CF\" d=\"M346 174Q348 176 378 249T411 325Q411 327 239 327H68Q55 342 55 347Q55 354 68 367H428L459 445Q487 509 494 521T510 534Q517 534 524 527T531 516Q531 515 502 438L471 367H677L666 381Q631 421 605 463T578 516Q578 522 582 523T599 525H615L619 512Q659 437 714 383T812 309T896 272T942 254Q943 246 938 243T911 232Q718 172 619 -13L615 -24L599 -26Q578 -26 578 -17Q578 -11 587 6T617 53T666 118L677 132H373L339 54Q323 12 313 -8T298 -32T288 -35Q280 -35 275 -29T269 -17Q269 -14 298 57T328 132H68Q55 145 55 152Q55 156 56 158T62 165T68 172H206Q346 172 346 174ZM848 249Q763 297 735 318L722 327H455L422 252L391 174Q391 172 557 172H722L735 181Q773 210 819 234L848 249Z\"></path></g></g></g></svg></mjx-container> <code>list</code> nor <code>forward_list</code>.<ul>\n<li>否则链表中的指针占用的额外空间反而占比较高, 导致空间浪费.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Pair\"><a href=\"#Pair\" class=\"headerlink\" title=\"Pair\"></a>Pair</h2><h3 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h3><h4 id=\"1-基本概念\"><a href=\"#1-基本概念\" class=\"headerlink\" title=\"1. 基本概念\"></a>1. 基本概念</h4><p>pair 是 C++ 标准库提供的模板类，用于<u>将两个不同类型的值组合成一个对象</u>。它定义在 <code>&lt;utility&gt;</code> 头文件中。</p>\n<h4 id=\"2-创建与初始化\"><a href=\"#2-创建与初始化\" class=\"headerlink\" title=\"2. 创建与初始化\"></a>2. 创建与初始化</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 默认构造</span></span><br><span class=\"line\">std::pair&lt;std::string, <span class=\"type\">int</span>&gt; p1;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 直接初始化</span></span><br><span class=\"line\"><span class=\"function\">std::pair&lt;std::string, <span class=\"type\">int</span>&gt; <span class=\"title\">p2</span><span class=\"params\">(<span class=\"string\">\"tag\"</span>, <span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用make_pair</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> p3 = std::<span class=\"built_in\">make_pair</span>(<span class=\"string\">\"data\"</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 统一初始化</span></span><br><span class=\"line\">std::pair&lt;std::string, <span class=\"type\">int</span>&gt; p4{<span class=\"string\">\"value\"</span>, <span class=\"number\">8</span>};</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3-访问元素\"><a href=\"#3-访问元素\" class=\"headerlink\" title=\"3. 访问元素\"></a>3. 访问元素</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 传统访问方式</span></span><br><span class=\"line\">std::cout &lt;&lt; p<span class=\"number\">2.f</span>irst &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; p<span class=\"number\">2.</span>second &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 结构化绑定(C++17)</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> [key, val] = p3;</span><br><span class=\"line\">std::cout &lt;&lt; key &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; val &lt;&lt; endl;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4-常用操作\"><a href=\"#4-常用操作\" class=\"headerlink\" title=\"4. 常用操作\"></a>4. 常用操作</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 比较操作</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (p1 == p2) {...}</span><br><span class=\"line\"><span class=\"keyword\">if</span> (p1 &lt; p2) {...}  <span class=\"comment\">// 先比较first，再比较second</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 交换内容</span></span><br><span class=\"line\">p<span class=\"number\">1.</span><span class=\"built_in\">swap</span>(p2);</span><br><span class=\"line\">std::<span class=\"built_in\">swap</span>(p1, p2);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"5-实际应用示例\"><a href=\"#5-实际应用示例\" class=\"headerlink\" title=\"5. 实际应用示例\"></a>5. 实际应用示例</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 作为函数返回值</span></span><br><span class=\"line\"><span class=\"function\">std::pair&lt;<span class=\"type\">bool</span>, string&gt; <span class=\"title\">checkInput</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; input)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (input.<span class=\"built_in\">empty</span>()) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> {<span class=\"literal\">false</span>, <span class=\"string\">\"输入不能为空\"</span>};</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> {<span class=\"literal\">true</span>, <span class=\"string\">\"\"</span>};</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在容器中使用</span></span><br><span class=\"line\">vector&lt;pair&lt;string, <span class=\"type\">int</span>&gt;&gt; dataList = {</span><br><span class=\"line\">    {<span class=\"string\">\"item1\"</span>, <span class=\"number\">10</span>},</span><br><span class=\"line\">    {<span class=\"string\">\"item2\"</span>, <span class=\"number\">20</span>},</span><br><span class=\"line\">    {<span class=\"string\">\"item3\"</span>, <span class=\"number\">30</span>}</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 与map配合使用</span></span><br><span class=\"line\">map&lt;string, pair&lt;<span class=\"type\">int</span>, <span class=\"type\">double</span>&gt;&gt; complexData;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6-注意事项\"><a href=\"#6-注意事项\" class=\"headerlink\" title=\"6. 注意事项\"></a>6. 注意事项</h4><ol>\n<li>pair 的元素可以是任意类型，包括自定义类型</li>\n<li>使用结构化绑定需要C++17或更高标准</li>\n<li>pair 常用于需要返回多个值的函数</li>\n<li>在性能敏感场景要注意构造和拷贝开销</li>\n</ol>\n<h2 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set\"></a>Set</h2><p><strong>集合</strong>: 用于存储一组不允许重复的元素, 且会自动排序.</p>\n<p>可以使用的方法包括:</p>\n<ol>\n<li><p><code>.insert( )</code>: 插入元素;</p>\n</li>\n<li><p><code>.erase()</code>: 删除元素. 如果输入是元素值, 那么返回1/0表示是否成功删除; 如果输入是迭代器, 那么返回的是<strong>下一个元素的迭代器</strong>.</p>\n</li>\n<li><p><code>.find( )</code>: 寻找元素, 如果找到 返回对应的 <strong>迭代器</strong>. 否则返回 <code>.end( )</code>;</p>\n</li>\n</ol>\n<h2 id=\"Vector\"><a href=\"#Vector\" class=\"headerlink\" title=\"Vector\"></a>Vector</h2><p>存储元素在<strong>连续的内存空间</strong>中, 支持<strong>随机访问</strong>.</p>\n<ul>\n<li>可以动态增长, 适合存储<strong>未知数量</strong>的元素;</li>\n<li>通过下标访问元素的时间复杂度为 O(1);</li>\n<li>在末尾插入和删除元素的时间复杂度为 O(1);</li>\n<li>在中间插入和删除元素的时间复杂度为 O(n);</li>\n<li><strong>使用场景</strong>: 需要随机访问、排序、内存连续存储的场景.</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<ul>\n<li><p>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> it = <span class=\"built_in\">find</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), value);  <span class=\"comment\">// 查找 value</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (it != vec.<span class=\"built_in\">end</span>()) {         <span class=\"comment\">// 如果找到了（即没有返回 end()）</span></span><br><span class=\"line\">      vec.<span class=\"built_in\">erase</span>(it);             <span class=\"comment\">// 则删除找到的元素</span></span><br><span class=\"line\">  }</span><br></pre></td></tr></table></figure></li>\n<li><p>使用 <code>.push_back()</code>在末尾插入元素, 或者使用<code>.emplace_back()</code>在末尾原位构造元素(更加高效);</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">vec.<span class=\"built_in\">emplace_back</span>(<span class=\"number\">20</span>); <span class=\"comment\">//更加高效</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>emplace_back</code>方法<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象, 相比于<code>push_back</code>而言更加<strong>高效</strong>.</p>\n</blockquote>\n</li>\n<li><p><code>.erase()</code>方法删除指定位置的元素, 可以删除单个元素, 也可以删除一段区间;</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>);       <span class=\"comment\">// 删除第二个元素</span></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">begin</span>() + <span class=\"number\">3</span>); <span class=\"comment\">// 删除前三个元素</span></span><br><span class=\"line\">vec.<span class=\"built_in\">clear</span>();                      <span class=\"comment\">// 清空整个 vector</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>vec.clear();</code> 将会清空整个vector.</p>\n<p>和<code>insert</code>需要的参数一样, 都需要<strong>迭代器</strong>而非索引来定位.</p>\n</blockquote>\n</li>\n<li><p><code>vec[i]</code>的形式访问, 使用<code>vec.at(i)</code>的方式可以在越界时抛出异常;</p>\n</li>\n<li><p><code>.begin()</code>和<code>.end()</code>获取迭代器, 使用范围for循环遍历元素;</p>\n  <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> cout &lt;&lt; <span class=\"string\">\"Vector elements:\"</span> &lt;&lt; endl;</span><br><span class=\"line\"> <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : vec) {</span><br><span class=\"line\">    cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\"> }</span><br><span class=\"line\"> cout &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//使用迭代器遍历</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> it = vec.<span class=\"built_in\">begin</span>(); it != vec.<span class=\"built_in\">end</span>(); ++it) {</span><br><span class=\"line\">    cout &lt;&lt; *it &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>\n<li><p><code>.size()</code>获取<code>vector</code>的大小, <code>.empty()</code>判断<code>vector</code>是否为空;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"Vector size: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (vec.<span class=\"built_in\">empty</span>()) {</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Vector is empty.\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n<li><p>使用<code>sort()</code>对<code>vector</code>进行排序, 使用<code>find()</code>查找元素;</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>());   <span class=\"comment\">// 排序</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = <span class=\"built_in\">find</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"number\">5</span>); <span class=\"comment\">// 查找 5</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>insert</code> 插入的位置是指定的迭代器位置之前一个;</p>\n</li>\n</ul>\n<h3 id=\"Reserve\"><a href=\"#Reserve\" class=\"headerlink\" title=\"Reserve\"></a>Reserve</h3><p>为了避免频繁地扩展内存, 可以通过<code>reserve</code>预先分配合适的空间, 同时通过<code>.reszie()</code>调整大小;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; v2;</span><br><span class=\"line\">v<span class=\"number\">2.</span><span class=\"built_in\">reserve</span>(<span class=\"number\">1000</span>);  <span class=\"comment\">// 一次性分配 1000 个元素的空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">v<span class=\"number\">2.</span><span class=\"built_in\">resize</span>(v<span class=\"number\">2.</span><span class=\"built_in\">size</span>() + v<span class=\"number\">2.</span><span class=\"built_in\">size</span>()/<span class=\"number\">2</span>); <span class=\"comment\">// 调整大小为原来的 1.5 倍</span></span><br></pre></td></tr></table></figure>\n\n<p><code>reserve</code>只分配空间而不创建元素,<code>resize</code>将同时分配元素(默认值):</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;string&gt; vec;</span><br><span class=\"line\"><span class=\"comment\">// reserve: 只分配空间，不创建元素</span></span><br><span class=\"line\">vec.<span class=\"built_in\">reserve</span>(<span class=\"number\">10</span>);  </span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"The capacity with reserve: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"The size with reserve: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// resize: 分配空间并创建元素</span></span><br><span class=\"line\">vec.<span class=\"built_in\">resize</span>(<span class=\"number\">10</span>);   </span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"The capacity with resize: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>() &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"The size with resize: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; endl;   </span><br></pre></td></tr></table></figure>\n\n<p><strong>Output</strong>:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The capacity with reserve: 10</span><br><span class=\"line\">The size with reserve: 0</span><br><span class=\"line\">The capacity with resize: 10</span><br><span class=\"line\">The size with resize: 10</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>[!important]</p>\n<p><code>.push_back()</code>的实际作用是在容器索引的<code>size</code>处插入元素.</p>\n<p> 而<code>reserve</code>不会影响容器的<code>size</code>,  初始化和<code>resize</code>会影响并且填充默认值:</p>\n</blockquote>\n<p><strong>e.g.  验证:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"function\">vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">vec</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打印初始状态</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"初始状态：\\n\"</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"size: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; <span class=\"string\">\", capacity: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>() &lt;&lt; <span class=\"string\">\"\\n\\n\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 预留5个空间</span></span><br><span class=\"line\">    vec.<span class=\"built_in\">reserve</span>(<span class=\"number\">15</span>);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"reserve(15) 后：\\n\"</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"size: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() &lt;&lt; <span class=\"string\">\", capacity: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>() &lt;&lt; <span class=\"string\">\"\\n\\n\"</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    vec[<span class=\"number\">20</span>] =<span class=\"number\">20</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 添加元素并观察</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"添加元素过程：\\n\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">1</span>; i &lt;= <span class=\"number\">6</span>; i++) {</span><br><span class=\"line\">        vec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"添加 \"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\" 后 - \"</span>;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"size: \"</span> &lt;&lt; vec.<span class=\"built_in\">size</span>() </span><br><span class=\"line\">             &lt;&lt; <span class=\"string\">\", capacity: \"</span> &lt;&lt; vec.<span class=\"built_in\">capacity</span>()</span><br><span class=\"line\">             &lt;&lt; <span class=\"string\">\", 元素: \"</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> x : vec) cout &lt;&lt; x &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"\\n\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>Output:</strong></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">初始状态：</span><br><span class=\"line\">size: 10, capacity: 10</span><br><span class=\"line\"></span><br><span class=\"line\">reserve(15) 后：</span><br><span class=\"line\">size: 10, capacity: 15</span><br><span class=\"line\"></span><br><span class=\"line\">添加元素过程：</span><br><span class=\"line\">添加 1 后 - size: 11, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 </span><br><span class=\"line\">添加 2 后 - size: 12, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 </span><br><span class=\"line\">添加 3 后 - size: 13, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 </span><br><span class=\"line\">添加 4 后 - size: 14, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 </span><br><span class=\"line\">添加 5 后 - size: 15, capacity: 15, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 </span><br><span class=\"line\">添加 6 后 - size: 16, capacity: 30, 元素: 0 0 0 0 0 0 0 0 0 0 1 2 3 4 5 6 </span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>此处的 <code>vector&lt;int&gt; vec(10);</code>初始化了10个默认值的<code>int</code>类型的元素;</li>\n<li><code>vec[20] = 20;</code>没有进行越界与否的检查, 实际上存在越界, 但是不会报错, 也不会有实际的作用;<ol>\n<li>如果换成<code>vec.at(20) = 20</code>将会在编译时报错;</li>\n</ol>\n</li>\n<li>可以发现, <code>reserve</code>的作用就是避免了多次自动扩容.</li>\n</ol>\n<blockquote>\n<p><code>reserve</code>的实质: 如果预留的容量大于当前的实际容量, 将自动分配一个指定容量的内存, 将原有的元素<strong>copy</strong>到新的内存空间, 并更新容器的指针, 然后释放原来的内存空间.</p>\n</blockquote>\n<h3 id=\"Resize\"><a href=\"#Resize\" class=\"headerlink\" title=\"Resize\"></a>Resize</h3><p>用法的枚举:</p>\n<ol>\n<li><p><code>resize(n)</code>: 将vector的大小调整为n, 如果大于当前值, 则在末尾添加具有默认值的新元素;</p>\n</li>\n<li><p><code>resize(n, val)</code>: 同样调整大小, 但是指定了默认值为新的 <code>val</code>;</p>\n</li>\n<li><p>对于二维向量的内存分配也是类似的:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; m;  <span class=\"comment\">//二维码向量;</span></span><br><span class=\"line\"> ...</span><br><span class=\"line\"> m.<span class=\"built_in\">resize</span>(r,<span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(c,<span class=\"number\">0</span>)); <span class=\"comment\">//初始化为一个r行c列且初始值为0的矩阵.</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h2><ul>\n<li>在<code>list</code>容器当中, 迭代器是双向迭代器;<ul>\n<li>双向迭代器不支持大小的比较, 只支持 <code>==</code>,<code>!=</code>,<code>++</code>,<code>--</code>;<br>因此, 注意实际的使用:</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt; lst1;</span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt;::iterator iter1 = lst<span class=\"number\">1.</span><span class=\"built_in\">begin</span>();</span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt;::iterator iter2 = lst<span class=\"number\">1.</span><span class=\"built_in\">end</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 正确的写法</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> (iter1 != iter2) {</span><br><span class=\"line\">    <span class=\"comment\">// 处理当前元素</span></span><br><span class=\"line\">    ++iter1;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 错误的比较</span></span><br><span class=\"line\"><span class=\"comment\">// while(iter1 &lt; iter2) </span></span><br><span class=\"line\">    </span><br></pre></td></tr></table></figure>\n\n<h3 id=\"有序链表\"><a href=\"#有序链表\" class=\"headerlink\" title=\"有序链表\"></a>有序链表</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    list&lt;string&gt; s;</span><br><span class=\"line\">    string str;</span><br><span class=\"line\">    list&lt;string&gt; :: iterator p;</span><br><span class=\"line\">    <span class=\"type\">int</span> count ;</span><br><span class=\"line\"></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"enter the number of the strings:\"</span> &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    cin &gt;&gt; count; </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; count; i++){</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"enter a string:\"</span> ;</span><br><span class=\"line\">        cin &gt;&gt;str;</span><br><span class=\"line\">        </span><br><span class=\"line\">        p = s.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(p != s.<span class=\"built_in\">end</span>() &amp;&amp; *p &lt;str)</span><br><span class=\"line\">            p++;</span><br><span class=\"line\">        s.<span class=\"built_in\">insert</span>(p,str);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(p = s.<span class=\"built_in\">begin</span>(); p!=s.<span class=\"built_in\">end</span>(); p++)</span><br><span class=\"line\">        cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p><strong>分析:</strong></p>\n<ul>\n<li><code>while(p != s.end() &amp;&amp; *p &lt;str)</code> 每次输入<code>str</code>时, 令迭代器从<code>list</code>的开头开始, 进行字典序的比较;</li>\n</ul>\n<blockquote>\n<p>[!important]</p>\n<p>找到插入的位置, 利用<code>insert()</code>方法插入到给出迭代器的<strong>前面</strong>!.</p>\n</blockquote>\n<h2 id=\"Deque\"><a href=\"#Deque\" class=\"headerlink\" title=\"Deque\"></a>Deque</h2><p><code>deque</code>即 double-ended queue, <strong>双端队列</strong>.</p>\n<p>支持:</p>\n<ul>\n<li>在两端快速的插入或删除;</li>\n<li>随机访问;</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;deque&gt;</span></span></span><br><span class=\"line\">deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 插入操作</span></span><br><span class=\"line\">dq.<span class=\"built_in\">push_back</span>(<span class=\"number\">1</span>);    <span class=\"comment\">// 在末尾插入</span></span><br><span class=\"line\">dq.<span class=\"built_in\">push_front</span>(<span class=\"number\">2</span>);   <span class=\"comment\">// 在开头插入</span></span><br><span class=\"line\">dq.<span class=\"built_in\">insert</span>(pos, val);<span class=\"comment\">// 在指定位置插入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 删除操作</span></span><br><span class=\"line\">dq.<span class=\"built_in\">pop_back</span>();      <span class=\"comment\">// 删除末尾元素</span></span><br><span class=\"line\">dq.<span class=\"built_in\">pop_front</span>();     <span class=\"comment\">// 删除首部元素</span></span><br><span class=\"line\">dq.<span class=\"built_in\">erase</span>(pos);      <span class=\"comment\">// 删除指定位置元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 访问操作</span></span><br><span class=\"line\">dq[<span class=\"number\">0</span>];              <span class=\"comment\">// 随机访问</span></span><br><span class=\"line\">dq.<span class=\"built_in\">at</span>(<span class=\"number\">1</span>);           <span class=\"comment\">// 带边界检查的访问</span></span><br><span class=\"line\">dq.<span class=\"built_in\">front</span>();         <span class=\"comment\">// 访问第一个元素</span></span><br><span class=\"line\">dq.<span class=\"built_in\">back</span>();          <span class=\"comment\">// 访问最后一个元素</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;deque&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    deque&lt;<span class=\"type\">int</span>&gt; dq;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在两端插入元素</span></span><br><span class=\"line\">    dq.<span class=\"built_in\">push_back</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    dq.<span class=\"built_in\">push_front</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    dq.<span class=\"built_in\">push_back</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    dq.<span class=\"built_in\">push_front</span>(<span class=\"number\">8</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// dq ：{8, 1, 3, 4}</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 使用随机访问</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">size_t</span> i = <span class=\"number\">0</span>; i &lt; dq.<span class=\"built_in\">size</span>(); ++i) {</span><br><span class=\"line\">        cout &lt;&lt; dq[i] &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Forward-list\"><a href=\"#Forward-list\" class=\"headerlink\" title=\"Forward_list\"></a>Forward_list</h3><p><code>forward_list</code>即 单项链表.</p>\n<ul>\n<li>只能向前遍历, 即对应的迭代器不支持<code>--</code>而支持<code>++</code>.</li>\n<li>同时不支持下标访问以及随机访问.</li>\n<li>单项链表的设计, 使得内部的每个节点只需要<strong>一个</strong>指针来指向下一个节点, 从而比<code>list</code>双向链表更加<strong>节省内存.</strong></li>\n</ul>\n<p><strong>语法</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;forward_list&gt;</span></span></span><br><span class=\"line\">forward_list&lt;<span class=\"type\">int</span>&gt; fl;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 插入操作</span></span><br><span class=\"line\">fl.<span class=\"built_in\">push_front</span>(<span class=\"number\">1</span>);           <span class=\"comment\">// 在开头插入</span></span><br><span class=\"line\">fl.<span class=\"built_in\">insert_after</span>(pos, val);  <span class=\"comment\">// 在指定位置之后插入</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 删除操作</span></span><br><span class=\"line\">fl.<span class=\"built_in\">pop_front</span>();            <span class=\"comment\">// 删除第一个元素</span></span><br><span class=\"line\">fl.<span class=\"built_in\">erase_after</span>(pos);       <span class=\"comment\">// 删除指定位置之后的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 访问操作</span></span><br><span class=\"line\">fl.<span class=\"built_in\">front</span>();               <span class=\"comment\">// 访问第一个元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 4. 特殊操作</span></span><br><span class=\"line\">fl.<span class=\"built_in\">before_begin</span>();        <span class=\"comment\">// 返回第一个元素之前的迭代器</span></span><br><span class=\"line\">fl.<span class=\"built_in\">begin</span>();               <span class=\"comment\">// 返回第一个元素的迭代器</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>示例</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;forward_list&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    forward_list&lt;<span class=\"type\">int</span>&gt; fl;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 插入元素</span></span><br><span class=\"line\">    fl.<span class=\"built_in\">push_front</span>(<span class=\"number\">3</span>);</span><br><span class=\"line\">    fl.<span class=\"built_in\">push_front</span>(<span class=\"number\">2</span>);</span><br><span class=\"line\">    fl.<span class=\"built_in\">push_front</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 在特定位置后插入</span></span><br><span class=\"line\">    <span class=\"keyword\">auto</span> it = fl.<span class=\"built_in\">begin</span>(); <span class=\"comment\">// 指向第一个元素</span></span><br><span class=\"line\">    fl.<span class=\"built_in\">insert_after</span>(it, <span class=\"number\">4</span>); <span class=\"comment\">// 在第一个元素后插入4</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 遍历打印</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; val : fl) {</span><br><span class=\"line\">        cout &lt;&lt; val &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"comment\">// 输出：1 4 2 3</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"访问前一个元素\"><a href=\"#访问前一个元素\" class=\"headerlink\" title=\"访问前一个元素\"></a>访问前一个元素</h4><p>由于单项链表的设计特点, 要使得我们可以访问某个节点的前一个元素, 必须采用双指针并结合<code>before_begin()</code>方法.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果需要访问某个元素的前一个元素，必须从头开始遍历</span></span><br><span class=\"line\"><span class=\"keyword\">auto</span> prev = fl.<span class=\"built_in\">before_begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">auto</span> curr = fl.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"><span class=\"keyword\">while</span>(curr != fl.<span class=\"built_in\">end</span>() &amp;&amp; *curr != target) {</span><br><span class=\"line\">    ++prev;</span><br><span class=\"line\">    ++curr;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h2><p>作为Associative container(关联容器), 存储键值对( key-value pair ), 并根据键<strong>自动排序</strong></p>\n<ul>\n<li>如果插入重复的key, 将会覆盖原有的value;</li>\n<li>通过键查找元素、插入和删除的时间复杂度均为O(log n);</li>\n<li><strong>使用场景</strong>: 字典、索引、统计等.</li>\n</ul>\n<p><strong>语法</strong>:</p>\n<ul>\n<li><p>使用 <code>.end()</code>返回一个指向容器<strong>末尾后一个位置</strong>的迭代器, 作为一个标记, 和查找相结合判断某个元素是否存在于<code>map</code>当中;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> it = ages.<span class=\"built_in\">find</span>(<span class=\"string\">\"Charlie\"</span>);  <span class=\"comment\">// 查找 \"Charlie\"</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (it != ages.<span class=\"built_in\">end</span>()) {         <span class=\"comment\">// 如果找到了（即没有返回 end()）</span></span><br><span class=\"line\">      ages.<span class=\"built_in\">erase</span>(it);             <span class=\"comment\">// 则删除找到的元素</span></span><br><span class=\"line\">  }</span><br></pre></td></tr></table></figure></li>\n<li><p>使用下标(键)直接插入,或者通过键值对插入</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages[<span class=\"string\">\"Alice\"</span>] = <span class=\"number\">25</span>;</span><br><span class=\"line\">ages.<span class=\"built_in\">insert</span>({<span class=\"string\">\"Bob\"</span>, <span class=\"number\">30</span>});</span><br><span class=\"line\">ages.<span class=\"built_in\">emplace</span>(<span class=\"string\">\"Charlie\"</span>, <span class=\"number\">28</span>); <span class=\"comment\">// 使用 emplace 插入 (更高效)</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>emplace</code>方法指<strong>直接</strong>在容器的<strong>内存空间中构造</strong>对象，而不是先在其他地方构造对象后再将其拷贝或移动到容器中, 相比于<code>insert</code>而言更加<strong>高效</strong>.</p>\n</blockquote>\n</li>\n<li><p><code>.erase()</code>方法删除指定key的元素, 也可以通过<code>.find()</code>找到key对应的迭代器<code>it</code>, 然后<code>erase(it)</code>.</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ages.<span class=\"built_in\">erase</span>(<span class=\"string\">\"Bob\"</span>);           <span class=\"comment\">// 删除键为 \"Bob\" 的元素</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">auto</span> it = ages.<span class=\"built_in\">find</span>(<span class=\"string\">\"Charlie\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (it != ages.<span class=\"built_in\">end</span>()) {</span><br><span class=\"line\">    ages.<span class=\"built_in\">erase</span>(it);         <span class=\"comment\">// 删除迭代器指向的元素</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>ages.clear();</code> 将会清空整个map.</p>\n</blockquote>\n</li>\n<li><p><code>map[key]</code>的形式访问, 使用<code>map.at(key)</code>的方式可以在key不存在时抛出异常;</p>\n</li>\n<li><p><code>.find(key)</code>查找对应键的元素( 返回<strong>迭代器</strong> ), <code>.count(key)</code>返回对应键的元素个数(0 or 1)</p>\n</li>\n<li><p><code>.size()</code>获取map的大小.</p>\n</li>\n<li><p>迭代器的<code>-&gt;first</code>和<code>-&gt;second</code>可以分别访问键和值.</p>\n  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"Map elements:\"</span> &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> mapIt = ages.<span class=\"built_in\">begin</span>(); mapIt != ages.<span class=\"built_in\">end</span>(); ++mapIt) {</span><br><span class=\"line\">   cout &lt;&lt; mapIt-&gt;first &lt;&lt; <span class=\"string\">\": \"</span> &lt;&lt; mapIt-&gt;second &lt;&lt; endl; <span class=\"comment\">// 访问键和值</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"Iterator\"><a href=\"#Iterator\" class=\"headerlink\" title=\"Iterator\"></a>Iterator</h2><p>迭代器(Iterator)是一种通用的访问容器元素的方式, 类似于指针.</p>\n<ul>\n<li><strong>标记位置</strong>: <code>.begin()</code>和<code>.end()</code> 分别返回容器第一个元素和最后一个元素的下一个位置的迭代器;</li>\n</ul>\n<p>迭代器的分类:</p>\n<ul>\n<li>输入迭代器: 支持读取和递增操作;<ul>\n<li><code>istream_iterator</code>: 用于从输入流读取数据;</li>\n</ul>\n</li>\n<li>输出迭代器: 支持写入和递增操作;<ul>\n<li><code>ostream_iterator</code>: 用于向输出流写入数据;</li>\n</ul>\n</li>\n<li>前向迭代器: 具有输入、输出迭代器的<strong>所有</strong>功能, 并且可以多次遍历同一个序列;<ul>\n<li>比如<code>forwarf_list</code>的迭代器:<code>auto it = flist.begin()</code> or <code>forward_list&lt;int&gt;::iterator it = flist.begin()</code>;</li>\n</ul>\n</li>\n<li>双向迭代器: 在前向迭代器的原有功能上, 同时支持<strong>递减</strong>操作;<ul>\n<li>比如双向链表<code>list</code>的迭代器.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    list&lt;<span class=\"type\">int</span>&gt; myList = {<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用双向迭代器正向遍历</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Forward traversal: \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( list&lt;<span class=\"type\">int</span>&gt;::iterator it = myList.<span class=\"built_in\">begin</span>(); it != myList.<span class=\"built_in\">end</span>(); ++it) {</span><br><span class=\"line\">        cout &lt;&lt; *it &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout &lt;&lt;  endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用双向迭代器逆向遍历</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Reverse traversal: \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( list&lt;<span class=\"type\">int</span>&gt;::reverse_iterator rit = myList.<span class=\"built_in\">rbegin</span>(); rit != myList.<span class=\"built_in\">rend</span>(); ++rit) {</span><br><span class=\"line\">        cout &lt;&lt; *rit &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    cout &lt;&lt;  endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// Forward traversal: 10 20 30 40 50 </span></span><br><span class=\"line\">    <span class=\"comment\">// Reverse traversal: 50 40 30 20 10 </span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li><code>reverse_iterator</code>用于声明逆向遍历的迭代器, 也可以使用<code>auto</code>直接声明.</li>\n<li><code>rbegin()</code>和<code>rend()</code>分别返回容器最后一个元素和第一个元素的前一个位置的逆向迭代器. 此时的<code>++</code>相当于正向遍历时的<code>--</code>操作.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>随机访问迭代器: 具有双向迭代器的所有功能, 同时支持<strong>随机访问</strong>, 如<code>it+n</code>,<code>it[n]</code>.<ul>\n<li>比如<code>vector</code>的迭代器.</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; vec = {<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>};</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"Vector elements (random access): \"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; vec.<span class=\"built_in\">size</span>(); ++i) {</span><br><span class=\"line\">    cout &lt;&lt; vec[i] &lt;&lt; <span class=\"string\">\" \"</span>; <span class=\"comment\">// 使用下标随机访问</span></span><br><span class=\"line\">}</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>另外, 还有一种迭代器称为<strong>插入迭代器</strong>, 比如<code>back_inserter</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; vec = {<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>, <span class=\"number\">40</span>, <span class=\"number\">50</span>};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//结合copy将容器的元素直接插入到另一个容器中</span></span><br><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; dest = {<span class=\"number\">60</span>,<span class=\"number\">70</span>};</span><br><span class=\"line\"><span class=\"built_in\">copy</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"built_in\">back_inserter</span>(dest)); <span class=\"comment\">// 在 dest 末尾插入元素</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"Copied vector: \"</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : dest) {</span><br><span class=\"line\">    cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// Copied vector: 60 70 10 20 30 40 50 </span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"for-each\"><a href=\"#for-each\" class=\"headerlink\" title=\"for-each\"></a>for-each</h2><p>for-each 循环的语法：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> (range_declaration : range_expression) {</span><br><span class=\"line\">    loop_statement;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<ul>\n<li>range_declaration： 声明一个变量，用于存储 range_expression 中的每个元素。这个变量的类型应该与 range_expression 中的元素类型兼容。可以使用 <code>auto </code>关键字让编译器自动推导类型;</li>\n<li>range_expression： 一个表示序列的表达式，例如数组、容器（如 vector、list、map 等）或<strong>字符串</strong>;</li>\n<li>loop_statement： 循环体，包含要对每个元素执行的语句.</li>\n</ul>\n<p>e.g:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; numbers = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>};</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 for-each 循环遍历 vector</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : numbers) {</span><br><span class=\"line\">        std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>; <span class=\"comment\">// 输出每个元素</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 auto 关键字自动推导类型</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num : numbers) {</span><br><span class=\"line\">        std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 修改容器中的元素（需要使用引用）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> &amp;num : numbers) {</span><br><span class=\"line\">        num *= <span class=\"number\">2</span>; <span class=\"comment\">// 将每个元素乘以 2</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出修改后的元素</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">auto</span> num : numbers) {</span><br><span class=\"line\">        std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>for (int &amp;num : numbers)</code>：使用引用 &amp;，可以直接修改容器中的元素.</li>\n</ul>\n<h3 id=\"Map的循环\"><a href=\"#Map的循环\" class=\"headerlink\" title=\"Map的循环\"></a>Map的循环</h3><p>当range_expression是<code>map</code>时, 可以使用<code>auto</code>自动推导range_declaration的类型.需要注意是:</p>\n<ul>\n<li>用迭代器的方式访问<code>map</code>中的键值对的形式是 <code>it-&gt;first</code>与<code>it-&gt;second</code>;</li>\n<li>在<code>for-each</code>循环当中, range_declaration是一个值, 因此使用<code>.first</code>与<code>.second</code>来访问键和值.  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;map&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    map&lt;string, string&gt; m = {{<span class=\"string\">\"one\"</span>, <span class=\"string\">\"1\"</span>}, {<span class=\"string\">\"two\"</span>, <span class=\"string\">\"2\"</span>}, {<span class=\"string\">\"three\"</span>, <span class=\"string\">\"3\"</span>}};</span><br><span class=\"line\">    vector&lt;string&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">auto</span>&amp; entry : m){</span><br><span class=\"line\">        vec.<span class=\"built_in\">push_back</span>(entry.first + <span class=\"string\">\":\"</span> + entry.second );</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">copy</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;string&gt;(cout, <span class=\"string\">\" \"</span>));</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n  <strong>Output:</strong>  <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">one:1 three:3 two:2</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此处由于<code>map</code>自动按照键的字典序进行排序, 因此输出时<code>three</code>的元素在<code>two</code>前;</p>\n</blockquote>\n</li>\n</ul>\n<p>在上述的示例中, 也可以使用下面的方式进行<code>vec</code>的输出:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">const</span> <span class=\"keyword\">auto</span>&amp; s : vec) {</span><br><span class=\"line\">    cout &lt;&lt; s &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>此时<code>auto</code>会自动推导为<code>string</code>类型, 且<code>&amp;</code>对数组的元素进行了引用, 使得输出更加高效.</p>\n<h3 id=\"Pro-Con\"><a href=\"#Pro-Con\" class=\"headerlink\" title=\"Pro&Con\"></a>Pro&amp;Con</h3><p><code>for-each</code>循环的优点:</p>\n<ul>\n<li>消除了访问数组等越界的风险;</li>\n<li>不需要事先初始化迭代器;</li>\n</ul>\n<p><code>for-each</code>循环的缺点:</p>\n<ul>\n<li>无法获取元素的索引;</li>\n<li>只能顺序地遍历.</li>\n</ul>\n<h2 id=\"typedef\"><a href=\"#typedef\" class=\"headerlink\" title=\"typedef\"></a>typedef</h2><p>我们可能经常遇到一些复杂的类型声明，特别是在使用模板、函数指针或复杂的数据结构时。这些类型名称可能会变得冗长，不仅书写起来繁琐，而且降低了代码的可读性.</p>\n<p>而typedef 就是为了解决这个问题而存在的，它允许我们为类型创建别名，使代码更加简洁和易于理解.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> old_type new_type;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Notices\"><a href=\"#Notices\" class=\"headerlink\" title=\"Notices\"></a>Notices</h2><ol>\n<li><p>直接对数组、字符串和<code>vector</code>进行随机访问时, 需要注意可能存在越界问题, 且编译器可能不会报错;</p>\n</li>\n<li><p>对于<code>vector</code>, 可以通过<code>.at() = </code>的方式进行安全访问, 编译器会进行边界检查. 或者通过<code>.push_back()</code> or <code>.emplace_back</code>的方式在末尾赋值. 同时注意用<code>.reserve()</code>预先分配充分的内存空间.</p>\n</li>\n<li><p>避免不经意地向<code>map</code>当中插入元素:</p>\n<ol>\n<li>错误的示范:</li>\n</ol>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(foo[<span class=\"string\">\"bob\"</span>] == <span class=\"number\">1</span>){...}</span><br><span class=\"line\"><span class=\"comment\">// 设置默认的零值</span></span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>使用<code>.count()</code>方法正确检查元素是否存在:</li>\n</ol>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>( foo.<span class=\"built_in\">count</span>(<span class=\"string\">\"bob\"</span>) ){...}</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>也可以使用<code>find()</code>方法检查元素是否存在:</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">auto</span> it = m.<span class=\"built_in\">find</span>(<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">if</span>(it  != m.<span class=\"built_in\">end</span>()){</span><br><span class=\"line\">    cout &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">else</span>{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Not found\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n<li><p>使用<code>.empty()</code>方法来检查容器<strong>整体是否为空</strong>, 而非<code>.count() == 0</code>的检查. 前者使用 O(1) 的时间复杂度, 而后者使用 O(n) 的时间复杂度.</p>\n</li>\n<li><p><code>erase()</code> 方法会返回<strong>指向</strong>被删除元素的<strong>下一个</strong>元素的迭代器, 应当直接采用返回值来对迭代器进行赋值:</p>\n <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Initialize a list</span></span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt; L;</span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt;::iterator li = L.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Wrong:</span></span><br><span class=\"line\">L.<span class=\"built_in\">erase</span>(li);    <span class=\"comment\">// 删除元素后，li 变成了无效迭代器</span></span><br><span class=\"line\">++li;           <span class=\"comment\">// 错误, 不能对无效迭代器进行操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Correct:</span></span><br><span class=\"line\">li = L.<span class=\"built_in\">erase</span>(li);  <span class=\"comment\">// 删除元素后，li 被更新为指向被删除元素的下一个元素</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"指针\"><a href=\"#指针\" class=\"headerlink\" title=\"指针\"></a>指针</h1><ul>\n<li>Pointers to Objects</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"hello\"</span>;</span><br><span class=\"line\">string *p = &amp;str;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Oprators with Pointers<ul>\n<li><code>&amp;</code>: 取地址;</li>\n<li><code>*</code>: 解引用;</li>\n<li><code>-&gt;</code>: 用于访问对象的成员.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*p).<span class=\"built_in\">length</span>();</span><br><span class=\"line\"><span class=\"comment\">// 等价于</span></span><br><span class=\"line\">p-&gt;<span class=\"built_in\">length</span>();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>length()</code>即为<code>string</code>类的成员函数, 因此可以用<code>-&gt;</code>来访问.</p>\n</blockquote>\n<h1 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h1><h2 id=\"指针-1\"><a href=\"#指针-1\" class=\"headerlink\" title=\"指针\"></a>指针</h2><blockquote>\n<p>以<code>char</code>为例.</p>\n</blockquote>\n<ul>\n<li>指向常量的指针 <code>const char *p</code><ul>\n<li>可以改变指针的地址.</li>\n<li>无法通过指针改变对象的值</li>\n</ul>\n</li>\n<li>常量指针 <code>char * const p</code><ul>\n<li>指针指向的地址无法改变;</li>\n<li>但是可以通过指针改变对象的值<br>如果需要同时保证地址和值都无法改变, 则需要使用<code>const char * const p</code>.</li>\n</ul>\n</li>\n</ul>\n<p>如果<code>sp</code>是指向字符串的指针, 那么这两种的写法是等价的, 注意<code>.</code>的优先级高于<code>*</code>, 因此括号不可忽略.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sp-&gt;<span class=\"built_in\">length</span>();</span><br><span class=\"line\">(*sp).<span class=\"built_in\">length</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Class\"><a href=\"#Class\" class=\"headerlink\" title=\"Class\"></a>Class</h1><h3 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"::\"></a><code>::</code></h3><p><code>::</code> resolver: 作用域解析运算符</p>\n<ul>\n<li><p>作用: </p>\n<ul>\n<li><p>访问全局的作用域<br>当局部变量和全局变量同名时, 可以使用 <code>::</code> 来访问全局变量</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> value = <span class=\"number\">10</span>; <span class=\"comment\">// 全局变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">function</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> value = <span class=\"number\">20</span>; <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">    cout &lt;&lt; value;    <span class=\"comment\">// 输出 20（局部变量）</span></span><br><span class=\"line\">    cout &lt;&lt; ::value;  <span class=\"comment\">// 输出 10（全局变量）</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问命名空间中的成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> Math {</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">double</span> PI = <span class=\"number\">3.14159</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span> circumference = <span class=\"number\">2</span> * Math::PI * radius; <span class=\"comment\">// 使用命名空间中的常量</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>语法:</p>\n<ul>\n<li><code>&lt;class_name&gt; :: &lt;function_name&gt;</code></li>\n<li><code>::&lt;function_name&gt;</code>  全局作用域</li>\n</ul>\n</li>\n</ul>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">S::f</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    ::<span class=\"built_in\">f</span>();  <span class=\"comment\">// Would be recursive otherwise!</span></span><br><span class=\"line\">    ::a++;  <span class=\"comment\">// Select the global a</span></span><br><span class=\"line\">    a--;    <span class=\"comment\">// The a at class scope</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>S::f()</code>: 定义了属于类S的成员函数f;</p>\n<p><code>::f()</code>:表示调用全局作用域中的函数 <code>f()</code>, 默认为递归调用当前的成员函数;</p>\n<p><code>::a++</code>表示将全局作用域的 <code>a</code> 自增, <code>a--</code>则访问并递减类作用域中的成员变量 <code>a</code>.</p>\n</blockquote>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a><code>this</code></h3><p><code>this</code>指针是成员函数的隐藏参数. 指向<strong>当前对象的实例</strong>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Point::move</span><span class=\"params\">(<span class=\"type\">int</span> dx, <span class=\"type\">int</span> dy)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Point::move</span><span class=\"params\">(Point *<span class=\"keyword\">this</span>, <span class=\"type\">int</span> dx, <span class=\"type\">int</span> dy)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>当调用成员函数时, 对象的地址会自动作为 <code>this</code>参数传递.</p>\n<p>在一个成员函数内部调用同一个类的其他成员函数时, 无需指定显式指定 <code>this</code>:</p>\n<p>e.g</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 移动点的位置</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move</span><span class=\"params\">(<span class=\"type\">int</span> dx, <span class=\"type\">int</span> dy)</span> </span>{</span><br><span class=\"line\">        x += dx;</span><br><span class=\"line\">        y += dy;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 打印点的坐标</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Point at (\"</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; y &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 组合以上两个功能的函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">move_and_print</span><span class=\"params\">(<span class=\"type\">int</span> dx, <span class=\"type\">int</span> dy)</span> </span>{</span><br><span class=\"line\">        <span class=\"built_in\">move</span>(dx, dy);  <span class=\"comment\">// 等同于 this-&gt;move(dx, dy)</span></span><br><span class=\"line\">        <span class=\"built_in\">print</span>();       <span class=\"comment\">// 等同于 this-&gt;print()</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>但是也可以显式指定 <code>this-&gt;move</code>, 这可以明确调用的是成员函数, 增强可读性, 便于IDE显示该类可访问的成员函数.</p>\n</blockquote>\n<h3 id=\"封装特性\"><a href=\"#封装特性\" class=\"headerlink\" title=\"封装特性\"></a>封装特性</h3><p>在OOP中, Object = Attributes + Services, 即数据和操作被<strong>封装</strong>在一起, 构成一个完整的对象.</p>\n<h3 id=\"声明与定义\"><a href=\"#声明与定义\" class=\"headerlink\" title=\"声明与定义\"></a>声明与定义</h3><p>我们应当在头文件中声明对象的成员及其 <code>public</code>,<code>private</code>和 <code>protected</code>等属性, 并且在 <code>cpp</code>文件中给出具体的定义:</p>\n<blockquote>\n<p>最好为每个类都建立如此对应的头文件和源文件 <code>cpp</code>.</p>\n</blockquote>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Student.h - 类的声明</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> STUDENT_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> STUDENT_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;  <span class=\"comment\">// 在头文件中使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 数据成员</span></span><br><span class=\"line\">    string name;     </span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\">    <span class=\"type\">float</span> gpa;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数原型</span></span><br><span class=\"line\">    <span class=\"built_in\">Student</span>(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">int</span> id);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 成员函数原型</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setName</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; newName)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">string <span class=\"title\">getName</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">calculateGPA</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">isEligibleForScholarship</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// STUDENT_H</span></span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Student.cpp - 成员函数的定义</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"Student.h\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;  <span class=\"comment\">// 在源文件中使用</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 构造函数实现</span></span><br><span class=\"line\">Student::<span class=\"built_in\">Student</span>(<span class=\"type\">const</span> string&amp; name, <span class=\"type\">int</span> id) {</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;name = name;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;id = id;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>-&gt;gpa = <span class=\"number\">0.0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 成员函数实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::setName</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; newName)</span> </span>{</span><br><span class=\"line\">    name = newName;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">Student::getName</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Student::calculateGPA</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 实现GPA计算逻辑</span></span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"title\">Student::isEligibleForScholarship</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> gpa &gt;= <span class=\"number\">3.5</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>Student::getName()</code>指的就是类 <code>Student</code>中的成员函数 <code>getName()</code>.</p>\n</blockquote>\n<p>具体来说, <code>.h</code>头文件当中应该有:</p>\n<ul>\n<li><p>外部变量的声明<br>e.g. <code>extern int globalCounter;  // 仅声明，不定义</code></p>\n</li>\n<li><p>函数原型<br>e.g. <code>int calculateSum(int a, int b);  // 函数声明，不包含实现</code></p>\n</li>\n<li><p>类/结构体的声明<br>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Student</span>;  <span class=\"comment\">// 前向声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 或完整类声明（不含成员函数定义）</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">double</span> width;</span><br><span class=\"line\">    <span class=\"type\">double</span> height;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Rectangle</span>(<span class=\"type\">double</span> w, <span class=\"type\">double</span> h);</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">double</span> <span class=\"title\">getArea</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>回顾 <code>#include</code>: 将被引用的文件插入 <code>.cpp</code> 文件当中</p>\n<ul>\n<li><p><code>#include \"xx.h\"</code>: 首先在当前目录下寻找;</p>\n</li>\n<li><p><code>#include &lt;xx.h&gt;</code>: 直接在指定的目录中寻找</p>\n<blockquote>\n<p>等价于 <code>#include &lt;xx&gt;</code>.</p>\n</blockquote>\n</li>\n</ul>\n<p>为了避免在多个 <code>.cpp</code> 文件中重复引用相同的头文件, 可以通过 <code>#ifndef</code>等标记来判断是否需要引用当前的头文件:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> HEADER_FLAG</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> HEADER_FLAG</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> </span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>HEADER_FLAG</code>一般使用完全大写来方便标识, 但是也可以大小写混合.</p>\n</blockquote>\n<p>e.g. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 文件: vector.h</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> VECTOR_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> VECTOR_H</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">// VECTOR_H</span></span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"生命周期管理\"><a href=\"#生命周期管理\" class=\"headerlink\" title=\"生命周期管理\"></a>生命周期管理</h2><p>当对象被创建时，通常需要进行一些初始化工作. 而当对象不再使用时，则需要进行相应的清理工作.</p>\n<p>为了确保这些工作不被遗忘, <code>cpp</code>的类具有构造函数和析构函数, 分别作用于对象的创建和消除过程.</p>\n<h3 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><p>构造函数是一种特殊的成员函数，其名称与类名相同，没有返回类型（甚至不是void）。当创建类的对象时，构造函数会自动被调用.</p>\n<ul>\n<li>语法:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 带参数的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>(参数列表);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassName</span>(<span class=\"type\">const</span> ClassName&amp; other);</span><br><span class=\"line\">    </span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li><strong>默认构造函数</strong>：不带参数或所有参数都有默认值;</li>\n<li><strong>带参数的构造函数</strong>：接受一个或多个参数;</li>\n<li><strong>拷贝构造函数</strong>：从同类型的另一个对象创建新对象.</li>\n</ol>\n</blockquote>\n<ul>\n<li><p>构造函数初始化列表</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point::<span class=\"built_in\">Point</span>(<span class=\"type\">int</span> xx, <span class=\"type\">int</span> yy) :<span class=\"built_in\">x</span>(xx), <span class=\"built_in\">y</span>(yy) {</span><br><span class=\"line\">  ...</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>构造函数时, 传递参数并直接赋值给内部的成员变量 <code>x</code> , <code>y</code>.</p>\n</blockquote>\n</li>\n<li><p>结构体中的构造函数:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Y</span> { </span><br><span class=\"line\">    <span class=\"type\">float</span> f;     <span class=\"comment\">// 浮点型成员变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> i;       <span class=\"comment\">// 整型成员变量</span></span><br><span class=\"line\">    <span class=\"built_in\">Y</span>(<span class=\"type\">int</span> a);    <span class=\"comment\">// 声明了一个接受int参数的构造函数</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>此处只是声明了构造函数需要 <code>int a</code>作为参数, 但是没有给出具体的实现;</li>\n<li>声明结构体对象(数组)  e.g. <code>Y y1[] = { Y(1), Y(2), Y(3) };</code></li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"默认构造\"><a href=\"#默认构造\" class=\"headerlink\" title=\"默认构造\"></a>默认构造</h3><p><code>auto</code> default constructor: (自动) 默认构造函数. <strong>当且仅当</strong>不存在任何构造函数时, 程序会自动生成默认构造函数, 不作任何的操作.</p>\n<p><code>默认构造函数</code>： 在没有参数的情况下可以调用的构造函数， 称为默认构造函数. 其来源除了上述的程序构造以外, 还包括:</p>\n<ol>\n<li>显示定义的无参构造函数;</li>\n<li>定义的所有参数都具有默认值的构造函数.</li>\n</ol>\n<ul>\n<li>对于成员变量: 不进行初始化;</li>\n</ul>\n<h3 id=\"析构函数\"><a href=\"#析构函数\" class=\"headerlink\" title=\"析构函数\"></a>析构函数</h3><p>析构函数也是一种特殊的成员函数，其名称是类名前加上波浪号 <code>~</code>. 当对象超出作用域或被显式删除时，析构函数会自动被调用.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassName</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">ClassName</span>();</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类似于栈, 优先创建的后析构.</li>\n</ul>\n<p>运用的示例:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;cstring&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyString</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span>* data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>() : <span class=\"built_in\">data</span>(<span class=\"literal\">nullptr</span>) {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"默认构造函数调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 带参数的构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> <span class=\"type\">char</span>* str) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str) {</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, str);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"参数构造函数调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyString</span>(<span class=\"type\">const</span> MyString&amp; other) {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data) {</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">        } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"拷贝构造函数调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">MyString</span>() {</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"析构函数调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 打印字符串</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; (data ? data : <span class=\"string\">\"空字符串\"</span>) &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 测试各种构造函数</span></span><br><span class=\"line\">    MyString s1;                  <span class=\"comment\">// 默认构造函数</span></span><br><span class=\"line\">    <span class=\"function\">MyString <span class=\"title\">s2</span><span class=\"params\">(<span class=\"string\">\"Hello\"</span>)</span></span>;         <span class=\"comment\">// 带参数的构造函数</span></span><br><span class=\"line\">    MyString s3 = s2;             <span class=\"comment\">// 拷贝构造函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    s<span class=\"number\">1.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    s<span class=\"number\">2.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    s<span class=\"number\">3.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  <span class=\"comment\">// 所有对象在这里被销毁，调用析构函数</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<p>本地对象: </p>\n<p><code>Field</code>(字段)指的是在类中定义的变量(成员变量):</p>\n<ul>\n<li>可以直接被类中的所有方法访问;</li>\n<li>生命周期<strong>和类的对象保持一致;</strong></li>\n</ul>\n<p>其他类型数据的生命周期:</p>\n<ul>\n<li><strong>参数</strong>: 函数执行期间;</li>\n<li><strong>局部变量</strong>: 声明的代码块内部.</li>\n</ul>\n<hr>\n<p>全局对象:</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>如果在类或对象的方法内部定义了一个和成员变量同名的变量, 那么将默认访问这个变量, 只有用 <code>this-&gt;xxx</code>才能显式访问成员变量. e.g. <code>int MyClass::count </code>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> value = <span class=\"number\">10</span>; <span class=\"comment\">// 字段</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printValue</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        <span class=\"type\">int</span> value = <span class=\"number\">20</span>; <span class=\"comment\">// 局部变量</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Local value: \"</span> &lt;&lt; value &lt;&lt; std::endl; <span class=\"comment\">// 输出局部变量</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Field value: \"</span> &lt;&lt; <span class=\"keyword\">this</span>-&gt;value &lt;&lt; std::endl;<span class=\"comment\">//使用this指针访问字段</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></blockquote>\n<h2 id=\"Access-Control\"><a href=\"#Access-Control\" class=\"headerlink\" title=\"Access Control\"></a>Access Control</h2><p><code>class</code>的默认为 <code>private</code>, 而 <code>struct</code>的默认权限是 <code>public</code>.</p>\n<p>访问限制符:</p>\n<h3 id=\"friend\"><a href=\"#friend\" class=\"headerlink\" title=\"friend\"></a><code>friend</code></h3><p>在 <code>class</code>内部声明友元, 可以使得对应的函数访问自身的成员变量(包括私有和受保护, 也即是所有的变量).</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">X</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">initialize</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">g</span><span class=\"params\">(X*, <span class=\"type\">int</span> i)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">friend</span> <span class=\"type\">void</span> <span class=\"title\">Y::y</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>[!NOTE]</p>\n<p><strong>友元关系不具有传递性 !</strong></p>\n</blockquote>\n<h3 id=\"protected\"><a href=\"#protected\" class=\"headerlink\" title=\"protected\"></a><code>protected</code></h3><p>该声明内的成员可以被以下的范围访问:</p>\n<ol>\n<li>该类自身的成员函数;</li>\n<li><strong>该类的派生类的成员函数;</strong></li>\n</ol>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> {</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> protectedVar;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">protectedVar</span>(val) {}</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">Base</span>(val) {}</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">accessProtectedVar</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        protectedVar = <span class=\"number\">10</span>; <span class=\"comment\">// 派生类可以访问 protectedVar</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getProtectedVar</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> protectedVar;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此处的 <code>base</code>就是一个基类, <code>class Derived : public Base</code>表明 Derived 是 base的一个派生类.</p>\n<p>因此,  派生类可以通过自己的成员函数, 访问基类的 <code>protected</code>内的成员变量.</p>\n</blockquote>\n<h2 id=\"Static\"><a href=\"#Static\" class=\"headerlink\" title=\"Static\"></a>Static</h2><p>对于本地变量和全局变量的作用不同, 前者是生命周期, 后者是访问空间.</p>\n<p>静态的对象的生命周期是全局, 但是不会跟全局变量一样(一开始就创建), 而是在第一次调用的时候才构造, 且只构造一次.</p>\n<ul>\n<li><p><code>静态成员变量</code>由所有的实例<strong>共享</strong>, 初始化的时候不能再添加 <code>static</code>标签(否则无法被外文件访问), 必须在类的外部进行初始化, 且需要声明所属于的类;</p>\n<blockquote>\n<p>但是也可以被普通的成员函数所访问.</p>\n</blockquote>\n</li>\n<li><p><code>静态成员函数</code>属于类本身, 因此可以通过类名直接调用, 但是只能访问类的静态成员变量, 因为不存在属于实例的<code>this</code>指针. 静态成员函数可以在<strong>类的内部</strong>就定义, 如果在类的外部定义, 也不需要额外的<code>static</code>标签;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">int</span> count; <span class=\"comment\">// 静态成员变量</span></span><br><span class=\"line\">    <span class=\"type\">int</span> id;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> i) : <span class=\"built_in\">id</span>(i) {</span><br><span class=\"line\">        count++; <span class=\"comment\">// 每次创建对象，count加1</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    ~<span class=\"built_in\">MyClass</span>() {</span><br><span class=\"line\">        count--;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">static</span> <span class=\"type\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>{ <span class=\"comment\">// 静态成员函数</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> MyClass::count = <span class=\"number\">0</span>; <span class=\"comment\">// 静态成员变量的初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Count: \"</span> &lt;&lt; MyClass::<span class=\"built_in\">getCount</span>() &lt;&lt; std::endl; <span class=\"comment\">// 通过类名调用静态成员函数</span></span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">obj1</span><span class=\"params\">(<span class=\"number\">1</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">obj2</span><span class=\"params\">(<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Count: \"</span> &lt;&lt; MyClass::<span class=\"built_in\">getCount</span>() &lt;&lt; std::endl; <span class=\"comment\">// 通过类名调用静态成员函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p><strong>Output:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Count: <span class=\"number\">0</span></span><br><span class=\"line\">Count: <span class=\"number\">2</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>函数内部的静态变量只会在调用的时候<strong>初始化一次</strong>, 直到程序结束.<br>e.g. 计数函数的调用次数:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  <span class=\"type\">static</span> <span class=\"type\">int</span> num_calls = <span class=\"number\">0</span>;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  num_calls += <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>extern</code>关键字用于声明变量或函数在其他文件中定义. 告诉编译器从而允许跨文件的访问.</p>\n<blockquote>\n<p>但是这种跨文件访问只能作用于<strong>非静态</strong>的全局变量, i.e. 全局变量加上<code>static</code>声明之后, 将其作用域限制在了当前文件的内部.</p>\n</blockquote>\n</li>\n<li><p>函数内部的静态对象, 其构造函数只会在定义的时候调用一次. 并且析构函数当退出程序时调用. 即使采取条件构造, 也只会在第一次条件满足的时候构造.</p>\n</li>\n<li><p>静态成员的使用:</p>\n<ul>\n<li><p>通过类名: <code>&lt;class_name&gt;::&lt;static member</code></p>\n</li>\n<li><p>通过实例名: <code>&lt;ob variable&gt;.&lt;static member&gt;</code></p>\n<blockquote>\n<p>让人误以为是类的对象变量, 不建议这样使用.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p>引用（Reference）是一个非常重要的特性。它的引入是为了解决一些特定场景下的问题：</p>\n<ul>\n<li><strong><u>避免不必要的拷贝</u></strong>：在某些情况下，传递大型对象或结构体给函数时，如果直接传递拷贝会导致性能下降。引用允许我们传递对象的别名，而不需要拷贝整个对象。</li>\n<li><strong><u>简化代码</u></strong>：引用可以使代码更简洁，特别是在函数返回值和参数传递时。例如，通过引用返回一个对象可以避免构造临时对象。</li>\n<li><strong><u>指针的安全替代</u></strong>：引用提供了指针的功能，但避免了指针容易导致的错误，如空指针解引用或野指针。</li>\n</ul>\n<p><strong>基本语法</strong>: </p>\n<p>引用是一个变量的别名，它在<strong>声明时必须被初始化</strong>，并且一旦初始化后就**<u>不能再指向其他</u>**对象.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp; ref = a;  <span class=\"comment\">// ref 是 a 的引用</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>int&amp;</code> 表示引用类型，<code>ref</code> 是 <code>a</code> 的引用。</li>\n<li>引用必须在声明时初始化，并且不能重新引用到另一个对象。</li>\n<li>无法对引用进行引用;</li>\n<li><strong>不允许</strong>存在 <strong>以引用为元素的数组</strong></li>\n</ul>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>&amp; ref = a;  <span class=\"comment\">// ref 是 a 的引用</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Original value of a: \"</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Value of ref: \"</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    ref = <span class=\"number\">20</span>;  <span class=\"comment\">// 修改引用会影响原变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"After modifying ref, value of a: \"</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Value of ref: \"</span> &lt;&lt; ref &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中：</p>\n<ul>\n<li><code>ref</code> 是 <code>a</code> 的引用，修改 <code>ref</code> 的值会影响 <code>a</code> 的值。</li>\n<li>通过引用，我们可以访问和修改原始变量 <code>a</code> 的值，而不需要直接操作 <code>a</code>。</li>\n</ul>\n<p>引用可以作为函数的形参, 此时<strong>函数内部的形参作为实参的引用可以改变实参的值</strong>.</p>\n<p>引用的绑定必须是一个具有明确地址的左值 ,而不能是临时产生的右值:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"type\">int</span> &amp;)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">func</span> (i * <span class=\"number\">3</span>); <span class=\"comment\">// Warning or error!</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"指针与引用\"><a href=\"#指针与引用\" class=\"headerlink\" title=\"指针与引用\"></a>指针与引用</h4><ul>\n<li><p>限制:</p>\n<ul>\n<li><p>无法获得指针的引用;</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> &amp;*p;<span class=\"comment\">// illegal</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>但是可以获得<strong>指向引用的指针</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> *&amp;p)</span></span>;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p> 可以如此理解, 引用实际上是对象的别名. 用于修改对象的值. 但是为了修改指针, 可以直接使用指针的指针 <code>**</code>.</p>\n<p>此外, 引用并非独立的对象, 而是直接 <strong>绑定</strong>. 因此 <code>int&amp; ref = a;</code>  <code>&amp;ref</code>就是 a的地址.</p>\n<h4 id=\"右值引用\"><a href=\"#右值引用\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h4><p>左值是指具有明确地址的变量或者引用, 右值是计算过程中的中间结果或者字面量 (e.g.<code>10</code>).等不可寻址的值;</p>\n<blockquote>\n<p>涉及到计算的基本都是右值, 但是这四种的计算结果依旧是左值: <code>*</code>,<code>.</code>,<code>[]</code>和 <code>-&gt;</code>.</p>\n</blockquote>\n<p>右值一般在计算结束后就消失了, 如果我们希望延长其生命周期, 就可以使用 <strong>右值引用</strong>.</p>\n<ul>\n<li><p><strong>格式</strong>: <code>&lt;tyep&gt; &amp;&amp; &lt;ref_name&gt; = &lt;right_value&gt;</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x=<span class=\"number\">20</span>; <span class=\"comment\">// left-value </span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rx = x * <span class=\"number\">2</span>:</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>TIps:</p>\n<ul>\n<li>右值引用在初始化之后就可以正常赋值;</li>\n<li>右值引用无法使用左值进行赋值.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"引用参数与函数重载\"><a href=\"#引用参数与函数重载\" class=\"headerlink\" title=\"引用参数与函数重载\"></a>引用参数与函数重载</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"type\">int</span>&amp; lref)</span></span>{</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">\"lref = \"</span> &lt;&lt; lref &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">fun</span><span class=\"params\">(<span class=\"type\">int</span>&amp;&amp; rref)</span></span>{</span><br><span class=\"line\">   cout &lt;&lt; <span class=\"string\">\"rref = \"</span> &lt;&lt; rref &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">   <span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\">   <span class=\"built_in\">fun</span>(x);</span><br><span class=\"line\">   <span class=\"built_in\">fun</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p><strong>Output</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lref = <span class=\"number\">10</span></span><br><span class=\"line\">rref = <span class=\"number\">10</span></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>字面量<code>10</code>作为右值, 可以通过右值引用作为函数的参数;</li>\n<li>具有明确地址的变量 <code>x</code>是左值;</li>\n<li>C++ 允许在同一个作用域内声明多个具有相同名称但参数列表不同的函数。这被称为<strong>函数重载</strong>。编译器通过检查函数调用时提供的参数类型和数量来决定调用哪个重载函数。</li>\n</ol>\n</blockquote>\n<p>另外, 加上<code>const</code>之后, <code>&amp; </code>的形参也可以接受右值作为实参, 比如: <code>void fun (const int&amp; clref) {...}</code></p>\n<blockquote>\n<p>但是如果已经存在右值实参作为形参的同名函数, 将会优先选择后者进行重载.</p>\n</blockquote>\n<p>这是因为普通引用对于右值的修改 make no sense, 而 <code>const</code> 引用<u>保证不会修改引用的对象</u>，因此即使是临时对象（右值）也可以安全地绑定到 <code>const</code> 引用.</p>\n<h2 id=\"Constants\"><a href=\"#Constants\" class=\"headerlink\" title=\"Constants\"></a>Constants</h2><p>使用 <code>const</code>声明常量, 常量的值不可修改.</p>\n<p><code>const</code>声明集合的时候, 其中的值在<strong>编译期间不可知</strong>, 因此<u>无法在代码中, 使用常量集合内部的值进行操作.</u></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">int</span> i[] = {<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>};</span><br><span class=\"line\"><span class=\"type\">float</span> f[i[<span class=\"number\">2</span>]]; <span class=\"comment\">// Illegal!</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用<code>const</code>对指针类型进行操作的时候:</p>\n<ol>\n<li>忽略类似于 <code>char</code>之类的类型, 只关注 <code>const</code>与 <code>*</code>之间的位置关系;</li>\n<li>如果是 <code>const *p</code> 意思是指针指向的内容不可通过这个指针进行更改;</li>\n<li>如果是 <code>* const p</code>意思是指针指向的对象不可更改, 但是可以通过 <code>*p</code> 的方式改写对象的值</li>\n</ol>\n<hr>\n<p>关于字符指针与字符数组:</p>\n<ul>\n<li><code>char  *p = \"hello\";</code> 实际上是 <code>const char *p</code>, 也就是说不允许修改 <code>*p</code>;</li>\n<li>而 <code>char p[] = 'hello';</code> 则可以通过<code>*p</code> 修改.</li>\n</ul>\n<hr>\n<p>如果<strong>成员函数</strong>的<u>名称后</u>加了 <code>const</code>标记, 意味着:</p>\n<ol>\n<li>无法通过该成员函数改变成员变量的值.</li>\n<li>同时无法调用其他 <strong>非const</strong>的成员函数</li>\n<li>实际上, 将其的 <code>this</code>指针转换为 <code>const A* this</code>, 也就是指向常量的指针</li>\n</ol>\n<blockquote>\n<p>因此 <code>const</code>修饰的成员函数具有 <code>this</code>指针(可访问), 不要与 <code>static</code>修饰的静态成员函数混淆! 后者不具有 <code>this</code>指针.</p>\n<p>注意不要与 <code>const  type f()</code>混淆, 这是限制返回的结果无法修改; 而 <code>type f() const</code>限制成员函数本身的操作.</p>\n</blockquote>\n<p><strong>重载</strong>: 允许根据成员函数是否被 <code>const</code>限制, 以及对象本身是否为 <code>const</code>来重载成员函数.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"const version\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"non-const version\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    A a;</span><br><span class=\"line\">    <span class=\"type\">const</span> A ca;</span><br><span class=\"line\"></span><br><span class=\"line\">    a.<span class=\"built_in\">f</span>();    <span class=\"comment\">// 输出: non-const version</span></span><br><span class=\"line\">    ca.<span class=\"built_in\">f</span>();   <span class=\"comment\">// 输出: const version</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果成员变量是 <code>const</code>, 那么:</p>\n<ul>\n<li><p><strong>必须在对象构造时进行初始化</strong> (无法在构造函数中进行直接赋值):</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> value) : <span class=\"built_in\">i</span>(value) {} <span class=\"comment\">// 在初始化列表中初始化</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>如果在实例化对象的时候,  声明了这个实例是 <code>const</code>, 那么就无法调用成员函数中没有在后面声明 <code>const</code>的部分.( 即使实际上并没有修改的函数, 也不能通过编译).  —— 只能调用那些被标记为<code>const</code>的成员函数。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>{</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get_value</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> get_const_value <span class=\"title\">const</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> A <span class=\"title\">a</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">a.get_value; <span class=\"comment\">// ERROR, const对象无法调用非const声明的成员函数</span></span><br><span class=\"line\">a.get_const_value; <span class=\"comment\">// ok</span></span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250318120332036.png?imageSlim\" alt=\"image-20250318120332036\"></p>\n<blockquote>\n<p>无法用普通的指针来指向 <code>const</code>常量.</p>\n<p>但是可以用指向常量的指针 来指向非常量的对象.</p>\n</blockquote>\n<hr>\n<p>全局变量的构造在 <code>main()</code>之前. 静态本地变量在第一次执行到的时候才发生构造, 且只构造一次.</p>\n<hr>\n<h2 id=\"动态内存\"><a href=\"#动态内存\" class=\"headerlink\" title=\"动态内存\"></a>动态内存</h2><p>在 C++ 中，使用 <code>new</code> 关键字分配的空间位于 <strong>堆</strong> 上，与栈上的自动变量不同，堆上的内存不会自动释放，需要手动使用 <code>delete</code> 来析构以避免内存泄漏。</p>\n<h4 id=\"示例代码\"><a href=\"#示例代码\" class=\"headerlink\" title=\"示例代码\"></a>示例代码</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"comment\">// 使用 new 在堆上分配一个整数</span></span><br><span class=\"line\">    <span class=\"type\">int</span>* ptr = <span class=\"keyword\">new</span> <span class=\"built_in\">int</span>(<span class=\"number\">10</span>);</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"值: \"</span> &lt;&lt; *ptr &lt;&lt; endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 使用 delete 释放内存</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> ptr;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 指针置空，避免野指针</span></span><br><span class=\"line\">    ptr = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"注意事项\"><a href=\"#注意事项\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ul>\n<li>每次 <code>new</code> 分配的内存都需要对应的 <code>delete</code>。</li>\n<li>对于数组，使用 <code>new[]</code> 分配，释放时用 <code>delete[]</code>：</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>* arr = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[<span class=\"number\">5</span>];  <span class=\"comment\">// 分配数组</span></span><br><span class=\"line\"><span class=\"keyword\">delete</span>[] arr;           <span class=\"comment\">// 释放数组</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Inline-Class\"><a href=\"#Inline-Class\" class=\"headerlink\" title=\"Inline Class\"></a>Inline Class</h2><h3 id=\"Delegating-Constructor\"><a href=\"#Delegating-Constructor\" class=\"headerlink\" title=\"Delegating Constructor\"></a>Delegating Constructor</h3><p>委托构造函数（Delegating Constructor）是通过一个构造函数调用另一个构造函数来完成初始化的机制, 也就是在初始化列表中调用其他.</p>\n<p>相对于委托构造的构造函数, 被称为 <em>target constructor</em> 目标构造函数.</p>\n<p>目标构造函数的执行先于委托构造函数.</p>\n<hr>\n<h4 id=\"什么是委托构造函数？\"><a href=\"#什么是委托构造函数？\" class=\"headerlink\" title=\"什么是委托构造函数？\"></a>什么是委托构造函数？</h4><ul>\n<li><strong>定义</strong>: 一个构造函数可以在其初始化列表中调用同一个类的另一个构造函数来完成部分或全部初始化工作。</li>\n<li><strong>目的</strong>: 避免在多个构造函数中重复编写相同的初始化逻辑，解决代码重复的问题。</li>\n<li><strong>限制</strong>: 委托构造函数<u>本身不能在初始化列表中再初始化其他成员变量</u>，只能依赖被调用的构造函数。</li>\n</ul>\n<h4 id=\"代码示例与分析\"><a href=\"#代码示例与分析\" class=\"headerlink\" title=\"代码示例与分析\"></a>代码示例与分析</h4><p>考虑将下面的冗余代码通过委托构造函数简化:</p>\n<p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250325120013059.png?imageSlim\"></p>\n<p>实现: </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassC</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> max;</span><br><span class=\"line\">    <span class=\"type\">int</span> min;</span><br><span class=\"line\">    <span class=\"type\">int</span> middle;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 基础构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max) {</span><br><span class=\"line\">        max = (my_max &gt; <span class=\"number\">0</span>) ? my_max : <span class=\"number\">10</span>;  <span class=\"comment\">// 默认值10</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 委托给基础构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max, <span class=\"type\">int</span> my_min) : <span class=\"built_in\">ClassC</span>(my_max) {</span><br><span class=\"line\">        min = (my_min &gt; <span class=\"number\">0</span> &amp;&amp; my_min &lt; max) ? my_min : <span class=\"number\">1</span>;  <span class=\"comment\">// 默认值1</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 委托给第二个构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max, <span class=\"type\">int</span> my_min, <span class=\"type\">int</span> my_middle) : <span class=\"built_in\">ClassC</span>(my_max, my_min) {</span><br><span class=\"line\">        middle = (my_middle &lt; max &amp;&amp; my_middle &gt; min) ? my_middle : <span class=\"number\">5</span>;  <span class=\"comment\">// 默认值5</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    ClassC c1{<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>};</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"max: \"</span> &lt;&lt; c<span class=\"number\">1.</span>max &lt;&lt; <span class=\"string\">\", min: \"</span> &lt;&lt; c<span class=\"number\">1.</span>min &lt;&lt; <span class=\"string\">\", middle: \"</span> &lt;&lt; c<span class=\"number\">1.</span>middle &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"运行结果分析\"><a href=\"#运行结果分析\" class=\"headerlink\" title=\"运行结果分析\"></a>运行结果分析</h4><ul>\n<li><code>ClassC c1{1, 3, 2}</code>:<ol>\n<li>调用 <code>ClassC(int, int, int)</code> 构造函数。</li>\n<li>它委托给 <code>ClassC(int, int)</code>，后者再委托给 <code>ClassC(int)</code>。</li>\n<li>初始化顺序：<ul>\n<li><code>max = 1</code>（因为 1 &gt; 0）。</li>\n<li><code>min = 1</code>（因为 3 &gt; max，不满足条件，使用默认值 1）。</li>\n<li><code>middle = 2</code>（因为 2 &lt; max 且 2 &gt; min 不成立，但逻辑上仍赋值 2，需检查代码逻辑）。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"关键点\"><a href=\"#关键点\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ol>\n<li><p><strong>初始化位置</strong>:</p>\n<ul>\n<li>成员变量不能在委托构造函数的初始化列表中直接使用参数初始化，必须通过被委托的构造函数完成。</li>\n<li>如 <code>ClassC(int my_max, int my_min) : ClassC(my_max)</code> 中，不能再初始化 <code>min</code>，只能在函数体内赋值。</li>\n</ul>\n</li>\n<li><p><strong>代码重复问题</strong>:</p>\n<ul>\n<li>如果每个构造函数都独立初始化 <code>max</code>、<code>min</code> 等，会导致重复代码。</li>\n<li>委托构造函数将公共逻辑集中到基础构造函数中。</li>\n</ul>\n</li>\n<li><p><strong>委托链</strong>:</p>\n<ul>\n<li>可以形成构造函数调用链，如 <code>ClassC(int, int, int)</code> → <code>ClassC(int, int)</code> → <code>ClassC(int)</code>。</li>\n</ul>\n</li>\n<li><p><strong>限制与解决方法</strong>:</p>\n<ul>\n<li>委托构造函数不能再有其他初始化列表项。</li>\n<li>如果需要更灵活的初始化，可以引入一个私有的辅助构造函数：</li>\n</ul>\n</li>\n</ol>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ClassC</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> max;  </span><br><span class=\"line\">    <span class=\"type\">int</span> min;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"type\">int</span> my_max)</span> </span>{ max = my_max &gt; <span class=\"number\">0</span> ? my_max : <span class=\"number\">10</span>; }</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max) { <span class=\"built_in\">init</span>(my_max); }</span><br><span class=\"line\">    <span class=\"built_in\">ClassC</span>(<span class=\"type\">int</span> my_max, <span class=\"type\">int</span> my_min) : <span class=\"built_in\">min</span>(my_min) { <span class=\"built_in\">init</span>(my_max); } <span class=\"comment\">// 直接在初始化列表中初始成员变量\t</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<hr>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><ul>\n<li>默认参数是在函数声明中为参数指定的默认值，调用时未提供参数则使用默认值。</li>\n<li>规则：默认参数必须<u>从右到左设置</u>。</li>\n</ul>\n<h4 id=\"代码示例\"><a href=\"#代码示例\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 函数声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">harpo</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m = <span class=\"number\">4</span>, <span class=\"type\">int</span> j = <span class=\"number\">5</span>)</span></span>;  <span class=\"comment\">// 合法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">chico</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m = <span class=\"number\">6</span>, <span class=\"type\">int</span> j)</span></span>;       <span class=\"comment\">// 非法：j 无默认值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">groucho</span><span class=\"params\">(<span class=\"type\">int</span> k = <span class=\"number\">1</span>, <span class=\"type\">int</span> m = <span class=\"number\">2</span>, <span class=\"type\">int</span> n = <span class=\"number\">3</span>)</span></span>;  <span class=\"comment\">// 合法</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> beeps;</span><br><span class=\"line\">    beeps = <span class=\"built_in\">harpo</span>(<span class=\"number\">2</span>);      <span class=\"comment\">// harpo(2, 4, 5) -&gt; 11</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"beeps = \"</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class=\"line\">    beeps = <span class=\"built_in\">harpo</span>(<span class=\"number\">1</span>, <span class=\"number\">8</span>);   <span class=\"comment\">// harpo(1, 8, 5) -&gt; 14</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"beeps = \"</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class=\"line\">    beeps = <span class=\"built_in\">harpo</span>(<span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">6</span>);  <span class=\"comment\">// harpo(8, 7, 6) -&gt; 21</span></span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"beeps = \"</span> &lt;&lt; beeps &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">harpo</span><span class=\"params\">(<span class=\"type\">int</span> n, <span class=\"type\">int</span> m, <span class=\"type\">int</span> j)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n + m + j;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关键点-1\"><a href=\"#关键点-1\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ol>\n<li><strong>规则</strong>:<ul>\n<li>默认参数从右到左设置。</li>\n<li><code>int harpo(int n, int m = 4, int j = 5)</code> 合法。</li>\n<li><code>int chico(int n, int m = 6, int j)</code> 非法。</li>\n</ul>\n</li>\n<li><strong>作用</strong>:<ul>\n<li>省略参数时自动填充默认值。</li>\n<li>减少函数重载需求。</li>\n</ul>\n</li>\n<li><strong>注意</strong>:<ul>\n<li>默认值在声明中指定，<u>不在定义中</u>。</li>\n<li>不能“跳跃”使用参数，如 <code>harpo(1, , 6)</code> 非法。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"改进建议\"><a href=\"#改进建议\" class=\"headerlink\" title=\"改进建议\"></a>改进建议</h4><ul>\n<li>复杂逻辑可考虑函数重载或委托构造函数。</li>\n<li>避免过度使用默认参数以保持代码清晰。</li>\n</ul>\n<hr>\n<h3 id=\"内联函数\"><a href=\"#内联函数\" class=\"headerlink\" title=\"内联函数\"></a>内联函数</h3><blockquote>\n<p>Inline Functions</p>\n</blockquote>\n<h4 id=\"定义-1\"><a href=\"#定义-1\" class=\"headerlink\" title=\"定义\"></a>定义</h4><ul>\n<li><p>内联函数是用 <code>inline</code> 关键字修饰的函数，编译器会尝试将函数调用替换为函数体代码，减少函数调用的开销。</p>\n<blockquote>\n<p>普通函数的调用需要经历: 压栈、传递参数、跳转到函数地址、返回值处理、出栈等步骤, 由此可见内联函数可以有效提升性能.</p>\n</blockquote>\n</li>\n<li><p>适用于小型、频繁调用的函数。</p>\n</li>\n</ul>\n<h4 id=\"代码示例-1\"><a href=\"#代码示例-1\" class=\"headerlink\" title=\"代码示例\"></a>代码示例</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 内联函数定义</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> <span class=\"title\">square</span><span class=\"params\">(<span class=\"type\">int</span> x)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x * x;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">int</span> num = <span class=\"number\">5</span>;</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Square of \"</span> &lt;&lt; num &lt;&lt; <span class=\"string\">\" is \"</span> &lt;&lt; <span class=\"built_in\">square</span>(num) &lt;&lt; endl;  <span class=\"comment\">// 输出 25</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"关键点-2\"><a href=\"#关键点-2\" class=\"headerlink\" title=\"关键点\"></a>关键点</h4><ol>\n<li><strong>作用</strong>:<ul>\n<li>减少函数调用开销（如参数传递、栈帧创建）。</li>\n<li>提高执行效率，适合小型函数。</li>\n</ul>\n</li>\n<li><strong>使用场景</strong>:<ul>\n<li>函数体短小、调用频繁。</li>\n<li>不适合复杂函数（可能导致代码膨胀）。</li>\n</ul>\n</li>\n<li><strong>注意</strong>:<ul>\n<li><code>inline</code> 是建议，编译器可能忽略（例如函数过大或包含循环）。</li>\n<li>内联函数定义通常放在头文件中，避免链接错误 (在多个源文件被调用的时候, <code>inline</code>的声明可以告诉编译器, 重复的定义是被允许的)</li>\n</ul>\n</li>\n</ol>\n<blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li><p><strong>Any function you define inside a class declaration is automatically an inline.</strong></p>\n<blockquote>\n<p><code>class</code>内部**<u>定义</u>**的函数自动为 <code>inline</code>类型. 如果是类外定义(相同的<code>.h</code>文件), 那么需要显式声明为内联函数.</p>\n</blockquote>\n</li>\n<li><p>内联函数必须在**<u>头文件</u>**中定义，或者在调用它的同一翻译单元中.</p>\n<blockquote>\n<p>如果定义在 .cpp 文件中，调用点无法看到定义，编译器无法内联，链接器会报错.</p>\n</blockquote>\n</li>\n<li><p>如果决定将类的函数定义写在头文件中, 有以下的两种选择使其成为内联函数;</p>\n<ol>\n<li>直接在声明的地方给出完全的定义;</li>\n<li>在类外声明 <code>inline</code>然后定义.</li>\n</ol>\n</li>\n<li><p><code>inline</code>确实比C语言的 <code>macro</code>更好, 因为内联函数实现了对参数的类型检查.</p>\n</li>\n<li><p>编译器会对声明为 <code>inline</code> 的函数进行检查: 如果包含了递归 或者 代码量较大, 编译器依旧不会将其视为 <code>inline</code> .</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"inline-变量\"><a href=\"#inline-变量\" class=\"headerlink\" title=\"inline 变量\"></a>inline 变量</h3><blockquote>\n<p>[!NOTE]</p>\n<ul>\n<li><p>为静态成员变量声明 <code>inline</code>, 不必在 <code>.cpp</code>中再次声明.</p>\n</li>\n<li><p>用于<strong>在头文件中定义具有外部链接的变量</strong>，避免了重复定义的问题.</p>\n</li>\n</ul>\n</blockquote>\n<p>在 C++ 传统规则中，<strong>全局变量</strong>（或者 namespace 作用域的变量）在头文件中定义会导致多个翻译单元（编译文件）出现<strong>重复定义错误</strong>。在 C++17 之前，通常的做法是：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myheader.h</span></span><br><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">int</span> myVar; <span class=\"comment\">// 声明</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// mysource.cpp</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"myheader.h\"</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> myVar = <span class=\"number\">42</span>; <span class=\"comment\">// 定义</span></span><br></pre></td></tr></table></figure>\n\n<p>但在 C++17 之后，可以使用 inline 变量，直接在头文件中定义，而不会导致重复定义错误：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// myheader.h</span></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> myVar = <span class=\"number\">42</span>;  <span class=\"comment\">// C++17 及以上</span></span><br></pre></td></tr></table></figure>\n\n<p>在任何 <code>#include \"myheader.h</code>“ 的地方，myVar 仍然是<u><strong>同一个变量</strong></u>。</p>\n<blockquote>\n<p>如果希望不同的文件不是一个实例, 需要声明为 静态全局变量.</p>\n</blockquote>\n<p><strong>inline 变量的特点</strong></p>\n<p>​\t1.\t<strong>允许在头文件中定义</strong>，避免 extern 的使用。</p>\n<p>​\t2.\t<strong>所有包含它的翻译单元共享同一个变量</strong>（编译时不会创建多个实例）。</p>\n<p>​\t3.\t<strong>必须初始化</strong>，否则编译器无法确定变量的值。</p>\n<p><strong>示例：多个文件使用 inline 变量</strong></p>\n<p>假设有以下两个源文件，同时包含 myheader.h，但不会引发重复定义错误：</p>\n<p><strong>头文件 myheader.h</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> MYHEADER_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MYHEADER_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">inline</span> <span class=\"type\">int</span> globalVar = <span class=\"number\">100</span>; <span class=\"comment\">// inline 变量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n\n<p><strong>源文件 file1.cpp</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"myheader.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"file1.cpp: \"</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p><strong>源文件 file2.cpp</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"myheader.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"file2.cpp: \"</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p><strong>主程序 main.cpp</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">\"myheader.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func1</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func2</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    <span class=\"built_in\">func1</span>();</span><br><span class=\"line\">    <span class=\"built_in\">func2</span>();</span><br><span class=\"line\">    globalVar += <span class=\"number\">10</span>;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"main.cpp: \"</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p><strong>编译 &amp; 运行</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">g++ file1.cpp file2.cpp main.cpp -o output &amp;&amp; ./output</span><br></pre></td></tr></table></figure>\n\n<p><strong>输出示例：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file1.cpp: 100</span><br><span class=\"line\">file2.cpp: 100</span><br><span class=\"line\">main.cpp: 110</span><br></pre></td></tr></table></figure>\n\n<p>说明：</p>\n<p>​\t•\tglobalVar 是<strong>同一个变量</strong>，而不是多个副本。</p>\n<p>​\t•\tmain.cpp 修改 globalVar 之后，globalVar 在所有翻译单元中都被更新。</p>\n<hr>\n<p><strong>inline 变量 vs constexpr 变量</strong></p>\n<p>​\t•\tinline 变量可以是<strong>可变的</strong>，可以修改其值。</p>\n<p>​\t•\tconstexpr 变量必须是<strong>编译时常量</strong>，不能修改。</p>\n<p>​\t•\tinline constexpr 变量既有 inline 特性，又是编译时常量。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">inline constexpr int constantVar = 50; // 不能修改</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"weak\"><a href=\"#weak\" class=\"headerlink\" title=\"weak\"></a>weak</h3><p><code>weak</code>允许不同的编译单元存在同名的函数, 并且在实际调用的时候, 优先调用不是 <code>weak</code>的函数. 从而提供了一种默认的实现.</p>\n<p><code>weak</code>关键字可以用于函数、变量与对象等, 与主要使用于函数的 <code>inline</code>不同.</p>\n<p>如果没有 <code>weak</code>标记, 就是强变量.</p>\n<ul>\n<li>一般的编译器需要使用 <code>__attribute__((weak)) </code> 来声明:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 声明 weak 变量，提供默认值</span></span><br><span class=\"line\">__attribute__((weak)) <span class=\"type\">int</span> globalValue = <span class=\"number\">42</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"globalValue = \"</span> &lt;&lt; globalValue &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Composition\"><a href=\"#Composition\" class=\"headerlink\" title=\"Composition\"></a>Composition</h1><p>用已有的对象构造新的对象. 称为组合.</p>\n<p>可以用 <code>has-a</code>的关系来描述.</p>\n<h2 id=\"类内对象的初始化\"><a href=\"#类内对象的初始化\" class=\"headerlink\" title=\"类内对象的初始化\"></a>类内对象的初始化</h2><p>假设我们有一个 <code>Person</code> 类，该类内部包含一个 <code>std::vector&lt;std::string&gt;</code> 类型的成员变量，用于存储人的爱好。我们将展示如何在类的构造函数中使用完全初始化和引用初始化来初始化这个成员变量。</p>\n<h3 id=\"1-Fully\"><a href=\"#1-Fully\" class=\"headerlink\" title=\"1. Fully\"></a>1. Fully</h3><p>完全初始化是指在类的构造函数中直接为成员变量赋予初始值。这通常通过成员初始化列表（member initializer list）来完成。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::vector&lt;std::string&gt; hobbies;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 完全初始化：使用成员初始化列表</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(<span class=\"type\">const</span> std::vector&lt;std::string&gt;&amp; initialHobbies)</span><br><span class=\"line\">        : <span class=\"built_in\">hobbies</span>(initialHobbies) { }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<ul>\n<li><strong>成员变量初始化</strong>：在 <code>Person</code> 类的构造函数中，我们使用成员初始化列表 <code>: hobbies(initialHobbies)</code> 来完全初始化 <code>hobbies</code> 成员变量。这意味着 <code>person1.hobbies</code> 将拥有 <code>initialHobbies</code> 的一个拷贝。</li>\n<li><strong>独立性</strong>：<code>person1.hobbies</code> 是 <code>initialHobbies</code> 的一个独立拷贝，修改 <code>person1.hobbies</code> 不会影响 <code>initialHobbies</code>，反之亦然。</li>\n</ul>\n<h3 id=\"2-Reference\"><a href=\"#2-Reference\" class=\"headerlink\" title=\"2. Reference\"></a>2. Reference</h3><p>引用初始化是指将类内部的成员变量声明为引用类型，并在构造函数中将其绑定到另一个对象。这意味着类内的引用将直接指向外部对象，而不是持有其拷贝。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::vector&lt;std::string&gt;&amp; hobbiesRef;  <span class=\"comment\">// 引用类型的成员变量</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 引用初始化：使用成员初始化列表绑定到外部对象</span></span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(std::vector&lt;std::string&gt;&amp; externalHobbies)</span><br><span class=\"line\">        : <span class=\"built_in\">hobbiesRef</span>(externalHobbies) { }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>解释</strong></p>\n<ul>\n<li><strong>成员变量声明</strong>：<code>std::vector&lt;std::string&gt;&amp; hobbiesRef;</code> 声明了一个引用类型的成员变量 <code>hobbiesRef</code>，它将引用外部的 <code>std::vector&lt;std::string&gt;</code> 对象。</li>\n<li><strong>引用绑定</strong>：在构造函数中，通过 <code>: hobbiesRef(externalHobbies)</code> 将 <code>hobbiesRef</code> 绑定到传入的 <code>externalHobbies</code> 对象。这意味着 <code>person2.hobbiesRef</code> 和 <code>sharedHobbies</code> 指向同一个内存位置。</li>\n<li><strong>共享数据</strong>：对 <code>person2.hobbiesRef</code> 的修改（如添加新爱好）会直接影响到 <code>sharedHobbies</code>，因为它们共享相同的数据。</li>\n</ul>\n<h3 id=\"3-对比\"><a href=\"#3-对比\" class=\"headerlink\" title=\"3. 对比\"></a>3. 对比</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>完全初始化</th>\n<th>引用初始化</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>存储方式</strong></td>\n<td>存储外部对象的拷贝</td>\n<td>存储对外部对象的引用</td>\n</tr>\n<tr>\n<td><strong>内存使用</strong></td>\n<td>额外占用内存用于拷贝</td>\n<td>不占用额外内存，直接引用外部对象</td>\n</tr>\n<tr>\n<td><strong>数据独立性</strong></td>\n<td>修改类内成员不会影响外部对象</td>\n<td>修改类内成员会影响外部对象</td>\n</tr>\n<tr>\n<td><strong>生命周期依赖</strong></td>\n<td>类内成员独立于外部对象的生命周期</td>\n<td>类内引用的生命周期必须至少与外部对象相同</td>\n</tr>\n<tr>\n<td><strong>适用场景</strong></td>\n<td>需要独立副本时使用</td>\n<td>需要与外部对象共享数据时使用, 初始情况下不知道容量</td>\n</tr>\n</tbody></table>\n<h4 id=\"注意事项-1\"><a href=\"#注意事项-1\" class=\"headerlink\" title=\"注意事项\"></a>注意事项</h4><ul>\n<li><p><strong>引用必须在构造时初始化</strong>：引用类型的成员变量必须在构造函数的初始化列表中绑定到一个对象，不能在构造函数体内赋值。</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>因为引用类型的对象必须在初始化的时候绑定, 并且只能绑定一次.</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 错误示例：试图在构造函数体内赋值给引用</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    std::vector&lt;std::string&gt;&amp; hobbiesRef;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">Person</span>(std::vector&lt;std::string&gt;&amp; externalHobbies) {</span><br><span class=\"line\">        hobbiesRef = externalHobbies; <span class=\"comment\">// 错误：引用必须在初始化时绑定</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>生命周期管理</strong>：使用引用初始化时，必须确保被引用的对象在使用期间是有效的。如果引用的对象被销毁，引用将变为悬空引用，导致未定义行为。</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 危险示例：悬空引用</span></span><br><span class=\"line\"><span class=\"function\">std::vector&lt;std::string&gt; <span class=\"title\">createHobbies</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::vector&lt;std::string&gt; temp = {<span class=\"string\">\"Temporary\"</span>};</span><br><span class=\"line\">    <span class=\"function\">Person <span class=\"title\">person</span><span class=\"params\">(temp)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp; <span class=\"comment\">// temp 被销毁，person.hobbiesRef 悬空</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>为了避免这种情况，通常可以使用智能指针（如 <code>std::shared_ptr</code> 或 <code>std::unique_ptr</code>）来管理对象的生命周期，或者确保引用的对象在使用期间一直有效。</p>\n</li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li><p>如果使用 完全初始化 的方式, 类内必须包含另一个类的完整定义(引用头文件);</p>\n</li>\n<li><p>如果是引用初始化, 可以直接在这个类的内部预先声明另一个类的存在即可.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span>; <span class=\"comment\">// 前向声明</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>{</span><br><span class=\"line\">  A* ptr;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n</ol>\n</blockquote>\n<hr>\n<h2 id=\"Embedded-objects\"><a href=\"#Embedded-objects\" class=\"headerlink\" title=\"Embedded objects\"></a>Embedded objects</h2><blockquote>\n<p>[!NOTE]</p>\n<ul>\n<li>对于嵌入对象，如果不用初始化列表，就必须有默认构造函数。</li>\n</ul>\n</blockquote>\n<h2 id=\"namespace\"><a href=\"#namespace\" class=\"headerlink\" title=\"namespace\"></a>namespace</h2><h3 id=\"命名空间的别名\"><a href=\"#命名空间的别名\" class=\"headerlink\" title=\"命名空间的别名\"></a>命名空间的别名</h3><p>如果 <code>namespace</code>过长, 可以将其重新赋值并使用:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> supercalifragilistic {</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"type\">short</span> = supercalifragilistic;</span><br><span class=\"line\"><span class=\"type\">short</span>::<span class=\"built_in\">f</span>();</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"selection\"><a href=\"#selection\" class=\"headerlink\" title=\"selection\"></a>selection</h3><p>除了直接在一个命名空间内部嵌套其他, 我们也可以在一个命名空间里选择性地使用其他空间的部分函数:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">namespace</span> mine｛</span><br><span class=\"line\">\t<span class=\"keyword\">using</span> orig::Cat;\t <span class=\"comment\">// use Cat class from origvoid ×O）；</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">x</span><span class=\"params\">()</span>；</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"type\">void</span> <span class=\"title\">y</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li><strong>Multiple namespace declarations add to the same namespace.</strong><br>也即是说, 多个 <code>.h</code>文件内相同的命名空间会自动的视作一个.</li>\n</ol>\n</blockquote>\n<h1 id=\"Inheritance\"><a href=\"#Inheritance\" class=\"headerlink\" title=\"Inheritance\"></a>Inheritance</h1><blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li>继承的对象都具有基类的属性, 但是不一定具有访问的权限.<br>也就是 <strong>Think of inherited traits as an embedded object</strong></li>\n<li>派生类的构造函数中的初始化列表应当包含基类的构造函数.</li>\n<li>由于基类的私有成员无法被子类直接访问, 需要让子类调用基类的public的函数, 从而间接访问.</li>\n<li>如果子类和父类含有同名的变量, 将会同时存在, 并且可以在子类中声明 <code>parent_class:A</code>来访问父类中的属性A.</li>\n<li>子类中一定有部分是父类的对象, 并且处于子类的开头(父类必须首先完成初始化).</li>\n</ol>\n</blockquote>\n<h4 id=\"初始化列表的常用场景\"><a href=\"#初始化列表的常用场景\" class=\"headerlink\" title=\"初始化列表的常用场景\"></a>初始化列表的常用场景</h4><ol>\n<li><p>调用基类的构造函数 (否则调用默认构造函数)</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>(<span class=\"type\">int</span> data) { <span class=\"comment\">/* ... */</span> }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>(<span class=\"type\">int</span> baseVal) : <span class=\"built_in\">Base</span>(baseVal) { }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>初始化嵌入类</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Member</span>(<span class=\"type\">const</span> std::string&amp; str) { <span class=\"comment\">/* ... */</span> }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Container</span> {</span><br><span class=\"line\">    Member memberObj;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Container</span>(<span class=\"type\">const</span> std::string&amp; s) : <span class=\"built_in\">memberObj</span>(s) { }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>需要注意的是, 此处的初始化列表中的嵌入类的构造, 变量名不是类名.</p>\n<p>如果嵌入类不存在默认的构造函数, 那么初始化列表中的显式构造是必要的.</p>\n</blockquote>\n</li>\n<li><p>初始化常量成员:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> constMember;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> val) : <span class=\"built_in\">constMember</span>(val) { }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>const 成员一旦定义，必须立即初始化，且<strong>只能</strong>在初始化列表中完成，不能在构造函数体内赋值。</p>\n</blockquote>\n</li>\n<li><p>初始化引用成员</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span>&amp; refMember;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span>&amp; ref) : <span class=\"built_in\">refMember</span>(ref) { }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>引用成员（如 int&amp; ref）必须在初始化时绑定对象，<strong>不能在构造函数体内赋值</strong>，因此也必须使用初始化列表。</p>\n</blockquote>\n</li>\n</ol>\n<p>继承: 基于已有的类来设计新的类，新的类的对象可以被当作已有类的对象.</p>\n<p>相比于 <em>composition</em>  的 <code>has-a</code>关系, 继承是 <code>is-a</code>的关系.</p>\n<p>同义词:</p>\n<ul>\n<li>父类、超类、基类</li>\n<li>派生类、子类</li>\n</ul>\n<p>控制基类成员在派生类中的可见性：</p>\n<ul>\n<li><code>public</code>：基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>，<code>protected</code> 成员仍然是 <code>protected</code>。</li>\n<li><code>protected</code>：基类的 <code>public</code> 和 <code>protected</code>成员在派生类中都变为 <code>protected</code>。</li>\n<li><code>private</code>：基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>此时, 仍旧可以通过子类的方法来访问基类的属性或者方法, 但是无法通过子类直接访问基类~!</p>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">baseFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Base function called.\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">private</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">derivedFunction</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"built_in\">baseFunction</span>(); <span class=\"comment\">// 在子类内部可以访问基类的成员函数</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    d.<span class=\"built_in\">baseFunction</span>();    <span class=\"comment\">// 错误：无法从子类外部访问基类的成员函数</span></span><br><span class=\"line\">    d.<span class=\"built_in\">derivedFunction</span>(); <span class=\"comment\">// 可以调用子类的函数，该函数内部调用了基类的函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></blockquote>\n<p>clint class 表示这个类要使用另一个类(中的public).</p>\n<p>子类的对象也可以认为是父类的对象。子类不能访问父类的私有变量，但私有变量存在于这个类中</p>\n<p>当调用构造函数时，我们不能调用父类的私有变量，只能用初始化列表的方式调用父类的构造函数。</p>\n<p>赋值的运算符不会被继承:</p>\n<h4 id=\"赋值运算符\"><a href=\"#赋值运算符\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h4><p>赋值运算符是这样形式的方法:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point &amp;<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Point &amp;other)</span><br><span class=\"line\">{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Point::operator= 被调用\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        x = other.x;</span><br><span class=\"line\">        y = other.y;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>当我们如此赋值的时候就会发生上述的调用:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Point <span class=\"title\">p1</span><span class=\"params\">(<span class=\"number\">1</span>,<span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Point <span class=\"title\">p2</span><span class=\"params\">(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">p1 = p2;</span><br></pre></td></tr></table></figure>\n\n<p>可见, 赋值运算符通过引用快速地将右值中的属性赋值给左侧的目标.</p>\n<p>但是父类的赋值运算符只会确保自身的属性能够被赋值, 无法确保子类自身的属性可以被正确设置. 因此, 为了安全性, CPP不允许子类自动继承父类的赋值运算符.</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>然而, 编译器可能为子类自动生成一个赋值运算符.</p>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Point</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x, y;</span><br><span class=\"line\">    <span class=\"built_in\">Point</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>, <span class=\"type\">int</span> y = <span class=\"number\">0</span>) : <span class=\"built_in\">x</span>(x), <span class=\"built_in\">y</span>(y) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义赋值运算符</span></span><br><span class=\"line\">    Point &amp;<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Point &amp;other)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Point::operator= 被调用\"</span> &lt;&lt; endl;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;other)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            x = other.x;</span><br><span class=\"line\">            y = other.y;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ColoredPoint</span> : <span class=\"keyword\">public</span> Point</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    string color;</span><br><span class=\"line\">    <span class=\"built_in\">ColoredPoint</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>, <span class=\"type\">int</span> y = <span class=\"number\">0</span>, string color = <span class=\"string\">\"white\"</span>) : <span class=\"built_in\">Point</span>(x, y), <span class=\"built_in\">color</span>(color) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"x:\"</span> &lt;&lt; x &lt;&lt; <span class=\"string\">\", y:\"</span> &lt;&lt; y &lt;&lt; <span class=\"string\">\", color:\"</span> &lt;&lt; color &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"function\">ColoredPoint <span class=\"title\">cp1</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"string\">\"red\"</span>)</span></span>;</span><br><span class=\"line\">    cp<span class=\"number\">1.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    <span class=\"function\">ColoredPoint <span class=\"title\">cp2</span><span class=\"params\">(<span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"string\">\"blue\"</span>)</span></span>;</span><br><span class=\"line\">    cp<span class=\"number\">2.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">    cp1 = cp2;</span><br><span class=\"line\">    cp<span class=\"number\">1.</span><span class=\"built_in\">print</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p><strong>输出结果</strong>:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x:<span class=\"number\">1</span>, y:<span class=\"number\">2</span>, color:red</span><br><span class=\"line\">x:<span class=\"number\">3</span>, y:<span class=\"number\">4</span>, color:blue</span><br><span class=\"line\">Point::<span class=\"keyword\">operator</span>= 被调用</span><br><span class=\"line\">x:<span class=\"number\">3</span>, y:<span class=\"number\">4</span>, color:blue</span><br></pre></td></tr></table></figure>\n\n<p>可见, 父类的赋值运算符也被自动地调用了, 这是因为编译器为子类自动生成了一份.</p>\n</blockquote>\n<hr>\n<p>父类的构造是在子类的构造之前。</p>\n<h3 id=\"using声明\"><a href=\"#using声明\" class=\"headerlink\" title=\"using声明\"></a><code>using</code>声明</h3><h4 id=\"将基类的函数派生使用\"><a href=\"#将基类的函数派生使用\" class=\"headerlink\" title=\"将基类的函数派生使用\"></a>将基类的函数派生使用</h4><p>必须使用 <code>using &lt;parentClass&gt;:: func</code>的方式, 无法忽略 <code>using</code>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span>{</span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">double</span>)</span></span>{</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">\"double\\n\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : Base{</span><br><span class=\"line\">  <span class=\"keyword\">public</span>:</span><br><span class=\"line\">  \t<span class=\"keyword\">using</span> Base::f; <span class=\"comment\">// 将基类中的私有函数本地使用</span></span><br><span class=\"line\">  \t<span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span>)</span></span>{</span><br><span class=\"line\">      cout &lt;&lt; <span class=\"string\">\"int\\n\"</span>&lt;&lt;endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    d.<span class=\"built_in\">f</span>(<span class=\"number\">4</span>);</span><br><span class=\"line\">    d.<span class=\"built_in\">f</span>(<span class=\"number\">4.5</span>);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p><strong>Output:</strong></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">double</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"默认参数值无法通过重载传递\"><a href=\"#默认参数值无法通过重载传递\" class=\"headerlink\" title=\"默认参数值无法通过重载传递\"></a>默认参数值无法通过重载传递</h4><p>在cpp中, 默认参数值绑定在函数声明的作用域上, 而不是函数本身! 这是为了避免<strong>多重继承时参数值产生冲突或二义性</strong>。默认参数是静态绑定（编译期行为），它必须清楚地知道取哪个作用域的值.</p>\n<blockquote>\n<p>如果你在派生类中<strong>重新声明或重载了基类的函数</strong>，那么你不能获得默认参数值，必须通过多个重载模拟默认参数功能.</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> a = <span class=\"number\">3</span>, <span class=\"type\">double</span> b = <span class=\"number\">2.0</span>)</span></span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> A::f;         <span class=\"comment\">// ✅ 此时默认参数仍可见</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> a)</span></span>;      <span class=\"comment\">// ❌ 重载后，这个版本没有默认参数</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>但是使用 <code>using</code>声明的父类函数可以获得默认参数值.</p>\n</blockquote>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"type\">int</span> a = <span class=\"number\">3</span>, <span class=\"type\">double</span> b = <span class=\"number\">2.0</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"A::f(\"</span> &lt;&lt; a &lt;&lt; <span class=\"string\">\", \"</span> &lt;&lt; b &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">using</span> A::f; <span class=\"comment\">// 继承 A::f 到 B 中</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    B b;</span><br><span class=\"line\">    b.<span class=\"built_in\">f</span>();        <span class=\"comment\">// ✅ 是否等价于 f(3, 2.0)？</span></span><br><span class=\"line\">    b.<span class=\"built_in\">f</span>(<span class=\"number\">10</span>);      <span class=\"comment\">// ✅ 是否等价于 f(10, 2.0)？</span></span><br><span class=\"line\">    b.<span class=\"built_in\">f</span>(<span class=\"number\">10</span>, <span class=\"number\">5.5</span>); <span class=\"comment\">// ✅ 正常调用</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>输出:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A::<span class=\"built_in\">f</span>(<span class=\"number\">3</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">A::<span class=\"built_in\">f</span>(<span class=\"number\">10</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">A::<span class=\"built_in\">f</span>(<span class=\"number\">10</span>, <span class=\"number\">5.5</span>)</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"解决重写函数的重载问题\"><a href=\"#解决重写函数的重载问题\" class=\"headerlink\" title=\"解决重写函数的重载问题\"></a>解决重写函数的重载问题</h4><p>子类重新定义 (<code>override</code>重写) 了父类的某个函数，就会把父类中对应 <code>overloaded</code> 的函数覆盖:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 基类中的重载函数</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Base display(int): \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">double</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Base display(double): \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 子类重新定义了基类的 display(int)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"type\">int</span> x)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Derived display(int): \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">using</span> Base::display;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    d.<span class=\"built_in\">display</span>(<span class=\"number\">5</span>); <span class=\"comment\">// 调用 Derived 的 display(int)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    d.Base::<span class=\"built_in\">display</span>(<span class=\"number\">5.5</span>); <span class=\"comment\">// 或者d.display(5.5);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li><p>注意, CPP中的浮点数可以隐式转换为整型.</p>\n<ul>\n<li>当将一个浮点数赋值给一个整型变量时，编译器会执行<strong>隐式转换</strong>，将浮点数的值转换为整型。这种转换通常涉及<strong>截断</strong>（truncation），即去掉小数部分，只保留整数部分.</li>\n</ul>\n</li>\n<li><p>可以通过 <code>using </code>声明重新引入基类中的重载函数: </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> Base::display;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n<hr>\n<h1 id=\"Polymorphism\"><a href=\"#Polymorphism\" class=\"headerlink\" title=\"Polymorphism\"></a>Polymorphism</h1><h4 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h4><ol>\n<li><p>成员函数（无论是虚函数还是非虚函数）本身不占用类对象的内存空间，因为它们的代码存储在程序的代码段中。只有<strong>成员变量和虚表指针</strong>（如果有虚函数）会占用对象的内存空间:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<p>此时的 <code>sizeof(A)</code>为4字节.</p>\n</li>\n<li><p>虚函数指针的大小一般是 <u>8字节</u>. 如果结构体内部存在虚函数指针, 就需要对齐为8字节的倍数.</p>\n</li>\n<li><p>因为子类的构造在父类的构造之后, 也就是每一个子类对象的前部分都是父类对象. 因此, 我们可以将一个子类对象的指针赋值给父类对象, 只要忽视后续数据结构即可.</p>\n</li>\n<li><p><u>多态变量</u>: 指向子类对象的基类指针/引用.</p>\n</li>\n<li><p>如果类内不存在任何成员变量, 它的对象依旧占用 <code>1</code> 个字节的空间.</p>\n</li>\n<li><p>如果一个类将来可能具有子类, 就让其析构函数设置为 <code>virtual</code>. —— 任何的类都应该设置它的析构为 <code>virtual</code>.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>: <span class=\"keyword\">public</span> A{};</span><br><span class=\"line\"></span><br><span class=\"line\">A* p = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>();</span><br><span class=\"line\"><span class=\"keyword\">delete</span> p;</span><br></pre></td></tr></table></figure>\n\n<p>如果 A 的析构函数不是virtual的, 那么编译器只会调用A的析构函数.</p>\n</li>\n<li><p>如果父类的构造函数中调用了 <code>virtual</code> 的函数, 那么实际上还是调用自己的函数(静态绑定)</p>\n<ol>\n<li>这是因为, 创建一个派生类的对象时, 首先调用父类的构造函数, 然后执行派生类的构造函数;</li>\n<li>此时, 子类的成员还没有初始化, 父类无法调用其重写版本, 也就无法实现多态.</li>\n</ol>\n</li>\n<li><blockquote>\n<p>[!NOTE]</p>\n<p>深刻理解什么叫做多态! 也就是子类对象的引用或者指针赋值给了父类! 此后调用这个对象时, 虚函数是动态绑定到子类的!</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A &amp;ra = b;    <span class=\"comment\">// ra是A类型的引用，但指向B类型的对象</span></span><br><span class=\"line\">ra.<span class=\"built_in\">f</span>();       <span class=\"comment\">// 虽然ra是A类型的引用，但f()会调用B::f()</span></span><br></pre></td></tr></table></figure></blockquote>\n</li>\n<li><p>如果B是A的子类:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(<span class=\"number\">3</span>);    <span class=\"comment\">// p1是A类型的指针，但指向B类型的对象</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上,  p1指向的对象是B类的对象</p>\n</li>\n</ol>\n<p>当一个被重写的函数在 Derived::func() 中通过 Base::func() 调用其基类版本时，会发生什么？</p>\n<ul>\n<li><p>可以正常调用, 这也正是重写存在的意义——扩充原来的功能, 同时保留.</p>\n</li>\n<li><p>多态与返回对象类型:</p>\n<ul>\n<li><p>允许重载返回自身的 <u>指针</u> 与 <u>引用</u>, 但是不支持直接返回自身的类型:</p>\n</li>\n<li><p>i.e. </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Class Expr｛</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> Expr* newExpr （）；</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> Expr&amp; clone （）；</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> Expr Expr self（）；</span><br><span class=\"line\">｝；</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">BinaryExpr</span> ： <span class=\"keyword\">public</span> Expr ｛</span><br><span class=\"line\"><span class=\"keyword\">public</span>：</span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> BinaryExpr* newExpr （）； <span class=\"comment\">//Ok</span></span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> BinaryExpr&amp; clone （）； <span class=\"comment\">// Ok</span></span><br><span class=\"line\">  <span class=\"keyword\">virtual</span> BinaryExpr self（）；<span class=\"comment\">// Error！</span></span><br><span class=\"line\">  ｝；</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>原因: 指针和引用的大小固定, 编译时刻可以确定调用时候所需的空间, 如果按照类型返回, 由于多态的动态绑定是运行时决定调用对应的方法, 所以编译的时候caller不知道要在栈上预留多少的空间.</p>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<ul>\n<li>Polymorphism<ul>\n<li>virtual functions and override</li>\n<li>abstract functions and classes</li>\n</ul>\n</li>\n<li>Multiple Inheritance</li>\n</ul>\n<p>由于子类具有父类的所有属性, 因此我们可以将一个子类对象看作父类的对象, 并进行对应的操作.</p>\n<p>将子类对象看作父类对象的操作, 叫做 <u>upcast</u>. 具体是说, 将子类的指针或者引用赋值给基类的对象.</p>\n<p>现在的问题是, 如果采取传统的继承+重写的方式, 我们在子类内部采取重写父类方法, 可能导致 <code>静态绑定</code> static binding:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Animal speaks\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Dog barks\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Animal *animal = <span class=\"keyword\">new</span> <span class=\"built_in\">Dog</span>(); <span class=\"comment\">// 注意：父类指针指向子类对象</span></span><br><span class=\"line\">    animal-&gt;<span class=\"built_in\">speak</span>();            <span class=\"comment\">// 会调用哪个？</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> animal;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>输出:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Animal speaks</span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>为了解决上述的问题, 我们引入 <u>虚函数</u> 的概念.</p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>虚函数可以实现 <strong>运行时多态</strong>. 所谓多态, 就是静态+ 动态的绑定.</p>\n<p>通过在父类的函数前加上 <code>virtual</code>的声明, 我们将其定义为虚函数</p>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Animal speaks\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Dog</span> : <span class=\"keyword\">public</span> Animal {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Dog barks\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    Animal* animal = <span class=\"keyword\">new</span> <span class=\"built_in\">Dog</span>(); </span><br><span class=\"line\">    animal-&gt;<span class=\"built_in\">speak</span>(); <span class=\"comment\">// 这次会调用哪个？</span></span><br><span class=\"line\">    <span class=\"keyword\">delete</span> animal;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>输出:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Dog barks</span><br></pre></td></tr></table></figure></li>\n</ul>\n<blockquote>\n<ul>\n<li><code>override</code>声明明确这个函数是重写父类的虚函数, 可以让编译器检查是否存在错误.</li>\n<li>但是上述的关键字也不是必须的.</li>\n</ul>\n</blockquote>\n<h3 id=\"纯虚函数\"><a href=\"#纯虚函数\" class=\"headerlink\" title=\"纯虚函数\"></a>纯虚函数</h3><p>~指的是需要强制派生类去实现的函数:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">virtual</span> 返回类型 函数名(...) = <span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"虚函数表\"><a href=\"#虚函数表\" class=\"headerlink\" title=\"虚函数表\"></a>虚函数表</h3><ul>\n<li>定义: 虚函数表（virtual table）是 C++ 为了实现<strong>运行时多态</strong>而采用的一种底层技术手段;</li>\n<li>本质:<ul>\n<li><code>vtable</code>是一个函数指针数组;</li>\n<li>每个类都有自己的vtable</li>\n<li>对象中存在一个隐藏的指针 <code>vptr</code>, 指向该类的vtable</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"内存示意图\"><a href=\"#内存示意图\" class=\"headerlink\" title=\"内存示意图\"></a>内存示意图</h4><p>假设有如下结构:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<p>内存布局的伪结构如下:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| vptr  → 指向vtable     |  ←隐藏成员</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\">| a : <span class=\"type\">int</span>                |  ←显式成员</span><br><span class=\"line\">+-------------------------+</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vtable</span> (Base):</span><br><span class=\"line\">[ func 的地址 ]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">vtable</span> (Derived):</span><br><span class=\"line\">[ 重写的 func 的地址 ]</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"拓展说明\"><a href=\"#拓展说明\" class=\"headerlink\" title=\"拓展说明\"></a>拓展说明</h4><ul>\n<li>vtable是类级别的, 所有该类的对象共享一个vtable;</li>\n<li>vptr是对象级别的, 隐含于各个对象当中.</li>\n<li>如果类没有虚函数, 就不存在上述的~</li>\n</ul>\n<h2 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h2><p>如果一个类中包含至少一个纯虚函数, 那么这个类就是一个抽象类.</p>\n<p>抽象类无法被实例化, <strong>只能用来作为基类.</strong></p>\n<h3 id=\"使用抽象类定义接口\"><a href=\"#使用抽象类定义接口\" class=\"headerlink\" title=\"使用抽象类定义接口\"></a>使用抽象类定义接口</h3><p>用图形绘制的例子来说明抽象类和纯虚函数的使用:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 抽象类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Shape</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 纯虚函数，子类必须实现</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类：Circle</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Circle</span> : <span class=\"keyword\">public</span> Shape {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Drawing Circle\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类：Rectangle</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rectangle</span> : <span class=\"keyword\">public</span> Shape {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">draw</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Drawing Rectangle\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 渲染函数：面向抽象类编程</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">render</span><span class=\"params\">(Shape* shape)</span> </span>{</span><br><span class=\"line\">    shape-&gt;<span class=\"built_in\">draw</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    Circle c;</span><br><span class=\"line\">    Rectangle r;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">render</span>(&amp;c); <span class=\"comment\">// Drawing Circle</span></span><br><span class=\"line\">    <span class=\"built_in\">render</span>(&amp;r); <span class=\"comment\">// Drawing Rectangle</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"继承链\"><a href=\"#继承链\" class=\"headerlink\" title=\"继承链\"></a>继承链</h3><p>一个抽象类可以有多个纯虚函数, 此时继承的子类可能没有完全实现. </p>\n<p>子类的子类, 也就是在继承链上完成了所有纯虚函数的定义的 最末一级的派生类, 才可以被实例化.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">speak</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">breathe</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Breathing...\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"虚析构函数\"><a href=\"#虚析构函数\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h2><p><strong>virtual destructor</strong>: 虚析构函数</p>\n<p>同样的, 虚析构函数的作用体现在 <code>upcast</code>, 也就是将子类的指针或引用转换为父类的指针或引用的过程. 此时, 如果父类的析构函数不是虚函数, 就会让向上转型之后的对象在析构时调用父类的析构函数.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Base</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Base Destructor\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Derived</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Derived Destructor\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Base *obj = <span class=\"keyword\">new</span> <span class=\"built_in\">Derived</span>();</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> obj; <span class=\"comment\">// 注意这里！</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>此时会输出 :  <code>Base Destructor</code> , 也就是调用了父类的析构函数.</p>\n<p>这是十分危险的, 特别是我们需要确保子类的所有资源都被安全地释放.</p>\n<p>因此, 我们可以将父类的析构函数也设置为虚函数:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Base</span>() {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Base Destructor\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    ~<span class=\"built_in\">Derived</span>() {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Derived Destructor\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<p>此时的输出:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Derived Destructor  </span><br><span class=\"line\">Base Destructor</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>先后调用子类和父类的析构函数.</p>\n</blockquote>\n<h2 id=\"接口类\"><a href=\"#接口类\" class=\"headerlink\" title=\"接口类\"></a>接口类</h2><blockquote>\n<p>也被称为 <u>协议类</u>. 其实就像 <code>swift</code>的协议一样, 强制要求继承的子类定义某些函数实现.</p>\n</blockquote>\n<ul>\n<li>含义:<ul>\n<li>只定义接口, 不提供实现的抽象类</li>\n<li>所有的成员函数都是纯虚函数;</li>\n<li>一般不包含任何数据成员.</li>\n</ul>\n</li>\n</ul>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Printable</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">virtual</span> ~<span class=\"built_in\">Printable</span>() = <span class=\"keyword\">default</span>; <span class=\"comment\">// 记得虚析构函数</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Document</span> : <span class=\"keyword\">public</span> Printable {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">print</span><span class=\"params\">()</span> <span class=\"keyword\">override</span> </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Printing Document\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><p>多重继承 <em>multiple inheritance</em> 指的是一个类继承自多个基类.</p>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sayA</span><span class=\"params\">()</span> </span>{ cout &lt;&lt; <span class=\"string\">\"I am A\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sayB</span><span class=\"params\">()</span> </span>{ cout &lt;&lt; <span class=\"string\">\"I am B\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">public</span> A, <span class=\"keyword\">public</span> B {</span><br><span class=\"line\">    <span class=\"comment\">// 继承了 A 和 B 的成员</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<p>可以将多个类的功能整合到一个类中:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C c;</span><br><span class=\"line\">c.<span class=\"built_in\">sayA</span>(); <span class=\"comment\">// OK</span></span><br><span class=\"line\">c.<span class=\"built_in\">sayB</span>(); <span class=\"comment\">// OK</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"菱形继承\"><a href=\"#菱形继承\" class=\"headerlink\" title=\"菱形继承\"></a>菱形继承</h3><p>多重继承中的特例:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A {};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">public</span> A {};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C {};</span><br></pre></td></tr></table></figure>\n\n<p>继承结构看上去就像菱形:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">   A</span><br><span class=\"line\"> /   \\</span><br><span class=\"line\">B     C</span><br><span class=\"line\"> \\   /</span><br><span class=\"line\">   D</span><br></pre></td></tr></table></figure>\n\n<p>如果我们直接使用D类:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D d;</span><br><span class=\"line\">d.value = <span class=\"number\">10</span>; <span class=\"comment\">// ❌ 编译错误：'value' is ambiguous</span></span><br></pre></td></tr></table></figure>\n\n<p>这是因为D继承自B和C, 而后者又各自具有自己的A子对象. 导致了二义性的问题.</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>注意此处的二义性的问题, 来自于在D类对象中直接访问A类对象的成员变量!  什么时候产生二义性? 就是判断此时是否存在多个相同名称的变量.</p>\n</blockquote>\n<h3 id=\"虚继承\"><a href=\"#虚继承\" class=\"headerlink\" title=\"虚继承\"></a>虚继承</h3><p>C++ 提供了一个机制：<strong>虚继承（virtual inheritance）</strong>，来解决上述问题:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> A{};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> B{};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> :  <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C{}</span><br></pre></td></tr></table></figure>\n\n<p>此时, D中只有一个共享的A子对象.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> value;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ptr</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"value: \"</span> &lt;&lt; value &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> A {};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> A {};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C {};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    D d;</span><br><span class=\"line\">    d.value = <span class=\"number\">10</span>; <span class=\"comment\">// ✅ OK，只有一个 A，二义性消除</span></span><br><span class=\"line\">    d.<span class=\"built_in\">ptr</span>();</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>此时, B,C不再具有自己的A.</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p>由于虚继承带来的是“共享”的基类对象，所以：</p>\n<ul>\n<li>虚基类的构造 <strong>必须由最底层派生类负责</strong></li>\n<li>派生类的构造函数中要<strong>显式初始化</strong>虚基类</li>\n</ul>\n</blockquote>\n<h1 id=\"Copy-and-Move\"><a href=\"#Copy-and-Move\" class=\"headerlink\" title=\"Copy and Move\"></a>Copy and Move</h1><h4 id=\"补充-1\"><a href=\"#补充-1\" class=\"headerlink\" title=\"补充\"></a>补充</h4><ul>\n<li><p><code>vptr</code>只会初始化一次, 然后保持不变. 发生在构造函数的第一步.</p>\n</li>\n<li><p>循环内部执行构造和析构时, 作用的地址是同一块. 此时将对象的地址传入到vector of <code>*</code> 时, 得到的是相同的地址;</p>\n<ul>\n<li>为了避免上述的情况, 我们在循环内部的构造, 需要为对象直接 <code>new</code> 一个新的空间.</li>\n</ul>\n</li>\n<li><p><code>std::move</code>的作用就是告诉编译器: 这个类型是右值引用, 需要使用移动语义.</p>\n</li>\n</ul>\n<h2 id=\"C-中的拷贝构造与移动语义\"><a href=\"#C-中的拷贝构造与移动语义\" class=\"headerlink\" title=\"C++中的拷贝构造与移动语义\"></a>C++中的拷贝构造与移动语义</h2><h3 id=\"拷贝构造函数基础\"><a href=\"#拷贝构造函数基础\" class=\"headerlink\" title=\"拷贝构造函数基础\"></a>拷贝构造函数基础</h3><p>拷贝构造函数是创建新对象的一种方式，它从现有对象复制数据来初始化新对象。</p>\n<ul>\n<li>拷贝构造函数的签名：<code>T::T(const T&amp;)</code></li>\n<li>如果不提供拷贝构造函数，C++会自动生成一个默认的拷贝构造函数</li>\n<li>默认拷贝构造函数执行的是成员级别的拷贝（memberwise copy），而非位级别的拷贝（bitwise copy）<ul>\n<li>对于基本类型成员，直接复制值</li>\n<li>对于对象类型成员，调用其拷贝构造函数</li>\n<li><strong><u>对于指针类型成员</u></strong>，只复制指针值（浅拷贝），导致两个对象共享同一块内存</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"拷贝构造函数的调用时机\"><a href=\"#拷贝构造函数的调用时机\" class=\"headerlink\" title=\"拷贝构造函数的调用时机\"></a>拷贝构造函数的调用时机</h3><p>拷贝构造函数在以下情况下会被调用：</p>\n<ol>\n<li><p><strong>按值传递参数时</strong>：当对象作为参数按值传递给函数时</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">func</span><span class=\"params\">(MyClass obj)</span></span>; <span class=\"comment\">// 调用时会触发拷贝构造</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>对象初始化时</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MyClass a;</span><br><span class=\"line\">MyClass b = a;    <span class=\"comment\">// 初始化，调用拷贝构造函数</span></span><br><span class=\"line\"><span class=\"function\">MyClass <span class=\"title\">c</span><span class=\"params\">(a)</span></span>;     <span class=\"comment\">// 初始化，调用拷贝构造函数</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>函数返回对象时</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">MyClass <span class=\"title\">func</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    MyClass obj;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> obj;   <span class=\"comment\">// 可能触发拷贝构造（取决于编译器优化）</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"拷贝构造函数的最佳实践\"><a href=\"#拷贝构造函数的最佳实践\" class=\"headerlink\" title=\"拷贝构造函数的最佳实践\"></a>拷贝构造函数的最佳实践</h3><ul>\n<li>显式定义拷贝构造函数，不要依赖默认版本</li>\n<li>如果类不需要被复制，可以声明私有的拷贝构造函数（不需要定义）</li>\n<li>如果类包含指针成员，必须实现<u>深拷贝</u>的拷贝构造函数</li>\n</ul>\n<h4 id=\"深拷贝构造函数\"><a href=\"#深拷贝构造函数\" class=\"headerlink\" title=\"深拷贝构造函数\"></a>深拷贝构造函数</h4><p>将拷贝的值另外寻找新的内存空间, 而不是指向同一处地址.</p>\n<ul>\n<li>如果没有显式定义深拷贝构造函数, 观察下面的代码:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">StringHolder <span class=\"title\">original</span><span class=\"params\">(<span class=\"string\">\"Hello World\"</span>)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">{</span><br><span class=\"line\">    StringHolder copy = original; <span class=\"comment\">// 调用拷贝构造函数</span></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"copy包含: \"</span> &lt;&lt; copy.<span class=\"built_in\">getString</span>() &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 修改copy，如果是浅拷贝，也会影响original</span></span><br><span class=\"line\">    copy.<span class=\"built_in\">setString</span>(<span class=\"string\">\"Modified\"</span>);</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"修改后，copy包含: \"</span> &lt;&lt; copy.<span class=\"built_in\">getString</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"修改后，original包含: \"</span> &lt;&lt; original.<span class=\"built_in\">getString</span>() &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// copy在此作用域结束时被销毁</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li><p><code>original</code>的层级在  <code>copy</code> 的外面;</p>\n</li>\n<li><p>在代码块的内部, 通过浅拷贝构造, 两者的数据共享一个内存空间;</p>\n</li>\n<li><p>二者先后析构, 导致 <code>double free</code>的问题!</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: Double free of object 0x11f6060c0</span><br><span class=\"line\">02_deep_vs_shallow_copy(5896,0x1eddb0840) malloc: *** <span class=\"built_in\">set</span> a breakpoint <span class=\"keyword\">in</span> malloc_error_break to debug</span><br></pre></td></tr></table></figure></li>\n</ul>\n</blockquote>\n<p>由此, 我们需要如此定义:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">StringHolder</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">char</span> *data;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">StringHolder</span>(<span class=\"type\">const</span> <span class=\"type\">char</span> *str)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (str)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(str) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, str);</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">\"构造函数: 为\\\"\"</span> &lt;&lt; data &lt;&lt; <span class=\"string\">\"\\\"分配内存\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        {</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">\"构造函数: 创建空字符串\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 自定义拷贝构造函数（深拷贝）</span></span><br><span class=\"line\">    <span class=\"comment\">// 如果复制掉这部分的自定义, 将会调用默认的浅拷贝构造函数, 导致问题:浅拷贝的指针两次释放内存</span></span><br><span class=\"line\">    <span class=\"built_in\">StringHolder</span>(<span class=\"type\">const</span> StringHolder &amp;other)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (other.data)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            data = <span class=\"keyword\">new</span> <span class=\"type\">char</span>[<span class=\"built_in\">strlen</span>(other.data) + <span class=\"number\">1</span>];</span><br><span class=\"line\">            <span class=\"built_in\">strcpy</span>(data, other.data);</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">\"深拷贝构造函数: 为\\\"\"</span> &lt;&lt; data &lt;&lt; <span class=\"string\">\"\\\"分配新内存\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        {</span><br><span class=\"line\">            data = <span class=\"literal\">nullptr</span>;</span><br><span class=\"line\">            std::cout &lt;&lt; <span class=\"string\">\"深拷贝构造函数: 复制空字符串\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">StringHolder</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"析构函数: 释放\\\"\"</span> &lt;&lt; (data ? data : <span class=\"string\">\"nullptr\"</span>) &lt;&lt; <span class=\"string\">\"\\\"的内存\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>这样就可以避免上面的问题.</p>\n<h3 id=\"函数参数和返回值的选择\"><a href=\"#函数参数和返回值的选择\" class=\"headerlink\" title=\"函数参数和返回值的选择\"></a>函数参数和返回值的选择</h3><ul>\n<li><p><strong>传入参数</strong>：</p>\n<ul>\n<li>按值传递：<code>void func(Student s)</code> - 创建新对象，适用于需要存储对象的情况<ul>\n<li>如果对象内部的属性存在指针类型的属性, 为了避免浅拷贝, 就需要自定义一个深拷贝构造函数.</li>\n</ul>\n</li>\n<li>常量引用：<code>void func(const Student&amp; s)</code> - 不创建新对象，适用于<u>只读取值</u>的情况</li>\n<li>指针/引用：<code>void func(Student* s)</code> 或 <code>void func(Student&amp; s)</code> - 适用于需要<u>修改对象</u>的情况</li>\n</ul>\n</li>\n<li><p><strong>返回值</strong>：</p>\n<ul>\n<li>按值返回：<code>Student func()</code> - 返回新创建的对象</li>\n<li>返回指针：<code>Student* func()</code> - 注意内存管理问题</li>\n<li>返回引用：<code>Student&amp; func()</code> - 注意生命周期问题</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"右值引用与移动语义\"><a href=\"#右值引用与移动语义\" class=\"headerlink\" title=\"右值引用与移动语义\"></a>右值引用与移动语义</h2><h4 id=\"左值与右值\"><a href=\"#左值与右值\" class=\"headerlink\" title=\"左值与右值\"></a>左值与右值</h4><ul>\n<li><strong>左值</strong>：可以出现在赋值号左边的表达式<ul>\n<li>变量名、引用</li>\n<li>解引用操作符（*）和下标操作符（[]）的结果</li>\n</ul>\n</li>\n<li><strong>右值</strong>：只能出现在赋值号右边的表达式<ul>\n<li>字面量</li>\n<li>表达式结果</li>\n<li>函数返回的临时对象</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"右值引用-1\"><a href=\"#右值引用-1\" class=\"headerlink\" title=\"右值引用\"></a>右值引用</h4><ul>\n<li>使用 <code>&amp;&amp;</code> 声明</li>\n<li>可以绑定到右值，延长其生命周期</li>\n<li>右值引用变量本身是左值</li>\n<li>可以使用 <code>std::move()</code> 将左值转换为右值引用</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> x = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; rx = x * <span class=\"number\">2</span>;  <span class=\"comment\">// 绑定右值</span></span><br><span class=\"line\">rx = <span class=\"number\">100</span>;          <span class=\"comment\">// rx本身是左值，可以被赋值</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>两种可以同时输入左值和右值引用作为参数的方法:</p>\n<ul>\n<li><p>重载</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 重载函数，分别处理左值和右值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"type\">int</span>&amp; x)</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"重载函数 - 处理左值: \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">process</span><span class=\"params\">(<span class=\"type\">int</span>&amp;&amp; x)</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"重载函数 - 处理右值: \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>const int&amp; x </code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 接受const左值引用的函数（可以接受左值和右值）</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">processAny</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">int</span>&amp; x)</span> </span>{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"处理任意值: \"</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"移动构造函数\"><a href=\"#移动构造函数\" class=\"headerlink\" title=\"移动构造函数\"></a>移动构造函数</h4><ul>\n<li>签名：<code>T::T(T&amp;&amp; other)</code>, 也就是<strong>将右值引用作为参数的构造函数</strong></li>\n<li>用于”窃取”即将销毁的对象的资源，避免不必要的深拷贝</li>\n<li>通常将源对象的指针成员置为<code>nullptr</code>，防止资源被错误释放</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">MyClass</span>(MyClass&amp;&amp; other) : </span><br><span class=\"line\">    ptr{other.ptr} {</span><br><span class=\"line\">      other.data = <span class=\"number\">0</span></span><br><span class=\"line\">      other.ptr = <span class=\"literal\">nullptr</span>;  <span class=\"comment\">// 防止源对象析构时释放内存</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>与浅拷贝类似, 但是需要在内部将源对象的指针成员 设置为 <code>nullptr</code> , 其他成员设置为有效但是为空的状态</li>\n</ul>\n<p> 标准库容器（如 std::vector）在进行元素移动时会优先选择不会抛异常的移动构造函数，否则会退而求其次选择拷贝构造函数（更慢）。</p>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;DynamicArray&gt; vec;</span><br><span class=\"line\">vec.<span class=\"built_in\">push_back</span>(<span class=\"built_in\">DynamicArray</span>(<span class=\"number\">5</span>));</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>在这个 push_back 中，如果 DynamicArray 的移动构造函数被标记为 <code>noexcept</code>，那么 vector 会使用移动构造（高效）。</p>\n</blockquote>\n<h2 id=\"初始化方式\"><a href=\"#初始化方式\" class=\"headerlink\" title=\"初始化方式\"></a>初始化方式</h2><p>C++11提供了多种初始化对象的方式：</p>\n<ul>\n<li><p><strong>小括号初始化</strong>：<code>MyClass obj(arg1, arg2);</code></p>\n</li>\n<li><p><strong>等号初始化</strong>：<code>MyClass obj = value;</code></p>\n</li>\n<li><p><strong>大括号初始化</strong>（统一初始化）：<code>MyClass obj{arg1, arg2};</code></p>\n</li>\n<li><p><strong>列表初始化</strong>：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> arr[] = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>};</span><br><span class=\"line\">MyClass* ptr = <span class=\"keyword\">new</span> MyClass{arg1, arg2};</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"基本类型的初始化\"><a href=\"#基本类型的初始化\" class=\"headerlink\" title=\"基本类型的初始化\"></a>基本类型的初始化</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本类型的初始化方式</span></span><br><span class=\"line\"><span class=\"type\">int</span> a = <span class=\"number\">10</span>;             <span class=\"comment\">// 等号初始化</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">b</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;              <span class=\"comment\">// 小括号初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> c{<span class=\"number\">30</span>};              <span class=\"comment\">// 大括号初始化（C++11）</span></span><br><span class=\"line\"><span class=\"type\">int</span> d = {<span class=\"number\">40</span>};           <span class=\"comment\">// 等号+大括号初始化（C++11）</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr1[] = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>}; <span class=\"comment\">// 数组初始化</span></span><br><span class=\"line\"><span class=\"type\">int</span> arr2[]{<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>};    <span class=\"comment\">// 数组大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"对象的初始化\"><a href=\"#对象的初始化\" class=\"headerlink\" title=\"对象的初始化\"></a>对象的初始化</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对象的初始化方式</span></span><br><span class=\"line\"><span class=\"function\">Person <span class=\"title\">p1</span><span class=\"params\">(<span class=\"string\">\"张三\"</span>, <span class=\"number\">25</span>)</span></span>;          <span class=\"comment\">// 小括号初始化</span></span><br><span class=\"line\">Person p2 = <span class=\"built_in\">Person</span>(<span class=\"string\">\"李四\"</span>, <span class=\"number\">30</span>); <span class=\"comment\">// 等号+临时对象初始化</span></span><br><span class=\"line\">Person p3{<span class=\"string\">\"王五\"</span>, <span class=\"number\">35</span>};          <span class=\"comment\">// 大括号初始化（C++11）</span></span><br><span class=\"line\">Person p4 = {<span class=\"string\">\"赵六\"</span>, <span class=\"number\">40</span>};       <span class=\"comment\">// 等号+大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>动态分配对象的初始化</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 动态分配对象的初始化方式</span></span><br><span class=\"line\">Person *pp1 = <span class=\"keyword\">new</span> <span class=\"built_in\">Person</span>(<span class=\"string\">\"动态张三\"</span>, <span class=\"number\">25</span>); <span class=\"comment\">// 传统new</span></span><br><span class=\"line\">Person *pp2 = <span class=\"keyword\">new</span> Person{<span class=\"string\">\"动态李四\"</span>, <span class=\"number\">30</span>}; <span class=\"comment\">// 大括号初始化（C++11）</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"深拷贝与浅拷贝\"><a href=\"#深拷贝与浅拷贝\" class=\"headerlink\" title=\"深拷贝与浅拷贝\"></a>深拷贝与浅拷贝</h3><ul>\n<li><strong>浅拷贝</strong>：默认拷贝构造函数执行的是浅拷贝，只复制指针值，不复制指针指向的内容</li>\n<li><strong>深拷贝</strong>：自定义拷贝构造函数可以实现深拷贝，为指针成员分配新内存并复制内容</li>\n</ul>\n<h3 id=\"何时使用移动语义\"><a href=\"#何时使用移动语义\" class=\"headerlink\" title=\"何时使用移动语义\"></a>何时使用移动语义</h3><ul>\n<li>类包含动态分配的资源（如指针成员）</li>\n<li>对象需要在函数间传递</li>\n<li>需要避免不必要的深拷贝操作</li>\n<li>使用容器时（如<code>std::vector</code>、<code>std::string</code>等）<ul>\n<li><code>move</code>会将一个左值变成右值引用, 从而允许调用移动构造函数!</li>\n<li>使用 <code>move</code> 时, 如果存在对应的移动构造函数, 就会优先调用;</li>\n<li>数组的 <code>push_back</code>也是如此, 优先调用移动构造函数<ul>\n<li>但是我们可以使用 <code>emplace</code>来继续优化上述的效率问题——直接将对象存储到数组的末端.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结-1\"><a href=\"#总结-1\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>拷贝构造函数用于创建对象的副本，深拷贝需要自定义实现</li>\n<li>移动语义通过右值引用实现<strong>资源的高效转移</strong>，避免不必要的拷贝, 同时<strong>规避了浅拷贝导致的 double free</strong> 的问题.</li>\n<li>根据需要选择合适的参数传递和返回值方式</li>\n<li>使用<code>std::move()</code>可以将左值转换为右值引用，触发移动语义</li>\n</ul>\n<hr>\n<h1 id=\"Overloaded-Operators\"><a href=\"#Overloaded-Operators\" class=\"headerlink\" title=\"Overloaded Operators\"></a>Overloaded Operators</h1><h4 id=\"补充-2\"><a href=\"#补充-2\" class=\"headerlink\" title=\"补充\"></a>补充</h4><p>自定义类型的方向转换:  <em>T</em> ==&gt; <em>C</em></p>\n<ul>\n<li><p>当下面情况存在一种时, 可以发生上述的转换:</p>\n<ol>\n<li><p>C存在以 <em>T</em> 作为输入参数的构造函数;</p>\n</li>\n<li><p><em>T</em> 存在 <code>operator C(){ }</code>的成员函数.<br>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rational</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">double</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{  <span class=\"comment\">// Rational到double的转换</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> numerator_ / (<span class=\"type\">double</span>)denominator_;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">double</span> d = r;  <span class=\"comment\">// 隐式转换：r =&gt; double</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n</li>\n<li><p>不同同时存在两者的转换(编译器无法知道采取什么方式)</p>\n</li>\n</ul>\n<p>题目:</p>\n<ul>\n<li><p>并非所有运算符都可以用三种方式重载。例如赋值运算符 =、下标运算符 []、函数调用运算符 ()、成员访问运算符 -&gt; <strong>只能</strong>作为成员函数重载;</p>\n</li>\n<li><p>流提取符 &gt;&gt; 和插入符 &lt;&lt; 可以被重载</p>\n</li>\n<li><p>运算符 <code>+</code> 返回的类型 <strong>不一定</strong> 要与参数类型一致;</p>\n</li>\n<li><p>对于友元函数, 在声明处加上 <code>friend</code>标识, 但是在定义处是没有这个标识的. </p>\n</li>\n<li><blockquote>\n<p>[!NOTE]</p>\n<p>无法被重载的运算符:</p>\n<ul>\n<li>条件运算符: <code>?:</code></li>\n<li>成员指针访问运算符: <code>.*</code></li>\n</ul>\n</blockquote>\n<p><code>new</code>是可以重载的!</p>\n</li>\n<li><p>运算符的分类:</p>\n<ul>\n<li><p>成员运算符: 在类内部以成员函数形式重载的运算符 ==&gt; 具有隐式的 <code>this</code>;</p>\n</li>\n<li><p>友元运算符: 定义在类外部（在类内部用 <code>friend</code> 声明），没有 <code>this</code> 指针.</p>\n<p>因此, 一个重载函数只有一个参数时 ==&gt; 二员成员运算符 / 一元友元运算符.</p>\n</li>\n</ul>\n</li>\n<li><p>隐式转换的尝试是从左到右的:</p>\n<ul>\n<li><code>1+a</code>会尝试将类的对象 <code>a</code> 尝试转换为int类型.</li>\n</ul>\n</li>\n<li><p>注意类型:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 前缀++</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer&amp; Integer::<span class=\"keyword\">operator</span>++() {</span><br><span class=\"line\">    *<span class=\"keyword\">this</span> += <span class=\"number\">1</span>;  <span class=\"comment\">// 先增加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 再返回</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后缀++（参数int未使用，仅用于区分）</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer Integer::<span class=\"keyword\">operator</span>++(<span class=\"type\">int</span>) {</span><br><span class=\"line\">    <span class=\"function\">Integer <span class=\"title\">old</span><span class=\"params\">(*<span class=\"keyword\">this</span>)</span></span>;  <span class=\"comment\">// 先保存</span></span><br><span class=\"line\">    ++(*<span class=\"keyword\">this</span>);  <span class=\"comment\">// 再增加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> old;  <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>前缀++的返回是 <code>&amp;</code> 类型, 因为比较节省空间和时间. 后缀++的返回是值.</p>\n<ul>\n<li><code>[]</code> 的返回必须是 <code>&amp;</code> 类型, 这样可以作为左值赋值.</li>\n</ul>\n</li>\n</ul>\n<p>返回类型设计的<strong>总体原则</strong>：</p>\n<ol>\n<li><p>如果运算符需要作为左值（可以出现在赋值左侧），返回非常量引用。</p>\n<ol>\n<li>否则, 声明为<code>const</code>类型, 避免成为左值.</li>\n</ol>\n</li>\n<li><p>如果运算符创建新对象，返回值（通常是常量值）。</p>\n</li>\n<li><p>如果运算符返回布尔结果，直接返回 <code>bool</code> 类型。</p>\n</li>\n<li><p>如果需要支持链式操作，返回引用。</p>\n</li>\n</ol>\n<p>全局和成员函数的设计思路:</p>\n<ol>\n<li>一元运算符（如 <code>-a</code>）应该用<strong>成员函数</strong>，因为只操作一个对象</li>\n<li>赋值相关运算符（<code>=</code>, <code>+=</code>, <code>[]</code>, <code>-&gt;()</code>与 <code>-&gt;*</code> 等）必须是成员函数，因为它们需要修改对象状态</li>\n<li>对于二元运算符（如 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>)建议使用<strong>全局函数</strong>，因为：<ul>\n<li>支持操作数的对称转换</li>\n<li>更好地支持与其他类型的互操作</li>\n<li>保持了运算符的自然语义（如 <code>3 * x</code> 和 <code>x * 3</code> 应该都能工作）</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"C-运算符重载基础\"><a href=\"#C-运算符重载基础\" class=\"headerlink\" title=\"C++运算符重载基础\"></a>C++运算符重载基础</h2><p>运算符重载是C++的一项强大特性，它允许用户定义的类型像内置类型一样使用各种运算符。本质上，运算符重载是函数调用的另一种形式。</p>\n<h3 id=\"可重载与不可重载的运算符\"><a href=\"#可重载与不可重载的运算符\" class=\"headerlink\" title=\"可重载与不可重载的运算符\"></a>可重载与不可重载的运算符</h3><p>C++允许重载大多数运算符，但以下<strong>运算符不能被重载</strong>：</p>\n<ul>\n<li><code>.</code> (成员访问运算符)</li>\n<li><code>.*</code> (成员指针访问运算符)</li>\n<li><code>::</code> (作用域解析运算符)</li>\n<li><code>?:</code> (条件运算符)</li>\n<li><code>sizeof</code> (获取类型大小)</li>\n<li><code>typeid</code> (获取类型信息)</li>\n<li>类型转换运算符 (<code>static_cast</code>, <code>dynamic_cast</code>, <code>const_cast</code>, <code>reinterpret_cast</code>)</li>\n</ul>\n<h3 id=\"运算符重载的限制\"><a href=\"#运算符重载的限制\" class=\"headerlink\" title=\"运算符重载的限制\"></a>运算符重载的限制</h3><ol>\n<li><p><strong>只能重载已存在的运算符</strong></p>\n<ul>\n<li>不能创建新的运算符（如Python中的<code>**</code>）</li>\n<li>可以改变运算符的语义（如重载<code>+</code>实现减法），但不推荐</li>\n</ul>\n</li>\n<li><p><strong>运算符必须在类或枚举类型上重载</strong></p>\n<ul>\n<li>至少有一个操作数必须是用户定义类型</li>\n</ul>\n</li>\n<li><p><strong>必须保持操作数数量</strong></p>\n<ul>\n<li>如二元运算符<code>/</code>重载后仍必须是二元的</li>\n</ul>\n</li>\n<li><p><strong>必须保持优先级和结合律</strong></p>\n<ul>\n<li>运算符的优先级和结合律是固定的，不能被改变</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"运算符重载的实现方式\"><a href=\"#运算符重载的实现方式\" class=\"headerlink\" title=\"运算符重载的实现方式\"></a>运算符重载的实现方式</h2><p>运算符重载本质上是一个以<code>operator</code>关键字为前缀，后跟运算符的特殊函数。</p>\n<h3 id=\"成员函数方式\"><a href=\"#成员函数方式\" class=\"headerlink\" title=\"成员函数方式\"></a>成员函数方式</h3><p>作为类的成员函数实现运算符重载时：</p>\n<ul>\n<li>第一个操作数（左操作数）隐式为<code>this</code>指针</li>\n<li>不对接收者（左操作数）执行类型转换</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> ii) : <span class=\"built_in\">i</span>(ii) {}</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">get</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> i; }</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 重载+运算符，返回新对象</span></span><br><span class=\"line\">    <span class=\"type\">const</span> A <span class=\"keyword\">operator</span>+(<span class=\"type\">const</span> A&amp; that) <span class=\"type\">const</span> {</span><br><span class=\"line\">        <span class=\"function\">A <span class=\"title\">c</span><span class=\"params\">(<span class=\"keyword\">this</span>-&gt;i + that.i)</span></span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">    }</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<p>使用成员函数重载时，左操作数必须是该类的对象：</p>\n<ul>\n<li><code>a + b</code> 可行（a是A类对象）</li>\n<li><code>a + 9</code> 可行（9会被隐式转换为A类对象）</li>\n<li><code>9 + a</code> 不可行（9不是A类对象）</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>隐式转换: 编译器查找是否存在从给出参数作为构造函数的输入, 从而创建一个指定对象的方式:</p>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Integer h = a + <span class=\"number\">7</span>; <span class=\"comment\">// 7被隐式转换为Integer</span></span><br></pre></td></tr></table></figure>\n\n<p>上述发生的前提条件是 类 <code>Integer</code> 存在对应的构造函数:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Integer</span>(<span class=\"type\">int</span> val = <span class=\"number\">0</span>) : <span class=\"built_in\">value</span>(val)</span><br></pre></td></tr></table></figure></blockquote>\n<h3 id=\"全局函数方式\"><a href=\"#全局函数方式\" class=\"headerlink\" title=\"全局函数方式\"></a>全局函数方式</h3><p>作为全局函数实现运算符重载时：</p>\n<ul>\n<li>所有操作数都是显式参数</li>\n<li>开发者不需要特殊访问类的权限</li>\n<li>可能需要声明为友元函数以访问私有成员</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Integer</span>{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">  <span class=\"type\">int</span> value;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">friend</span> <span class=\"type\">const</span> Integer <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> Integer &amp;left, <span class=\"type\">const</span> Integer&amp; right);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可以直接在全局函数中访问私有成员</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer <span class=\"keyword\">operator</span>*(<span class=\"type\">const</span> Integer &amp;left, <span class=\"type\">const</span> Integer &amp;right)</span><br><span class=\"line\">{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"调用全局函数*运算符: \"</span> &lt;&lt; left.value &lt;&lt; <span class=\"string\">\" * \"</span> &lt;&lt; right.value &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Integer</span>(left.value * right.value);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<p>当然, 全局函数实现的运算符重载, 可以通过调用类的public中的函数接口, 来间接访问内部的私有成员变量:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Integer</span>{</span><br><span class=\"line\">  <span class=\"keyword\">public</span>: </span><br><span class=\"line\">  <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getValue</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过public接口访问内部的私有成员变量.</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer <span class=\"keyword\">operator</span>/(<span class=\"type\">const</span> Integer &amp;left, <span class=\"type\">const</span> Integer &amp;right)</span><br><span class=\"line\">{</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"调用全局函数/运算符: \"</span> &lt;&lt; left.<span class=\"built_in\">getValue</span>() &lt;&lt; <span class=\"string\">\" / \"</span> &lt;&lt; right.<span class=\"built_in\">getValue</span>() &lt;&lt; std::endl;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (right.<span class=\"built_in\">getValue</span>() == <span class=\"number\">0</span>)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">\"错误: 除数不能为零\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Integer</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Integer</span>(left.<span class=\"built_in\">getValue</span>() / right.<span class=\"built_in\">getValue</span>());</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用全局函数重载时，可以处理左操作数不是该类对象的情况：</p>\n<ul>\n<li><code>9 - b</code> 可行（9会被隐式转换为A类对象）</li>\n<li>因为两个操作数都是普通参数，地位平等, 体现了运算符的对称性</li>\n</ul>\n<h3 id=\"成员函数vs全局函数的选择\"><a href=\"#成员函数vs全局函数的选择\" class=\"headerlink\" title=\"成员函数vs全局函数的选择\"></a>成员函数vs全局函数的选择</h3><ul>\n<li><strong>一元运算符</strong>应该作为成员函数</li>\n<li><strong>赋值运算符</strong>（<code>=</code>, <code>()</code>, <code>[]</code>, <code>-&gt;</code>, <code>-&gt;</code>）必须是成员函数</li>\n<li>其他<strong>二元运算符</strong>最好作为非成员函数（全局函数）</li>\n</ul>\n<h2 id=\"参数传递与返回类型\"><a href=\"#参数传递与返回类型\" class=\"headerlink\" title=\"参数传递与返回类型\"></a>参数传递与返回类型</h2><h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><ol>\n<li>对于只读参数，使用<code>const</code>引用传递（除了内置类型）</li>\n<li>对于不修改对象的成员函数，声明为<code>const</code></li>\n<li>对于全局函数，如果左操作数会被修改，使用引用传递</li>\n</ol>\n<h3 id=\"返回类型\"><a href=\"#返回类型\" class=\"headerlink\" title=\"返回类型\"></a>返回类型</h3><p>根据运算符的预期含义选择返回类型：</p>\n<ol>\n<li><p><strong>算术运算符</strong>（<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>^</code>, <code>&amp;</code>, <code>|</code>, <code>~</code>）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> T <span class=\"keyword\">operator</span> <span class=\"title\">X</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; l, <span class=\"type\">const</span> T&amp; r)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回新对象，不应返回引用（除非返回成员引用）</li>\n<li>返回<code>const</code>对象防止<code>(a+b) = c</code>这样的操作</li>\n</ul>\n</li>\n<li><p><strong>逻辑运算符</strong>（<code>!</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>==</code>, <code>&gt;=</code>, <code>&gt;</code>）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">bool</span> <span class=\"keyword\">operator</span> <span class=\"title\">X</span><span class=\"params\">(<span class=\"type\">const</span> T&amp; l, <span class=\"type\">const</span> T&amp; r)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回布尔值</li>\n</ul>\n</li>\n<li><p><strong>下标运算符</strong>（<code>[]</code>）</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">E&amp; T::<span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>返回左值（非<code>const</code>引用），允许<code>a[i] = value</code>操作</li>\n<li>不能返回新对象，否则赋值操作无效</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"特殊运算符重载\"><a href=\"#特殊运算符重载\" class=\"headerlink\" title=\"特殊运算符重载\"></a>特殊运算符重载</h2><h3 id=\"自增自减运算符\"><a href=\"#自增自减运算符\" class=\"headerlink\" title=\"自增自减运算符\"></a>自增自减运算符</h3><p>C++区分前缀和后缀自增自减运算符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 前缀++</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer&amp; Integer::<span class=\"keyword\">operator</span>++() {</span><br><span class=\"line\">    *<span class=\"keyword\">this</span> += <span class=\"number\">1</span>;  <span class=\"comment\">// 先增加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 再返回</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 后缀++（参数int未使用，仅用于区分）</span></span><br><span class=\"line\"><span class=\"type\">const</span> Integer Integer::<span class=\"keyword\">operator</span>++(<span class=\"type\">int</span>) {</span><br><span class=\"line\">    <span class=\"function\">Integer <span class=\"title\">old</span><span class=\"params\">(*<span class=\"keyword\">this</span>)</span></span>;  <span class=\"comment\">// 先保存</span></span><br><span class=\"line\">    ++(*<span class=\"keyword\">this</span>);  <span class=\"comment\">// 再增加</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> old;  <span class=\"comment\">// 返回旧值</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>调用方式：</p>\n<ul>\n<li><p><code>++x</code> 调用 <code>x.operator++()</code></p>\n<ul>\n<li><p>返回的是引用, 从而支持链式操作 如:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Counter g = ++(++f); <span class=\"comment\">// 可以，因为前缀返回引用</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><code>x++</code> 调用 <code>x.operator++(0)</code></p>\n<ul>\n<li><p>返回的是临时的对象, 也就是旧值的副本. 声明<code>const</code>避免了后缀的链式调用</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Counter h = (f++)++; <span class=\"comment\">// 不可以，因为后缀返回const值</span></span><br></pre></td></tr></table></figure>\n\n<p>之所以要防止上述的后缀链式调用, 是因为 对<code>f++</code>继续自增将会导致语义的混乱.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"下标运算符\"><a href=\"#下标运算符\" class=\"headerlink\" title=\"下标运算符\"></a>下标运算符</h3><p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 下标运算符（返回左值引用，允许修改）</span></span><br><span class=\"line\"><span class=\"type\">int</span>&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) {</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">\"错误: 下标越界 [\"</span> &lt;&lt; index &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"comment\">// 返回第一个元素作为应急措施（实际应用中应抛出异常）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> data[<span class=\"number\">0</span>];</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data[index];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 下标运算符的const版本（返回值，不允许修改）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> index) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (index &lt; <span class=\"number\">0</span> || index &gt;= size) {</span><br><span class=\"line\">        std::cerr &lt;&lt; <span class=\"string\">\"错误: 下标越界 [\"</span> &lt;&lt; index &lt;&lt; <span class=\"string\">\"]\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">        <span class=\"comment\">// 返回0作为应急措施（实际应用中应抛出异常）</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data[index];</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"关系运算符\"><a href=\"#关系运算符\" class=\"headerlink\" title=\"关系运算符\"></a>关系运算符</h3><p>关系运算符通常成对实现，可以相互利用：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>==(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i == rhs.i;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>!=(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(*<span class=\"keyword\">this</span> == rhs);  <span class=\"comment\">// 利用==运算符</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> i &lt; rhs.i;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>&gt;(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> rhs &lt; *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 利用&lt;运算符</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>&lt;=(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(rhs &lt; *<span class=\"keyword\">this</span>);  <span class=\"comment\">// 利用&lt;运算符</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">bool</span> Integer::<span class=\"keyword\">operator</span>&gt;=(<span class=\"type\">const</span> Integer&amp; rhs) <span class=\"type\">const</span> {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> !(*<span class=\"keyword\">this</span> &lt; rhs);  <span class=\"comment\">// 利用&lt;运算符</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"流运算符\"><a href=\"#流运算符\" class=\"headerlink\" title=\"流运算符\"></a>流运算符</h3><p>输入输出流运算符通常实现为全局函数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 输出流运算符</span></span><br><span class=\"line\">ostream&amp; <span class=\"keyword\">operator</span>&lt;&lt;(ostream&amp; os, <span class=\"type\">const</span> A&amp; a) {</span><br><span class=\"line\">    os &lt;&lt; a.<span class=\"built_in\">get</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> os;  <span class=\"comment\">// 返回流对象以支持链式操作</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 输入流运算符</span></span><br><span class=\"line\">istream&amp; <span class=\"keyword\">operator</span>&gt;&gt;(istream&amp; is, A&amp; a) {</span><br><span class=\"line\">    string line;</span><br><span class=\"line\">    cin &gt;&gt; line;</span><br><span class=\"line\">    <span class=\"comment\">// 读取a的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> is;  <span class=\"comment\">// 返回流对象以支持链式操作</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>输出流运算符的第一个参数不能是<code>const</code>，因为输出会修改流</li>\n<li>输入流运算符的第二个参数不能是<code>const</code>，因为需要修改对象</li>\n<li>通常需要声明为友元以访问私有成员</li>\n</ul>\n<h3 id=\"自定义流操纵符\"><a href=\"#自定义流操纵符\" class=\"headerlink\" title=\"自定义流操纵符\"></a>自定义流操纵符</h3><p>可以定义自己的流操纵符：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">ostream&amp; <span class=\"title\">tab</span><span class=\"params\">(ostream&amp; out)</span> </span>{</span><br><span class=\"line\">    <span class=\"keyword\">return</span> out &lt;&lt; <span class=\"string\">'\\t'</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用：cout &lt;&lt; \"Hello\" &lt;&lt; tab &lt;&lt; \"World!\" &lt;&lt; endl;</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"赋值运算符与类型转换\"><a href=\"#赋值运算符与类型转换\" class=\"headerlink\" title=\"赋值运算符与类型转换\"></a>赋值运算符与类型转换</h2><h3 id=\"赋值运算符-1\"><a href=\"#赋值运算符-1\" class=\"headerlink\" title=\"赋值运算符\"></a>赋值运算符</h3><p>赋值运算符有几个重要特点：</p>\n<ul>\n<li>必须是成员函数</li>\n<li>如果不提供，编译器会自动生成（行为类似默认拷贝构造函数）</li>\n<li>需要检查自赋值情况</li>\n<li>确保为所有数据成员赋值</li>\n<li>返回<code>*this</code>的引用</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A&amp; A::<span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> A&amp; rhs) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;rhs) {  <span class=\"comment\">// 检查自赋值</span></span><br><span class=\"line\">        <span class=\"comment\">// 释放当前资源</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 分配新资源</span></span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[rhs.size];</span><br><span class=\"line\">        size = rhs.size;</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"comment\">// 复制数据</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {</span><br><span class=\"line\">            data[i] = rhs.data[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 返回对象引用</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><h4 id=\"隐式转换\"><a href=\"#隐式转换\" class=\"headerlink\" title=\"隐式转换\"></a>隐式转换</h4><p>C++支持两种用户定义的类型转换：</p>\n<ol>\n<li><p><strong>构造函数转换</strong>：从其他类型到当前类型</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">PathName</span> {</span><br><span class=\"line\">    string name;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">PathName</span>(<span class=\"type\">const</span> string&amp; s) : <span class=\"built_in\">name</span>(s) {}  <span class=\"comment\">// string到PathName的转换</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">string <span class=\"title\">abc</span><span class=\"params\">(<span class=\"string\">\"abc\"</span>)</span></span>;</span><br><span class=\"line\">PathName xyz = abc;  <span class=\"comment\">// 隐式转换：abc =&gt; PathName</span></span><br></pre></td></tr></table></figure>\n\n<p>可以使用<code>explicit</code>关键字禁止隐式转换：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">PathName</span><span class=\"params\">(<span class=\"type\">const</span> string&amp; s)</span></span>;  <span class=\"comment\">// 只能用于显式构造</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><strong>转换运算符</strong>：从当前类型到其他类型</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Rational</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">double</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{  <span class=\"comment\">// Rational到double的转换</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> numerator_ / (<span class=\"type\">double</span>)denominator_;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">3</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">double</span> d = r;  <span class=\"comment\">// 隐式转换：r =&gt; double</span></span><br></pre></td></tr></table></figure>\n\n<p>同样可以使用<code>explicit</code>关键字要求显式转换：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"keyword\">operator</span> <span class=\"title\">double</span><span class=\"params\">()</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\"><span class=\"type\">double</span> d = (<span class=\"type\">double</span>)r;  <span class=\"comment\">// 必须显式转换</span></span><br></pre></td></tr></table></figure></li>\n</ol>\n<p>注意：如果同时提供了从T到C的构造函数和从C到T的转换运算符，编译器可能会产生歧义。</p>\n<h4 id=\"显式转换\"><a href=\"#显式转换\" class=\"headerlink\" title=\"显式转换\"></a>显式转换</h4><p>显式转换的外在特点:</p>\n<ul>\n<li>使用直接初始化语法</li>\n<li>明确指出要用构造函数创建对象</li>\n<li>转换过程更加清晰可见</li>\n</ul>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 构造函数转换：double到Rational</span></span><br><span class=\"line\">Rational r1 = <span class=\"number\">3.14</span>;  <span class=\"comment\">// 隐式转换</span></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r2</span><span class=\"params\">(<span class=\"number\">2.5</span>)</span></span>;    <span class=\"comment\">// 显式转换</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果声明 <code>explict</code>, 就必须使用强制的显式转换:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 如果想要强制显式转换，应该这样声明：</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">explicit</span> <span class=\"title\">Rational</span><span class=\"params\">(<span class=\"type\">double</span> value)</span> </span>{</span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"type\">int</span> PRECISION = <span class=\"number\">10000</span>;</span><br><span class=\"line\">    numerator = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">int</span>&gt;(value * PRECISION);</span><br><span class=\"line\">    denominator = PRECISION;</span><br><span class=\"line\">    <span class=\"built_in\">simplify</span>();</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">Rational r1 = <span class=\"number\">3.14</span>;        <span class=\"comment\">// 错误：不允许隐式转换</span></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r2</span><span class=\"params\">(<span class=\"number\">2.5</span>)</span></span>;          <span class=\"comment\">// 正确：显式构造</span></span><br><span class=\"line\">Rational r3 = <span class=\"built_in\">Rational</span>(<span class=\"number\">3.14</span>); <span class=\"comment\">// 正确：显式转换</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>类型的显式转换:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">double</span> d2 = <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(r2);  <span class=\"comment\">// 显式转换</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"混合类型的转换\"><a href=\"#混合类型的转换\" class=\"headerlink\" title=\"混合类型的转换\"></a>混合类型的转换</h4><p>根据运算结果, 自动地将运算的操作数进行类型转换:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 混合类型运算</span></span><br><span class=\"line\"><span class=\"function\">Rational <span class=\"title\">r3</span><span class=\"params\">(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span></span>;</span><br><span class=\"line\"><span class=\"type\">double</span> d3 = <span class=\"number\">0.5</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 这里会将r3转换为double，然后进行double加法</span></span><br><span class=\"line\"><span class=\"type\">double</span> result = r3 + d3;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"Template\"><a href=\"#Template\" class=\"headerlink\" title=\"Template\"></a>Template</h1><h2 id=\"模板概述\"><a href=\"#模板概述\" class=\"headerlink\" title=\"模板概述\"></a>模板概述</h2><p>模板是C++中实现**<u>泛型编程</u>**的核心机制，允许我们编写可以处理不同数据类型的代码，而不必为每种类型重复编写相同的逻辑。</p>\n<ul>\n<li><p>首先尝试匹配普通的函数, 否则尝试匹配模板函数</p>\n</li>\n<li><p>函数模板是声明, 而非定义. 是在实际调用时候去 <strong><u>实例化</u></strong> 对应类型的函数.</p>\n</li>\n<li><p>必须都放在头文件的实现包含:</p>\n<ul>\n<li><p>函数模板;</p>\n</li>\n<li><p>inline函数</p>\n</li>\n<li><p>带有default参数的声明.</p>\n</li>\n<li><p>类模板的成员函数</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;T&gt;</span><br><span class=\"line\"><span class=\"type\">int</span> Vector&lt;T&gt;::<span class=\"built_in\">getSize</span>()<span class=\"type\">const</span>{</span><br><span class=\"line\">  <span class=\"keyword\">return</span> size;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>注意, 都需要声明模板类, 并且需要在 <code>&lt; &gt;</code>内部声明类.</p>\n</li>\n</ul>\n</li>\n<li><p><code>template&lt;class T&gt;</code> 和 <code>template&lt;typename T&gt;</code> 是等价的, 后者是后来引入的更明确的语法.</p>\n</li>\n<li><p>类模板的每个成员函数在类外定义时，都必须以<code>template&lt;class T&gt;</code>（或<code>template&lt;typename T&gt;</code>）开头，即使该成员函数没有直接使用模板参数T.</p>\n</li>\n<li><p><code>Vector&lt; int (*)&gt;</code></p>\n</li>\n</ul>\n<h2 id=\"函数模板\"><a href=\"#函数模板\" class=\"headerlink\" title=\"函数模板\"></a>函数模板</h2><h3 id=\"基本语法-1\"><a href=\"#基本语法-1\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> T&gt;</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">swap</span><span class=\"params\">(T&amp; x, T&amp; y)</span> </span>{</span><br><span class=\"line\">    T temp = x;</span><br><span class=\"line\">    x = y;</span><br><span class=\"line\">    y = temp;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>template</code> 关键字引入模板声明</li>\n<li><code>class T</code> 指定参数化类型名称（<code>class</code>在这里表示任何内置类型或用户定义类型）</li>\n<li>在模板内部，<code>T</code> 被用作类型名称</li>\n</ul>\n<h3 id=\"模板实例化\"><a href=\"#模板实例化\" class=\"headerlink\" title=\"模板实例化\"></a>模板实例化</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> i = <span class=\"number\">3</span>, j = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"built_in\">swap</span>(i, j);  <span class=\"comment\">// 使用int类型的swap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">float</span> k = <span class=\"number\">4.5</span>, m = <span class=\"number\">3.7</span>;</span><br><span class=\"line\"><span class=\"built_in\">swap</span>(k, m);  <span class=\"comment\">// 实例化float类型的swap</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">std::string <span class=\"title\">s</span><span class=\"params\">(<span class=\"string\">\"Hello\"</span>)</span>, <span class=\"title\">t</span><span class=\"params\">(<span class=\"string\">\"World\"</span>)</span></span>;</span><br><span class=\"line\"><span class=\"built_in\">swap</span>(s, t);  <span class=\"comment\">// 实例化std::string类型的swap</span></span><br></pre></td></tr></table></figure>\n\n<p>编译器会根据传入的参数类型自动生成相应的函数实例。</p>\n<h3 id=\"模板匹配规则\"><a href=\"#模板匹配规则\" class=\"headerlink\" title=\"模板匹配规则\"></a>模板匹配规则</h3><ul>\n<li>只使用类型的精确匹配</li>\n<li>不应用类型转换操作</li>\n<li>即使是隐式转换也会被忽略</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">swap</span>(<span class=\"type\">int</span>, <span class=\"type\">int</span>);     <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"built_in\">swap</span>(<span class=\"type\">double</span>, <span class=\"type\">double</span>); <span class=\"comment\">// 正确</span></span><br><span class=\"line\"><span class=\"built_in\">swap</span>(<span class=\"type\">int</span>, <span class=\"type\">double</span>);  <span class=\"comment\">// 错误！类型不匹配</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"模板函数与普通函数共存\"><a href=\"#模板函数与普通函数共存\" class=\"headerlink\" title=\"模板函数与普通函数共存\"></a>模板函数与普通函数共存</h3><p>如果同时存在模板函数和普通函数，编译器会优先选择**<u>普通函数</u>**.</p>\n<h4 id=\"显式指定\"><a href=\"#显式指定\" class=\"headerlink\" title=\"显式指定\"></a>显式指定</h4><p>可以显式地指定模板参数类型:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 带有返回值的函数模板</span></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"function\">T <span class=\"title\">myMax</span><span class=\"params\">(T a, T b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"调用模板版本的myMax\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &gt; b) ? a : b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  cout &lt;&lt; <span class=\"string\">\"myMax&lt;double&gt;(10, 20.5) = \"</span> &lt;&lt; <span class=\"built_in\">myMax</span>&lt;<span class=\"type\">double</span>&gt;(<span class=\"number\">10</span>, <span class=\"number\">20.5</span>) &lt;&lt; endl; </span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// myMax(10, 20.5);  // 错误：参数类型不一致</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"多参数的函数模板\"><a href=\"#多参数的函数模板\" class=\"headerlink\" title=\"多参数的函数模板\"></a>多参数的函数模板</h4><p>同理的, 我们可以设置多个参数类型, 根据输入的类型来推断:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T1</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">T2</span>&gt;</span><br><span class=\"line\"><span class=\"function\">T1 <span class=\"title\">myMax</span><span class=\"params\">(T1 a, T2 b)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"调用模板版本的myMax2\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (a &gt; b) ? a : b;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">  cout &lt;&lt;  <span class=\"built_in\">myMax</span>(<span class=\"number\">10</span>, <span class=\"number\">20.5</span>) &lt;&lt; endl; </span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p> 此时, 上述的函数不需要显式的声明参数类型, 因为存在匹配的模板函数.</p>\n<p>同时, 此时根据类型推断, 返回的类型是 <code>int</code>, 然后舍弃 20.5的小数部分, 最终的结果是 <code>20</code>.</p>\n<h2 id=\"类模板\"><a href=\"#类模板\" class=\"headerlink\" title=\"类模板\"></a>类模板</h2><h3 id=\"基本语法-2\"><a href=\"#基本语法-2\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><p>此处的 <code>Vector</code>是自己定义的.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Vector</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Vector</span>(<span class=\"type\">int</span>);</span><br><span class=\"line\">    ~<span class=\"built_in\">Vector</span>();</span><br><span class=\"line\">    <span class=\"built_in\">Vector</span>(<span class=\"type\">const</span> Vector&amp;);</span><br><span class=\"line\">    Vector&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Vector&amp;);</span><br><span class=\"line\">    T&amp; <span class=\"keyword\">operator</span>[](<span class=\"type\">int</span>);</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    T* m_elements;</span><br><span class=\"line\">    <span class=\"type\">int</span> m_size;</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类模板的使用\"><a href=\"#类模板的使用\" class=\"headerlink\" title=\"类模板的使用\"></a>类模板的使用</h3><p>类模板必须显式指定类型参数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">v1</span><span class=\"params\">(<span class=\"number\">100</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Vector&lt;Complex&gt; <span class=\"title\">v2</span><span class=\"params\">(<span class=\"number\">256</span>)</span></span>;</span><br><span class=\"line\">v1[<span class=\"number\">20</span>] = <span class=\"number\">10</span>;</span><br><span class=\"line\">v2[<span class=\"number\">20</span>] = v1[<span class=\"number\">20</span>];  <span class=\"comment\">// 如果定义了int到Complex的转换，则正确</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类模板成员函数的定义\"><a href=\"#类模板成员函数的定义\" class=\"headerlink\" title=\"类模板成员函数的定义\"></a>类模板成员函数的定义</h3><p>所有成员函数定义都需要包含模板声明：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\">Vector&lt;T&gt;::<span class=\"built_in\">Vector</span>(<span class=\"type\">int</span> size) : <span class=\"built_in\">m_size</span>(size) {</span><br><span class=\"line\">    m_elements = <span class=\"keyword\">new</span> T[m_size];</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">template</span> &lt;<span class=\"keyword\">class</span> <span class=\"title class_\">T</span>&gt;</span><br><span class=\"line\">T&amp; Vector&lt;T&gt;::<span class=\"keyword\">operator</span>[](<span class=\"type\">int</span> indx) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (indx &lt; m_size &amp;&amp; indx &gt;= <span class=\"number\">0</span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m_elements[indx];</span><br><span class=\"line\">    } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">        <span class=\"comment\">// 错误处理</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>每个成员函数定义前都要加上 <code>template &lt;class T&gt;</code></li>\n<li>类名必须写为 <code>Vector&lt;T&gt;</code></li>\n<li>类模板的函数通常在头文件中实现，不需要分离的.cpp文件</li>\n</ul>\n<h2 id=\"多参数模板\"><a href=\"#多参数模板\" class=\"headerlink\" title=\"多参数模板\"></a>多参数模板</h2><p>模板可以使用多个类型参数：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Key</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">Value</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">HashTable</span> {</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> Value&amp; <span class=\"title\">lookup</span><span class=\"params\">(<span class=\"type\">const</span> Key&amp;)</span> <span class=\"type\">const</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">install</span><span class=\"params\">(<span class=\"type\">const</span> Key&amp;, <span class=\"type\">const</span> Value&amp;)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"嵌套模板\"><a href=\"#嵌套模板\" class=\"headerlink\" title=\"嵌套模板\"></a>嵌套模板</h2><p>模板可以嵌套使用，因为它们只是新的类型：</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector&lt;Vector&lt;<span class=\"type\">double</span>&gt;&gt; matrix;  <span class=\"comment\">// 注意C++11之前需要空格：Vector&lt;Vector&lt;double&gt; &gt;</span></span><br><span class=\"line\">Vector&lt;<span class=\"built_in\">int</span> (*)(Vector&lt;<span class=\"type\">double</span>&gt;&amp;, <span class=\"type\">int</span>)&gt; functionPointers;  <span class=\"comment\">// 函数指针的向量</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"非类型模板参数\"><a href=\"#非类型模板参数\" class=\"headerlink\" title=\"非类型模板参数\"></a>非类型模板参数</h4><p>~也就是没有使用模板类型的普通参数.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"keyword\">class</span> <span class=\"title class_\">Key</span>, <span class=\"keyword\">class</span> <span class=\"title class_\">Value</span>, <span class=\"type\">int</span> TableSize = <span class=\"number\">10</span>&gt;</span><br><span class=\"line\"><span class=\"keyword\">class</span> HashTable {</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<p>其中的 <code>TableSize</code> 就是普通的参数. 在编译时就确定了类型.</p>\n<h2 id=\"模板的局限性与注意事项\"><a href=\"#模板的局限性与注意事项\" class=\"headerlink\" title=\"模板的局限性与注意事项\"></a>模板的局限性与注意事项</h2><ol>\n<li>模板代码通常放在头文件中，因为编译器需要在编译时看到完整的模板定义</li>\n<li>模板错误通常在实例化时才会被发现，错误信息可能很复杂</li>\n<li>模板可能导致代码膨胀，因为每种类型都会生成一份代码</li>\n<li>模板参数必须支持模板中使用的所有操作</li>\n</ol>\n<h1 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h1><ul>\n<li>使用指针作为参数, 而不是直接将结构体本身作为参数传递给函数, 可以避免对结构体的复制. 从而更加高效.<ul>\n<li>另外, 如果希望修改结构体本身的数据, 必须传递指向它本身的指针.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"访问控制\"><a href=\"#访问控制\" class=\"headerlink\" title=\"访问控制\"></a>访问控制</h2><h3 id=\"继承关系中的访问控制\"><a href=\"#继承关系中的访问控制\" class=\"headerlink\" title=\"继承关系中的访问控制\"></a>继承关系中的访问控制</h3><p>控制基类成员在派生类中的可见性：</p>\n<ul>\n<li><code>public</code>：基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>，<code>protected</code> 成员仍然是 <code>protected</code>。</li>\n<li><code>protected</code>：基类的 <code>public</code> 和 <code>protected</code>成员在派生类中都变为 <code>protected</code>。</li>\n<li><code>private</code>：基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li>\n</ul>\n<h2 id=\"作用域与生存期\"><a href=\"#作用域与生存期\" class=\"headerlink\" title=\"作用域与生存期\"></a>作用域与生存期</h2><p>本地: 均为本地</p>\n<p>全局: 均为全局</p>\n<p>静态本地: 作用域是本地, 生存期是全局</p>\n<p>静态全局: ~</p>\n<h2 id=\"Includes\"><a href=\"#Includes\" class=\"headerlink\" title=\"Includes\"></a>Includes</h2><h3 id=\"Algorithm\"><a href=\"#Algorithm\" class=\"headerlink\" title=\"Algorithm\"></a>Algorithm</h3><p><code>copy(first, last, result)</code>:</p>\n<ul>\n<li><code>fisrt</code>和<code>last</code>是输入迭代器, 表示要复制的范围, 左闭右开即<code>last</code>应当指向要复制元素的下一个位置. 必须支持读取操作和递增操作;</li>\n<li><code>result</code>是输出迭代器, 指向复制目标范围的起始位置, 必须支持写入操作和递增操作<ul>\n<li>e.g.<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">std::vector&lt;<span class=\"type\">int</span>&gt; source = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>};</span><br><span class=\"line\"><span class=\"function\">std::vector&lt;<span class=\"type\">int</span>&gt; <span class=\"title\">destination</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>; <span class=\"comment\">// 确保目标容器有足够的空间</span></span><br><span class=\"line\"></span><br><span class=\"line\">std::<span class=\"built_in\">copy</span>(source.<span class=\"built_in\">begin</span>(), source.<span class=\"built_in\">end</span>(), destination.<span class=\"built_in\">begin</span>());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"type\">int</span> num : destination) {</span><br><span class=\"line\">    std::cout &lt;&lt; num &lt;&lt; <span class=\"string\">\" \"</span>; <span class=\"comment\">// 输出：1 2 3 4 5</span></span><br><span class=\"line\">}</span><br><span class=\"line\">std::cout &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><code>result</code>可以直接输出到<code>cout</code>中.  <figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vector&lt;<span class=\"type\">int</span>&gt; vec;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++){</span><br><span class=\"line\">    vec.<span class=\"built_in\">push_back</span>(i);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>()<span class=\"number\">+2</span>); <span class=\"comment\">//删除第三个元素</span></span><br><span class=\"line\"><span class=\"built_in\">copy</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(cout, <span class=\"string\">\",\"</span>));</span><br><span class=\"line\">cout &lt;&lt; endl;</span><br><span class=\"line\"><span class=\"comment\">// 0,1,3,4,</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<ul>\n<li>数组之间<strong>不可以</strong>直接赋值, 但是字符串可以直接赋值</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> str1[] = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\"><span class=\"type\">char</span> str2[] = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">str1 = str2;  <span class=\"comment\">// 错误，数组之间不可以直接赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\">string s1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string s2 = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\">s1 = s2;  <span class=\"comment\">// 正确，字符串可以直接赋值</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string s1 = <span class=\"string\">\"Hello\"</span>;</span><br><span class=\"line\">string s2 = <span class=\"string\">\"World\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"初始状态：\"</span> &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s1: \"</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"comment\">// 输出：Hello</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s2: \"</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\"></span><br><span class=\"line\">s1 = s2;  <span class=\"comment\">// 赋值操作</span></span><br><span class=\"line\"></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"赋值后：\"</span> &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s1: \"</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s2: \"</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 修改 s2 不会影响 s1，因为是深拷贝</span></span><br><span class=\"line\">s2 = <span class=\"string\">\"Changed\"</span>;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"修改 s2 后：\"</span> &lt;&lt; endl;</span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s1: \"</span> &lt;&lt; s1 &lt;&lt; endl;  <span class=\"comment\">// 输出：World</span></span><br><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"s2: \"</span> &lt;&lt; s2 &lt;&lt; endl;  <span class=\"comment\">// 输出：Changed</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Temp\"><a href=\"#Temp\" class=\"headerlink\" title=\"Temp\"></a>Temp</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 迭代器</span></span><br><span class=\"line\">I.<span class=\"built_in\">begin</span>();</span><br><span class=\"line\">I.<span class=\"built_in\">end</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Item Access</span></span><br><span class=\"line\">V.<span class=\"built_in\">front</span>();;</span><br><span class=\"line\">V.<span class=\"built_in\">back</span>();</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"区分\"><a href=\"#区分\" class=\"headerlink\" title=\"区分\"></a>区分</h2><h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p><code>find</code>是字符串类的一种方法, 同时也是标准库<code>algorithm</code>中的一个函数.</p>\n<ul>\n<li><code>find</code>方法: 用于在字符串中查找子字符串的位置。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> pos = str.<span class=\"built_in\">find</span>(<span class=\"string\">\"World\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (pos != string::npos) {</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"Found 'World' at position \"</span> &lt;&lt; pos &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>algorithm</code>中的<code>find</code>函数: 用于在容器（如数组、向量等）中查找元素。</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt; vec = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>};</span><br><span class=\"line\">    vector&lt;<span class=\"type\">int</span>&gt;::iterator it = <span class=\"built_in\">find</span>(vec.<span class=\"built_in\">begin</span>(), vec.<span class=\"built_in\">end</span>(), <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (it != vec.<span class=\"built_in\">end</span>()) {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"Found 3 at position \"</span> &lt;&lt; <span class=\"built_in\">distance</span>(vec.<span class=\"built_in\">begin</span>(), it) &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"comment\">// Found 3 at position 2</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>编译: <code>g++ -std=c++11 test.cpp -o test</code></p>\n</blockquote>\n<h3 id=\"erase\"><a href=\"#erase\" class=\"headerlink\" title=\"erase\"></a>erase</h3><ul>\n<li>对于字符串的方法: <code>str.erase(pos, len)</code><ul>\n<li>删除从指定位置开始的指定个数字符</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">string str = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\">str.<span class=\"built_in\">erase</span>(<span class=\"number\">6</span>, <span class=\"number\">5</span>);</span><br><span class=\"line\">cout &lt;&lt; str &lt;&lt; endl;  <span class=\"comment\">// 输出: Hello</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<ul>\n<li>对于容器的方法: <code>erase(pos1, pos2)</code><ul>\n<li>左闭右开式删除容器当中的元素.</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    std::vector&lt;<span class=\"type\">int</span>&gt; vec = {<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>};</span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Original vector: \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : vec) {</span><br><span class=\"line\">        std::cout &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 删除从第二个元素 (索引 1) 到第四个元素 (索引 3) 的元素</span></span><br><span class=\"line\">    vec.<span class=\"built_in\">erase</span>(vec.<span class=\"built_in\">begin</span>() + <span class=\"number\">1</span>, vec.<span class=\"built_in\">begin</span>() + <span class=\"number\">4</span>); <span class=\"comment\">// 删除 vec[1], vec[2], vec[3]</span></span><br><span class=\"line\"></span><br><span class=\"line\">    std::cout &lt;&lt; <span class=\"string\">\"Modified vector: \"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i : vec) {</span><br><span class=\"line\">        std::cout &lt;&lt; i &lt;&lt; <span class=\"string\">\" \"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">    std::cout &lt;&lt; std::endl; <span class=\"comment\">// 输出 \"1 5 6\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"不知道放在哪里的代码块\"><a href=\"#不知道放在哪里的代码块\" class=\"headerlink\" title=\"不知道放在哪里的代码块\"></a>不知道放在哪里的代码块</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;list&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\"><span class=\"comment\">// 1. 创建并填充链表</span></span><br><span class=\"line\">list&lt;<span class=\"type\">int</span>&gt; L;                      <span class=\"comment\">// 创建一个空的整数链表</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">1</span>; i&lt;=<span class=\"number\">5</span>; ++i)          <span class=\"comment\">// 循环5次</span></span><br><span class=\"line\">    L.<span class=\"built_in\">push_back</span>(i);              <span class=\"comment\">// 依次在链表尾部添加数字1,2,3,4,5</span></span><br><span class=\"line\">                                 <span class=\"comment\">// 此时链表内容为：1,2,3,4,5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 删除第二个元素</span></span><br><span class=\"line\">L.<span class=\"built_in\">erase</span>( ++L.<span class=\"built_in\">begin</span>() );          <span class=\"comment\">// L.begin()指向第一个元素</span></span><br><span class=\"line\">                                 <span class=\"comment\">// ++L.begin()指向第二个元素</span></span><br><span class=\"line\">                                 <span class=\"comment\">// erase删除迭代器指向的元素</span></span><br><span class=\"line\">                                 <span class=\"comment\">// 此时链表内容为：1,3,4,5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 打印链表内容</span></span><br><span class=\"line\"><span class=\"built_in\">copy</span>(                            <span class=\"comment\">// 标准库算法，用于复制序列</span></span><br><span class=\"line\">    L.<span class=\"built_in\">begin</span>(),                   <span class=\"comment\">// 源序列的起始位置</span></span><br><span class=\"line\">    L.<span class=\"built_in\">end</span>(),                     <span class=\"comment\">// 源序列的结束位置</span></span><br><span class=\"line\">    <span class=\"built_in\">ostream_iterator</span>&lt;<span class=\"type\">int</span>&gt;(       <span class=\"comment\">// 输出流迭代器</span></span><br><span class=\"line\">        cout,                    <span class=\"comment\">// 指定输出到标准输出</span></span><br><span class=\"line\">        <span class=\"string\">\",\"</span>                      <span class=\"comment\">// 每个元素后面追加的分隔符</span></span><br><span class=\"line\">    )</span><br><span class=\"line\">);</span><br><span class=\"line\">cout &lt;&lt; endl;                    <span class=\"comment\">// 换行</span></span><br><span class=\"line\"></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"课堂缓冲区\"><a href=\"#课堂缓冲区\" class=\"headerlink\" title=\"课堂缓冲区\"></a>课堂缓冲区</h1><ul>\n<li><p>私有的边界是 <code>class</code>而非对象. 也就是说, <strong>相同类的对象可以直接访问对方的私有属性</strong>.</p>\n</li>\n<li><p>不同文件之间的全局变量, 初始化的前后顺序由链接器随机决定. 此时需要确保它们之间没有初始化的依赖.</p>\n</li>\n<li><p>需要尽可能地避免使用全局变量.</p>\n</li>\n<li><p>一个良好的习惯: 当成员函数不需要改变成员变量的值时, 在后面加上 <code>const</code>的关键字, 确保不会改变;</p>\n</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* s = <span class=\"string\">\"Hello,world！\"</span>；</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此时的右侧字符串位于 段 <code>text</code>, 不可写. <code>s</code>本身是一个固定内存的指针.</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> s［］ = <span class=\"string\">\"Hello,world！\"</span>；</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此时的 <code>s</code>是一个大小等于数组内容的对象.</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">const</span> <span class=\"type\">int</span>* <span class=\"title\">f</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 只能将函数的返回值赋值给一个 const int*</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"函数内部的对象的空间分配\"><a href=\"#函数内部的对象的空间分配\" class=\"headerlink\" title=\"函数内部的对象的空间分配\"></a>函数内部的对象的空间分配</h4><p>编译器在编译的时候计算得到函数内部所有的对象的空间, 在实际进入函数的时候**, 立即分配所有对象的空间;**</p>\n<ul>\n<li>实际执行到的时候发生构造.</li>\n</ul>\n<h4 id=\"Quiz\"><a href=\"#Quiz\" class=\"headerlink\" title=\"Quiz\"></a>Quiz</h4><p>静态全局、本地和成员变量都存储于全局数据区.</p>\n<ul>\n<li>静态成员变量的构造也在 <code>main()</code>之前.</li>\n</ul>\n<h1 id=\"题目梳理\"><a href=\"#题目梳理\" class=\"headerlink\" title=\"题目梳理\"></a>题目梳理</h1><h2 id=\"HW2\"><a href=\"#HW2\" class=\"headerlink\" title=\"HW2\"></a>HW2</h2><p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedundefinedundefinedimage-20250225160042809.png?imageSlim\"></p>\n<ul>\n<li>ANS:  B</li>\n<li>由于此处的<code>map</code>以<code>char *</code>作为key, 同时初始化<code>str</code>的操作发生在读取操作的外部, 因此只发生了一次的初始化, 地址是一开始就确定的值. 因此插入时总是插入到同一个键值对.</li>\n</ul>\n<hr>\n<p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedundefinedimage-20250225160652522.png?imageSlim\"></p>\n<ul>\n<li>逗号表达式, 从左到右分别计算,最后返回的结果是最右侧的值, 此处为1.</li>\n</ul>\n<blockquote>\n<ul>\n<li><p><code>vector&lt;int&gt; v(10);</code> 创建包含10个元素的容器, 每个元素初始化为 <code>0</code>;</p>\n</li>\n<li><p><code>vector &lt;int&gt; v(10, 1);</code>: 创建包含10个元素的容器, 但是都初始化为 <code>1</code>;</p>\n</li>\n<li><p><code>vector &lt;int&gt; v{10, 1};</code>: 创建包含10,1 这2个元素的容器;</p>\n</li>\n<li><p>此外, 还可以使用 <code>vector &lt;int&gt; v</code>;创建一个空的容器; </p>\n</li>\n<li><p>同时也还可以用 <strong>迭代器</strong>进行初始化: <code>vector &lt;int&gt; v(arr, arr + 5);</code></p>\n</li>\n</ul>\n</blockquote>\n<h2 id=\"HW3\"><a href=\"#HW3\" class=\"headerlink\" title=\"HW3\"></a>HW3</h2><ul>\n<li>类成员的默认访问权限是 <strong><u>私有的</u></strong>, 即不显式声明访问修饰符, 默认为 <code>private</code>;</li>\n</ul>\n<h2 id=\"HW4\"><a href=\"#HW4\" class=\"headerlink\" title=\"HW4\"></a>HW4</h2><h3 id=\"可变大小矩阵\"><a href=\"#可变大小矩阵\" class=\"headerlink\" title=\"可变大小矩阵:\"></a>可变大小矩阵:</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Matrix</span>{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> r,c;</span><br><span class=\"line\">    vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; m; <span class=\"comment\">// 二维向量, 每个向量元素是一个一维向量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Matrix</span>(<span class=\"type\">int</span> r, <span class=\"type\">int</span> c) : <span class=\"built_in\">r</span>(r),<span class=\"built_in\">c</span>(c){</span><br><span class=\"line\">        m.<span class=\"built_in\">resize</span>(r, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(c)); <span class=\"comment\">// 分配r个一维向量, 每个一维向量的大小为c</span></span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">\t...</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">transform</span><span class=\"params\">()</span></span>{</span><br><span class=\"line\">        vector&lt;vector&lt;<span class=\"type\">int</span>&gt;&gt; <span class=\"built_in\">new_m</span>(c, <span class=\"built_in\">vector</span>&lt;<span class=\"type\">int</span>&gt;(r,<span class=\"number\">0</span>)); <span class=\"comment\">//\t声明一个临时的二维向量</span></span><br><span class=\"line\">        </span><br><span class=\"line\">    \t<span class=\"comment\">// 将矩阵转置, 放入临时的向量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; c; i++){</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"type\">int</span> j = <span class=\"number\">0</span> ; j&lt; r; j++){</span><br><span class=\"line\">                new_m[i][j] = m[j][i];</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">swap</span>(r,c); <span class=\"comment\">//改变矩阵的行与列</span></span><br><span class=\"line\">        m = <span class=\"built_in\">move</span>(new_m); <span class=\"comment\">//使用 move 直接将临时变量的所有权交给m, 避免拷贝</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>此处值得注意的是 <code>resize</code>在二维向量中的使用, 以及 <code>move</code>直接给予“所有权”的特性.</p>\n</blockquote>\n<h2 id=\"HW5\"><a href=\"#HW5\" class=\"headerlink\" title=\"HW5\"></a>HW5</h2><p><strong>判断题</strong>: const成员函数不能作用于非const对象</p>\n<blockquote>\n<p>答案是 <strong>False</strong>. </p>\n<p>题目的意思大致是: 非const对象无法调用 const对象, 实际上是事实是相反的描述. 只需要理解题目的表述即可做出判断.</p>\n</blockquote>\n<h2 id=\"HW6\"><a href=\"#HW6\" class=\"headerlink\" title=\"HW6\"></a>HW6</h2><p>右值引用本身是一个左值, 可以取地址.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span>&amp;&amp; r = <span class=\"number\">5</span>;</span><br><span class=\"line\">std::cout &lt;&lt; r; <span class=\"comment\">// r 在这里是左值，因为它有名字</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"HW7\"><a href=\"#HW7\" class=\"headerlink\" title=\"HW7\"></a>HW7</h2><h2 id=\"HW9\"><a href=\"#HW9\" class=\"headerlink\" title=\"HW9\"></a>HW9</h2><ol>\n<li><p>因为静态成员函数不能是虚函数，所以它们不能实现多态</p>\n<ul>\n<li>静态成员函数不与类的任何具体实例（对象）相关联;</li>\n</ul>\n</li>\n<li><p>在多继承中，派生类的构造函数需要依次调用其基类的构造函数，调用顺序取决于定义派生类时所指定的各基类的顺序</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类A</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"A的构造函数被调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 基类B</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">B</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"B的构造函数被调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 派生类C，继承自A和B</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">public</span> A, <span class=\"keyword\">public</span> B</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数中显式调用基类构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">C</span>() : <span class=\"built_in\">B</span>(), <span class=\"built_in\">A</span>()</span><br><span class=\"line\">    { <span class=\"comment\">// 注意：这里虽然B在A之前，但实际调用顺序由类定义决定</span></span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"C的构造函数被调用\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    C c; <span class=\"comment\">// 创建C的实例</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>输出:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A的构造函数被调用</span><br><span class=\"line\">B的构造函数被调用</span><br><span class=\"line\">C的构造函数被调用</span><br></pre></td></tr></table></figure>\n\n<p>由此可见, 虽然在C的初始化列表中声明了B前A后, 但是实际上A优先调用.</p>\n</li>\n<li><p><del>如果一个类的函数全部都是纯虚函数，则这个类不能有自己类的实现（包括引用和指针）</del></p>\n<ul>\n<li><p>这句话的括号内部是错误的.</p>\n</li>\n<li><p>因为我们依旧可以将其的子类 <code>upcast</code></p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"type\">void</span> <span class=\"title\">ptr</span><span class=\"params\">()</span> </span>= <span class=\"number\">0</span>;</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">ptr</span><span class=\"params\">()</span> <span class=\"keyword\">override</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    A *a = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>();</span><br><span class=\"line\">    a-&gt;<span class=\"built_in\">ptr</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><p>类内的纯虚函数被认为是 <code>inline</code>的函数;</p>\n</li>\n<li><p>在创建派生类的对象时, 构造函数的执行顺序为—— 基类对象-&gt;对象成员-&gt;派生类自身:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Base</span>() { cout &lt;&lt; <span class=\"string\">\"Base 构造函数\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Member</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Member</span>() { cout &lt;&lt; <span class=\"string\">\"Member 构造函数\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">public</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\">    Member m;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Derived</span>() { cout &lt;&lt; <span class=\"string\">\"Derived 构造函数\"</span> &lt;&lt; endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>输出:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Base 构造函数</span><br><span class=\"line\">Member 构造函数</span><br><span class=\"line\">Derived 构造函数</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>私有继承问题: 可以通过方法访问私有继承的public, protected的基类成员(不包括私有成员), 但是无法直接访问.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Base</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">1</span>; <span class=\"comment\">// 私有</span></span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> b = <span class=\"number\">2</span>; <span class=\"comment\">// 保护</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> c = <span class=\"number\">3</span>; <span class=\"comment\">// 公有</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Derived</span> : <span class=\"keyword\">private</span> Base</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> d = <span class=\"number\">4</span>; <span class=\"comment\">// 派生类自己的私有成员</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; a;  // ❌ 错误！Base 的私有成员 a，派生类根本不能访问</span></span><br><span class=\"line\">        cout &lt;&lt; b &lt;&lt; endl; <span class=\"comment\">// ✅ OK：Base 的 protected 成员，在 Derived 中变成了 private</span></span><br><span class=\"line\">        cout &lt;&lt; c &lt;&lt; endl; <span class=\"comment\">// ✅ OK：Base 的 public 成员，在 Derived 中变成了 private</span></span><br><span class=\"line\">        cout &lt;&lt; d &lt;&lt; endl; <span class=\"comment\">// ✅ OK：Derived 的私有成员当然能访问</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Derived d;</span><br><span class=\"line\">    d.<span class=\"built_in\">show</span>();</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; d.b; // ❌ 错误！Base 的 protected 成员，在 Derived 中变成了 private</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>虚函数也具有 <code>this</code> 指针.</p>\n</li>\n<li><p>在构造函数中调用虚函数，不是动态联编</p>\n<ul>\n<li>原因是：<strong>对象还未完全构造完成（或已经开始析构）时，虚函数表（vtable）可能尚未指向最终派生类</strong>.</li>\n<li>所以，在构造函数中调用虚函数时，<strong>只会调用当前类中该函数的版本</strong>，不会发生多态。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"虚析构函数-1\"><a href=\"#虚析构函数-1\" class=\"headerlink\" title=\"虚析构函数\"></a>虚析构函数</h4><ul>\n<li>为了在多重继承的时候, 可以正确的调用各个阶段的析构函数, 我们需要声明基类的析构为虚函数, 然后在子类中重写:</li>\n</ul>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">virtual</span> ~<span class=\"built_in\">CRAFT</span>()</span><br><span class=\"line\">{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"销毁航行器(速度: \"</span> &lt;&lt; speed &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">~<span class=\"built_in\">PLANE</span>() <span class=\"keyword\">override</span></span><br><span class=\"line\">{</span><br><span class=\"line\">    cout &lt;&lt; <span class=\"string\">\"销毁飞机(翼展: \"</span> &lt;&lt; width &lt;&lt; <span class=\"string\">\")\"</span> &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p>菱形继承的时候, 注意 <code>virtual public</code>的声明 以及 在底层的子类中的初始化列表的顺序!</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SEAPLANE</span>(<span class=\"type\">float</span> speed, <span class=\"type\">float</span> width, <span class=\"type\">float</span> depth) : <span class=\"built_in\">CRAFT</span>(speed), <span class=\"built_in\">PLANE</span>(speed, width), <span class=\"built_in\">SHIP</span>(speed, depth)</span><br><span class=\"line\">{</span><br><span class=\"line\">  ...</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"HW10\"><a href=\"#HW10\" class=\"headerlink\" title=\"HW10\"></a>HW10</h2><ul>\n<li>判断: 对象间赋值将调用拷贝构造函数。  <ul>\n<li>错误. 对象间的赋值调用的是 <u>拷贝复赋值运算符</u>.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"异常类\"><a href=\"#异常类\" class=\"headerlink\" title=\"异常类\"></a>异常类</h4><p><img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefinedimage-20250423094724267.png?imageSlim\" alt=\"image-20250423094724267\"></p>\n<ul>\n<li><strong>A</strong>是错误的。C++允许自定义异常类，可以继承标准异常类如std::exception。</li>\n<li><strong>B</strong>是正确的，C++异常机制会在异常抛出前自动销毁局部对象。</li>\n<li><strong>C</strong>是正确的，抛出异常时对象会被拷贝（或移动）到catch块中。</li>\n<li><strong>D</strong>是正确的，在catch块中可以使用对象引用来接收异常对象。</li>\n</ul>\n<h4 id=\"赋值运算符重载\"><a href=\"#赋值运算符重载\" class=\"headerlink\" title=\"赋值运算符重载\"></a>赋值运算符重载</h4><ul>\n<li><p>语法:</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">类名&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> 类名&amp; 对象名)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特点:</p>\n<ul>\n<li>返回类型是类的引用（为了支持连续赋值 a=b=c）</li>\n<li>参数是const引用（防止修改原对象）</li>\n<li>通常需要先释放自己的资源，再复制数据</li>\n</ul>\n</li>\n</ul>\n<p>e.g.</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array&amp; <span class=\"keyword\">operator</span>=(<span class=\"type\">const</span> Array&amp; a) {</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span> != &amp;a) {  <span class=\"comment\">// 防止自赋值</span></span><br><span class=\"line\">        <span class=\"keyword\">delete</span>[] data;  <span class=\"comment\">// 释放原有内存</span></span><br><span class=\"line\">        size = a.size;  <span class=\"comment\">// 复制大小</span></span><br><span class=\"line\">        data = <span class=\"keyword\">new</span> <span class=\"type\">int</span>[size];  <span class=\"comment\">// 分配新内存</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; size; i++) {  <span class=\"comment\">// 复制数据</span></span><br><span class=\"line\">            data[i] = a.data[i];</span><br><span class=\"line\">        }</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *<span class=\"keyword\">this</span>;  <span class=\"comment\">// 返回对象自身的引用</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"W12\"><a href=\"#W12\" class=\"headerlink\" title=\"W12\"></a>W12</h2><ul>\n<li>建立类模板对象的实例化过程为: <code>模板类-对象</code>.<ul>\n<li>编译器根据提供的模板参数将类模板实例化为一个具体的模板类（也称为实例化类或特化类），然后才能创建该模板类的对象。</li>\n<li>类模板的使用实际上是将类模板实例化成一个 <code>类</code></li>\n</ul>\n</li>\n<li>类模板与模板类<ul>\n<li>类模板是类的蓝图或规范，它本身不是一个类</li>\n<li>模板类（或实例化类、特化类）是使用具体的类型参数实例化类模板后得到的具体的类。</li>\n</ul>\n</li>\n<li>类模板和函数模板的实例化的时期 – 均为<code>编译时期</code><ul>\n<li>函数模板在编译时期检查定义中的基本语法;</li>\n<li>尝试调用某一个函数模板时, 编译器根据实际的参数类型来推导模板参数类型/或者由显式指定类型得到, 如果合法就生成函数实例(i.e. <em><strong>模板函数</strong></em>), 这个过程就是模板实例化(生成代码).</li>\n</ul>\n</li>\n<li>除了使用构造函数, 还可以直接调用 <code>make_pair</code> 让编译器自动推导类型来创建pair对象;</li>\n<li></li>\n</ul>\n<h2 id=\"L3\"><a href=\"#L3\" class=\"headerlink\" title=\"L3\"></a>L3</h2><blockquote>\n<p>[!NOTE]</p>\n<ol>\n<li>内联函数在 <strong><u>编译时展开</u></strong>, 而不是运行时.</li>\n<li>内联函数的声明以及最终的生效与否, 是由 <strong><u>编译器</u></strong> 决定的. 也就是说, 无论是否存在 inline 的声明, 编译器最终决定函数的类型.</li>\n</ol>\n</blockquote>\n<h3 id=\"C-初始化列表与成员变量初始化\"><a href=\"#C-初始化列表与成员变量初始化\" class=\"headerlink\" title=\"C++ 初始化列表与成员变量初始化\"></a>C++ 初始化列表与成员变量初始化</h3><blockquote>\n<p>[!NOTE]</p>\n<ul>\n<li><code>int</code>和自己定义的类都是cpp的类, 所以可以直接在初始化列表中用 <code>:class_instance{input},...{}</code>来初始化类内的类对象.</li>\n<li>推荐使用 <code>{}</code>来初始化, 不会产生是函数的歧义.</li>\n</ul>\n</blockquote>\n<h4 id=\"1-构造顺序\"><a href=\"#1-构造顺序\" class=\"headerlink\" title=\"1. 构造顺序\"></a>1. 构造顺序</h4><ul>\n<li>在 C++ 中，<strong>成员变量的初始化顺序由它们在类中声明的顺序决定</strong>，而不是在初始化列表中的顺序。</li>\n<li>初始化列表用于 <strong>直接初始化</strong> 成员变量，而不是在构造函数体内先创建未初始化的对象再赋值。</li>\n</ul>\n<h4 id=\"2-为什么必须使用初始化列表？\"><a href=\"#2-为什么必须使用初始化列表？\" class=\"headerlink\" title=\"2. 为什么必须使用初始化列表？\"></a>2. 为什么必须使用初始化列表？</h4><ul>\n<li><strong>成员变量在进入构造函数体之前就已经完成了初始化</strong>，不能在构造函数体内赋值来替代初始化。</li>\n<li><strong>如果成员变量是一个没有默认构造函数的对象</strong>，必须在初始化列表中显式调用其构造函数，否则编译会报错。</li>\n<li>在构造函数体内赋值，意味着：<ol>\n<li>先调用默认构造函数创建对象（如果 <code>NumberDisplay</code> 没有默认构造函数，这一步会失败）。</li>\n<li>然后使用赋值运算符进行赋值，而赋值运算与初始化是不同的过程。</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"3-示例代码\"><a href=\"#3-示例代码\" class=\"headerlink\" title=\"3. 示例代码\"></a>3. 示例代码</h4><h4 id=\"❌-错误示例（可能会编译失败）\"><a href=\"#❌-错误示例（可能会编译失败）\" class=\"headerlink\" title=\"❌ 错误示例（可能会编译失败）\"></a>❌ 错误示例（可能会编译失败）</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NumberDisplay</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">NumberDisplay</span>(<span class=\"type\">int</span> max) { <span class=\"comment\">/* 初始化代码 */</span> }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Clock</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    NumberDisplay hour_display;</span><br><span class=\"line\">    NumberDisplay minute_display;</span><br><span class=\"line\">    NumberDisplay second_display;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">Clock</span>(<span class=\"type\">int</span> hour, <span class=\"type\">int</span> minute, <span class=\"type\">int</span> second) { <span class=\"comment\">// ❌ 错误：NumberDisplay 没有默认构造函数</span></span><br><span class=\"line\">        hour_display = <span class=\"built_in\">NumberDisplay</span>(<span class=\"number\">24</span>);     <span class=\"comment\">// 不能这样赋值</span></span><br><span class=\"line\">        minute_display = <span class=\"built_in\">NumberDisplay</span>(<span class=\"number\">60</span>);</span><br><span class=\"line\">        second_display = <span class=\"built_in\">NumberDisplay</span>(<span class=\"number\">60</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"✅-正确示例\"><a href=\"#✅-正确示例\" class=\"headerlink\" title=\"✅ 正确示例\"></a><strong>✅ 正确示例</strong></h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Clock</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    NumberDisplay hour_display;</span><br><span class=\"line\">    NumberDisplay minute_display;</span><br><span class=\"line\">    NumberDisplay second_display;</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 使用初始化列表</span></span><br><span class=\"line\">    <span class=\"built_in\">Clock</span>(<span class=\"type\">int</span> hour, <span class=\"type\">int</span> minute, <span class=\"type\">int</span> second)</span><br><span class=\"line\">        : <span class=\"built_in\">hour_display</span>(<span class=\"number\">24</span>), <span class=\"built_in\">minute_display</span>(<span class=\"number\">60</span>), <span class=\"built_in\">second_display</span>(<span class=\"number\">60</span>) {</span><br><span class=\"line\">        <span class=\"comment\">// 构造函数体内的代码可以进行额外的赋值操作</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br></pre></td></tr></table></figure>\n\n\n\n<p><strong>4. 结论</strong></p>\n<p>​\t•\t<strong>所有成员变量都会在构造函数体执行前被初始化</strong>，不能依赖在构造函数体内赋值。</p>\n<p>​\t•\t<strong>如果成员变量是没有默认构造函数的对象</strong>，必须使用初始化列表进行初始化，否则会导致编译错误。</p>\n<p>​\t•\t<strong>初始化列表的顺序应与成员变量的声明顺序一致</strong>，否则可能会导致未定义行为。</p>\n<h2 id=\"Project\"><a href=\"#Project\" class=\"headerlink\" title=\"Project\"></a>Project</h2><h3 id=\"P1\"><a href=\"#P1\" class=\"headerlink\" title=\"P1\"></a>P1</h3><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cout &lt;&lt; <span class=\"string\">\"\\\"\"</span> &lt;&lt; value &lt;&lt; <span class=\"string\">\"\\\"\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>如果要输出引号, 需要加入 <code>\\</code>来进行转义!</p>\n<h4 id=\"使用匿名函数来排序\"><a href=\"#使用匿名函数来排序\" class=\"headerlink\" title=\"使用匿名函数来排序\"></a>使用匿名函数来排序</h4><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">sort</span>(sortedRecords.<span class=\"built_in\">begin</span>(), sortedRecords.<span class=\"built_in\">end</span>(),</span><br><span class=\"line\">     [](<span class=\"type\">const</span> Record&amp; a, <span class=\"type\">const</span> Record&amp; b) {</span><br><span class=\"line\">         <span class=\"keyword\">if</span> (a.qso_date != b.qso_date) <span class=\"keyword\">return</span> a.qso_date &lt; b.qso_date;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> a.time_on &lt; b.time_on;</span><br><span class=\"line\">     });</span><br></pre></td></tr></table></figure>\n\n<p><code>sort</code>是 <code>algorithm</code>头文件中的库函数, 支持原地排序.</p>\n<p>第三个参数是一个函数, 返回 <code>true</code>表示这个函数的第一个参数应该排在第二个参数的前面.</p>\n<p>比如此处, 使用了匿名函数 <code>[]</code>, 同时比较 <code>date</code>, 当 </p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> a.qso_date &lt; b.qso_date;</span><br></pre></td></tr></table></figure>\n\n<p>指的是当前者的时间较小, 应该排在前面, 因此是升序.</p>\n<blockquote>\n<p>不要因为语句太长而忘记末尾的 <code>;</code>.</p>\n</blockquote>\n<h3 id=\"P2\"><a href=\"#P2\" class=\"headerlink\" title=\"P2\"></a>P2</h3><h4 id=\"思路分析\"><a href=\"#思路分析\" class=\"headerlink\" title=\"思路分析\"></a>思路分析</h4><ul>\n<li>整体设计:<ul>\n<li>程序随机生成一组设置, 然后用户开始输入</li>\n<li>大概率, 用户不可避免地会失败, 此时应当让用户选择是否继续参与这场游戏, 否则程序生成下一组的设置;</li>\n</ul>\n</li>\n<li>房间:<ul>\n<li>monster所在;</li>\n<li>princess所在</li>\n<li>lobby;</li>\n<li>普通的room</li>\n<li>具有毒药的房间(接触后限制之后行动的次数)</li>\n<li>解药房间(可以解除中毒的状态)</li>\n<li>地图房间(接触后可以通过输入 <code>map</code>来显示当前的位置)</li>\n</ul>\n</li>\n<li>房间个数: <ul>\n<li>每次都将上述的因素都加入, 不太合适, 因此需要用户输入游戏的类型/难度;</li>\n<li>经典模式: 只会产生monster, princess,lobby和普通房间. 房间的个数较少;</li>\n<li>挑战模式:  加入毒药, 解药和地图因素; 房间个数较多.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"刷题\"><a href=\"#刷题\" class=\"headerlink\" title=\"刷题\"></a>刷题</h2><ul>\n<li><p>Destructors can not be overloaded.</p>\n<ul>\n<li>因为析构函数没有任何的参数和返回类型, 无法重载.</li>\n</ul>\n</li>\n<li><p><strong>类的成员函数可以访问同类的私有成员，即使是其他对象的成员。</strong> 回顾类的私有边界不是相对于对象的, 而是类. </p>\n</li>\n<li><p>cpp中, 构造函数一定不能是 <code>virtual</code> 的! </p>\n</li>\n<li><p>静态变量需要再类的外部定义, 但是静态函数不一定.</p>\n</li>\n<li><p>“In C++， struct is actually the same thing as class， except for minor differences in usage.”</p>\n<ul>\n<li>这句话是正确的, 注意结构体也是支持继承的. 只是默认的继承方式也是 <code>public</code>.</li>\n</ul>\n</li>\n<li><p>In C++, inheritance allows a derived class to directly access all of the functions and data of its base class.（T/F）</p>\n<ul>\n<li>错误的. 对于 <code>public</code> 类型的继承, 依旧无法直接访问父类的私有成员, 只能通过子类的方法来间接访问.</li>\n</ul>\n</li>\n<li><p>下面的代码段, 能够能够通过编译, 但是存在运行时的错误(越界访问):</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{ vector&lt;<span class=\"type\">float</span>&gt; v; v[<span class=\"number\">0</span>] = <span class=\"number\">2.5</span>; }</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编译器在编译时候, 检查的主要是程序的语法和类型;</li>\n<li>越界访问的问题存在于运行时检测.</li>\n</ul>\n</li>\n<li><p>64位系统系统环境, 按照8个字节进行对齐:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 参考的类定义方式</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A1</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> i;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>{}</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 其他的类型定义</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>Output:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Size of <span class=\"title\">A1</span> <span class=\"params\">(non - <span class=\"keyword\">virtual</span> function with <span class=\"type\">int</span> member)</span>: <span class=\"number\">4</span> bytes</span></span><br><span class=\"line\"><span class=\"function\">Size of A2 (virtual function with int member): <span class=\"number\">16</span> bytes</span></span><br><span class=\"line\"><span class=\"function\">Size of A3 (non - virtual function without int member): <span class=\"number\">1</span> bytes</span></span><br><span class=\"line\"><span class=\"function\">Size of A4 (virtual function without int member): <span class=\"number\">8</span> bytes</span></span><br><span class=\"line\"><span class=\"function\">Size of B (derived from A1): <span class=\"number\">8</span> bytes</span></span><br></pre></td></tr></table></figure>\n\n<p>主要注意2点:</p>\n<ol>\n<li><p>没有任何成员的类, 也占用1个字节的大小;</p>\n</li>\n<li><p>4+8 将会对齐得到16个字节的空间大小.</p>\n<blockquote>\n<p>[!NOTE]</p>\n<p><code>void*</code> 和 <code>int*</code> 的大小相同! (题目通常给出 <code>int*</code>的大小, 然后给出虚函数)</p>\n</blockquote>\n</li>\n</ol>\n</li>\n<li><p><code>malloc</code> 不会调用对象的构造函数, 仅仅分配内存, 并不涉及对象的初始化;</p>\n<ul>\n<li><p><code>new</code>会调用构造函数</p>\n</li>\n<li><p><code>malloc</code> 需要显式地类型转换:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>() { std::cout &lt;&lt; <span class=\"string\">\"Constructor called!\"</span> &lt;&lt; std::endl; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\">MyClass* p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">MyClass</span>();  <span class=\"comment\">// 输出 \"Constructor called!\"</span></span><br><span class=\"line\">MyClass* p2 = (MyClass*)<span class=\"built_in\">malloc</span>(<span class=\"built_in\">sizeof</span>(MyClass));  <span class=\"comment\">// 无输出，构造函数未调用</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><code>new</code> 是CPP的运算符, 可以重载; <code>malloc</code>是标准库的函数, 无法重载.</p>\n</li>\n<li><p>每个类最多具有一个析构函数</p>\n</li>\n</ul>\n<h4 id=\"重载问题\"><a href=\"#重载问题\" class=\"headerlink\" title=\"重载问题\"></a>重载问题</h4><p>在 <code>::</code>, <code>()</code> 和 <code>-&gt;</code>中, 只有 <code>-&gt;</code>可以被重载:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span> {</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">sayHello</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">        std::cout &lt;&lt; <span class=\"string\">\"Hello from MyClass!\"</span> &lt;&lt; std::endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyPtr</span> {</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    MyClass* ptr;  <span class=\"comment\">// 内部存储一个原生指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">MyPtr</span>(MyClass* p) : <span class=\"built_in\">ptr</span>(p) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 重载 -&gt; 运算符</span></span><br><span class=\"line\">    MyClass* <span class=\"keyword\">operator</span>-&gt;() {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ptr;  <span class=\"comment\">// 返回原生指针，使得可以继续用 -&gt; 访问成员</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>{</span><br><span class=\"line\">    MyClass obj;</span><br><span class=\"line\">    <span class=\"function\">MyPtr <span class=\"title\">myPtr</span><span class=\"params\">(&amp;obj)</span></span>;  <span class=\"comment\">// 用 MyPtr 包装 MyClass 对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">    myPtr-&gt;<span class=\"built_in\">sayHello</span>();  <span class=\"comment\">// 调用 MyClass 的成员函数</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"new与对象转换\"><a href=\"#new与对象转换\" class=\"headerlink\" title=\"new与对象转换\"></a>new与对象转换</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">protected</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">A</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>) : <span class=\"built_in\">x</span>(x) {}</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">B</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">getx</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> x; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">B</span>(<span class=\"type\">int</span> x = <span class=\"number\">0</span>) : <span class=\"built_in\">A</span>(x) { <span class=\"keyword\">this</span>-&gt;x++; }</span><br><span class=\"line\">    <span class=\"built_in\">B</span>(<span class=\"type\">const</span> B &amp;b) : <span class=\"built_in\">A</span>(b.x) { <span class=\"keyword\">this</span>-&gt;x++; }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">A::<span class=\"keyword\">operator</span> <span class=\"title\">B</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> *<span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(x + <span class=\"number\">1</span>); } <span class=\"comment\">// 特别注意此处</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    A *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(<span class=\"number\">3</span>); <span class=\"comment\">// new的时候触发B的构造函数, 自增</span></span><br><span class=\"line\">    A *p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">A</span>(<span class=\"number\">9</span>);</span><br><span class=\"line\">    B b0 = *p1; <span class=\"comment\">// 发生了A类对象向B类对象的转化, 详见下面两行:</span></span><br><span class=\"line\">    <span class=\"comment\">// *p1 将要转化的时候,  先传入x+1作为B的初始化参数输入,</span></span><br><span class=\"line\">    <span class=\"comment\">// 然后new将触发B的构造函数, 最后返回, 返回结果用于初始化b0, 继续触发拷贝构造函数</span></span><br><span class=\"line\">    B &amp;r = b0;</span><br><span class=\"line\">    B b1 = b0;  <span class=\"comment\">// 发生了 B类对象的拷贝构造, b1的x为8, 但是不会改变b0的x=7</span></span><br><span class=\"line\">    B b2 = *p2; <span class=\"comment\">// 这一步的转换与上面的同理. 也是+3</span></span><br><span class=\"line\">    cout &lt;&lt; p1-&gt;<span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; p2-&gt;<span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b<span class=\"number\">0.</span><span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; r.<span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b<span class=\"number\">1.</span><span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">    cout &lt;&lt; b<span class=\"number\">2.</span><span class=\"built_in\">getx</span>() &lt;&lt; endl;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>解题过程中的关键步骤已经写在注释当中, 最后的输出是:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br><span class=\"line\"><span class=\"number\">12</span></span><br></pre></td></tr></table></figure>\n\n<p>梳理考察的重要知识点:</p>\n<ol>\n<li><p>upcast的时候, 是子类的属性赋值给父类, 包括虚函数表. 因此, 此时看作是父类的对象, 但是虚函数能够动态绑定.</p>\n</li>\n<li><p><code>new</code>和<code>delete</code>分别自动调用类的构造函数和析构函数;</p>\n</li>\n<li><p><code>A::operator B()</code> 形式表示A类对象如何转换成B类型对象的, 在发生转换的时候自动调用这部分的函数.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A *p1 = <span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(<span class=\"number\">3</span>); <span class=\"comment\">// 拷贝构造的时候直接自增为4</span></span><br><span class=\"line\">A *p2 = <span class=\"keyword\">new</span> <span class=\"built_in\">A</span>(<span class=\"number\">9</span>);</span><br></pre></td></tr></table></figure>\n\n<p>注意上面的指针都指向A类的对象.</p>\n</li>\n</ol>\n<h4 id=\"链式的析构顺序\"><a href=\"#链式的析构顺序\" class=\"headerlink\" title=\"链式的析构顺序\"></a>链式的析构顺序</h4><ul>\n<li>构造顺序: 父类-&gt;成员对象-&gt; 自身</li>\n<li>析构顺序: 自身-&gt; 成员对象-&gt; 父类</li>\n</ul>\n<p>下面的这道题目涉及的类的关系如下:</p>\n<ol>\n<li>P是父类, S是子类;</li>\n<li>P内部有两个P类型的指针成员.</li>\n</ol>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 1. 先声明基类 P</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">P</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">static</span> <span class=\"type\">bool</span> flag; <span class=\"comment\">// 静态成员声明</span></span><br><span class=\"line\">    <span class=\"type\">int</span> x;            <span class=\"comment\">// 数据成员</span></span><br><span class=\"line\">    P *left, *right;  <span class=\"comment\">// 指针成员</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">P</span>(P *left = <span class=\"literal\">nullptr</span>, P *right = <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">        : <span class=\"built_in\">x</span>(<span class=\"number\">0</span>), <span class=\"built_in\">left</span>(left), <span class=\"built_in\">right</span>(right) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 虚析构函数（因为有继承关系，应该是虚函数）</span></span><br><span class=\"line\">    ~<span class=\"built_in\">P</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag)</span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> left;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> right;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        {</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (right != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> right;</span><br><span class=\"line\">            }</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left != <span class=\"literal\">nullptr</span>)</span><br><span class=\"line\">            {</span><br><span class=\"line\">                <span class=\"keyword\">delete</span> left;</span><br><span class=\"line\">            }</span><br><span class=\"line\">        }</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"P\"</span> &lt;&lt; x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 2. 静态成员的定义（必须在类外定义）</span></span><br><span class=\"line\"><span class=\"type\">bool</span> P::flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 3. 派生类 S</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">S</span> : <span class=\"keyword\">public</span> P</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"comment\">// 构造函数，调用基类构造函数</span></span><br><span class=\"line\">    <span class=\"built_in\">S</span>(P *left = <span class=\"literal\">nullptr</span>, P *right = <span class=\"literal\">nullptr</span>) : <span class=\"built_in\">P</span>(left, right) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 析构函数</span></span><br><span class=\"line\">    ~<span class=\"built_in\">S</span>()</span><br><span class=\"line\">    {</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"string\">\"S\"</span> &lt;&lt; x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    S *p1 = <span class=\"keyword\">new</span> S;</span><br><span class=\"line\">    p1-&gt;x = <span class=\"number\">1</span>; <span class=\"comment\">// 设置第一个节点的值</span></span><br><span class=\"line\">    S *p2 = <span class=\"keyword\">new</span> S;</span><br><span class=\"line\">    p2-&gt;x = <span class=\"number\">2</span>;   <span class=\"comment\">// 设置第二个节点的值</span></span><br><span class=\"line\">    <span class=\"function\">S <span class=\"title\">s</span><span class=\"params\">(p1, p2)</span></span>; <span class=\"comment\">// 创建根节点，连接p1和p2</span></span><br><span class=\"line\">    s.x = <span class=\"number\">3</span>;     <span class=\"comment\">// 设置根节点的值/</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;    <span class=\"comment\">// 程序结束时析构对象</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>最终的输出:</p>\n<ol>\n<li>析构s, 首先析构子类自身, 调用s的析构函数, 输出s;</li>\n<li>然后析构父类, 父类是P, 析构的时候直接调用自身的析构函数, 一词析构右指针和左指针;</li>\n<li>执行到末尾, 输出自身的P3.</li>\n</ol>\n<p>Output:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">S3P2P1P3</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h4 id=\"操作符的重载\"><a href=\"#操作符的重载\" class=\"headerlink\" title=\"操作符的重载\"></a>操作符的重载</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iomanip&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> MAXN 110</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Your answer will be inserted here. Feel free to add anything needed here.*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">vec</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> first, second;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">vec</span>(<span class=\"type\">int</span> a, <span class=\"type\">int</span> b) : <span class=\"built_in\">first</span>(a), <span class=\"built_in\">second</span>(b) {}</span><br><span class=\"line\">    <span class=\"comment\">//  &lt; 的重载</span></span><br><span class=\"line\">    <span class=\"type\">bool</span> <span class=\"keyword\">operator</span>&lt;(<span class=\"type\">const</span> vec &amp;other) <span class=\"type\">const</span></span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> second &lt; other.second;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 类型转换的重载</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">operator</span> <span class=\"title\">double</span><span class=\"params\">()</span> <span class=\"type\">const</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(first);</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 输出的重载</span></span><br><span class=\"line\">    <span class=\"keyword\">friend</span> std::ostream &amp;<span class=\"keyword\">operator</span>&lt;&lt;(std::ostream &amp;os, <span class=\"type\">const</span> vec &amp;v)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> os &lt;&lt; <span class=\"string\">\"(\"</span> &lt;&lt; v.first &lt;&lt; <span class=\"string\">\",\"</span> &lt;&lt; v.second &lt;&lt; <span class=\"string\">\")\"</span>;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">printArrayInfo</span><span class=\"params\">(vec **arr, <span class=\"type\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    vec *maxv = arr[<span class=\"number\">0</span>], *minv = arr[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"type\">double</span> avg = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; ++i)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        vec *val = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*val &lt; *minv)</span><br><span class=\"line\">            minv = val;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (*maxv &lt; *val)</span><br><span class=\"line\">            maxv = val;</span><br><span class=\"line\">        avg = avg + <span class=\"built_in\">static_cast</span>&lt;<span class=\"type\">double</span>&gt;(*val);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    avg /= n;</span><br><span class=\"line\">    std::cout &lt;&lt; std::fixed &lt;&lt; std::<span class=\"built_in\">setprecision</span>(<span class=\"number\">2</span>) &lt;&lt; <span class=\"string\">\"min = \"</span> &lt;&lt; *minv &lt;&lt; <span class=\"string\">\", max = \"</span> &lt;&lt; *maxv &lt;&lt; <span class=\"string\">\", avg = \"</span> &lt;&lt; avg &lt;&lt; std::endl;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    vec *pool[MAXN];</span><br><span class=\"line\">    <span class=\"type\">int</span> n;</span><br><span class=\"line\">    <span class=\"type\">int</span> a, b;</span><br><span class=\"line\">    std::cin &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"type\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br><span class=\"line\">    {</span><br><span class=\"line\">        std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class=\"line\">        pool[i] = <span class=\"keyword\">new</span> <span class=\"built_in\">vec</span>(a, b);</span><br><span class=\"line\">    }</span><br><span class=\"line\">    <span class=\"built_in\">printArrayInfo</span>(pool, n);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"菱形继承与二义性问题\"><a href=\"#菱形继承与二义性问题\" class=\"headerlink\" title=\"菱形继承与二义性问题\"></a>菱形继承与二义性问题</h4><p>并不是菱形继承的操作都会导致二义性, 要从本质–访问的操作是否导致无法区分正确的单独对象?</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">A</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">A</span>() : <span class=\"built_in\">x</span>(<span class=\"number\">6</span>) {}</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">B</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A::<span class=\"built_in\">fun</span>() + x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">C</span> : <span class=\"keyword\">public</span> A</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> A::<span class=\"built_in\">fun</span>() + x;</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">D</span> : <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C</span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">fun</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        <span class=\"keyword\">return</span> B::<span class=\"built_in\">fun</span>() + C::<span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    D d;</span><br><span class=\"line\">    cout &lt;&lt; d.<span class=\"built_in\">fun</span>();</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; d.A::fun(); 存在二义性的问题, 因为在D当中分别存在来自于B和C的这个函数!</span></span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>在上面代码中, D是菱形继承, 但是可以直接访问d的fun, 因为在d的fun中涉及的是B和C自己的fun. 而后者又能够直接调用自己的继承自A的fun</p>\n<ul>\n<li>无法直接调用 <code>d.A::fun()</code>, 参见注释.</li>\n</ul>\n<h1 id=\"最后的枚举\"><a href=\"#最后的枚举\" class=\"headerlink\" title=\"最后的枚举\"></a>最后的枚举</h1><h4 id=\"转换运算符\"><a href=\"#转换运算符\" class=\"headerlink\" title=\"转换运算符\"></a>转换运算符</h4><p><code>A::operator B()</code>的含义： 定义了如何将 <code>A</code> 类型的对象转换为 <code>B</code> 类型的对象。</p>\n<ul>\n<li><code>A::</code> 表示这是 <code>A</code> 类的成员函数</li>\n<li><code>operator B</code> 表示这是一个到 <code>B</code> 类型的转换运算符</li>\n<li><code>()</code> 表示这是一个函数</li>\n</ul>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// A 具有一个成员变量且在构造函数中可以赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">A::<span class=\"keyword\">operator</span> <span class=\"title\">B</span><span class=\"params\">()</span> </span>{ <span class=\"keyword\">return</span> *<span class=\"keyword\">new</span> <span class=\"built_in\">B</span>(x + <span class=\"number\">1</span>); }</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>new B(x + 1)</code> 创建一个新的 <code>B</code> 对象，其中 <code>x</code> 是 <code>A</code> 类的成员变量</li>\n<li><code>*</code> 解引用这个新创建的对象</li>\n<li>返回这个 <code>B</code> 类型的对象</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>注意, 这只是决定了B类对象的如何构造, 并不会影响A类对象本身.</p>\n</blockquote>\n<p>调用的场景: 需要将A类型的对象转换为B类型的对象 e.g.——</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">A <span class=\"title\">a</span><span class=\"params\">(<span class=\"number\">5</span>)</span></span>;</span><br><span class=\"line\">B b = a;  <span class=\"comment\">// 这里会自动调用 A::operator B()</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"const相关\"><a href=\"#const相关\" class=\"headerlink\" title=\"const相关\"></a>const相关</h2><h3 id=\"对象与方法的对应\"><a href=\"#对象与方法的对应\" class=\"headerlink\" title=\"对象与方法的对应\"></a>对象与方法的对应</h3><p>C++在选择成员函数时会考虑对象的const属性：</p>\n<ul>\n<li><p>const对象只能调用const成员函数 </p>\n</li>\n<li><p>非const对象优先调用非const版本，如果没有非const版本才会调用const版本</p>\n</li>\n<li><blockquote>\n<p>[!NOTE]</p>\n<p>函数定义的顺序并不会影响调用的选择!</p>\n</blockquote>\n</li>\n</ul>\n<p>e.g.</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> std;</span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">MyClass</span></span><br><span class=\"line\">{</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"built_in\">MyClass</span>(<span class=\"type\">int</span> x) : <span class=\"built_in\">val</span>(x) {}</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>{</span><br><span class=\"line\">        cout &lt;&lt; <span class=\"number\">2</span> &lt;&lt; endl</span><br><span class=\"line\">             &lt;&lt; val &lt;&lt; endl;</span><br><span class=\"line\">    }</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">Print</span><span class=\"params\">()</span> <span class=\"type\">const</span> </span>{ cout &lt;&lt; <span class=\"number\">1</span> &lt;&lt; endl</span><br><span class=\"line\">                              &lt;&lt; val &lt;&lt; endl; }</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    <span class=\"type\">int</span> val;</span><br><span class=\"line\">};</span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    <span class=\"function\"><span class=\"type\">const</span> MyClass <span class=\"title\">obj1</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"function\">MyClass <span class=\"title\">obj2</span><span class=\"params\">(<span class=\"number\">20</span>)</span></span>;</span><br><span class=\"line\">    obj<span class=\"number\">1.</span><span class=\"built_in\">Print</span>();</span><br><span class=\"line\">    obj<span class=\"number\">2.</span><span class=\"built_in\">Print</span>();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p>output:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">20</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"初始化先后的问题\"><a href=\"#初始化先后的问题\" class=\"headerlink\" title=\"初始化先后的问题\"></a>初始化先后的问题</h2><p>C++中对象的初始化和销毁顺序遵循特定的规则，这对于理解程序行为和避免内存问题至关重要</p>\n<h3 id=\"初始化列表\"><a href=\"#初始化列表\" class=\"headerlink\" title=\"初始化列表\"></a>初始化列表</h3><h3 id=\"类的构造与析构顺序\"><a href=\"#类的构造与析构顺序\" class=\"headerlink\" title=\"类的构造与析构顺序\"></a>类的构造与析构顺序</h3><p>在C++中，对象的构造和析构顺序遵循以下规则：</p>\n<ol>\n<li><p><strong>构造顺序</strong>：</p>\n<ul>\n<li>基类先于派生类构造</li>\n<li>成员变量按声明顺序构造</li>\n<li>基类构造完成后，才执行派生类构造函数体</li>\n<li><blockquote>\n<p>[!NOTE]</p>\n<p>对象在调用构造函数之前, 首先完成内部成员对象的构造</p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li><p><strong>析构顺序</strong>：</p>\n<ul>\n<li>与构造顺序相反</li>\n<li>先执行派生类析构函数体</li>\n<li>然后按声明顺序的逆序析构成员变量</li>\n<li>最后析构基类</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"示例分析\"><a href=\"#示例分析\" class=\"headerlink\" title=\"示例分析\"></a>示例分析</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"type\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>{</span><br><span class=\"line\">    Child c;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"类层次结构\"><a href=\"#类层次结构\" class=\"headerlink\" title=\"类层次结构\"></a>类层次结构</h5><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X (基础类)</span><br><span class=\"line\">↑</span><br><span class=\"line\">Y (继承自X)</span><br><span class=\"line\"></span><br><span class=\"line\">Parent (包含X成员)</span><br><span class=\"line\">↑</span><br><span class=\"line\">Child (继承自Parent，包含Y成员)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"构造过程分析\"><a href=\"#构造过程分析\" class=\"headerlink\" title=\"构造过程分析\"></a>构造过程分析</h5><p>当创建<code>Child</code>对象时，构造顺序为：</p>\n<ol>\n<li>首先构造基类<code>Parent</code><ul>\n<li>在<code>Parent</code>构造前，先构造其成员<code>x</code>（调用<code>X::X()</code>）</li>\n<li>然后执行<code>Parent</code>构造函数体（输出”Parent::Parent()”）</li>\n</ul>\n</li>\n<li>基类构造完成后，构造<code>Child</code>的成员<code>y</code><ul>\n<li>在构造<code>y</code>前，先构造其基类部分（调用<code>X::X()</code>）</li>\n<li>然后执行<code>Y</code>构造函数体（输出”Y::Y()”）</li>\n</ul>\n</li>\n<li>最后执行<code>Child</code>构造函数体（输出”Child::Child()”）</li>\n</ol>\n<h5 id=\"析构过程分析\"><a href=\"#析构过程分析\" class=\"headerlink\" title=\"析构过程分析\"></a>析构过程分析</h5><p>当<code>Child</code>对象离开作用域时，析构顺序为：</p>\n<ol>\n<li>首先执行<code>Child</code>析构函数体（输出”Child::~Child()”）</li>\n<li>然后析构成员<code>y</code><ul>\n<li>先执行<code>Y</code>析构函数体（输出”Y::~Y()”）</li>\n<li>然后析构其基类部分（调用<code>X::~X()</code>）</li>\n</ul>\n</li>\n<li>最后析构基类<code>Parent</code><ul>\n<li>先执行<code>Parent</code>析构函数体（输出”Parent::~Parent()”）</li>\n<li>然后析构其成员<code>x</code>（调用<code>X::~X()</code>）</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"预期输出\"><a href=\"#预期输出\" class=\"headerlink\" title=\"预期输出\"></a>预期输出</h4><p>执行<code>test.cpp</code>程序时，预期输出为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X::X()              // Parent的成员x构造</span><br><span class=\"line\">Parent::Parent()    // Parent构造函数体</span><br><span class=\"line\">X::X()              // Y的基类部分构造</span><br><span class=\"line\">Y::Y()              // Y构造函数体</span><br><span class=\"line\">Child::Child()      // Child构造函数体</span><br><span class=\"line\">Child::~Child()     // Child析构函数体</span><br><span class=\"line\">Y::~Y()             // Y析构函数体</span><br><span class=\"line\">X::~X()             // Y的基类部分析构</span><br><span class=\"line\">Parent::~Parent()   // Parent析构函数体</span><br><span class=\"line\">X::~X()             // Parent的成员x析构</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"重要注意事项\"><a href=\"#重要注意事项\" class=\"headerlink\" title=\"重要注意事项\"></a>重要注意事项</h4><ol>\n<li><p><strong>虚析构函数</strong>：当使用多态时，基类应该有虚析构函数，确保正确调用派生类析构函数。</p>\n</li>\n<li><p><strong>成员初始化列表</strong>：推荐使用成员初始化列表而非在构造函数体内赋值，这样可以直接初始化而非先默认构造再赋值。</p>\n</li>\n<li><p><strong>异常安全</strong>：构造过程中如果抛出异常，已构造的成员会被正确析构，但未完全构造的对象不会调用析构函数。</p>\n</li>\n<li><p><strong>RAII原则</strong>：资源获取即初始化，在构造函数中获取资源，在析构函数中释放资源，确保资源管理安全。</p>\n</li>\n</ol>\n<h4 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h4><p>理解对象生命周期对以下场景尤为重要：</p>\n<ol>\n<li><strong>资源管理</strong>：确保资源在不再需要时被释放</li>\n<li><strong>依赖关系处理</strong>：确保依赖对象在被依赖对象之前构造，之后析构</li>\n<li><strong>继承层次设计</strong>：合理设计基类和派生类的构造和析构行为</li>\n</ol>\n","_processedHighlight":true},{"title":"JavaScript","date":"2025-01-09T06:06:30.000Z","excerpt":"一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「料理的加护」下, 尽可能将JS处理得更加可口一些)","mathjax":true,"index_img":"/img/料理的加护.jpg","_content":"> JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「**料理的加护**」下, 尽可能将JS处理得更加**可口**一些)\n<img src=\"/img/料理的加护.jpg\" width = \"35%\">\n\n# 创建JS代码块\n## 变量\n### `var` or `let`?\n`var`先于`let`的产生, 后者是现代版本的JS中新的关键字.\n\n使用`var`, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是`let`并不适用.\n```js\nmyName = \"Chris\";\n\nfunction logName() {\n  console.log(myName);\n}\n\nlogName(); //输出\"Chris\"\n\nvar myName = \"Aniya\";\nlogName(); //输出\"Aniya\"\n```\n\n除此之外, 可以使用`var`前后声明相同的变量, 这并不会报错:\n```js\nvar myName = \"Chris\";\nvar myName = \"Bob\";\n```\n\n而`let`只能声明一次:\n```js\nlet myName = \"Chris\";\nmyName = \"Bob\";\n```\n\n因此, 在代码编写中应尽量**多使用**`let`而非`var`, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.\n\n\n### 变量命名的规则\n与C语言类似, 建议以 **字母、数字、下划线** 组成的标识符来命名变量.\n- 不可用`_`开头, 因为可能被JS设计为特殊的含义;\n- 不可用数字开头, 否则引发错误;\n- 大小写敏感;\n- 建议采用 **小写驼峰命名法** ,即小写整个命名的第一个字母然后大写剩下单词的首字符;\n- 避免使用保留字, 比如`var`,`let`,`for`等.\n\n### 变量类型\n\n```js\nlet myAge = 20 ;// 数字\nlet dolphinGoodbye = \"So long and thanks for all the fish\"; // 字符串\nlet test = 6 < 3; //boolean\n\n//数组类型\nlet myNameArray = [\"Chris\", \"Bob\", \"Jim\"];\nlet myNumberArray = [10, 15, 40];\n\n//对象类型\nlet dog = { name: \"Spot\", breed: \"Dalmatian\" };\n\n```\n> 对象类型的访问与结构体相似, `dog.name;`\n\n在上面的几种变量类型中, 我们都采用`let`关键字声明变量, 这体现了JS是一种 **动态类型语言** ,即无需指定变量包含的数据类型.\n\n同时, 这也意味着我们可以像`python`一样对同一个变量先后赋值不同类型的值:\n```js\nlet myNumber = \"500\";\ntypeof myNumber;\n// 输出 'string'\n\nmyNumber = 500; \ntypeof myNumber;\n//输出'number'\n```\n\n\n## 函数\n- $\\underline{提升}$ 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.\n```js\nexampleFunction();\n\nfunction exampleFunction() {\n  console.log(\"函数内\");\n  console.log(x);\n}\n```\n> 由于 **提升** 的存在, 上述的函数调用不会出错.\n\n\n### 默认参数\n在编写函数时, 可以通过在参数名称后添加`=`, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。\n```js\nfunction greeding(name = \"my friend\") {\n    console.log(`Hello, ${name}!`);\n}\nhello(); //Hello, my friend!\nhello(\"world\"); //Hello, world!\n```\n\n<br>\n\n事件处理函数的默认接受值是`event`:\n```html\n<button>\nonclick\n</button>\n\n<p>\nnothing here\n</p>\n\n<script>\nbtn = document.querySelector(\"button\")\npara = document.querySelector(\"p\")\n\nbtn.onclick = click;\n\nfunction click(string){\n  console.log(\"clicked!\")\n  para.textContent = string;\n}\n</script>\n```\n1. 上述的`btn`在点击之后调用函数`click`, 该函数需要一个参数`string`, 由于`btn.onclick = click;`的绑定方式, 我们无法指定传参的值, 因此点击之后的`para`的内容显示为: `[object PointerEvent]`;\n2. `textContent`是属性而非方法, 因此采用赋值实现;\n\n\n```js\nbtn.onclick = function click(string) {\n  console.log(\"clicked!\")\n  para.textContent = \"You have clicked the button!\";\n}\n```\n> 将上述的绑定方式如此改写, 可以在`btn`外对`string`进行赋值, 然后点击按钮可以传入指定参数供后续处理.\n\n\n\n### 箭头函数\n在了解箭头函数的作用之前, 需要先介绍 $\\underline{匿名函数}$:\n```js\nfunction myFunction() {\n  alert(\"你好\");\n}\n\n// 匿名函数\n(function () {\n  alert(\"你好\");\n});\n```\n> 正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.\n\n如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:\n```js\nfunction logKey(event) {\n  console.log(`You pressed \"${event.key}\".`);\n}\n\ntextBox.addEventListener(\"keydown\", logKey);\n```\n这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:\n```js\ntextBox.addEventListener(\"keydown\", function (event) {\n  console.log(`You pressed \"${event.key}\".`);\n});\n```\n>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.\n\n而**箭头函数**则是在此情况下更简洁的函数定义方式:\n```js\ntextBox.addEventListener(\"keydown\", (event) => {\n  console.log(`You pressed \"${event.key}\".`);\n});\n\n//如果函数只接受一个参数, 也可以省略参数周围的括号\ntextBox.addEventListener(\"keydown\", event => {\n  console.log(`You pressed \"${event.key}\".`);\n});\n```\n\n如果只包含一行的`return`,则可以忽略`{}`和`return`关键字:\n```js\nconst originals = [1, 2, 3];\n\nconst doubled = originals.map(item => item * 2);\n\nconsole.log(doubled); // [2, 4, 6]\n```\n> `item => item * 2`等价于:\n```js\nfunction doubleItem(item) {\n  return item * 2;\n}\n```\n\n#### 一个实例\n```html\n<input id=\"textBox\" type=\"text\" />\n<div id=\"output\"></div>\n```\n```js\nconst textBox = document.querySelector(\"#textBox\");\nconst output = document.querySelector(\"#output\");\n\ntextBox.addEventListener(\"keydown\", (event) => {\n  output.textContent = `You pressed \"${event.key}\".`;\n});\n```\n通过监听输入框的keydown事件, 输出按下的键盘按键.\n\n### 函数作用域和冲突\n$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. \n- 全局作用域: 脚本模式运行所有代码的默认作用域;\n- 模块作用域: 模块模式中运行代码的作用域;\n- 函数作用域: 由函数创建的作用域\n\n和C语言相似, 在函数外部`let`定义的变量, 以及`const`定义的常量可以在函数内部访问.\n\n如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:\n```html\n<!-- Excerpt from my HTML -->\n<script src=\"first.js\"></script>\n<script src=\"second.js\"></script>\n<script>\n  greeting();\n</script>\n```\n> 如果两个JS文件都定义了`greeting`函数, 则只有第一个文件中的函数才会被调用.\n\n## 数据类型\n### 数字和操作符\n大部分与C语言相同, 概括需要注意的差异:\n- JS当中只有一种数字类型 -- `number`, 对于整型或者浮点数的初始化得到的量, 由`typeof`均得到`number`;\n- 算术运算符: 求幂为`**`;\n- 常量无法使用自增或自减,~~好像也是C语言的 忘了~~\n- `===`表示严格等于, `!==`表示不等于;\n> 同时存在`==`和`!=`来判断是否相等, 但是它们只是测试 **值** 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用`===`和`!==`来避免类型不一致的错误.\n\n### 字符串\n创建字符串\n```js\nlet myString = \"A string\";\nconst constString = myString;\nconsole.log(constString);\n//A string\n``` \n可以使用单引号,双引号和**反引号**来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:\n```js\nconst single = '单引号';\nconst double = \"双引号\";\nconst backtick = `反引号`;\n```\n\n反引号包裹的字符串称为$\\underline{模板字符串}$, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:\n- 可以嵌入 **JavaScript**;\n- 可以声明**多行**的模板字面量.\n\n#### 字符串的拼接\n字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 $\\underline{串联法}$:\n```js\nconst name = \"克里斯\";\nconst greeting = `你好，${name}`;\nconsole.log(greeting); // \"你好，克里斯\"\n```\n> 在模板字面量中用`${}`包装JS的变量或者表达式.\n\n\n```js\nconst one = \"你好，\";\nconst two = \"请问最近如何？\";\nconst joined = `${one}${two}`;\nconsole.log(joined); // \"你好，请问最近如何？\"\n```\n> 连接2个变量.\n\n```js\nconst song = \"青花瓷\";\nconst score = 9;\nconst highestScore = 10;\nconst output = `我喜欢歌曲《${song}》。我给它打了 ${\n  (score / highestScore) * 100\n} 分。`;\nconsole.log(output); // \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"\n```\n> 在模板字面量的`${}`内部包含表达式.\n\n<br>\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\n```js\nconst greeting = \"你好\";\nconst name = \"克里斯\";\nconsole.log(greeting + \"，\" + name); // \"你好，克里斯\"\n```\n\n#### 多行字符串\n模板字符串会**保留**源代码中的换行符，因此可以编写跨越多行的字符串:\n```js\nconst newline = `终于有一天，\n你知道了必须做的事情，而且开始……`;\nconsole.log(newline);\n\n/*\n终于有一天，\n你知道了必须做的事情，而且开始……\n*/\n```\n\n如果希望用普通的字符串得到等效的输出, 必须在字符串中包含`\\n`,而非直接跨行:\n```js\nconst newline = \"终于有一天，\\n你知道了必须做的事情，而且开始……\";\nconsole.log(newline);\n\n/*\n终于有一天，\n你知道了必须做的事情，而且开始……\n*/\n```\n\n#### 显示引号\n1. $\\underline{转义}$  通过在符号前加上反斜杠`\\`, 可以转义字符串中的特殊字符,包括字符串中的引号:\n```js\nconst bigmouth = 'I\\'ve got no right to take my place…';\n```\n2. 换用其他字符: 在字面量内用不同于包裹字符串的引号:\n```js\nconst goodQuotes1 = 'She said \"I think so!\"';\nconst goodQuotes2 = `She said \"I'm not going in there!\"`;\n```\n\n\n#### 常用方法\n对于字符串对象实例,其常用的方法:\n- `.length`: 获取字符串的长度;\n- `[]`: 返回字符串中对应索引的字符, 索引同样从`0`开始;\n- `.indexOf(\"\")`: 查找子字符串\n  - **input**: 希望查找的子字符串;\n  - **output**: 子字符串开始的下标(如果不存在则返回`-1`);\n- `.slice(indedxStart, indexEnd)`: 截取字符串\n  - **input**: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;\n  - **output**: 截取的子字符串;\n\n更多的`slice`知识:\n1. $\\underline{标准化负值}$ 如果索引是个负数, 取`index+str.length`进行标准化;\n2. 如果`indexStart`大于`str.length`, 返回空字符串;\n3. 如果标准化负值之后, `indexStart`大于`indexEnd`, 也返回空字符串;\n \n- `.toLowerCase()` & `.toUpperCase()`: 转换字符串中的所有字符为小写或大写;\n- `.replace(original, new)`: 替换字符串中`original`子字符串为`new`;\n> 此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.\n\n#### Cases\n利用 **indexOf** 和 **slice** 方法, 获取新字符串:\n- **input**: `\"str3\"`三位长字符串+`\"...\"`(无关字符串)+`\";\"`+`strLast`(剩余字符串);\n- **output**: `\"str3\"+\";\"+strLast`\n\n```js\nvar stations = ['MAN675847583748sjt567654;Manchester Piccadilly',\n                'GNF576746573fhdg4737dh4;Greenfield',\n                'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street',\n                'SYB4f65hf75f736463;Stalybridge',\n                'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'];\n\nfor(var i = 0; i < stations.length; i++){\n    var input = stations[i];\n    var str3 = input.slice(0,3);\n    var strLast = input.slice(input.indexOf(\";\")+1); //indexOf获取;位置\n    var output = str3 + \";\" + strLast;\n}\n```\n\n---\n\n通过 **indexOf** 根据子字符串筛选字符串数组:\n- **input**: 可能包含 *Christmas* 的字符串数组;\n- **output**: 包含 *Christmas* 的字符串数组;\n\n```js\nvar list = document.querySelector('.output ul');\nlist.innerHTML = '';\nvar greetings = ['Happy Birthday!',\n                 'Merry Christmas my love',\n                 'A happy Christmas to all the family',\n                 'You\\'re all I want for Christmas',\n                 'Get well soon'];\n\nfor(var i = 0; i < greetings.length; i++) {\n  var input = greetings[i];\n  if(greetings[i].indexOf('Christmas') !== -1) {\n    var result = input;\n    var listItem = document.createElement('li');\n    listItem.textContent = result;\n    list.appendChild(listItem);\n  }\n}\n```\n\n### 数字与字符串\n#### 相互转换\n非常神奇, 在JS当中, 数字和字符串可以直接通过函数`Number()`和`String()`进行转换, 与C语言不同.\n```js\nconst myString = \"123\";\nconst myNum = Number(myString);\nconsole.log(typeof myNum);\n// number\nconsole.log(myNum);\n// 123\n```\n\n```js\nconst myNum2 = 123;\nconst myString2 = String(myNum2);\nconsole.log(typeof myString2);\n// string\nconsole.log(myString2);\n// \"123\"\n```\n> 对于浮点数同样成立.\n\n#### 前后拼接\n使用`+`将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:\n```js\nconst name = \"Front \";\nconst number = 242;\nconst combine = name + number;\n\nconsole.log(combine); //Front 242\n\nconsole.log(typeof(combine));  //string\n```\n\n### 数组\n1. 存储任意类型元素--字符串，数字，对象，变量，**另一个数组**;\n2. 可以 **混合** 元素类型:\n```js\nlet random = [\"tree\", 795, [0, 1, 2]];\n```\n3. 像访问字符串一样, 利用索引访问数组元素;\n4. $\\underline{多维数组}$ 包含数组的数组结构称为~\n\n#### split()\n- 作用: 将一个字符串根据给定的字符分隔为字符串数组;\n```js\nlet myData = \"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\";\nlet myArray = myData.split(\",\");\nconsole.log(myArray);\n // [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]\n```\n\n#### join()\n`split`的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:\n```js\nlet myNewString = myArray.join(\",\");\nmyNewString;\n```\n\n#### toString()\n与`join`方法相似, 但是无法自定义分隔符, 默认为`,`:\n```js\nlet dogNames = [\"Rocket\", \"Flash\", \"Bella\", \"Slugger\"];\ndogNames.toString(); //Rocket,Flash,Bella,Slugger\n```\n\n#### push & pop\n`push()`方法可以将1或多个元素添加到数组的 **末尾**:\n1. 将会直接改写原来的数组,不需要重新赋值;\n2. 该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);\n```js\nlet myArray = [1, 2, 3];\nlet newLength = myArray.push(4, 5,\"string\");\nconsole.log(myArray); // [1, 2, 3, 4, 5, \"string\"]\nconsole.log(newLength); // 6\n```\n\n使用`.pop()`从数组中删除最后一个元素:\n```js\nmyArray.pop(); //\"string\"\nconsole.log(myArray); // [1, 2, 3, 4, 5]\n```\n1. 方法调用返回值就是删除的元素本身;\n2. 直接对原始数组操作并赋值, 不需要另外的赋值操作;\n\n> shift & unshift:\n> 在功能上分别与`push`和`pop`相同, 但是作用于数组的开始位置.\n\n## 条件语句\nJS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:\n### 天气预报\n```html\n<label for=\"weather\">选择今天的天气：</label\n><select id=\"weather\">\n  <option value=\"\">--作出选择--</option>\n  <option value=\"sunny\">晴天</option>\n  <option value=\"rainy\">雨天</option>\n  <option value=\"snowing\">雪天</option>\n  <option value=\"overcast\">阴天</option>\n</select>\n\n<p></p>\n```\n> `lable`当中的`for`标签与`select`标签的`id`属性对应, 用于关联两个标签.\n\n```js\nconst select = document.querySelector(\"select\");\nconst para = document.querySelector(\"p\");\n\nselect.addEventListener(\"change\", setWeather);\n\nfunction setWeather() {\n  const choice = select.value;\n\n  switch (choice) {\n    case \"sunny\":\n      para.textContent = \"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\";\n      break;\n    case \"rainy\":\n      para.textContent = \"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\";\n      break;\n    case \"snowing\":\n      para.textContent =\n        \"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\";\n      break;\n    case \"overcast\":\n      para.textContent =\n        \"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\";\n      break;\n    default:\n      para.textContent = \"\";\n  }\n}\n```\n> 1. 通过`querySelector`方法获取`select`和`p`标签;\n> 2. 然后为`select`标签添加事件监听器, 当内容改变时触发 **change** 事件, 同时调用`setWeather`函数;\n> 3. 进而通过 **switch** 语句处理不同天气的情况, 并设置相应的文字内容;\n> 在线网页示例:[simple-switch](https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html)\n\n\n## 事件介绍\n什么是$\\underline{事件}$? \n- 用户选择、点击或者光标悬停在某一元素;\n- 用户在键盘中按下某个按键;\n- 网页结束加载;\n- ...\n\n$\\underline{事件处理器}$ 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.\n\n### 处理点击事件\n以点击事件为例, 介绍html与js如何进行事件处理的交互:\n```html\n<button> 改变颜色 </button>\n```\n```js\nconst btn = document.querySelector(\"button\");\n\nfunction random(number){\n  return Math.floor(Math.random()*(number+1));\n  \n}\n\nbtn.addEventListener(\"click\", ()=>{\n  const rndCol = `rgb(${random(255)},${random(255)},${random(255)})`;\n  document.body.style.backgroundColor = rndCol;\n})\n```\n1. `Math.random()`方法生成一个介于[0,1)之间的随机数;\n2. `*(number+1)`之后利用向下取整的方法`Math.floor()`将其转换为整数, 范围为[0,number];\n> 假如输入的number为`4`, 则`random(4)`的结果可能为`0`, `1`, `2`, `3`, `4`中的一个;\n> 假设输入的number为`3.6`, 则输出的结果还是0~4中的整数.\n3. ``rndCol = `rgb(${random(255)},${random(255)},${random(255)})`` 采用的是在$\\underline{模板字符串}$内部使用`${}`调用函数变量的方法.\n\n### addEventListener()\n`adEventListener`方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.\n\n通过`EventTarget.adddEventListener()`的方法, 将指定的监听器注册到对象上, 具体的语法如下:\n```js\naddEventListener(type, listener);\naddEventListener(type, listener, options);\naddEventListener(type, listener, useCapture);\n```\n- `type`: 事件类型, 如`click`, `mouseover`, `mouseout`, `keydown`, `keyup`等;\n- `listener`: 事件处理函数, 该函数将在事件发生时被调用;\n  - 包括 **回调函数** 以及 实现了 **EventListener 接口的对象**;\n- `options`: 可选参数, 用于配置事件监听器的行为;\n> 可以为单个事件添加多个事件监听器.\n\n\n#### listener\n$\\underline{回调函数}$ 简单来说, ~指的是当某个事件发生时被调用的一段代码.\n- 是一个函数, 但是只有等到特定的事件发生时才会执行.\n\n实现了 EventListener 接口的对象:\n- **特点**: 以对象作为listener, 对象中具有名为`handleEvent()`的方法;\n- **作用**: \n  - 将事件处理封装到一个对象当中, 可以更好地组织代码;\n  - 便于在对象中保存更多的状态信息;\n```js\nconst listenerObject = {\n    count: 0,\n    handleEvent(event) {\n        this.count++;\n        console.log(`事件类型是：${event.type}，已触发 ${this.count} 次`);\n    }\n};\n\nconst button = document.querySelector('button');\nbutton.addEventListener('click', listenerObject);\n```\n\n#### options\n一个指定有关 listener 属性的可选参数对象.\n##### Capture\n- 含义:\n  - 一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;\n  - 默认为false, 表示只有在冒泡阶段才触发.\n\n- 区别:\n  - `capture`和`useCapture`实际上指的都是 **监听器是否在捕获阶段触发** 的布尔值.\n> 捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.\n  - 后来DOM的规范更新时引入了`options`参数, 此后`capture`取代了`useCapture`的作用.\n  - 如果`addEventListener`的第三个参数不指定对象, 只有布尔值, 那么默认是在设置`useCapture`\n\n> 可以先查看[事件传播的阶段](#事件传播的阶段)来辅助理解不同的阶段.\n\n##### Once\n- 含义:\n  - 一个布尔值，表示 listener 在添加之后最多只调用一次;\n  - 默认为false, 表示可以多次调用.\n- e.g.\n```js\nchild.addEventListener('click', () => {\n    console.log('子元素 - 目标阶段');\n},{once: true});\n```\n> `once`属性被设置为`true`, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.\n\n##### Passive\n- 含义:\n  - 一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();\n\n- 作用:\n  - 明确不会在`listener`中不会调用`preventDefault()`方法, 即不会阻止浏览器的[默认行为](#默认行为);\n  - 此时, 浏览器可以直接渲染默认行为的结果, 无需等待`listener`的执行与默认行为的检查, 从而提高了性能.\n- Notice:\n  - 如果设置`passive`为`true`, 则`listener`当中不可出现`preventDefault()`方法, 否则会报错.\n\ne.g.\n```js\ndocument.addEventListener('wheel',()=>{\n\tevent.preventDefault();\n  console.log(\"scrolling\");\n},{passive: false});\n```\n- `wheel`事件的默认行为是滚动页面;\n- `event.preventDefault();`表示会阻止鼠标滚动带来的页面滚动;\n\n\n```js\ndocument.addEventListener('wheel',()=>{\n  console.log(\"scrolling\");\n},{passive: true});\n```\n> 明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.\n\n```js\ndocument.addEventListener('wheel',()=>{\n  event.preventDefault();\n  console.log(\"scrolling\");\n},{passive: true});\n```\n> `passive`的设置与`listener`内部矛盾, 将会报错.\n\n##### Signal\n用于有条件地移除事件监听器, 具体使用参见[可被移除的监听器](#可被移除的监听器).\n\n### 事件传播的阶段\n1. 捕获阶段 $\\underline{capture\\space phase}$: 事件从根节点开始向目标节点传播;\n> e.g. 点击事件从document开始传播, 经过html,body直到目标元素.\n2. 目标阶段阶段 $\\underline{target\\space phase}$: 事件到达目标元素;\n3. 冒泡阶段 $\\underline{bubble\\space phase}$: 事件从目标元素开始沿着DOM树向上传播.\n\n#### Case\n```html\n<div id=\"parent\">\n  parent\n  <div id=\"child\">child</div>\n</div>\n```\n```js\nconst parent = document.querySelector('#parent');\nconst child = document.querySelector('#child');\n\nparent.addEventListener('click', () => {\n    console.log('父元素 - 冒泡阶段');\n});\n\nparent.addEventListener('click', () => {\n    console.log('父元素 - 捕获阶段');\n}, { capture: true });\n\nchild.addEventListener('click', () => {\n    console.log('子元素 - 目标阶段');\n});\n```\n上述的`child`被包裹在`parent`内部.\n- 当点击`parent`时将会显示:\n```bash\n\"父元素 - 捕获阶段\"\n\"父元素 - 冒泡阶段\"\n```\n> 由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;\n\n- 当点击`child`时将会显示:\n```bash\n\"父元素 - 捕获阶段\"\n\"子元素 - 目标阶段\"\n\"父元素 - 冒泡阶段\"\n```\n> `child`是整个事件流的目标元素, 所以触发时机介于二者之间.\n\n#### Notice\n1. 如果将`div`换成`button`, 则点击`child`时可能只会显示 **目标** 阶段的输出.\n> 这是因为, 不同浏览器对于`button`元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段\n\n2.  `event.stopPropagation();`加入该~~咒语~~代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:\n```js\nparent.addEventListener('click', () => {\n    console.log('父元素 - 捕获阶段');\n    event.stopPropagation();\n}, { capture: true });\n```\n> 此时, 点击`parent`时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.\n\n### 可被移除的监听器\n```html\n<table id=\"outside\">\n  <tr>\n    <td id=\"t1\">one</td>\n  </tr>\n  <tr>\n    <td id=\"t2\">two</td>\n  </tr>\n</table>\n```\n```js\n// 为 table 添加可被移除的事件监听器\nconst controller = new AbortController();\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\"click\", modifyText, { signal: controller.signal });\n\n// 改变 t2 内容的函数\nfunction modifyText() {\n  const t2 = document.getElementById(\"t2\");\n  if (t2.firstChild.nodeValue === \"three\") {\n    t2.firstChild.nodeValue = \"two\";\n  } else {\n    t2.firstChild.nodeValue = \"three\";\n    controller.abort(); // 当值变为 \"three\" 后，移除监听器\n  }\n}\n```\n> - `AbortController`是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;\n> - `signal`属性是一个`AbortSignal`对象, 用于控制监听器的移除;\n> - `controller.abort()`方法用于移除监听器;\n> - 当`t2`的内容变为\"three\"时, 移除监听器, 使得`modifyText`函数不再执行. 此后, 点击`t2`不会触发`modifyText`函数.\n\n具体的**构造步骤:**\n1. 创建一个`AbortController`实例: `const controller = new AbortController();`\n2. 在事件监听器内的参数中添加`signal: controller.signal`选项;\n3. 在需要移除监听器的地方调用`controller.abort()`方法;\n\n---\n\n我们也可以直接使用`removeEventListener()`方法来移除事件监听器:\n```js\nremoveEventListener(type, listener);\nremoveEventListener(type, listener, options);\nremoveEventListener(type, listener, useCapture);\n```\n\n\n- Notices:\n  - 如果同一个对象上存在2个事件监听器, 且仅在`useCapture`参数存在差异, 那么需要先后2次调用`removeEventListener()`方法才能完全移除其事件监听器;\n  - 如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;\n  - `type`,`listener`参数必须完全匹配才能移除事件监听器;\n  - 对于`options`参数:\n    - 字段相同: 一定可以移除;\n    - 字段不同: 需要与默认值false匹配才可以移除.\n```js\nelement.addEventListener(\"mousedown\", handleMouseDown, { passive: true });\n\nelement.removeEventListener(\"mousedown\", handleMouseDown, { passive: true }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, { capture: false }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, { capture: true }); // 失败\nelement.removeEventListener(\"mousedown\", handleMouseDown, { passive: false }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, false); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, true); // 失败\n```\n\n---\n**添加与移除**的结合使用:\n```js\nconst body = document.querySelector(\"body\");\nconst clickTarget = document.getElementById(\"click-target\");\nconst mouseOverTarget = document.getElementById(\"mouse-over-target\");\n\nlet toggle = false;\nfunction makeBackgroundYellow() {\n  body.style.backgroundColor = toggle ? \"white\" : \"yellow\";\n\n  toggle = !toggle;\n}\n\nclickTarget.addEventListener(\"click\", makeBackgroundYellow, false);\n\nmouseOverTarget.addEventListener(\"mouseover\", () => {\n  clickTarget.removeEventListener(\"click\", makeBackgroundYellow, false);\n});\n```\n\n\n### 使用匿名函数\n在上述`html`例子下:\n```js\n// 改变 t2 内容的函数\nfunction modifyText(new_text) {\n  const t2 = document.getElementById(\"t2\");\n  t2.firstChild.nodeValue = new_text;\n}\n\n// 用匿名函数为 table 添加事件监听器\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\n  \"click\",\n  function () {\n    modifyText(\"four\");\n  },\n  false,\n);\n```\n通过匿名函数封装代码, 将参数传入函数`modifyText`, 使得函数可以被调用.\n\n### 使用箭头函数\n```js\n// 改变 t2 内容的函数\nfunction modifyText(new_text) {\n  var t2 = document.getElementById(\"t2\");\n  t2.firstChild.nodeValue = new_text;\n}\n\n// 用箭头函数为 table 添加事件监听器\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\n  \"click\",\n  () => {\n    modifyText(\"four\");\n  },\n  false,\n);\n```\n通过`=>{}`形式的箭头函数简化代码书写.\n\n---\n#### 比较匿名与箭头\n匿名函数与箭头函数在此处的应用基本相同, 但是在`this`的指向上有所不同:\n- 匿名函数与其他普通的JS函数:`this`指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为`undefined`);\n```js\nfunction sayHello() {\n  console.log(this); // 在非严格模式下，this 指向 window\n}\nsayHello();\n```\n\n- 箭头函数的`this`继承自外部作用域, 即调用该方法的对象.\n```js\nconst obj = {\n  name: \"ZJU\",\n  greet: function () {\n    console.log(this.name); // this 指向 obj\n  },\n};\nobj.greet(); // 输出：ZJU\n```\n\n- e.g.\n```js\nconst obj = {\n  name: \"ZJU\",\n  getNameWithAnonymous: function () {\n    return function () {\n      console.log(this.name);\n    };\n  },\n  getNameWithArrow: function () {\n    return () => {\n      console.log(this.name);\n    };\n  },\n};\n\nconst anonymousFn = obj.getNameWithAnonymous();\nanonymousFn(); // 输出：undefined\n\nconst arrowFn = obj.getNameWithArrow();\narrowFn(); // 输出：ZJU\n```\n> 进一步完善.\n\n### 事件对象\n$\\underline{事件对象}$ 在事件处理函数的内部, 以固定指定名称出现的参数, 例如`event`,`e`,`evt`. 它被自动传递给事件处理函数，以提供额外的功能和信息。\n\n`e.target`始终是对 **事件刚刚发生的元素** 的引用\n\n## 表达式和运算符\n### new()\n$\\underline{new}$ 用来创建对象实例的一个关键字. \n- 作用: **调用** 一个 构造函数, 并返回一个由该构造函数创建的对象实例.\n#### 语法\n```js\nnew constructor\nnew constructor()\nnew constructor(arg1)\nnew constructor(arg1, arg2)\nnew constructor(arg1, arg2, /* …, */ argN)\n```\n1. 如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即`new foo` 等价于 `new foo()`;\n2. 构造函数内部的`this`将被绑定到新建的对象实例上;\n\n- e.g. \n```js\nfunction Car(color, brand) {\n  this.color = color;   // 将 color 赋值给新对象\n  this.brand = brand;   // 将 brand 赋值给新对象\n}\n\nconst myCar = new Car(\"red\", \"Toyota\");\n\nconsole.log(myCar.color); // 输出 \"red\"\nconsole.log(myCar.brand); // 输出 \"Toyota\"\n```\n\n使用`new()`的**步骤**:\n 1. 定义构造函数;\n 2. 使用`new()`并传入构造函数的参数;\n 3. 将返回的对象实例赋值给一个变量;\n\n#### 新增属性\n- 为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:\n```js\ncar1.color = \"black\" //为car1新增color属性\n```\n<br>\n\n- 添加共享属性到构造函数中的`prototype`:\n```js\nfunction Car() {}\ncar1 = new Car();\ncar2 = new Car();\n\nconsole.log(car1.color); // undefined\n\nCar.prototype.color = \"原色\";\nconsole.log(car1.color); // '原色'\n\ncar1.color = \"黑色\";\nconsole.log(car1.color); // '黑色'\n\nconsole.log(Object.getPrototypeOf(car1).color); // '原色'\nconsole.log(Object.getPrototypeOf(car2).color); // '原色'\nconsole.log(car1.color); // '黑色'\nconsole.log(car2.color); // '原色'\n```\n> - 此处的构造函数名为`Car`, 因此通过`Car.prototype`可以访问到构造函数的原型对象;\n> - `getPrototypeOf` 表示获取对象的**原型对象**, 因此此处均为最初定义的 **原色**.\n\n#### new.target\n函数通过`new.target`属性可以判断是否通过`new`关键字调用, 即构造.\n- 如果函数是正常调用, 则返回`undefined`;\n- 如果函数是通过`new`调用, 返回被调用的构造函数.\n\n- e.g.\n```js\nfunction Car(color) {\n  if (!new.target) {\n    // 以函数的形式被调用。\n    return `${color}车`;\n  }\n  // 通过 new 被调用。\n  this.color = color;\n}\n\nconst a = Car(\"红\"); // a 是“红车”\nconst b = new Car(\"红\"); // b 是 `Car { color: \"红\" }`\n```\n\n#### 对象类型与实例\n$\\underline{对象类型}$ 通过构造函数可以创建一个对象类型:\n```js\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\n```\n\n$\\underline{对象实例}$ 通过使用`new()`方法, 由对象类型构造一个对象实例:\n```js\nconst myCar = new Car(\"鹰牌\", \"Talon TSi\", 1993);\n```\n\n#### 类与new\n在JS当中, 类 **必须** 通过`new`调用.\n> 可以优先阅读[类相关的知识](#类)\n\n- e.g. \n```js\nclass Animal {\n  //构造函数\n  constructor(name) {\n    this.name = name;\n  }\n  //实例方法\n  greet() {\n    console.log(`你好，我的名字是${this.name}`);\n  }\n}\n```\n对于上述的类, 必须使用如下的调用方式:\n```js\nconst animal = new Animal(\"Dog\"); // 正常\n```\n而下面这样类似于普通函数的调用方式会抛出错误:\n```js\nAnimal(\"Cat\"); // TypeError:  Class constructor Animal cannot be invoked without 'new'\n```\n<br>\n\n在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:\n```js\nanimal.greet(); // 输出 \"你好，我的名字是Dog\"\n```\n\n---\n\n下面给出与普通函数的区别:\n```js\nfunction Car(model) {\n  this.model = model;\n}\n\nconst car = new Car(\"Toyota\"); // 正常\nCar(\"Honda\"); // 不抛出错误，但 this 会指向全局对象.\nconst anotherCar = Car(\"cat\"); //此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.\n```\n总结:\n- 以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;\n- 如果以new方法构造得到对象实例, 依旧正常.\n\n---\n\n# 补充\n## 默认行为\n$\\underline{默认行为}$ 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.\n\n- 比如存在以下的默认行为:\n  - 滚动事件：触摸屏上滑动手指，页面会滚动;\n  - 拖拽文件到浏览器：浏览器会尝试加载文件;\n  - 点击链接 `(<a href=\"...\">)`：跳转到指定的 URL;\n\n$\\underline{阻止默认行为}$ 使用 `event.preventDefault()` 方法可以阻止事件的默认行为.\n\n- e.g: 阻止链接跳转\n```js\ndocument.querySelector('a').addEventListener('click', function(event) {\n    event.preventDefault(); // 阻止点击链接时的默认行为\n    console.log('链接被点击，但没有跳转');\n});\n```\n\n- 作用:\n  - 通过阻止默认行为, 可以实现自定义逻辑.\n\n## this\n\n- `this`可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;\n- `this` 指向的是**当前函数的调用者**，而不是函数内部定义的变量.\n\n<br>\n\n- e.g.\n```js\nconst obj = {\n    a: \"a in the obj\",\n    b: \"b in the obj\",\n    f: function() {\n        const b = \"b in the function\"; // 函数作用域\n        console.log(this.b); // 访问 this.b\n    }\n};\n\nconst b = \"b outside of the func\";\n\nobj.f();\n```\n> 此处的`f`\n\n### 函数上下文中的this\n- `this`参数的值取决于函数**如何**被调用, 而不是函数如何被定义.\n```js\n// 对象可以作为第一个参数传递给 'call' 或 'apply'，\n// 并且 'this' 将被绑定到它。\nconst obj = { a: \"Custom\" };\n\n// 使用 var 声明的变量成为 'globalThis' 的属性。\nvar a = \"Global\";\n\nfunction whatsThis() {\n  return this.a; // 'this' 取决于函数如何被调用\n}\n\nwhatsThis(); // 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'\nobj.whatsThis = whatsThis;\nobj.whatsThis(); // 'Custom'; 'this' 参数被绑定到 obj\n```\n1. 同样是调用函数`whatsThis()`, 但是`this`参数被绑定到不同的对象上, 导致返回值不同;\n2. 在非严格模式下, `this`参数默认指向`globalThis`, 即全局对象;\n3. 对于典型函数, `this`指向函数访问的对象;\n\n- e.g. \n```js\nconst obj = {\n    b: \"b in the obj\",\n    f: function() {\n        const b = \"b in the function\"; // 函数作用域\n        console.log(this.b); // 访问 this.b\n    }\n};\n\nconst b = \"b outside of the func\";\n\nobj.f();\n```\n> 此处`f`作为`obj`对象的方法被调用, 因此普通函数的`this`指向`obj`.\n\n- e.g. 直接调用的普通函数`this`指向全局:\n```js\nconst obj = {\n    a: \"a in the obj\",\n    f: function() {\n        const funcA = function () { return this.a }; // 普通函数，this 由调用方式决定\n        console.log(funcA()); // 访问 this.a\n    }\n};\n\nvar a = \"a in the global\";\nobj.f(); // \"a in the global\"\n```\n> - 此处的`funcA`并没有类似于作为对象的属性调用(`obj.funcA()`), 因此其`this`指向全局作用域(`window`), 输出`undefined`, 而是直接调用的形式, 因此其`this`指向全局作用域.\n\n\n\n\n\n### 对this传值\n使用`call()`以及`apply()`方法可以将`this`绑定到其他对象上.\n#### call()\n- 形式: `func.call(thisArg, arg1, arg2, ...)`\n- e.g:\n```js\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// 第一个参数被绑定到隐式的 'this' 参数；\n// 剩余的参数被绑定到命名参数。\nadd.call(o, 5, 7); // 16\n```\n\n#### apply()\n- 形式: `func.apply(thisArg, [argsArray])`\n- e.g:\n```js\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// 第一个参数被绑定到隐式的 'this' 参数；\n// 第二个参数是一个数组，其成员被绑定到命名参数。\nadd.apply(o, [10, 20]); // 34\n```\n\n#### bind()\n- 形式: `f.bind(someObject)`;\n- **作用**: \n  - 创建一个新的函数(需要重新赋值), 具有与`f`相同的函数体和作用域;\n  - 新函数的`this`被 **永久地** 绑定到`someObject`, 不随调用方式的变化而变化.\n- **限制**: \n  - `bind`无法多次生效. 即对函数f`bind`得到的g, 无法继续用`bind`得到期望的h;\n- e.g. 多次`bind`:\n```js\nfunction f() {\n  return this.a;\n}\n\nconst g = f.bind({ b: \"azerty\" });\nconsole.log(g()); // undefined\n\nconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！\nconsole.log(h()); // undefined\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37 37 undefined undefined\n```\n> - 由于`bind`只能对一个原始函数作用, 因此由f得到的g无法继续由`bind`绑定`this`得到期望的h, 此处h的`this`依旧是`{b: \"azerty\"}`, 因此在输出对象`a`时显示`undefined`;\n> - `o.f()`的调用是普通函数的调用, 因此其`this`继承自对象`o`, 输出`37`;\n\n- e.g. 对象\n```js\nfunction f() {\n  return this.a + \" \" + this.c;\n}\n\nconst g = f.bind({ b: \"azerty\" , c:\"ccc\"});\nconsole.log(g()); // \"undefined ccc\"\n\nconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！\nconsole.log(h()); // \"undefined ccc\"\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty\n```\n> - `bind`绑定的`this`是永久覆盖, 而非简单叠加;\n> - 由于`bind`绑定的`this`不随者调用方式的变化而变化, 因此即使处于对象`o`当中, `g`,`h`依旧不会输出`o`中的`a`.\n\n### 箭头函数中的this\n\n\n使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。\n\n\n普通函数:\n```js\nconst a = \"a in the global\";\nconst foo = function () {return this.a};\n\nconst obj = {\n a: \"a in the obj\",\n f: foo\n};\n\nconsole.log(obj.f()); // \"a in the obj\"\n```\n\n`call()`、 `apply()`、 `bind()` 无法改变箭头函数的`this`(但是call与apply的其他参数可以正常传递:\n```js\nconst foo = ()=> this.a;\n\nconst obj = {\n a: \"a in the obj\",\n f: foo.bind({a:\"a in the bind\"}) // 显式绑定 this 到 obj, 但是无法生效\n};\n\nconsole.log(obj.f()); // undefined\n\n```\n> 换成普通函数则输出`a in the obj`.\n\n\n- 全局作用域\n```js\nvar a = \"a in the global\";\nconst foo1 = () => this.a;\n\nconst obj = {\n\ta: \"a in the obj\",\n\tf: ()=> a\n};\n\nconsole.log(obj.f());\n```\n\n## 作用域\n$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. \n- 全局作用域: 脚本模式运行所有代码的默认作用域;\n- 模块作用域: 模块模式中运行代码的作用域;\n- 函数作用域: 由函数创建的作用域\n- 块级作用域: 由`let`或`const`声明的变量的作用域.(对于`var`无效);\n\n```js\n{\n  var x = 1;\n}\nconsole.log(x); // 1\n\n{\n  const x = 1;\n}\nconsole.log(x); // undefined\n```\n\nNotices:\n- 对象本身并不会创建作用域, 只是一个键值对的集合;\n- 箭头函数也不会创建自己的作用域, 而是 **继承** 外层作用域中的`this`;\n\n### 变量与作用域\n- `var`在全局作用域中声明时会成为 **全局对象** (`window`或`global`)的属性;\n- `let`和`const`即使在全局作用域中声明, 也不会成为全局对象的属性;\n```js\nvar a = \"1\";\nlet b = \"2\";\n\nwindow.a; // \"1\"\nwindow.b; // undefined\n```\n> 因此, 建议在全局作用域中不要使用`var`声明变量, 而使用`let`或`const`声明变量. 从而避免导致意外的覆盖和冲突.\n\n\n### 函数与作用域\n#### 普通函数\n普通函数和匿名函数的作用域继承自其定义时的作用域.\n```js\nconst obj = {\n    a: \"a in the obj\",\n    insideObj: {\n        g: function() {\n            return this.a; // 普通函数，this 动态绑定到 insideObj\n        }\n    },\n    f: function() {\n        return this.a; // 普通函数，this 动态绑定到 obj\n    }\n};\n\nconsole.log(obj.f());        // \"a in the obj\"\nconsole.log(obj.insideObj.g()); // undefined，因为 insideObj 中没有 a\n```\n\n#### 箭头函数\ne.g. **箭头函数继承外层作用域**:\n```js\nvar a = \"a in the global\";\n\nconst obj = {\n    a: \"a in the obj\",\n    insideObj: {\n        g: () => this.a\n    },\n    f: () => this.a\n};\n\nconsole.log(obj.f());        // \"a in the global\"\nconsole.log(obj.insideObj.g()); //\"a in the global\"\n```\n由于对象不会创建作用域, 因此此处的箭头函数的`this`继承了外层作用域(window)的`this`, 且`var`创建的变量存在于全局作用域中.\n\n## 语法糖\n$\\underline{语法糖}$ 一种让代码更简洁、更易读的语法形式.\n- 本质上没有增加语言的功能, 而是对已有功能的 **包装** 或者优化;\n- **可读性提升**: ~~让代码更填~~ 使得代码更加容易理解和书写;\n- **底层实现**: 实质上依旧用基础的语法实现.\n\n### 类\n类 `class` 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承`prototype`的封装.\n\n使用`class`的写法:\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nconst person = new Person(\"Alice\");\nperson.greet(); // 输出：Hello, my name is Alice\n```\n\n等价的原型写法:\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.greet(); // 输出：Hello, my name is Alice\n```\n\n### 箭头函数\n箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.\n\n- e.g.\n```js\n// 使用箭头函数\nconst add = (a, b) => a + b;\n\n// 等价的普通函数\nconst add = function add(a, b) {\n  return a + b;\n}\n```\n\n### 结构赋值\n$\\underline{结构赋值}$ 手动提取**对象**属性的语法糖.\n\n- 使用结构赋值:\n```js\nconst person = {name:\"Zhuo\", gender:\"male\"};\n\nconst {name, gender} = person;\n```\n\n- 等价的原型写法:\n```js\nconst person = {name:\"Zhuo\", gender:\"male\"};\n\nconst name = person.name;\nconst gender = person.gender;\n```\n\n#### 赋值规则\n结构赋值时, 基于 **属性名匹配** 而非顺序. \n因此, 对象结构的`{}`内部属性必须和 **对象的属性名** 相对应.\n\n**错误**的示例:\n```js\nconst person = { name: \"Alice\", age: 25 };\nconst { a, b } = person;\n\nconsole.log(a); // 输出：undefined\nconsole.log(b); // 输出：undefined\n```\n\n**重命名属性**的写法:\n```js\nconst person = { name: \"Alice\", age: 25 };\nconst { name: a, age: b } = person;\n\nconsole.log(a); // 输出：Alice\nconsole.log(b); // 输出：25\n```\n\n**手动赋值**: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:\n```js\nconst person = { name: \"Alice\" };\nconst { name, age = 30 } = person;\n\nconsole.log(name); // 输出：Alice\nconsole.log(age);  // 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）\n```\n#### 数组的结构赋值\n上述讨论的结构赋值都是对 **对象** 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— **基于顺序**赋值:\n```js\nconst arr = [\"Alice\", 25];\nconst [a, b] = arr;\n\nconsole.log(a); // 输出：Alice\nconsole.log(b); // 输出：25\n```\n","source":"_posts/编程语言/JavaScript.md","raw":"---\ntitle: JavaScript\ndate: 2025-01-09 14:06:30\ntags: \n- 前端\n- JS\ncategories: 学习笔记\nexcerpt: 一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「料理的加护」下, 尽可能将JS处理得更加可口一些)\nmathjax: true\nindex_img: /img/料理的加护.jpg\n---\n> JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「**料理的加护**」下, 尽可能将JS处理得更加**可口**一些)\n<img src=\"/img/料理的加护.jpg\" width = \"35%\">\n\n# 创建JS代码块\n## 变量\n### `var` or `let`?\n`var`先于`let`的产生, 后者是现代版本的JS中新的关键字.\n\n使用`var`, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是`let`并不适用.\n```js\nmyName = \"Chris\";\n\nfunction logName() {\n  console.log(myName);\n}\n\nlogName(); //输出\"Chris\"\n\nvar myName = \"Aniya\";\nlogName(); //输出\"Aniya\"\n```\n\n除此之外, 可以使用`var`前后声明相同的变量, 这并不会报错:\n```js\nvar myName = \"Chris\";\nvar myName = \"Bob\";\n```\n\n而`let`只能声明一次:\n```js\nlet myName = \"Chris\";\nmyName = \"Bob\";\n```\n\n因此, 在代码编写中应尽量**多使用**`let`而非`var`, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.\n\n\n### 变量命名的规则\n与C语言类似, 建议以 **字母、数字、下划线** 组成的标识符来命名变量.\n- 不可用`_`开头, 因为可能被JS设计为特殊的含义;\n- 不可用数字开头, 否则引发错误;\n- 大小写敏感;\n- 建议采用 **小写驼峰命名法** ,即小写整个命名的第一个字母然后大写剩下单词的首字符;\n- 避免使用保留字, 比如`var`,`let`,`for`等.\n\n### 变量类型\n\n```js\nlet myAge = 20 ;// 数字\nlet dolphinGoodbye = \"So long and thanks for all the fish\"; // 字符串\nlet test = 6 < 3; //boolean\n\n//数组类型\nlet myNameArray = [\"Chris\", \"Bob\", \"Jim\"];\nlet myNumberArray = [10, 15, 40];\n\n//对象类型\nlet dog = { name: \"Spot\", breed: \"Dalmatian\" };\n\n```\n> 对象类型的访问与结构体相似, `dog.name;`\n\n在上面的几种变量类型中, 我们都采用`let`关键字声明变量, 这体现了JS是一种 **动态类型语言** ,即无需指定变量包含的数据类型.\n\n同时, 这也意味着我们可以像`python`一样对同一个变量先后赋值不同类型的值:\n```js\nlet myNumber = \"500\";\ntypeof myNumber;\n// 输出 'string'\n\nmyNumber = 500; \ntypeof myNumber;\n//输出'number'\n```\n\n\n## 函数\n- $\\underline{提升}$ 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.\n```js\nexampleFunction();\n\nfunction exampleFunction() {\n  console.log(\"函数内\");\n  console.log(x);\n}\n```\n> 由于 **提升** 的存在, 上述的函数调用不会出错.\n\n\n### 默认参数\n在编写函数时, 可以通过在参数名称后添加`=`, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。\n```js\nfunction greeding(name = \"my friend\") {\n    console.log(`Hello, ${name}!`);\n}\nhello(); //Hello, my friend!\nhello(\"world\"); //Hello, world!\n```\n\n<br>\n\n事件处理函数的默认接受值是`event`:\n```html\n<button>\nonclick\n</button>\n\n<p>\nnothing here\n</p>\n\n<script>\nbtn = document.querySelector(\"button\")\npara = document.querySelector(\"p\")\n\nbtn.onclick = click;\n\nfunction click(string){\n  console.log(\"clicked!\")\n  para.textContent = string;\n}\n</script>\n```\n1. 上述的`btn`在点击之后调用函数`click`, 该函数需要一个参数`string`, 由于`btn.onclick = click;`的绑定方式, 我们无法指定传参的值, 因此点击之后的`para`的内容显示为: `[object PointerEvent]`;\n2. `textContent`是属性而非方法, 因此采用赋值实现;\n\n\n```js\nbtn.onclick = function click(string) {\n  console.log(\"clicked!\")\n  para.textContent = \"You have clicked the button!\";\n}\n```\n> 将上述的绑定方式如此改写, 可以在`btn`外对`string`进行赋值, 然后点击按钮可以传入指定参数供后续处理.\n\n\n\n### 箭头函数\n在了解箭头函数的作用之前, 需要先介绍 $\\underline{匿名函数}$:\n```js\nfunction myFunction() {\n  alert(\"你好\");\n}\n\n// 匿名函数\n(function () {\n  alert(\"你好\");\n});\n```\n> 正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.\n\n如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:\n```js\nfunction logKey(event) {\n  console.log(`You pressed \"${event.key}\".`);\n}\n\ntextBox.addEventListener(\"keydown\", logKey);\n```\n这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:\n```js\ntextBox.addEventListener(\"keydown\", function (event) {\n  console.log(`You pressed \"${event.key}\".`);\n});\n```\n>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.\n\n而**箭头函数**则是在此情况下更简洁的函数定义方式:\n```js\ntextBox.addEventListener(\"keydown\", (event) => {\n  console.log(`You pressed \"${event.key}\".`);\n});\n\n//如果函数只接受一个参数, 也可以省略参数周围的括号\ntextBox.addEventListener(\"keydown\", event => {\n  console.log(`You pressed \"${event.key}\".`);\n});\n```\n\n如果只包含一行的`return`,则可以忽略`{}`和`return`关键字:\n```js\nconst originals = [1, 2, 3];\n\nconst doubled = originals.map(item => item * 2);\n\nconsole.log(doubled); // [2, 4, 6]\n```\n> `item => item * 2`等价于:\n```js\nfunction doubleItem(item) {\n  return item * 2;\n}\n```\n\n#### 一个实例\n```html\n<input id=\"textBox\" type=\"text\" />\n<div id=\"output\"></div>\n```\n```js\nconst textBox = document.querySelector(\"#textBox\");\nconst output = document.querySelector(\"#output\");\n\ntextBox.addEventListener(\"keydown\", (event) => {\n  output.textContent = `You pressed \"${event.key}\".`;\n});\n```\n通过监听输入框的keydown事件, 输出按下的键盘按键.\n\n### 函数作用域和冲突\n$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. \n- 全局作用域: 脚本模式运行所有代码的默认作用域;\n- 模块作用域: 模块模式中运行代码的作用域;\n- 函数作用域: 由函数创建的作用域\n\n和C语言相似, 在函数外部`let`定义的变量, 以及`const`定义的常量可以在函数内部访问.\n\n如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:\n```html\n<!-- Excerpt from my HTML -->\n<script src=\"first.js\"></script>\n<script src=\"second.js\"></script>\n<script>\n  greeting();\n</script>\n```\n> 如果两个JS文件都定义了`greeting`函数, 则只有第一个文件中的函数才会被调用.\n\n## 数据类型\n### 数字和操作符\n大部分与C语言相同, 概括需要注意的差异:\n- JS当中只有一种数字类型 -- `number`, 对于整型或者浮点数的初始化得到的量, 由`typeof`均得到`number`;\n- 算术运算符: 求幂为`**`;\n- 常量无法使用自增或自减,~~好像也是C语言的 忘了~~\n- `===`表示严格等于, `!==`表示不等于;\n> 同时存在`==`和`!=`来判断是否相等, 但是它们只是测试 **值** 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用`===`和`!==`来避免类型不一致的错误.\n\n### 字符串\n创建字符串\n```js\nlet myString = \"A string\";\nconst constString = myString;\nconsole.log(constString);\n//A string\n``` \n可以使用单引号,双引号和**反引号**来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:\n```js\nconst single = '单引号';\nconst double = \"双引号\";\nconst backtick = `反引号`;\n```\n\n反引号包裹的字符串称为$\\underline{模板字符串}$, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:\n- 可以嵌入 **JavaScript**;\n- 可以声明**多行**的模板字面量.\n\n#### 字符串的拼接\n字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 $\\underline{串联法}$:\n```js\nconst name = \"克里斯\";\nconst greeting = `你好，${name}`;\nconsole.log(greeting); // \"你好，克里斯\"\n```\n> 在模板字面量中用`${}`包装JS的变量或者表达式.\n\n\n```js\nconst one = \"你好，\";\nconst two = \"请问最近如何？\";\nconst joined = `${one}${two}`;\nconsole.log(joined); // \"你好，请问最近如何？\"\n```\n> 连接2个变量.\n\n```js\nconst song = \"青花瓷\";\nconst score = 9;\nconst highestScore = 10;\nconst output = `我喜欢歌曲《${song}》。我给它打了 ${\n  (score / highestScore) * 100\n} 分。`;\nconsole.log(output); // \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"\n```\n> 在模板字面量的`${}`内部包含表达式.\n\n<br>\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\n```js\nconst greeting = \"你好\";\nconst name = \"克里斯\";\nconsole.log(greeting + \"，\" + name); // \"你好，克里斯\"\n```\n\n#### 多行字符串\n模板字符串会**保留**源代码中的换行符，因此可以编写跨越多行的字符串:\n```js\nconst newline = `终于有一天，\n你知道了必须做的事情，而且开始……`;\nconsole.log(newline);\n\n/*\n终于有一天，\n你知道了必须做的事情，而且开始……\n*/\n```\n\n如果希望用普通的字符串得到等效的输出, 必须在字符串中包含`\\n`,而非直接跨行:\n```js\nconst newline = \"终于有一天，\\n你知道了必须做的事情，而且开始……\";\nconsole.log(newline);\n\n/*\n终于有一天，\n你知道了必须做的事情，而且开始……\n*/\n```\n\n#### 显示引号\n1. $\\underline{转义}$  通过在符号前加上反斜杠`\\`, 可以转义字符串中的特殊字符,包括字符串中的引号:\n```js\nconst bigmouth = 'I\\'ve got no right to take my place…';\n```\n2. 换用其他字符: 在字面量内用不同于包裹字符串的引号:\n```js\nconst goodQuotes1 = 'She said \"I think so!\"';\nconst goodQuotes2 = `She said \"I'm not going in there!\"`;\n```\n\n\n#### 常用方法\n对于字符串对象实例,其常用的方法:\n- `.length`: 获取字符串的长度;\n- `[]`: 返回字符串中对应索引的字符, 索引同样从`0`开始;\n- `.indexOf(\"\")`: 查找子字符串\n  - **input**: 希望查找的子字符串;\n  - **output**: 子字符串开始的下标(如果不存在则返回`-1`);\n- `.slice(indedxStart, indexEnd)`: 截取字符串\n  - **input**: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;\n  - **output**: 截取的子字符串;\n\n更多的`slice`知识:\n1. $\\underline{标准化负值}$ 如果索引是个负数, 取`index+str.length`进行标准化;\n2. 如果`indexStart`大于`str.length`, 返回空字符串;\n3. 如果标准化负值之后, `indexStart`大于`indexEnd`, 也返回空字符串;\n \n- `.toLowerCase()` & `.toUpperCase()`: 转换字符串中的所有字符为小写或大写;\n- `.replace(original, new)`: 替换字符串中`original`子字符串为`new`;\n> 此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.\n\n#### Cases\n利用 **indexOf** 和 **slice** 方法, 获取新字符串:\n- **input**: `\"str3\"`三位长字符串+`\"...\"`(无关字符串)+`\";\"`+`strLast`(剩余字符串);\n- **output**: `\"str3\"+\";\"+strLast`\n\n```js\nvar stations = ['MAN675847583748sjt567654;Manchester Piccadilly',\n                'GNF576746573fhdg4737dh4;Greenfield',\n                'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street',\n                'SYB4f65hf75f736463;Stalybridge',\n                'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'];\n\nfor(var i = 0; i < stations.length; i++){\n    var input = stations[i];\n    var str3 = input.slice(0,3);\n    var strLast = input.slice(input.indexOf(\";\")+1); //indexOf获取;位置\n    var output = str3 + \";\" + strLast;\n}\n```\n\n---\n\n通过 **indexOf** 根据子字符串筛选字符串数组:\n- **input**: 可能包含 *Christmas* 的字符串数组;\n- **output**: 包含 *Christmas* 的字符串数组;\n\n```js\nvar list = document.querySelector('.output ul');\nlist.innerHTML = '';\nvar greetings = ['Happy Birthday!',\n                 'Merry Christmas my love',\n                 'A happy Christmas to all the family',\n                 'You\\'re all I want for Christmas',\n                 'Get well soon'];\n\nfor(var i = 0; i < greetings.length; i++) {\n  var input = greetings[i];\n  if(greetings[i].indexOf('Christmas') !== -1) {\n    var result = input;\n    var listItem = document.createElement('li');\n    listItem.textContent = result;\n    list.appendChild(listItem);\n  }\n}\n```\n\n### 数字与字符串\n#### 相互转换\n非常神奇, 在JS当中, 数字和字符串可以直接通过函数`Number()`和`String()`进行转换, 与C语言不同.\n```js\nconst myString = \"123\";\nconst myNum = Number(myString);\nconsole.log(typeof myNum);\n// number\nconsole.log(myNum);\n// 123\n```\n\n```js\nconst myNum2 = 123;\nconst myString2 = String(myNum2);\nconsole.log(typeof myString2);\n// string\nconsole.log(myString2);\n// \"123\"\n```\n> 对于浮点数同样成立.\n\n#### 前后拼接\n使用`+`将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:\n```js\nconst name = \"Front \";\nconst number = 242;\nconst combine = name + number;\n\nconsole.log(combine); //Front 242\n\nconsole.log(typeof(combine));  //string\n```\n\n### 数组\n1. 存储任意类型元素--字符串，数字，对象，变量，**另一个数组**;\n2. 可以 **混合** 元素类型:\n```js\nlet random = [\"tree\", 795, [0, 1, 2]];\n```\n3. 像访问字符串一样, 利用索引访问数组元素;\n4. $\\underline{多维数组}$ 包含数组的数组结构称为~\n\n#### split()\n- 作用: 将一个字符串根据给定的字符分隔为字符串数组;\n```js\nlet myData = \"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\";\nlet myArray = myData.split(\",\");\nconsole.log(myArray);\n // [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]\n```\n\n#### join()\n`split`的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:\n```js\nlet myNewString = myArray.join(\",\");\nmyNewString;\n```\n\n#### toString()\n与`join`方法相似, 但是无法自定义分隔符, 默认为`,`:\n```js\nlet dogNames = [\"Rocket\", \"Flash\", \"Bella\", \"Slugger\"];\ndogNames.toString(); //Rocket,Flash,Bella,Slugger\n```\n\n#### push & pop\n`push()`方法可以将1或多个元素添加到数组的 **末尾**:\n1. 将会直接改写原来的数组,不需要重新赋值;\n2. 该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);\n```js\nlet myArray = [1, 2, 3];\nlet newLength = myArray.push(4, 5,\"string\");\nconsole.log(myArray); // [1, 2, 3, 4, 5, \"string\"]\nconsole.log(newLength); // 6\n```\n\n使用`.pop()`从数组中删除最后一个元素:\n```js\nmyArray.pop(); //\"string\"\nconsole.log(myArray); // [1, 2, 3, 4, 5]\n```\n1. 方法调用返回值就是删除的元素本身;\n2. 直接对原始数组操作并赋值, 不需要另外的赋值操作;\n\n> shift & unshift:\n> 在功能上分别与`push`和`pop`相同, 但是作用于数组的开始位置.\n\n## 条件语句\nJS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:\n### 天气预报\n```html\n<label for=\"weather\">选择今天的天气：</label\n><select id=\"weather\">\n  <option value=\"\">--作出选择--</option>\n  <option value=\"sunny\">晴天</option>\n  <option value=\"rainy\">雨天</option>\n  <option value=\"snowing\">雪天</option>\n  <option value=\"overcast\">阴天</option>\n</select>\n\n<p></p>\n```\n> `lable`当中的`for`标签与`select`标签的`id`属性对应, 用于关联两个标签.\n\n```js\nconst select = document.querySelector(\"select\");\nconst para = document.querySelector(\"p\");\n\nselect.addEventListener(\"change\", setWeather);\n\nfunction setWeather() {\n  const choice = select.value;\n\n  switch (choice) {\n    case \"sunny\":\n      para.textContent = \"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\";\n      break;\n    case \"rainy\":\n      para.textContent = \"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\";\n      break;\n    case \"snowing\":\n      para.textContent =\n        \"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\";\n      break;\n    case \"overcast\":\n      para.textContent =\n        \"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\";\n      break;\n    default:\n      para.textContent = \"\";\n  }\n}\n```\n> 1. 通过`querySelector`方法获取`select`和`p`标签;\n> 2. 然后为`select`标签添加事件监听器, 当内容改变时触发 **change** 事件, 同时调用`setWeather`函数;\n> 3. 进而通过 **switch** 语句处理不同天气的情况, 并设置相应的文字内容;\n> 在线网页示例:[simple-switch](https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html)\n\n\n## 事件介绍\n什么是$\\underline{事件}$? \n- 用户选择、点击或者光标悬停在某一元素;\n- 用户在键盘中按下某个按键;\n- 网页结束加载;\n- ...\n\n$\\underline{事件处理器}$ 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.\n\n### 处理点击事件\n以点击事件为例, 介绍html与js如何进行事件处理的交互:\n```html\n<button> 改变颜色 </button>\n```\n```js\nconst btn = document.querySelector(\"button\");\n\nfunction random(number){\n  return Math.floor(Math.random()*(number+1));\n  \n}\n\nbtn.addEventListener(\"click\", ()=>{\n  const rndCol = `rgb(${random(255)},${random(255)},${random(255)})`;\n  document.body.style.backgroundColor = rndCol;\n})\n```\n1. `Math.random()`方法生成一个介于[0,1)之间的随机数;\n2. `*(number+1)`之后利用向下取整的方法`Math.floor()`将其转换为整数, 范围为[0,number];\n> 假如输入的number为`4`, 则`random(4)`的结果可能为`0`, `1`, `2`, `3`, `4`中的一个;\n> 假设输入的number为`3.6`, 则输出的结果还是0~4中的整数.\n3. ``rndCol = `rgb(${random(255)},${random(255)},${random(255)})`` 采用的是在$\\underline{模板字符串}$内部使用`${}`调用函数变量的方法.\n\n### addEventListener()\n`adEventListener`方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.\n\n通过`EventTarget.adddEventListener()`的方法, 将指定的监听器注册到对象上, 具体的语法如下:\n```js\naddEventListener(type, listener);\naddEventListener(type, listener, options);\naddEventListener(type, listener, useCapture);\n```\n- `type`: 事件类型, 如`click`, `mouseover`, `mouseout`, `keydown`, `keyup`等;\n- `listener`: 事件处理函数, 该函数将在事件发生时被调用;\n  - 包括 **回调函数** 以及 实现了 **EventListener 接口的对象**;\n- `options`: 可选参数, 用于配置事件监听器的行为;\n> 可以为单个事件添加多个事件监听器.\n\n\n#### listener\n$\\underline{回调函数}$ 简单来说, ~指的是当某个事件发生时被调用的一段代码.\n- 是一个函数, 但是只有等到特定的事件发生时才会执行.\n\n实现了 EventListener 接口的对象:\n- **特点**: 以对象作为listener, 对象中具有名为`handleEvent()`的方法;\n- **作用**: \n  - 将事件处理封装到一个对象当中, 可以更好地组织代码;\n  - 便于在对象中保存更多的状态信息;\n```js\nconst listenerObject = {\n    count: 0,\n    handleEvent(event) {\n        this.count++;\n        console.log(`事件类型是：${event.type}，已触发 ${this.count} 次`);\n    }\n};\n\nconst button = document.querySelector('button');\nbutton.addEventListener('click', listenerObject);\n```\n\n#### options\n一个指定有关 listener 属性的可选参数对象.\n##### Capture\n- 含义:\n  - 一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;\n  - 默认为false, 表示只有在冒泡阶段才触发.\n\n- 区别:\n  - `capture`和`useCapture`实际上指的都是 **监听器是否在捕获阶段触发** 的布尔值.\n> 捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.\n  - 后来DOM的规范更新时引入了`options`参数, 此后`capture`取代了`useCapture`的作用.\n  - 如果`addEventListener`的第三个参数不指定对象, 只有布尔值, 那么默认是在设置`useCapture`\n\n> 可以先查看[事件传播的阶段](#事件传播的阶段)来辅助理解不同的阶段.\n\n##### Once\n- 含义:\n  - 一个布尔值，表示 listener 在添加之后最多只调用一次;\n  - 默认为false, 表示可以多次调用.\n- e.g.\n```js\nchild.addEventListener('click', () => {\n    console.log('子元素 - 目标阶段');\n},{once: true});\n```\n> `once`属性被设置为`true`, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.\n\n##### Passive\n- 含义:\n  - 一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();\n\n- 作用:\n  - 明确不会在`listener`中不会调用`preventDefault()`方法, 即不会阻止浏览器的[默认行为](#默认行为);\n  - 此时, 浏览器可以直接渲染默认行为的结果, 无需等待`listener`的执行与默认行为的检查, 从而提高了性能.\n- Notice:\n  - 如果设置`passive`为`true`, 则`listener`当中不可出现`preventDefault()`方法, 否则会报错.\n\ne.g.\n```js\ndocument.addEventListener('wheel',()=>{\n\tevent.preventDefault();\n  console.log(\"scrolling\");\n},{passive: false});\n```\n- `wheel`事件的默认行为是滚动页面;\n- `event.preventDefault();`表示会阻止鼠标滚动带来的页面滚动;\n\n\n```js\ndocument.addEventListener('wheel',()=>{\n  console.log(\"scrolling\");\n},{passive: true});\n```\n> 明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.\n\n```js\ndocument.addEventListener('wheel',()=>{\n  event.preventDefault();\n  console.log(\"scrolling\");\n},{passive: true});\n```\n> `passive`的设置与`listener`内部矛盾, 将会报错.\n\n##### Signal\n用于有条件地移除事件监听器, 具体使用参见[可被移除的监听器](#可被移除的监听器).\n\n### 事件传播的阶段\n1. 捕获阶段 $\\underline{capture\\space phase}$: 事件从根节点开始向目标节点传播;\n> e.g. 点击事件从document开始传播, 经过html,body直到目标元素.\n2. 目标阶段阶段 $\\underline{target\\space phase}$: 事件到达目标元素;\n3. 冒泡阶段 $\\underline{bubble\\space phase}$: 事件从目标元素开始沿着DOM树向上传播.\n\n#### Case\n```html\n<div id=\"parent\">\n  parent\n  <div id=\"child\">child</div>\n</div>\n```\n```js\nconst parent = document.querySelector('#parent');\nconst child = document.querySelector('#child');\n\nparent.addEventListener('click', () => {\n    console.log('父元素 - 冒泡阶段');\n});\n\nparent.addEventListener('click', () => {\n    console.log('父元素 - 捕获阶段');\n}, { capture: true });\n\nchild.addEventListener('click', () => {\n    console.log('子元素 - 目标阶段');\n});\n```\n上述的`child`被包裹在`parent`内部.\n- 当点击`parent`时将会显示:\n```bash\n\"父元素 - 捕获阶段\"\n\"父元素 - 冒泡阶段\"\n```\n> 由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;\n\n- 当点击`child`时将会显示:\n```bash\n\"父元素 - 捕获阶段\"\n\"子元素 - 目标阶段\"\n\"父元素 - 冒泡阶段\"\n```\n> `child`是整个事件流的目标元素, 所以触发时机介于二者之间.\n\n#### Notice\n1. 如果将`div`换成`button`, 则点击`child`时可能只会显示 **目标** 阶段的输出.\n> 这是因为, 不同浏览器对于`button`元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段\n\n2.  `event.stopPropagation();`加入该~~咒语~~代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:\n```js\nparent.addEventListener('click', () => {\n    console.log('父元素 - 捕获阶段');\n    event.stopPropagation();\n}, { capture: true });\n```\n> 此时, 点击`parent`时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.\n\n### 可被移除的监听器\n```html\n<table id=\"outside\">\n  <tr>\n    <td id=\"t1\">one</td>\n  </tr>\n  <tr>\n    <td id=\"t2\">two</td>\n  </tr>\n</table>\n```\n```js\n// 为 table 添加可被移除的事件监听器\nconst controller = new AbortController();\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\"click\", modifyText, { signal: controller.signal });\n\n// 改变 t2 内容的函数\nfunction modifyText() {\n  const t2 = document.getElementById(\"t2\");\n  if (t2.firstChild.nodeValue === \"three\") {\n    t2.firstChild.nodeValue = \"two\";\n  } else {\n    t2.firstChild.nodeValue = \"three\";\n    controller.abort(); // 当值变为 \"three\" 后，移除监听器\n  }\n}\n```\n> - `AbortController`是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;\n> - `signal`属性是一个`AbortSignal`对象, 用于控制监听器的移除;\n> - `controller.abort()`方法用于移除监听器;\n> - 当`t2`的内容变为\"three\"时, 移除监听器, 使得`modifyText`函数不再执行. 此后, 点击`t2`不会触发`modifyText`函数.\n\n具体的**构造步骤:**\n1. 创建一个`AbortController`实例: `const controller = new AbortController();`\n2. 在事件监听器内的参数中添加`signal: controller.signal`选项;\n3. 在需要移除监听器的地方调用`controller.abort()`方法;\n\n---\n\n我们也可以直接使用`removeEventListener()`方法来移除事件监听器:\n```js\nremoveEventListener(type, listener);\nremoveEventListener(type, listener, options);\nremoveEventListener(type, listener, useCapture);\n```\n\n\n- Notices:\n  - 如果同一个对象上存在2个事件监听器, 且仅在`useCapture`参数存在差异, 那么需要先后2次调用`removeEventListener()`方法才能完全移除其事件监听器;\n  - 如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;\n  - `type`,`listener`参数必须完全匹配才能移除事件监听器;\n  - 对于`options`参数:\n    - 字段相同: 一定可以移除;\n    - 字段不同: 需要与默认值false匹配才可以移除.\n```js\nelement.addEventListener(\"mousedown\", handleMouseDown, { passive: true });\n\nelement.removeEventListener(\"mousedown\", handleMouseDown, { passive: true }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, { capture: false }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, { capture: true }); // 失败\nelement.removeEventListener(\"mousedown\", handleMouseDown, { passive: false }); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, false); // 成功\nelement.removeEventListener(\"mousedown\", handleMouseDown, true); // 失败\n```\n\n---\n**添加与移除**的结合使用:\n```js\nconst body = document.querySelector(\"body\");\nconst clickTarget = document.getElementById(\"click-target\");\nconst mouseOverTarget = document.getElementById(\"mouse-over-target\");\n\nlet toggle = false;\nfunction makeBackgroundYellow() {\n  body.style.backgroundColor = toggle ? \"white\" : \"yellow\";\n\n  toggle = !toggle;\n}\n\nclickTarget.addEventListener(\"click\", makeBackgroundYellow, false);\n\nmouseOverTarget.addEventListener(\"mouseover\", () => {\n  clickTarget.removeEventListener(\"click\", makeBackgroundYellow, false);\n});\n```\n\n\n### 使用匿名函数\n在上述`html`例子下:\n```js\n// 改变 t2 内容的函数\nfunction modifyText(new_text) {\n  const t2 = document.getElementById(\"t2\");\n  t2.firstChild.nodeValue = new_text;\n}\n\n// 用匿名函数为 table 添加事件监听器\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\n  \"click\",\n  function () {\n    modifyText(\"four\");\n  },\n  false,\n);\n```\n通过匿名函数封装代码, 将参数传入函数`modifyText`, 使得函数可以被调用.\n\n### 使用箭头函数\n```js\n// 改变 t2 内容的函数\nfunction modifyText(new_text) {\n  var t2 = document.getElementById(\"t2\");\n  t2.firstChild.nodeValue = new_text;\n}\n\n// 用箭头函数为 table 添加事件监听器\nconst el = document.getElementById(\"outside\");\nel.addEventListener(\n  \"click\",\n  () => {\n    modifyText(\"four\");\n  },\n  false,\n);\n```\n通过`=>{}`形式的箭头函数简化代码书写.\n\n---\n#### 比较匿名与箭头\n匿名函数与箭头函数在此处的应用基本相同, 但是在`this`的指向上有所不同:\n- 匿名函数与其他普通的JS函数:`this`指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为`undefined`);\n```js\nfunction sayHello() {\n  console.log(this); // 在非严格模式下，this 指向 window\n}\nsayHello();\n```\n\n- 箭头函数的`this`继承自外部作用域, 即调用该方法的对象.\n```js\nconst obj = {\n  name: \"ZJU\",\n  greet: function () {\n    console.log(this.name); // this 指向 obj\n  },\n};\nobj.greet(); // 输出：ZJU\n```\n\n- e.g.\n```js\nconst obj = {\n  name: \"ZJU\",\n  getNameWithAnonymous: function () {\n    return function () {\n      console.log(this.name);\n    };\n  },\n  getNameWithArrow: function () {\n    return () => {\n      console.log(this.name);\n    };\n  },\n};\n\nconst anonymousFn = obj.getNameWithAnonymous();\nanonymousFn(); // 输出：undefined\n\nconst arrowFn = obj.getNameWithArrow();\narrowFn(); // 输出：ZJU\n```\n> 进一步完善.\n\n### 事件对象\n$\\underline{事件对象}$ 在事件处理函数的内部, 以固定指定名称出现的参数, 例如`event`,`e`,`evt`. 它被自动传递给事件处理函数，以提供额外的功能和信息。\n\n`e.target`始终是对 **事件刚刚发生的元素** 的引用\n\n## 表达式和运算符\n### new()\n$\\underline{new}$ 用来创建对象实例的一个关键字. \n- 作用: **调用** 一个 构造函数, 并返回一个由该构造函数创建的对象实例.\n#### 语法\n```js\nnew constructor\nnew constructor()\nnew constructor(arg1)\nnew constructor(arg1, arg2)\nnew constructor(arg1, arg2, /* …, */ argN)\n```\n1. 如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即`new foo` 等价于 `new foo()`;\n2. 构造函数内部的`this`将被绑定到新建的对象实例上;\n\n- e.g. \n```js\nfunction Car(color, brand) {\n  this.color = color;   // 将 color 赋值给新对象\n  this.brand = brand;   // 将 brand 赋值给新对象\n}\n\nconst myCar = new Car(\"red\", \"Toyota\");\n\nconsole.log(myCar.color); // 输出 \"red\"\nconsole.log(myCar.brand); // 输出 \"Toyota\"\n```\n\n使用`new()`的**步骤**:\n 1. 定义构造函数;\n 2. 使用`new()`并传入构造函数的参数;\n 3. 将返回的对象实例赋值给一个变量;\n\n#### 新增属性\n- 为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:\n```js\ncar1.color = \"black\" //为car1新增color属性\n```\n<br>\n\n- 添加共享属性到构造函数中的`prototype`:\n```js\nfunction Car() {}\ncar1 = new Car();\ncar2 = new Car();\n\nconsole.log(car1.color); // undefined\n\nCar.prototype.color = \"原色\";\nconsole.log(car1.color); // '原色'\n\ncar1.color = \"黑色\";\nconsole.log(car1.color); // '黑色'\n\nconsole.log(Object.getPrototypeOf(car1).color); // '原色'\nconsole.log(Object.getPrototypeOf(car2).color); // '原色'\nconsole.log(car1.color); // '黑色'\nconsole.log(car2.color); // '原色'\n```\n> - 此处的构造函数名为`Car`, 因此通过`Car.prototype`可以访问到构造函数的原型对象;\n> - `getPrototypeOf` 表示获取对象的**原型对象**, 因此此处均为最初定义的 **原色**.\n\n#### new.target\n函数通过`new.target`属性可以判断是否通过`new`关键字调用, 即构造.\n- 如果函数是正常调用, 则返回`undefined`;\n- 如果函数是通过`new`调用, 返回被调用的构造函数.\n\n- e.g.\n```js\nfunction Car(color) {\n  if (!new.target) {\n    // 以函数的形式被调用。\n    return `${color}车`;\n  }\n  // 通过 new 被调用。\n  this.color = color;\n}\n\nconst a = Car(\"红\"); // a 是“红车”\nconst b = new Car(\"红\"); // b 是 `Car { color: \"红\" }`\n```\n\n#### 对象类型与实例\n$\\underline{对象类型}$ 通过构造函数可以创建一个对象类型:\n```js\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n}\n```\n\n$\\underline{对象实例}$ 通过使用`new()`方法, 由对象类型构造一个对象实例:\n```js\nconst myCar = new Car(\"鹰牌\", \"Talon TSi\", 1993);\n```\n\n#### 类与new\n在JS当中, 类 **必须** 通过`new`调用.\n> 可以优先阅读[类相关的知识](#类)\n\n- e.g. \n```js\nclass Animal {\n  //构造函数\n  constructor(name) {\n    this.name = name;\n  }\n  //实例方法\n  greet() {\n    console.log(`你好，我的名字是${this.name}`);\n  }\n}\n```\n对于上述的类, 必须使用如下的调用方式:\n```js\nconst animal = new Animal(\"Dog\"); // 正常\n```\n而下面这样类似于普通函数的调用方式会抛出错误:\n```js\nAnimal(\"Cat\"); // TypeError:  Class constructor Animal cannot be invoked without 'new'\n```\n<br>\n\n在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:\n```js\nanimal.greet(); // 输出 \"你好，我的名字是Dog\"\n```\n\n---\n\n下面给出与普通函数的区别:\n```js\nfunction Car(model) {\n  this.model = model;\n}\n\nconst car = new Car(\"Toyota\"); // 正常\nCar(\"Honda\"); // 不抛出错误，但 this 会指向全局对象.\nconst anotherCar = Car(\"cat\"); //此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.\n```\n总结:\n- 以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;\n- 如果以new方法构造得到对象实例, 依旧正常.\n\n---\n\n# 补充\n## 默认行为\n$\\underline{默认行为}$ 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.\n\n- 比如存在以下的默认行为:\n  - 滚动事件：触摸屏上滑动手指，页面会滚动;\n  - 拖拽文件到浏览器：浏览器会尝试加载文件;\n  - 点击链接 `(<a href=\"...\">)`：跳转到指定的 URL;\n\n$\\underline{阻止默认行为}$ 使用 `event.preventDefault()` 方法可以阻止事件的默认行为.\n\n- e.g: 阻止链接跳转\n```js\ndocument.querySelector('a').addEventListener('click', function(event) {\n    event.preventDefault(); // 阻止点击链接时的默认行为\n    console.log('链接被点击，但没有跳转');\n});\n```\n\n- 作用:\n  - 通过阻止默认行为, 可以实现自定义逻辑.\n\n## this\n\n- `this`可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;\n- `this` 指向的是**当前函数的调用者**，而不是函数内部定义的变量.\n\n<br>\n\n- e.g.\n```js\nconst obj = {\n    a: \"a in the obj\",\n    b: \"b in the obj\",\n    f: function() {\n        const b = \"b in the function\"; // 函数作用域\n        console.log(this.b); // 访问 this.b\n    }\n};\n\nconst b = \"b outside of the func\";\n\nobj.f();\n```\n> 此处的`f`\n\n### 函数上下文中的this\n- `this`参数的值取决于函数**如何**被调用, 而不是函数如何被定义.\n```js\n// 对象可以作为第一个参数传递给 'call' 或 'apply'，\n// 并且 'this' 将被绑定到它。\nconst obj = { a: \"Custom\" };\n\n// 使用 var 声明的变量成为 'globalThis' 的属性。\nvar a = \"Global\";\n\nfunction whatsThis() {\n  return this.a; // 'this' 取决于函数如何被调用\n}\n\nwhatsThis(); // 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'\nobj.whatsThis = whatsThis;\nobj.whatsThis(); // 'Custom'; 'this' 参数被绑定到 obj\n```\n1. 同样是调用函数`whatsThis()`, 但是`this`参数被绑定到不同的对象上, 导致返回值不同;\n2. 在非严格模式下, `this`参数默认指向`globalThis`, 即全局对象;\n3. 对于典型函数, `this`指向函数访问的对象;\n\n- e.g. \n```js\nconst obj = {\n    b: \"b in the obj\",\n    f: function() {\n        const b = \"b in the function\"; // 函数作用域\n        console.log(this.b); // 访问 this.b\n    }\n};\n\nconst b = \"b outside of the func\";\n\nobj.f();\n```\n> 此处`f`作为`obj`对象的方法被调用, 因此普通函数的`this`指向`obj`.\n\n- e.g. 直接调用的普通函数`this`指向全局:\n```js\nconst obj = {\n    a: \"a in the obj\",\n    f: function() {\n        const funcA = function () { return this.a }; // 普通函数，this 由调用方式决定\n        console.log(funcA()); // 访问 this.a\n    }\n};\n\nvar a = \"a in the global\";\nobj.f(); // \"a in the global\"\n```\n> - 此处的`funcA`并没有类似于作为对象的属性调用(`obj.funcA()`), 因此其`this`指向全局作用域(`window`), 输出`undefined`, 而是直接调用的形式, 因此其`this`指向全局作用域.\n\n\n\n\n\n### 对this传值\n使用`call()`以及`apply()`方法可以将`this`绑定到其他对象上.\n#### call()\n- 形式: `func.call(thisArg, arg1, arg2, ...)`\n- e.g:\n```js\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// 第一个参数被绑定到隐式的 'this' 参数；\n// 剩余的参数被绑定到命名参数。\nadd.call(o, 5, 7); // 16\n```\n\n#### apply()\n- 形式: `func.apply(thisArg, [argsArray])`\n- e.g:\n```js\nfunction add(c, d) {\n  return this.a + this.b + c + d;\n}\n\nconst o = { a: 1, b: 3 };\n\n// 第一个参数被绑定到隐式的 'this' 参数；\n// 第二个参数是一个数组，其成员被绑定到命名参数。\nadd.apply(o, [10, 20]); // 34\n```\n\n#### bind()\n- 形式: `f.bind(someObject)`;\n- **作用**: \n  - 创建一个新的函数(需要重新赋值), 具有与`f`相同的函数体和作用域;\n  - 新函数的`this`被 **永久地** 绑定到`someObject`, 不随调用方式的变化而变化.\n- **限制**: \n  - `bind`无法多次生效. 即对函数f`bind`得到的g, 无法继续用`bind`得到期望的h;\n- e.g. 多次`bind`:\n```js\nfunction f() {\n  return this.a;\n}\n\nconst g = f.bind({ b: \"azerty\" });\nconsole.log(g()); // undefined\n\nconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！\nconsole.log(h()); // undefined\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37 37 undefined undefined\n```\n> - 由于`bind`只能对一个原始函数作用, 因此由f得到的g无法继续由`bind`绑定`this`得到期望的h, 此处h的`this`依旧是`{b: \"azerty\"}`, 因此在输出对象`a`时显示`undefined`;\n> - `o.f()`的调用是普通函数的调用, 因此其`this`继承自对象`o`, 输出`37`;\n\n- e.g. 对象\n```js\nfunction f() {\n  return this.a + \" \" + this.c;\n}\n\nconst g = f.bind({ b: \"azerty\" , c:\"ccc\"});\nconsole.log(g()); // \"undefined ccc\"\n\nconst h = g.bind({ a: \"yoo\" }); // bind 只能生效一次！\nconsole.log(h()); // \"undefined ccc\"\n\nconst o = { a: 37, f, g, h };\nconsole.log(o.a, o.f(), o.g(), o.h()); // 37 37 azerty azerty\n```\n> - `bind`绑定的`this`是永久覆盖, 而非简单叠加;\n> - 由于`bind`绑定的`this`不随者调用方式的变化而变化, 因此即使处于对象`o`当中, `g`,`h`依旧不会输出`o`中的`a`.\n\n### 箭头函数中的this\n\n\n使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。\n\n\n普通函数:\n```js\nconst a = \"a in the global\";\nconst foo = function () {return this.a};\n\nconst obj = {\n a: \"a in the obj\",\n f: foo\n};\n\nconsole.log(obj.f()); // \"a in the obj\"\n```\n\n`call()`、 `apply()`、 `bind()` 无法改变箭头函数的`this`(但是call与apply的其他参数可以正常传递:\n```js\nconst foo = ()=> this.a;\n\nconst obj = {\n a: \"a in the obj\",\n f: foo.bind({a:\"a in the bind\"}) // 显式绑定 this 到 obj, 但是无法生效\n};\n\nconsole.log(obj.f()); // undefined\n\n```\n> 换成普通函数则输出`a in the obj`.\n\n\n- 全局作用域\n```js\nvar a = \"a in the global\";\nconst foo1 = () => this.a;\n\nconst obj = {\n\ta: \"a in the obj\",\n\tf: ()=> a\n};\n\nconsole.log(obj.f());\n```\n\n## 作用域\n$\\underline{作用域}$ 指当前的执行上下文, 在其中的值和表达式可以被访问. \n- 全局作用域: 脚本模式运行所有代码的默认作用域;\n- 模块作用域: 模块模式中运行代码的作用域;\n- 函数作用域: 由函数创建的作用域\n- 块级作用域: 由`let`或`const`声明的变量的作用域.(对于`var`无效);\n\n```js\n{\n  var x = 1;\n}\nconsole.log(x); // 1\n\n{\n  const x = 1;\n}\nconsole.log(x); // undefined\n```\n\nNotices:\n- 对象本身并不会创建作用域, 只是一个键值对的集合;\n- 箭头函数也不会创建自己的作用域, 而是 **继承** 外层作用域中的`this`;\n\n### 变量与作用域\n- `var`在全局作用域中声明时会成为 **全局对象** (`window`或`global`)的属性;\n- `let`和`const`即使在全局作用域中声明, 也不会成为全局对象的属性;\n```js\nvar a = \"1\";\nlet b = \"2\";\n\nwindow.a; // \"1\"\nwindow.b; // undefined\n```\n> 因此, 建议在全局作用域中不要使用`var`声明变量, 而使用`let`或`const`声明变量. 从而避免导致意外的覆盖和冲突.\n\n\n### 函数与作用域\n#### 普通函数\n普通函数和匿名函数的作用域继承自其定义时的作用域.\n```js\nconst obj = {\n    a: \"a in the obj\",\n    insideObj: {\n        g: function() {\n            return this.a; // 普通函数，this 动态绑定到 insideObj\n        }\n    },\n    f: function() {\n        return this.a; // 普通函数，this 动态绑定到 obj\n    }\n};\n\nconsole.log(obj.f());        // \"a in the obj\"\nconsole.log(obj.insideObj.g()); // undefined，因为 insideObj 中没有 a\n```\n\n#### 箭头函数\ne.g. **箭头函数继承外层作用域**:\n```js\nvar a = \"a in the global\";\n\nconst obj = {\n    a: \"a in the obj\",\n    insideObj: {\n        g: () => this.a\n    },\n    f: () => this.a\n};\n\nconsole.log(obj.f());        // \"a in the global\"\nconsole.log(obj.insideObj.g()); //\"a in the global\"\n```\n由于对象不会创建作用域, 因此此处的箭头函数的`this`继承了外层作用域(window)的`this`, 且`var`创建的变量存在于全局作用域中.\n\n## 语法糖\n$\\underline{语法糖}$ 一种让代码更简洁、更易读的语法形式.\n- 本质上没有增加语言的功能, 而是对已有功能的 **包装** 或者优化;\n- **可读性提升**: ~~让代码更填~~ 使得代码更加容易理解和书写;\n- **底层实现**: 实质上依旧用基础的语法实现.\n\n### 类\n类 `class` 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承`prototype`的封装.\n\n使用`class`的写法:\n```js\nclass Person {\n  constructor(name) {\n    this.name = name;\n  }\n\n  greet() {\n    console.log(`Hello, my name is ${this.name}`);\n  }\n}\n\nconst person = new Person(\"Alice\");\nperson.greet(); // 输出：Hello, my name is Alice\n```\n\n等价的原型写法:\n```js\nfunction Person(name) {\n  this.name = name;\n}\n\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name}`);\n};\n\nconst person = new Person(\"Alice\");\nperson.greet(); // 输出：Hello, my name is Alice\n```\n\n### 箭头函数\n箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.\n\n- e.g.\n```js\n// 使用箭头函数\nconst add = (a, b) => a + b;\n\n// 等价的普通函数\nconst add = function add(a, b) {\n  return a + b;\n}\n```\n\n### 结构赋值\n$\\underline{结构赋值}$ 手动提取**对象**属性的语法糖.\n\n- 使用结构赋值:\n```js\nconst person = {name:\"Zhuo\", gender:\"male\"};\n\nconst {name, gender} = person;\n```\n\n- 等价的原型写法:\n```js\nconst person = {name:\"Zhuo\", gender:\"male\"};\n\nconst name = person.name;\nconst gender = person.gender;\n```\n\n#### 赋值规则\n结构赋值时, 基于 **属性名匹配** 而非顺序. \n因此, 对象结构的`{}`内部属性必须和 **对象的属性名** 相对应.\n\n**错误**的示例:\n```js\nconst person = { name: \"Alice\", age: 25 };\nconst { a, b } = person;\n\nconsole.log(a); // 输出：undefined\nconsole.log(b); // 输出：undefined\n```\n\n**重命名属性**的写法:\n```js\nconst person = { name: \"Alice\", age: 25 };\nconst { name: a, age: b } = person;\n\nconsole.log(a); // 输出：Alice\nconsole.log(b); // 输出：25\n```\n\n**手动赋值**: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:\n```js\nconst person = { name: \"Alice\" };\nconst { name, age = 30 } = person;\n\nconsole.log(name); // 输出：Alice\nconsole.log(age);  // 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）\n```\n#### 数组的结构赋值\n上述讨论的结构赋值都是对 **对象** 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— **基于顺序**赋值:\n```js\nconst arr = [\"Alice\", 25];\nconst [a, b] = arr;\n\nconsole.log(a); // 输出：Alice\nconsole.log(b); // 输出：25\n```\n","slug":"编程语言/JavaScript","published":1,"updated":"2025-05-08T11:54:46.819Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ag000t2xqgb0ynaimp","content":"<blockquote>\n<p>JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「<strong>料理的加护</strong>」下, 尽可能将JS处理得更加<strong>可口</strong>一些)</p>\n<img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"/img/料理的加护.jpg\" width=\"35%\"></blockquote>\n<h1 id=\"创建JS代码块\"><a href=\"#创建JS代码块\" class=\"headerlink\" title=\"创建JS代码块\"></a>创建JS代码块</h1><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"var-or-let\"><a href=\"#var-or-let\" class=\"headerlink\" title=\"var or let?\"></a><code>var</code> or <code>let</code>?</h3><p><code>var</code>先于<code>let</code>的产生, 后者是现代版本的JS中新的关键字.</p>\n<p>使用<code>var</code>, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是<code>let</code>并不适用.</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myName = <span class=\"string\">\"Chris\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logName</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myName);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">logName</span>(); <span class=\"comment\">//输出\"Chris\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"Aniya\"</span>;</span><br><span class=\"line\"><span class=\"title function_\">logName</span>(); <span class=\"comment\">//输出\"Aniya\"</span></span><br></pre></td></tr></table></figure></div>\n\n<p>除此之外, 可以使用<code>var</code>前后声明相同的变量, 这并不会报错:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"Chris\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"Bob\"</span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>而<code>let</code>只能声明一次:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Chris\"</span>;</span><br><span class=\"line\">myName = <span class=\"string\">\"Bob\"</span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>因此, 在代码编写中应尽量<strong>多使用</strong><code>let</code>而非<code>var</code>, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.</p>\n<h3 id=\"变量命名的规则\"><a href=\"#变量命名的规则\" class=\"headerlink\" title=\"变量命名的规则\"></a>变量命名的规则</h3><p>与C语言类似, 建议以 <strong>字母、数字、下划线</strong> 组成的标识符来命名变量.</p>\n<ul>\n<li>不可用<code>_</code>开头, 因为可能被JS设计为特殊的含义;</li>\n<li>不可用数字开头, 否则引发错误;</li>\n<li>大小写敏感;</li>\n<li>建议采用 <strong>小写驼峰命名法</strong> ,即小写整个命名的第一个字母然后大写剩下单词的首字符;</li>\n<li>避免使用保留字, 比如<code>var</code>,<code>let</code>,<code>for</code>等.</li>\n</ul>\n<h3 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h3><div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAge = <span class=\"number\">20</span> ;<span class=\"comment\">// 数字</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dolphinGoodbye = <span class=\"string\">\"So long and thanks for all the fish\"</span>; <span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"number\">6</span> &lt; <span class=\"number\">3</span>; <span class=\"comment\">//boolean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myNameArray = [<span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Bob\"</span>, <span class=\"string\">\"Jim\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> myNumberArray = [<span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">40</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对象类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = { <span class=\"attr\">name</span>: <span class=\"string\">\"Spot\"</span>, <span class=\"attr\">breed</span>: <span class=\"string\">\"Dalmatian\"</span> };</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>对象类型的访问与结构体相似, <code>dog.name;</code></p>\n</blockquote>\n<p>在上面的几种变量类型中, 我们都采用<code>let</code>关键字声明变量, 这体现了JS是一种 <strong>动态类型语言</strong> ,即无需指定变量包含的数据类型.</p>\n<p>同时, 这也意味着我们可以像<code>python</code>一样对同一个变量先后赋值不同类型的值:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myNumber = <span class=\"string\">\"500\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> myNumber;</span><br><span class=\"line\"><span class=\"comment\">// 输出 'string'</span></span><br><span class=\"line\"></span><br><span class=\"line\">myNumber = <span class=\"number\">500</span>; </span><br><span class=\"line\"><span class=\"keyword\">typeof</span> myNumber;</span><br><span class=\"line\"><span class=\"comment\">//输出'number'</span></span><br></pre></td></tr></table></figure></div>\n\n\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ul>\n<li><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">提</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">升</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"2000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"500 148 2000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(6,1)\"></path></svg></g></g></g></g></svg></mjx-container> 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">exampleFunction</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">exampleFunction</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"函数内\"</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>由于 <strong>提升</strong> 的存在, 上述的函数调用不会出错.</p>\n</blockquote>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在编写函数时, 可以通过在参数名称后添加<code>=</code>, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greeding</span>(<span class=\"params\">name = <span class=\"string\">\"my friend\"</span></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">${name}</span>!`</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">hello</span>(); <span class=\"comment\">//Hello, my friend!</span></span><br><span class=\"line\"><span class=\"title function_\">hello</span>(<span class=\"string\">\"world\"</span>); <span class=\"comment\">//Hello, world!</span></span><br></pre></td></tr></table></figure></div>\n\n<br>\n\n<p>事件处理函数的默认接受值是<code>event</code>:</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">onclick</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">nothing here</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"button\"</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">para = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"p\"</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">btn.<span class=\"property\">onclick</span> = click;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">function</span> <span class=\"title function_\">click</span>(<span class=\"params\">string</span>){</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"clicked!\"</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">  para.<span class=\"property\">textContent</span> = string;</span></span><br><span class=\"line\"><span class=\"language-javascript\">}</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<ol>\n<li>上述的<code>btn</code>在点击之后调用函数<code>click</code>, 该函数需要一个参数<code>string</code>, 由于<code>btn.onclick = click;</code>的绑定方式, 我们无法指定传参的值, 因此点击之后的<code>para</code>的内容显示为: <code>[object PointerEvent]</code>;</li>\n<li><code>textContent</code>是属性而非方法, 因此采用赋值实现;</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">click</span>(<span class=\"params\">string</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"clicked!\"</span>)</span><br><span class=\"line\">  para.<span class=\"property\">textContent</span> = <span class=\"string\">\"You have clicked the button!\"</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>将上述的绑定方式如此改写, 可以在<code>btn</code>外对<code>string</code>进行赋值, 然后点击按钮可以传入指定参数供后续处理.</p>\n</blockquote>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>在了解箭头函数的作用之前, 需要先介绍 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">匿</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">名</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">函</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">数</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container>:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">alert</span>(<span class=\"string\">\"你好\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名函数</span></span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">alert</span>(<span class=\"string\">\"你好\"</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.</p>\n</blockquote>\n<p>如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logKey</span>(<span class=\"params\">event</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, logKey);</span><br></pre></td></tr></table></figure></div>\n<p>这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.</p>\n</blockquote>\n<p>而<strong>箭头函数</strong>则是在此情况下更简洁的函数定义方式:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果函数只接受一个参数, 也可以省略参数周围的括号</span></span><br><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure></div>\n\n<p>如果只包含一行的<code>return</code>,则可以忽略<code>{}</code>和<code>return</code>关键字:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> originals = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doubled = originals.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(doubled); <span class=\"comment\">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>item =&gt; item * 2</code>等价于:</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doubleItem</span>(<span class=\"params\">item</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item * <span class=\"number\">2</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"一个实例\"><a href=\"#一个实例\" class=\"headerlink\" title=\"一个实例\"></a>一个实例</h4><div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"textBox\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"output\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> textBox = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"#textBox\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"#output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  output.<span class=\"property\">textContent</span> = <span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>;</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure></div>\n<p>通过监听输入框的keydown事件, 输出按下的键盘按键.</p>\n<h3 id=\"函数作用域和冲突\"><a href=\"#函数作用域和冲突\" class=\"headerlink\" title=\"函数作用域和冲突\"></a>函数作用域和冲突</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">作</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">用</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">域</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container> 指当前的执行上下文, 在其中的值和表达式可以被访问. </p>\n<ul>\n<li>全局作用域: 脚本模式运行所有代码的默认作用域;</li>\n<li>模块作用域: 模块模式中运行代码的作用域;</li>\n<li>函数作用域: 由函数创建的作用域</li>\n</ul>\n<p>和C语言相似, 在函数外部<code>let</code>定义的变量, 以及<code>const</code>定义的常量可以在函数内部访问.</p>\n<p>如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Excerpt from my HTML --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"first.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"second.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  greeting();</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>如果两个JS文件都定义了<code>greeting</code>函数, 则只有第一个文件中的函数才会被调用.</p>\n</blockquote>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"数字和操作符\"><a href=\"#数字和操作符\" class=\"headerlink\" title=\"数字和操作符\"></a>数字和操作符</h3><p>大部分与C语言相同, 概括需要注意的差异:</p>\n<ul>\n<li>JS当中只有一种数字类型 – <code>number</code>, 对于整型或者浮点数的初始化得到的量, 由<code>typeof</code>均得到<code>number</code>;</li>\n<li>算术运算符: 求幂为<code>**</code>;</li>\n<li>常量无法使用自增或自减,<del>好像也是C语言的 忘了</del></li>\n<li><code>===</code>表示严格等于, <code>!==</code>表示不等于;<blockquote>\n<p>同时存在<code>==</code>和<code>!=</code>来判断是否相等, 但是它们只是测试 <strong>值</strong> 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用<code>===</code>和<code>!==</code>来避免类型不一致的错误.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>创建字符串</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myString = <span class=\"string\">\"A string\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> constString = myString;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(constString);</span><br><span class=\"line\"><span class=\"comment\">//A string</span></span><br></pre></td></tr></table></figure></div>\n<p>可以使用单引号,双引号和<strong>反引号</strong>来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> single = <span class=\"string\">'单引号'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"string\">\"双引号\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> backtick = <span class=\"string\">`反引号`</span>;</span><br></pre></td></tr></table></figure></div>\n\n<p>反引号包裹的字符串称为<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.312ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 5000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">模</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">板</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">字</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">符</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">串</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"5000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1250 148 5000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(15,1)\"></path></svg></g></g></g></g></svg></mjx-container>, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:</p>\n<ul>\n<li>可以嵌入 <strong>JavaScript</strong>;</li>\n<li>可以声明<strong>多行</strong>的模板字面量.</li>\n</ul>\n<h4 id=\"字符串的拼接\"><a href=\"#字符串的拼接\" class=\"headerlink\" title=\"字符串的拼接\"></a>字符串的拼接</h4><p>字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">串</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">联</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">法</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container>:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"克里斯\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> greeting = <span class=\"string\">`你好，<span class=\"subst\">${name}</span>`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(greeting); <span class=\"comment\">// \"你好，克里斯\"</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>在模板字面量中用<code>${}</code>包装JS的变量或者表达式.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> one = <span class=\"string\">\"你好，\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> two = <span class=\"string\">\"请问最近如何？\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> joined = <span class=\"string\">`<span class=\"subst\">${one}</span><span class=\"subst\">${two}</span>`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(joined); <span class=\"comment\">// \"你好，请问最近如何？\"</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>连接2个变量.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> song = <span class=\"string\">\"青花瓷\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> score = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> highestScore = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = <span class=\"string\">`我喜欢歌曲《<span class=\"subst\">${song}</span>》。我给它打了 <span class=\"subst\">${</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">  (score / highestScore) * <span class=\"number\">100</span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">}</span> 分。`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(output); <span class=\"comment\">// \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>在模板字面量的<code>${}</code>内部包含表达式.</p>\n</blockquote>\n<br>\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> greeting = <span class=\"string\">\"你好\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"克里斯\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(greeting + <span class=\"string\">\"，\"</span> + name); <span class=\"comment\">// \"你好，克里斯\"</span></span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h4><p>模板字符串会<strong>保留</strong>源代码中的换行符，因此可以编写跨越多行的字符串:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newline = <span class=\"string\">`终于有一天，</span></span><br><span class=\"line\"><span class=\"string\">你知道了必须做的事情，而且开始……`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newline);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">终于有一天，</span></span><br><span class=\"line\"><span class=\"comment\">你知道了必须做的事情，而且开始……</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></div>\n\n<p>如果希望用普通的字符串得到等效的输出, 必须在字符串中包含<code>\\n</code>,而非直接跨行:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newline = <span class=\"string\">\"终于有一天，\\n你知道了必须做的事情，而且开始……\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newline);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">终于有一天，</span></span><br><span class=\"line\"><span class=\"comment\">你知道了必须做的事情，而且开始……</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"显示引号\"><a href=\"#显示引号\" class=\"headerlink\" title=\"显示引号\"></a>显示引号</h4><ol>\n<li><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">转</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">义</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"2000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"500 148 2000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(6,1)\"></path></svg></g></g></g></g></svg></mjx-container>  通过在符号前加上反斜杠<code>\\</code>, 可以转义字符串中的特殊字符,包括字符串中的引号:</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bigmouth = <span class=\"string\">'I\\'ve got no right to take my place…'</span>;</span><br></pre></td></tr></table></figure></div>\n<ol start=\"2\">\n<li>换用其他字符: 在字面量内用不同于包裹字符串的引号:</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> goodQuotes1 = <span class=\"string\">'She said \"I think so!\"'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> goodQuotes2 = <span class=\"string\">`She said \"I'm not going in there!\"`</span>;</span><br></pre></td></tr></table></figure></div>\n\n\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><p>对于字符串对象实例,其常用的方法:</p>\n<ul>\n<li><code>.length</code>: 获取字符串的长度;</li>\n<li><code>[]</code>: 返回字符串中对应索引的字符, 索引同样从<code>0</code>开始;</li>\n<li><code>.indexOf(\"\")</code>: 查找子字符串<ul>\n<li><strong>input</strong>: 希望查找的子字符串;</li>\n<li><strong>output</strong>: 子字符串开始的下标(如果不存在则返回<code>-1</code>);</li>\n</ul>\n</li>\n<li><code>.slice(indedxStart, indexEnd)</code>: 截取字符串<ul>\n<li><strong>input</strong>: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;</li>\n<li><strong>output</strong>: 截取的子字符串;</li>\n</ul>\n</li>\n</ul>\n<p>更多的<code>slice</code>知识:</p>\n<ol>\n<li><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.312ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 5000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">标</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">准</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">化</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">负</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">值</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"5000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1250 148 5000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(15,1)\"></path></svg></g></g></g></g></svg></mjx-container> 如果索引是个负数, 取<code>index+str.length</code>进行标准化;</li>\n<li>如果<code>indexStart</code>大于<code>str.length</code>, 返回空字符串;</li>\n<li>如果标准化负值之后, <code>indexStart</code>大于<code>indexEnd</code>, 也返回空字符串;</li>\n</ol>\n<ul>\n<li><code>.toLowerCase()</code> &amp; <code>.toUpperCase()</code>: 转换字符串中的所有字符为小写或大写;</li>\n<li><code>.replace(original, new)</code>: 替换字符串中<code>original</code>子字符串为<code>new</code>;<blockquote>\n<p>此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Cases\"><a href=\"#Cases\" class=\"headerlink\" title=\"Cases\"></a>Cases</h4><p>利用 <strong>indexOf</strong> 和 <strong>slice</strong> 方法, 获取新字符串:</p>\n<ul>\n<li><strong>input</strong>: <code>\"str3\"</code>三位长字符串+<code>\"...\"</code>(无关字符串)+<code>\";\"</code>+<code>strLast</code>(剩余字符串);</li>\n<li><strong>output</strong>: <code>\"str3\"+\";\"+strLast</code></li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stations = [<span class=\"string\">'MAN675847583748sjt567654;Manchester Piccadilly'</span>,</span><br><span class=\"line\">                <span class=\"string\">'GNF576746573fhdg4737dh4;Greenfield'</span>,</span><br><span class=\"line\">                <span class=\"string\">'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street'</span>,</span><br><span class=\"line\">                <span class=\"string\">'SYB4f65hf75f736463;Stalybridge'</span>,</span><br><span class=\"line\">                <span class=\"string\">'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; stations.<span class=\"property\">length</span>; i++){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> input = stations[i];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> str3 = input.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> strLast = input.<span class=\"title function_\">slice</span>(input.<span class=\"title function_\">indexOf</span>(<span class=\"string\">\";\"</span>)+<span class=\"number\">1</span>); <span class=\"comment\">//indexOf获取;位置</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> output = str3 + <span class=\"string\">\";\"</span> + strLast;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p>通过 <strong>indexOf</strong> 根据子字符串筛选字符串数组:</p>\n<ul>\n<li><strong>input</strong>: 可能包含 <em>Christmas</em> 的字符串数组;</li>\n<li><strong>output</strong>: 包含 <em>Christmas</em> 的字符串数组;</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'.output ul'</span>);</span><br><span class=\"line\">list.<span class=\"property\">innerHTML</span> = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> greetings = [<span class=\"string\">'Happy Birthday!'</span>,</span><br><span class=\"line\">                 <span class=\"string\">'Merry Christmas my love'</span>,</span><br><span class=\"line\">                 <span class=\"string\">'A happy Christmas to all the family'</span>,</span><br><span class=\"line\">                 <span class=\"string\">'You\\'re all I want for Christmas'</span>,</span><br><span class=\"line\">                 <span class=\"string\">'Get well soon'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; greetings.<span class=\"property\">length</span>; i++) {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> input = greetings[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(greetings[i].<span class=\"title function_\">indexOf</span>(<span class=\"string\">'Christmas'</span>) !== -<span class=\"number\">1</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = input;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> listItem = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">    listItem.<span class=\"property\">textContent</span> = result;</span><br><span class=\"line\">    list.<span class=\"title function_\">appendChild</span>(listItem);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"数字与字符串\"><a href=\"#数字与字符串\" class=\"headerlink\" title=\"数字与字符串\"></a>数字与字符串</h3><h4 id=\"相互转换\"><a href=\"#相互转换\" class=\"headerlink\" title=\"相互转换\"></a>相互转换</h4><p>非常神奇, 在JS当中, 数字和字符串可以直接通过函数<code>Number()</code>和<code>String()</code>进行转换, 与C语言不同.</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myString = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myNum = <span class=\"title class_\">Number</span>(myString);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> myNum);</span><br><span class=\"line\"><span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myNum);</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure></div>\n\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myNum2 = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myString2 = <span class=\"title class_\">String</span>(myNum2);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> myString2);</span><br><span class=\"line\"><span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myString2);</span><br><span class=\"line\"><span class=\"comment\">// \"123\"</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>对于浮点数同样成立.</p>\n</blockquote>\n<h4 id=\"前后拼接\"><a href=\"#前后拼接\" class=\"headerlink\" title=\"前后拼接\"></a>前后拼接</h4><p>使用<code>+</code>将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"Front \"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> number = <span class=\"number\">242</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> combine = name + number;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(combine); <span class=\"comment\">//Front 242</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">typeof</span>(combine));  <span class=\"comment\">//string</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ol>\n<li>存储任意类型元素–字符串，数字，对象，变量，<strong>另一个数组</strong>;</li>\n<li>可以 <strong>混合</strong> 元素类型:</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> random = [<span class=\"string\">\"tree\"</span>, <span class=\"number\">795</span>, [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]];</span><br></pre></td></tr></table></figure></div>\n<ol start=\"3\">\n<li>像访问字符串一样, 利用索引访问数组元素;</li>\n<li><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">多</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">维</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">数</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">组</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 包含数组的数组结构称为~</li>\n</ol>\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><ul>\n<li>作用: 将一个字符串根据给定的字符分隔为字符串数组;</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myData = <span class=\"string\">\"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray = myData.<span class=\"title function_\">split</span>(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myArray);</span><br><span class=\"line\"> <span class=\"comment\">// [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]</span></span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h4><p><code>split</code>的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myNewString = myArray.<span class=\"title function_\">join</span>(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">myNewString;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h4><p>与<code>join</code>方法相似, 但是无法自定义分隔符, 默认为<code>,</code>:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dogNames = [<span class=\"string\">\"Rocket\"</span>, <span class=\"string\">\"Flash\"</span>, <span class=\"string\">\"Bella\"</span>, <span class=\"string\">\"Slugger\"</span>];</span><br><span class=\"line\">dogNames.<span class=\"title function_\">toString</span>(); <span class=\"comment\">//Rocket,Flash,Bella,Slugger</span></span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"push-pop\"><a href=\"#push-pop\" class=\"headerlink\" title=\"push & pop\"></a>push &amp; pop</h4><p><code>push()</code>方法可以将1或多个元素添加到数组的 <strong>末尾</strong>:</p>\n<ol>\n<li>将会直接改写原来的数组,不需要重新赋值;</li>\n<li>该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> newLength = myArray.<span class=\"title function_\">push</span>(<span class=\"number\">4</span>, <span class=\"number\">5</span>,<span class=\"string\">\"string\"</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myArray); <span class=\"comment\">// [1, 2, 3, 4, 5, \"string\"]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newLength); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure></div>\n\n<p>使用<code>.pop()</code>从数组中删除最后一个元素:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myArray.<span class=\"title function_\">pop</span>(); <span class=\"comment\">//\"string\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myArray); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure></div>\n<ol>\n<li>方法调用返回值就是删除的元素本身;</li>\n<li>直接对原始数组操作并赋值, 不需要另外的赋值操作;</li>\n</ol>\n<blockquote>\n<p>shift &amp; unshift:<br>在功能上分别与<code>push</code>和<code>pop</code>相同, 但是作用于数组的开始位置.</p>\n</blockquote>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><p>JS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:</p>\n<h3 id=\"天气预报\"><a href=\"#天气预报\" class=\"headerlink\" title=\"天气预报\"></a>天气预报</h3><div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"weather\"</span>&gt;</span>选择今天的天气：&lt;/label</span><br><span class=\"line\">&gt;<span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"weather\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span>&gt;</span>--作出选择--<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"sunny\"</span>&gt;</span>晴天<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"rainy\"</span>&gt;</span>雨天<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"snowing\"</span>&gt;</span>雪天<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"overcast\"</span>&gt;</span>阴天<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>lable</code>当中的<code>for</code>标签与<code>select</code>标签的<code>id</code>属性对应, 用于关联两个标签.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> select = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"select\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> para = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">select.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"change\"</span>, setWeather);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setWeather</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> choice = select.<span class=\"property\">value</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (choice) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"sunny\"</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> = <span class=\"string\">\"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"rainy\"</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> = <span class=\"string\">\"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"snowing\"</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> =</span><br><span class=\"line\">        <span class=\"string\">\"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"overcast\"</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> =</span><br><span class=\"line\">        <span class=\"string\">\"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<ol>\n<li>通过<code>querySelector</code>方法获取<code>select</code>和<code>p</code>标签;</li>\n<li>然后为<code>select</code>标签添加事件监听器, 当内容改变时触发 <strong>change</strong> 事件, 同时调用<code>setWeather</code>函数;</li>\n<li>进而通过 <strong>switch</strong> 语句处理不同天气的情况, 并设置相应的文字内容;<br>在线网页示例:<a class=\"link\" href=\"https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html\">simple-switch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ol>\n</blockquote>\n<h2 id=\"事件介绍\"><a href=\"#事件介绍\" class=\"headerlink\" title=\"事件介绍\"></a>事件介绍</h2><p>什么是<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">事</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">件</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"2000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"500 148 2000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(6,1)\"></path></svg></g></g></g></g></svg></mjx-container>? </p>\n<ul>\n<li>用户选择、点击或者光标悬停在某一元素;</li>\n<li>用户在键盘中按下某个按键;</li>\n<li>网页结束加载;</li>\n<li>…</li>\n</ul>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.312ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 5000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">事</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">件</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">处</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">理</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">器</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"5000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1250 148 5000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(15,1)\"></path></svg></g></g></g></g></svg></mjx-container> 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.</p>\n<h3 id=\"处理点击事件\"><a href=\"#处理点击事件\" class=\"headerlink\" title=\"处理点击事件\"></a>处理点击事件</h3><p>以点击事件为例, 介绍html与js如何进行事件处理的交互:</p>\n<div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span> 改变颜色 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"button\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">random</span>(<span class=\"params\">number</span>){</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>()*(number+<span class=\"number\">1</span>));</span><br><span class=\"line\">  </span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">btn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"click\"</span>, <span class=\"function\">()=&gt;</span>{</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rndCol = <span class=\"string\">`rgb(<span class=\"subst\">${random(<span class=\"number\">255</span>)}</span>,<span class=\"subst\">${random(<span class=\"number\">255</span>)}</span>,<span class=\"subst\">${random(<span class=\"number\">255</span>)}</span>)`</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = rndCol;</span><br><span class=\"line\">})</span><br></pre></td></tr></table></figure></div>\n<ol>\n<li><code>Math.random()</code>方法生成一个介于[0,1)之间的随机数;</li>\n<li><code>*(number+1)</code>之后利用向下取整的方法<code>Math.floor()</code>将其转换为整数, 范围为[0,number];<blockquote>\n<p>假如输入的number为<code>4</code>, 则<code>random(4)</code>的结果可能为<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>中的一个;<br>假设输入的number为<code>3.6</code>, 则输出的结果还是0~4中的整数.</p>\n</blockquote>\n</li>\n<li><code>rndCol = `rgb(${random(255)},${random(255)},${random(255)})</code> 采用的是在<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.312ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 5000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">模</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">板</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">字</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">符</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">串</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"5000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1250 148 5000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(15,1)\"></path></svg></g></g></g></g></svg></mjx-container>内部使用<code>${}</code>调用函数变量的方法.</li>\n</ol>\n<h3 id=\"addEventListener\"><a href=\"#addEventListener\" class=\"headerlink\" title=\"addEventListener()\"></a>addEventListener()</h3><p><code>adEventListener</code>方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.</p>\n<p>通过<code>EventTarget.adddEventListener()</code>的方法, 将指定的监听器注册到对象上, 具体的语法如下:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener);</span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener, options);</span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener, useCapture);</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>type</code>: 事件类型, 如<code>click</code>, <code>mouseover</code>, <code>mouseout</code>, <code>keydown</code>, <code>keyup</code>等;</li>\n<li><code>listener</code>: 事件处理函数, 该函数将在事件发生时被调用;<ul>\n<li>包括 <strong>回调函数</strong> 以及 实现了 <strong>EventListener 接口的对象</strong>;</li>\n</ul>\n</li>\n<li><code>options</code>: 可选参数, 用于配置事件监听器的行为;<blockquote>\n<p>可以为单个事件添加多个事件监听器.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"listener\"><a href=\"#listener\" class=\"headerlink\" title=\"listener\"></a>listener</h4><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">回</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">调</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">函</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">数</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 简单来说, ~指的是当某个事件发生时被调用的一段代码.</p>\n<ul>\n<li>是一个函数, 但是只有等到特定的事件发生时才会执行.</li>\n</ul>\n<p>实现了 EventListener 接口的对象:</p>\n<ul>\n<li><strong>特点</strong>: 以对象作为listener, 对象中具有名为<code>handleEvent()</code>的方法;</li>\n<li><strong>作用</strong>: <ul>\n<li>将事件处理封装到一个对象当中, 可以更好地组织代码;</li>\n<li>便于在对象中保存更多的状态信息;</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> listenerObject = {</span><br><span class=\"line\">    <span class=\"attr\">count</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"title function_\">handleEvent</span>(<span class=\"params\">event</span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">count</span>++;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`事件类型是：<span class=\"subst\">${event.type}</span>，已触发 <span class=\"subst\">${<span class=\"variable language_\">this</span>.count}</span> 次`</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> button = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'button'</span>);</span><br><span class=\"line\">button.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, listenerObject);</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"options\"><a href=\"#options\" class=\"headerlink\" title=\"options\"></a>options</h4><p>一个指定有关 listener 属性的可选参数对象.</p>\n<h5 id=\"Capture\"><a href=\"#Capture\" class=\"headerlink\" title=\"Capture\"></a>Capture</h5><ul>\n<li><p>含义:</p>\n<ul>\n<li>一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;</li>\n<li>默认为false, 表示只有在冒泡阶段才触发.</li>\n</ul>\n</li>\n<li><p>区别:</p>\n<ul>\n<li><code>capture</code>和<code>useCapture</code>实际上指的都是 <strong>监听器是否在捕获阶段触发</strong> 的布尔值.<blockquote>\n<p>捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.</p>\n</blockquote>\n</li>\n<li>后来DOM的规范更新时引入了<code>options</code>参数, 此后<code>capture</code>取代了<code>useCapture</code>的作用.</li>\n<li>如果<code>addEventListener</code>的第三个参数不指定对象, 只有布尔值, 那么默认是在设置<code>useCapture</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可以先查看<a href=\"#%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E7%9A%84%E9%98%B6%E6%AE%B5\">事件传播的阶段</a>来辅助理解不同的阶段.</p>\n</blockquote>\n<h5 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h5><ul>\n<li>含义:<ul>\n<li>一个布尔值，表示 listener 在添加之后最多只调用一次;</li>\n<li>默认为false, 表示可以多次调用.</li>\n</ul>\n</li>\n<li>e.g.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'子元素 - 目标阶段'</span>);</span><br><span class=\"line\">},{<span class=\"attr\">once</span>: <span class=\"literal\">true</span>});</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>once</code>属性被设置为<code>true</code>, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.</p>\n</blockquote>\n<h5 id=\"Passive\"><a href=\"#Passive\" class=\"headerlink\" title=\"Passive\"></a>Passive</h5><ul>\n<li><p>含义:</p>\n<ul>\n<li>一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();</li>\n</ul>\n</li>\n<li><p>作用:</p>\n<ul>\n<li>明确不会在<code>listener</code>中不会调用<code>preventDefault()</code>方法, 即不会阻止浏览器的<a href=\"#%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA\">默认行为</a>;</li>\n<li>此时, 浏览器可以直接渲染默认行为的结果, 无需等待<code>listener</code>的执行与默认行为的检查, 从而提高了性能.</li>\n</ul>\n</li>\n<li><p>Notice:</p>\n<ul>\n<li>如果设置<code>passive</code>为<code>true</code>, 则<code>listener</code>当中不可出现<code>preventDefault()</code>方法, 否则会报错.</li>\n</ul>\n</li>\n</ul>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'wheel'</span>,<span class=\"function\">()=&gt;</span>{</span><br><span class=\"line\">\tevent.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"scrolling\"</span>);</span><br><span class=\"line\">},{<span class=\"attr\">passive</span>: <span class=\"literal\">false</span>});</span><br></pre></td></tr></table></figure></div>\n<ul>\n<li><code>wheel</code>事件的默认行为是滚动页面;</li>\n<li><code>event.preventDefault();</code>表示会阻止鼠标滚动带来的页面滚动;</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'wheel'</span>,<span class=\"function\">()=&gt;</span>{</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"scrolling\"</span>);</span><br><span class=\"line\">},{<span class=\"attr\">passive</span>: <span class=\"literal\">true</span>});</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'wheel'</span>,<span class=\"function\">()=&gt;</span>{</span><br><span class=\"line\">  event.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"scrolling\"</span>);</span><br><span class=\"line\">},{<span class=\"attr\">passive</span>: <span class=\"literal\">true</span>});</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>passive</code>的设置与<code>listener</code>内部矛盾, 将会报错.</p>\n</blockquote>\n<h5 id=\"Signal\"><a href=\"#Signal\" class=\"headerlink\" title=\"Signal\"></a>Signal</h5><p>用于有条件地移除事件监听器, 具体使用参见<a href=\"#%E5%8F%AF%E8%A2%AB%E7%A7%BB%E9%99%A4%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8\">可被移除的监听器</a>.</p>\n<h3 id=\"事件传播的阶段\"><a href=\"#事件传播的阶段\" class=\"headerlink\" title=\"事件传播的阶段\"></a>事件传播的阶段</h3><ol>\n<li>捕获阶段 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.156ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"13.819ex\" height=\"2.726ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 6108 1205\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(962,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1465,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1826,0)\"><path data-c=\"1D462\" d=\"M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2398,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2849,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(3315,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3565,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4068,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4644,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(5173,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(5642,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-659)\"><svg width=\"6108\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1527 148 6108 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(18.324,1)\"></path></svg></g></g></g></g></svg></mjx-container>: 事件从根节点开始向目标节点传播;<blockquote>\n<p>e.g. 点击事件从document开始传播, 经过html,body直到目标元素.</p>\n</blockquote>\n</li>\n<li>目标阶段阶段 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.181ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12.303ex\" height=\"2.751ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 5438 1216\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(361,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(890,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1341,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1818,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2284,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(2645,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2895,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3398,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3974,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4503,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4972,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-670)\"><svg width=\"5438\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1359.5 148 5438 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(16.314,1)\"></path></svg></g></g></g></g></svg></mjx-container>: 事件到达目标元素;</li>\n<li>冒泡阶段 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.156ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12.253ex\" height=\"2.726ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 5416 1205\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><path data-c=\"1D44F\" d=\"M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(429,0)\"><path data-c=\"1D462\" d=\"M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1001,0)\"><path data-c=\"1D44F\" d=\"M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1430,0)\"><path data-c=\"1D44F\" d=\"M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1859,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2157,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(2623,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2873,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3376,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3952,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4481,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4950,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-659)\"><svg width=\"5416\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1354 148 5416 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(16.248,1)\"></path></svg></g></g></g></g></svg></mjx-container>: 事件从目标元素开始沿着DOM树向上传播.</li>\n</ol>\n<h4 id=\"Case\"><a href=\"#Case\" class=\"headerlink\" title=\"Case\"></a>Case</h4><div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">  parent</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"child\"</span>&gt;</span>child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parent = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'#parent'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'#child'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">parent.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父元素 - 冒泡阶段'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\">parent.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父元素 - 捕获阶段'</span>);</span><br><span class=\"line\">}, { <span class=\"attr\">capture</span>: <span class=\"literal\">true</span> });</span><br><span class=\"line\"></span><br><span class=\"line\">child.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'子元素 - 目标阶段'</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure></div>\n<p>上述的<code>child</code>被包裹在<code>parent</code>内部.</p>\n<ul>\n<li>当点击<code>parent</code>时将会显示:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"父元素 - 捕获阶段\"</span></span><br><span class=\"line\"><span class=\"string\">\"父元素 - 冒泡阶段\"</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;</p>\n</blockquote>\n<ul>\n<li>当点击<code>child</code>时将会显示:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Bash\"><figure class=\"iseeu highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"父元素 - 捕获阶段\"</span></span><br><span class=\"line\"><span class=\"string\">\"子元素 - 目标阶段\"</span></span><br><span class=\"line\"><span class=\"string\">\"父元素 - 冒泡阶段\"</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p><code>child</code>是整个事件流的目标元素, 所以触发时机介于二者之间.</p>\n</blockquote>\n<h4 id=\"Notice\"><a href=\"#Notice\" class=\"headerlink\" title=\"Notice\"></a>Notice</h4><ol>\n<li><p>如果将<code>div</code>换成<code>button</code>, 则点击<code>child</code>时可能只会显示 <strong>目标</strong> 阶段的输出.</p>\n<blockquote>\n<p>这是因为, 不同浏览器对于<code>button</code>元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段</p>\n</blockquote>\n</li>\n<li><p><code>event.stopPropagation();</code>加入该<del>咒语</del>代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:</p>\n</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父元素 - 捕获阶段'</span>);</span><br><span class=\"line\">    event.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">}, { <span class=\"attr\">capture</span>: <span class=\"literal\">true</span> });</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>此时, 点击<code>parent</code>时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.</p>\n</blockquote>\n<h3 id=\"可被移除的监听器\"><a href=\"#可被移除的监听器\" class=\"headerlink\" title=\"可被移除的监听器\"></a>可被移除的监听器</h3><div class=\"code-container\" data-rel=\"Html\"><figure class=\"iseeu highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">id</span>=<span class=\"string\">\"outside\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">id</span>=<span class=\"string\">\"t1\"</span>&gt;</span>one<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">id</span>=<span class=\"string\">\"t2\"</span>&gt;</span>two<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure></div>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为 table 添加可被移除的事件监听器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"outside\"</span>);</span><br><span class=\"line\">el.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"click\"</span>, modifyText, { <span class=\"attr\">signal</span>: controller.<span class=\"property\">signal</span> });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变 t2 内容的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">modifyText</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t2 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> === <span class=\"string\">\"three\"</span>) {</span><br><span class=\"line\">    t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> = <span class=\"string\">\"two\"</span>;</span><br><span class=\"line\">  } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> = <span class=\"string\">\"three\"</span>;</span><br><span class=\"line\">    controller.<span class=\"title function_\">abort</span>(); <span class=\"comment\">// 当值变为 \"three\" 后，移除监听器</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<ul>\n<li><code>AbortController</code>是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;</li>\n<li><code>signal</code>属性是一个<code>AbortSignal</code>对象, 用于控制监听器的移除;</li>\n<li><code>controller.abort()</code>方法用于移除监听器;</li>\n<li>当<code>t2</code>的内容变为”three”时, 移除监听器, 使得<code>modifyText</code>函数不再执行. 此后, 点击<code>t2</code>不会触发<code>modifyText</code>函数.</li>\n</ul>\n</blockquote>\n<p>具体的<strong>构造步骤:</strong></p>\n<ol>\n<li>创建一个<code>AbortController</code>实例: <code>const controller = new AbortController();</code></li>\n<li>在事件监听器内的参数中添加<code>signal: controller.signal</code>选项;</li>\n<li>在需要移除监听器的地方调用<code>controller.abort()</code>方法;</li>\n</ol>\n<hr>\n<p>我们也可以直接使用<code>removeEventListener()</code>方法来移除事件监听器:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">removeEventListener</span>(type, listener);</span><br><span class=\"line\"><span class=\"title function_\">removeEventListener</span>(type, listener, options);</span><br><span class=\"line\"><span class=\"title function_\">removeEventListener</span>(type, listener, useCapture);</span><br></pre></td></tr></table></figure></div>\n\n\n<ul>\n<li>Notices:<ul>\n<li>如果同一个对象上存在2个事件监听器, 且仅在<code>useCapture</code>参数存在差异, 那么需要先后2次调用<code>removeEventListener()</code>方法才能完全移除其事件监听器;</li>\n<li>如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;</li>\n<li><code>type</code>,<code>listener</code>参数必须完全匹配才能移除事件监听器;</li>\n<li>对于<code>options</code>参数:<ul>\n<li>字段相同: 一定可以移除;</li>\n<li>字段不同: 需要与默认值false匹配才可以移除.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">passive</span>: <span class=\"literal\">true</span> });</span><br><span class=\"line\"></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">passive</span>: <span class=\"literal\">true</span> }); <span class=\"comment\">// 成功</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">capture</span>: <span class=\"literal\">false</span> }); <span class=\"comment\">// 成功</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">capture</span>: <span class=\"literal\">true</span> }); <span class=\"comment\">// 失败</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">passive</span>: <span class=\"literal\">false</span> }); <span class=\"comment\">// 成功</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, <span class=\"literal\">false</span>); <span class=\"comment\">// 成功</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, <span class=\"literal\">true</span>); <span class=\"comment\">// 失败</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p><strong>添加与移除</strong>的结合使用:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> body = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"body\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> clickTarget = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"click-target\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mouseOverTarget = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mouse-over-target\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> toggle = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeBackgroundYellow</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  body.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = toggle ? <span class=\"string\">\"white\"</span> : <span class=\"string\">\"yellow\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  toggle = !toggle;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">clickTarget.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"click\"</span>, makeBackgroundYellow, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mouseOverTarget.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"mouseover\"</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  clickTarget.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"click\"</span>, makeBackgroundYellow, <span class=\"literal\">false</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure></div>\n\n\n<h3 id=\"使用匿名函数\"><a href=\"#使用匿名函数\" class=\"headerlink\" title=\"使用匿名函数\"></a>使用匿名函数</h3><p>在上述<code>html</code>例子下:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改变 t2 内容的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">modifyText</span>(<span class=\"params\">new_text</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t2 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">  t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> = new_text;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用匿名函数为 table 添加事件监听器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"outside\"</span>);</span><br><span class=\"line\">el.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">\"click\"</span>,</span><br><span class=\"line\">  <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"title function_\">modifyText</span>(<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"literal\">false</span>,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></div>\n<p>通过匿名函数封装代码, 将参数传入函数<code>modifyText</code>, 使得函数可以被调用.</p>\n<h3 id=\"使用箭头函数\"><a href=\"#使用箭头函数\" class=\"headerlink\" title=\"使用箭头函数\"></a>使用箭头函数</h3><div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改变 t2 内容的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">modifyText</span>(<span class=\"params\">new_text</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t2 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">  t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> = new_text;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用箭头函数为 table 添加事件监听器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"outside\"</span>);</span><br><span class=\"line\">el.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">\"click\"</span>,</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">modifyText</span>(<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"literal\">false</span>,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure></div>\n<p>通过<code>=&gt;{}</code>形式的箭头函数简化代码书写.</p>\n<hr>\n<h4 id=\"比较匿名与箭头\"><a href=\"#比较匿名与箭头\" class=\"headerlink\" title=\"比较匿名与箭头\"></a>比较匿名与箭头</h4><p>匿名函数与箭头函数在此处的应用基本相同, 但是在<code>this</code>的指向上有所不同:</p>\n<ul>\n<li>匿名函数与其他普通的JS函数:<code>this</code>指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为<code>undefined</code>);</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sayHello</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>); <span class=\"comment\">// 在非严格模式下，this 指向 window</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>箭头函数的<code>this</code>继承自外部作用域, 即调用该方法的对象.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"ZJU\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">greet</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>); <span class=\"comment\">// this 指向 obj</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\">obj.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 输出：ZJU</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>e.g.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"ZJU\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">getNameWithAnonymous</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">    };</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"attr\">getNameWithArrow</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">    };</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> anonymousFn = obj.<span class=\"title function_\">getNameWithAnonymous</span>();</span><br><span class=\"line\"><span class=\"title function_\">anonymousFn</span>(); <span class=\"comment\">// 输出：undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrowFn = obj.<span class=\"title function_\">getNameWithArrow</span>();</span><br><span class=\"line\"><span class=\"title function_\">arrowFn</span>(); <span class=\"comment\">// 输出：ZJU</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>进一步完善.</p>\n</blockquote>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">事</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">件</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">对</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">象</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 在事件处理函数的内部, 以固定指定名称出现的参数, 例如<code>event</code>,<code>e</code>,<code>evt</code>. 它被自动传递给事件处理函数，以提供额外的功能和信息。</p>\n<p><code>e.target</code>始终是对 <strong>事件刚刚发生的元素</strong> 的引用</p>\n<h2 id=\"表达式和运算符\"><a href=\"#表达式和运算符\" class=\"headerlink\" title=\"表达式和运算符\"></a>表达式和运算符</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new()\"></a>new()</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.742ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.032ex\" height=\"1.744ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -443 1782 771\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(600,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1066,0)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-476)\"><svg width=\"1782\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"445.5 148 1782 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(5.346,1)\"></path></svg></g></g></g></g></svg></mjx-container> 用来创建对象实例的一个关键字. </p>\n<ul>\n<li>作用: <strong>调用</strong> 一个 构造函数, 并返回一个由该构造函数创建的对象实例.</li>\n</ul>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> constructor</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title function_\">constructor</span>(<span class=\"params\">arg1</span>)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title function_\">constructor</span>(<span class=\"params\">arg1, arg2</span>)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title function_\">constructor</span>(<span class=\"params\">arg1, arg2, <span class=\"comment\">/* …, */</span> argN</span>)</span><br></pre></td></tr></table></figure></div>\n<ol>\n<li>如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即<code>new foo</code> 等价于 <code>new foo()</code>;</li>\n<li>构造函数内部的<code>this</code>将被绑定到新建的对象实例上;</li>\n</ol>\n<ul>\n<li>e.g.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\">color, brand</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">color</span> = color;   <span class=\"comment\">// 将 color 赋值给新对象</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">brand</span> = brand;   <span class=\"comment\">// 将 brand 赋值给新对象</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myCar = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"Toyota\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myCar.<span class=\"property\">color</span>); <span class=\"comment\">// 输出 \"red\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myCar.<span class=\"property\">brand</span>); <span class=\"comment\">// 输出 \"Toyota\"</span></span><br></pre></td></tr></table></figure></div>\n\n<p>使用<code>new()</code>的<strong>步骤</strong>:</p>\n<ol>\n<li>定义构造函数;</li>\n<li>使用<code>new()</code>并传入构造函数的参数;</li>\n<li>将返回的对象实例赋值给一个变量;</li>\n</ol>\n<h4 id=\"新增属性\"><a href=\"#新增属性\" class=\"headerlink\" title=\"新增属性\"></a>新增属性</h4><ul>\n<li>为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">car1.<span class=\"property\">color</span> = <span class=\"string\">\"black\"</span> <span class=\"comment\">//为car1新增color属性</span></span><br></pre></td></tr></table></figure></div>\n<br>\n\n<ul>\n<li>添加共享属性到构造函数中的<code>prototype</code>:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\">car1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>();</span><br><span class=\"line\">car2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car1.<span class=\"property\">color</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Car</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">color</span> = <span class=\"string\">\"原色\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car1.<span class=\"property\">color</span>); <span class=\"comment\">// '原色'</span></span><br><span class=\"line\"></span><br><span class=\"line\">car1.<span class=\"property\">color</span> = <span class=\"string\">\"黑色\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car1.<span class=\"property\">color</span>); <span class=\"comment\">// '黑色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(car1).<span class=\"property\">color</span>); <span class=\"comment\">// '原色'</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(car2).<span class=\"property\">color</span>); <span class=\"comment\">// '原色'</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car1.<span class=\"property\">color</span>); <span class=\"comment\">// '黑色'</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car2.<span class=\"property\">color</span>); <span class=\"comment\">// '原色'</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<ul>\n<li>此处的构造函数名为<code>Car</code>, 因此通过<code>Car.prototype</code>可以访问到构造函数的原型对象;</li>\n<li><code>getPrototypeOf</code> 表示获取对象的<strong>原型对象</strong>, 因此此处均为最初定义的 <strong>原色</strong>.</li>\n</ul>\n</blockquote>\n<h4 id=\"new-target\"><a href=\"#new-target\" class=\"headerlink\" title=\"new.target\"></a>new.target</h4><p>函数通过<code>new.target</code>属性可以判断是否通过<code>new</code>关键字调用, 即构造.</p>\n<ul>\n<li><p>如果函数是正常调用, 则返回<code>undefined</code>;</p>\n</li>\n<li><p>如果函数是通过<code>new</code>调用, 返回被调用的构造函数.</p>\n</li>\n<li><p>e.g.</p>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\">color</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">new</span>.<span class=\"property\">target</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 以函数的形式被调用。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">${color}</span>车`</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">// 通过 new 被调用。</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">color</span> = color;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"title class_\">Car</span>(<span class=\"string\">\"红\"</span>); <span class=\"comment\">// a 是“红车”</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>(<span class=\"string\">\"红\"</span>); <span class=\"comment\">// b 是 `Car { color: \"红\" }`</span></span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"对象类型与实例\"><a href=\"#对象类型与实例\" class=\"headerlink\" title=\"对象类型与实例\"></a>对象类型与实例</h4><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">对</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">象</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">类</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">型</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 通过构造函数可以创建一个对象类型:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\">make, model, year</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">make</span> = make;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">model</span> = model;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">year</span> = year;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">对</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">象</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">实</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">例</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 通过使用<code>new()</code>方法, 由对象类型构造一个对象实例:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCar = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>(<span class=\"string\">\"鹰牌\"</span>, <span class=\"string\">\"Talon TSi\"</span>, <span class=\"number\">1993</span>);</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"类与new\"><a href=\"#类与new\" class=\"headerlink\" title=\"类与new\"></a>类与new</h4><p>在JS当中, 类 <strong>必须</strong> 通过<code>new</code>调用.</p>\n<blockquote>\n<p>可以优先阅读<a href=\"#%E7%B1%BB\">类相关的知识</a></p>\n</blockquote>\n<ul>\n<li>e.g.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {</span><br><span class=\"line\">  <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">//实例方法</span></span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`你好，我的名字是<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n<p>对于上述的类, 必须使用如下的调用方式:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animal = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">\"Dog\"</span>); <span class=\"comment\">// 正常</span></span><br></pre></td></tr></table></figure></div>\n<p>而下面这样类似于普通函数的调用方式会抛出错误:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Animal</span>(<span class=\"string\">\"Cat\"</span>); <span class=\"comment\">// TypeError:  Class constructor Animal cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure></div>\n<br>\n\n<p>在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animal.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 输出 \"你好，我的名字是Dog\"</span></span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<p>下面给出与普通函数的区别:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\">model</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">model</span> = model;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> car = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>(<span class=\"string\">\"Toyota\"</span>); <span class=\"comment\">// 正常</span></span><br><span class=\"line\"><span class=\"title class_\">Car</span>(<span class=\"string\">\"Honda\"</span>); <span class=\"comment\">// 不抛出错误，但 this 会指向全局对象.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> anotherCar = <span class=\"title class_\">Car</span>(<span class=\"string\">\"cat\"</span>); <span class=\"comment\">//此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.</span></span><br></pre></td></tr></table></figure></div>\n<p>总结:</p>\n<ul>\n<li>以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;</li>\n<li>如果以new方法构造得到对象实例, 依旧正常.</li>\n</ul>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"默认行为\"><a href=\"#默认行为\" class=\"headerlink\" title=\"默认行为\"></a>默认行为</h2><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">默</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">认</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">行</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">为</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.</p>\n<ul>\n<li>比如存在以下的默认行为:<ul>\n<li>滚动事件：触摸屏上滑动手指，页面会滚动;</li>\n<li>拖拽文件到浏览器：浏览器会尝试加载文件;</li>\n<li>点击链接 <code>(&lt;a href=\"...\"&gt;)</code>：跳转到指定的 URL;</li>\n</ul>\n</li>\n</ul>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"13.575ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 6000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">阻</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">止</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">默</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">认</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">行</text></g><g data-mml-node=\"mi\" transform=\"translate(5000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">为</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"6000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1500 148 6000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(18,1)\"></path></svg></g></g></g></g></svg></mjx-container> 使用 <code>event.preventDefault()</code> 方法可以阻止事件的默认行为.</p>\n<ul>\n<li>e.g: 阻止链接跳转</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'a'</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) {</span><br><span class=\"line\">    event.<span class=\"title function_\">preventDefault</span>(); <span class=\"comment\">// 阻止点击链接时的默认行为</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'链接被点击，但没有跳转'</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>作用:<ul>\n<li>通过阻止默认行为, 可以实现自定义逻辑.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><ul>\n<li><code>this</code>可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;</li>\n<li><code>this</code> 指向的是<strong>当前函数的调用者</strong>，而不是函数内部定义的变量.</li>\n</ul>\n<br>\n\n<ul>\n<li>e.g.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"string\">\"b in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = <span class=\"string\">\"b in the function\"</span>; <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">b</span>); <span class=\"comment\">// 访问 this.b</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"string\">\"b outside of the func\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>此处的<code>f</code></p>\n</blockquote>\n<h3 id=\"函数上下文中的this\"><a href=\"#函数上下文中的this\" class=\"headerlink\" title=\"函数上下文中的this\"></a>函数上下文中的this</h3><ul>\n<li><code>this</code>参数的值取决于函数<strong>如何</strong>被调用, 而不是函数如何被定义.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对象可以作为第一个参数传递给 'call' 或 'apply'，</span></span><br><span class=\"line\"><span class=\"comment\">// 并且 'this' 将被绑定到它。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = { <span class=\"attr\">a</span>: <span class=\"string\">\"Custom\"</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 var 声明的变量成为 'globalThis' 的属性。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"Global\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">whatsThis</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>; <span class=\"comment\">// 'this' 取决于函数如何被调用</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">whatsThis</span>(); <span class=\"comment\">// 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'</span></span><br><span class=\"line\">obj.<span class=\"property\">whatsThis</span> = whatsThis;</span><br><span class=\"line\">obj.<span class=\"title function_\">whatsThis</span>(); <span class=\"comment\">// 'Custom'; 'this' 参数被绑定到 obj</span></span><br></pre></td></tr></table></figure></div>\n<ol>\n<li>同样是调用函数<code>whatsThis()</code>, 但是<code>this</code>参数被绑定到不同的对象上, 导致返回值不同;</li>\n<li>在非严格模式下, <code>this</code>参数默认指向<code>globalThis</code>, 即全局对象;</li>\n<li>对于典型函数, <code>this</code>指向函数访问的对象;</li>\n</ol>\n<ul>\n<li>e.g.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"string\">\"b in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = <span class=\"string\">\"b in the function\"</span>; <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">b</span>); <span class=\"comment\">// 访问 this.b</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"string\">\"b outside of the func\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>此处<code>f</code>作为<code>obj</code>对象的方法被调用, 因此普通函数的<code>this</code>指向<code>obj</code>.</p>\n</blockquote>\n<ul>\n<li>e.g. 直接调用的普通函数<code>this</code>指向全局:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> funcA = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) { <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> }; <span class=\"comment\">// 普通函数，this 由调用方式决定</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">funcA</span>()); <span class=\"comment\">// 访问 this.a</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"a in the global\"</span>;</span><br><span class=\"line\">obj.<span class=\"title function_\">f</span>(); <span class=\"comment\">// \"a in the global\"</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<ul>\n<li>此处的<code>funcA</code>并没有类似于作为对象的属性调用(<code>obj.funcA()</code>), 因此其<code>this</code>指向全局作用域(<code>window</code>), 输出<code>undefined</code>, 而是直接调用的形式, 因此其<code>this</code>指向全局作用域.</li>\n</ul>\n</blockquote>\n<h3 id=\"对this传值\"><a href=\"#对this传值\" class=\"headerlink\" title=\"对this传值\"></a>对this传值</h3><p>使用<code>call()</code>以及<code>apply()</code>方法可以将<code>this</code>绑定到其他对象上.</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call()\"></a>call()</h4><ul>\n<li>形式: <code>func.call(thisArg, arg1, arg2, ...)</code></li>\n<li>e.g:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">c, d</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> + c + d;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = { <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数被绑定到隐式的 'this' 参数；</span></span><br><span class=\"line\"><span class=\"comment\">// 剩余的参数被绑定到命名参数。</span></span><br><span class=\"line\">add.<span class=\"title function_\">call</span>(o, <span class=\"number\">5</span>, <span class=\"number\">7</span>); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><ul>\n<li>形式: <code>func.apply(thisArg, [argsArray])</code></li>\n<li>e.g:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">c, d</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> + c + d;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = { <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数被绑定到隐式的 'this' 参数；</span></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数是一个数组，其成员被绑定到命名参数。</span></span><br><span class=\"line\">add.<span class=\"title function_\">apply</span>(o, [<span class=\"number\">10</span>, <span class=\"number\">20</span>]); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind()\"></a>bind()</h4><ul>\n<li>形式: <code>f.bind(someObject)</code>;</li>\n<li><strong>作用</strong>: <ul>\n<li>创建一个新的函数(需要重新赋值), 具有与<code>f</code>相同的函数体和作用域;</li>\n<li>新函数的<code>this</code>被 <strong>永久地</strong> 绑定到<code>someObject</code>, 不随调用方式的变化而变化.</li>\n</ul>\n</li>\n<li><strong>限制</strong>: <ul>\n<li><code>bind</code>无法多次生效. 即对函数f<code>bind</code>得到的g, 无法继续用<code>bind</code>得到期望的h;</li>\n</ul>\n</li>\n<li>e.g. 多次<code>bind</code>:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = f.<span class=\"title function_\">bind</span>({ <span class=\"attr\">b</span>: <span class=\"string\">\"azerty\"</span> });</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> h = g.<span class=\"title function_\">bind</span>({ <span class=\"attr\">a</span>: <span class=\"string\">\"yoo\"</span> }); <span class=\"comment\">// bind 只能生效一次！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">h</span>()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = { <span class=\"attr\">a</span>: <span class=\"number\">37</span>, f, g, h };</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o.<span class=\"property\">a</span>, o.<span class=\"title function_\">f</span>(), o.<span class=\"title function_\">g</span>(), o.<span class=\"title function_\">h</span>()); <span class=\"comment\">// 37 37 undefined undefined</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<ul>\n<li>由于<code>bind</code>只能对一个原始函数作用, 因此由f得到的g无法继续由<code>bind</code>绑定<code>this</code>得到期望的h, 此处h的<code>this</code>依旧是<code>{b: \"azerty\"}</code>, 因此在输出对象<code>a</code>时显示<code>undefined</code>;</li>\n<li><code>o.f()</code>的调用是普通函数的调用, 因此其<code>this</code>继承自对象<code>o</code>, 输出<code>37</code>;</li>\n</ul>\n</blockquote>\n<ul>\n<li>e.g. 对象</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"string\">\" \"</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">c</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = f.<span class=\"title function_\">bind</span>({ <span class=\"attr\">b</span>: <span class=\"string\">\"azerty\"</span> , <span class=\"attr\">c</span>:<span class=\"string\">\"ccc\"</span>});</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>()); <span class=\"comment\">// \"undefined ccc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> h = g.<span class=\"title function_\">bind</span>({ <span class=\"attr\">a</span>: <span class=\"string\">\"yoo\"</span> }); <span class=\"comment\">// bind 只能生效一次！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">h</span>()); <span class=\"comment\">// \"undefined ccc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = { <span class=\"attr\">a</span>: <span class=\"number\">37</span>, f, g, h };</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o.<span class=\"property\">a</span>, o.<span class=\"title function_\">f</span>(), o.<span class=\"title function_\">g</span>(), o.<span class=\"title function_\">h</span>()); <span class=\"comment\">// 37 37 azerty azerty</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<ul>\n<li><code>bind</code>绑定的<code>this</code>是永久覆盖, 而非简单叠加;</li>\n<li>由于<code>bind</code>绑定的<code>this</code>不随者调用方式的变化而变化, 因此即使处于对象<code>o</code>当中, <code>g</code>,<code>h</code>依旧不会输出<code>o</code>中的<code>a</code>.</li>\n</ul>\n</blockquote>\n<h3 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h3><p>使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。</p>\n<p>普通函数:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"string\">\"a in the global\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\"> <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\"> <span class=\"attr\">f</span>: foo</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>()); <span class=\"comment\">// \"a in the obj\"</span></span><br></pre></td></tr></table></figure></div>\n\n<p><code>call()</code>、 <code>apply()</code>、 <code>bind()</code> 无法改变箭头函数的<code>this</code>(但是call与apply的其他参数可以正常传递:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\"></span>)=&gt; <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\"> <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\"> <span class=\"attr\">f</span>: foo.<span class=\"title function_\">bind</span>({<span class=\"attr\">a</span>:<span class=\"string\">\"a in the bind\"</span>}) <span class=\"comment\">// 显式绑定 this 到 obj, 但是无法生效</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>换成普通函数则输出<code>a in the obj</code>.</p>\n</blockquote>\n<ul>\n<li>全局作用域</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"a in the global\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo1</span> = (<span class=\"params\"></span>) =&gt; <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">\t<span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">\t<span class=\"attr\">f</span>: <span class=\"function\">()=&gt;</span> a</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>());</span><br></pre></td></tr></table></figure></div>\n\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">作</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">用</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">域</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container> 指当前的执行上下文, 在其中的值和表达式可以被访问. </p>\n<ul>\n<li>全局作用域: 脚本模式运行所有代码的默认作用域;</li>\n<li>模块作用域: 模块模式中运行代码的作用域;</li>\n<li>函数作用域: 由函数创建的作用域</li>\n<li>块级作用域: 由<code>let</code>或<code>const</code>声明的变量的作用域.(对于<code>var</code>无效);</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></div>\n\n<p>Notices:</p>\n<ul>\n<li>对象本身并不会创建作用域, 只是一个键值对的集合;</li>\n<li>箭头函数也不会创建自己的作用域, 而是 <strong>继承</strong> 外层作用域中的<code>this</code>;</li>\n</ul>\n<h3 id=\"变量与作用域\"><a href=\"#变量与作用域\" class=\"headerlink\" title=\"变量与作用域\"></a>变量与作用域</h3><ul>\n<li><code>var</code>在全局作用域中声明时会成为 <strong>全局对象</strong> (<code>window</code>或<code>global</code>)的属性;</li>\n<li><code>let</code>和<code>const</code>即使在全局作用域中声明, 也不会成为全局对象的属性;</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"string\">\"2\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">a</span>; <span class=\"comment\">// \"1\"</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">b</span>; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></div>\n<blockquote>\n<p>因此, 建议在全局作用域中不要使用<code>var</code>声明变量, 而使用<code>let</code>或<code>const</code>声明变量. 从而避免导致意外的覆盖和冲突.</p>\n</blockquote>\n<h3 id=\"函数与作用域\"><a href=\"#函数与作用域\" class=\"headerlink\" title=\"函数与作用域\"></a>函数与作用域</h3><h4 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h4><p>普通函数和匿名函数的作用域继承自其定义时的作用域.</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">insideObj</span>: {</span><br><span class=\"line\">        <span class=\"attr\">g</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>; <span class=\"comment\">// 普通函数，this 动态绑定到 insideObj</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>; <span class=\"comment\">// 普通函数，this 动态绑定到 obj</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>());        <span class=\"comment\">// \"a in the obj\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">insideObj</span>.<span class=\"title function_\">g</span>()); <span class=\"comment\">// undefined，因为 insideObj 中没有 a</span></span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"箭头函数-1\"><a href=\"#箭头函数-1\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><p>e.g. <strong>箭头函数继承外层作用域</strong>:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"a in the global\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">insideObj</span>: {</span><br><span class=\"line\">        <span class=\"attr\">g</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span></span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>());        <span class=\"comment\">// \"a in the global\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">insideObj</span>.<span class=\"title function_\">g</span>()); <span class=\"comment\">//\"a in the global\"</span></span><br></pre></td></tr></table></figure></div>\n<p>由于对象不会创建作用域, 因此此处的箭头函数的<code>this</code>继承了外层作用域(window)的<code>this</code>, 且<code>var</code>创建的变量存在于全局作用域中.</p>\n<h2 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h2><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">语</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">法</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">糖</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container> 一种让代码更简洁、更易读的语法形式.</p>\n<ul>\n<li>本质上没有增加语言的功能, 而是对已有功能的 <strong>包装</strong> 或者优化;</li>\n<li><strong>可读性提升</strong>: <del>让代码更填</del> 使得代码更加容易理解和书写;</li>\n<li><strong>底层实现</strong>: 实质上依旧用基础的语法实现.</li>\n</ul>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>类 <code>class</code> 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承<code>prototype</code>的封装.</p>\n<p>使用<code>class</code>的写法:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, my name is <span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">\"Alice\"</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 输出：Hello, my name is Alice</span></span><br></pre></td></tr></table></figure></div>\n\n<p>等价的原型写法:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">greet</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, my name is <span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">\"Alice\"</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 输出：Hello, my name is Alice</span></span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"箭头函数-2\"><a href=\"#箭头函数-2\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.</p>\n<ul>\n<li>e.g.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">add</span> = (<span class=\"params\">a, b</span>) =&gt; a + b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价的普通函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure></div>\n\n<h3 id=\"结构赋值\"><a href=\"#结构赋值\" class=\"headerlink\" title=\"结构赋值\"></a>结构赋值</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">结</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">构</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">赋</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">值</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 手动提取<strong>对象</strong>属性的语法糖.</p>\n<ul>\n<li>使用结构赋值:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = {<span class=\"attr\">name</span>:<span class=\"string\">\"Zhuo\"</span>, <span class=\"attr\">gender</span>:<span class=\"string\">\"male\"</span>};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> {name, gender} = person;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>等价的原型写法:</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = {<span class=\"attr\">name</span>:<span class=\"string\">\"Zhuo\"</span>, <span class=\"attr\">gender</span>:<span class=\"string\">\"male\"</span>};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = person.<span class=\"property\">name</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> gender = person.<span class=\"property\">gender</span>;</span><br></pre></td></tr></table></figure></div>\n\n<h4 id=\"赋值规则\"><a href=\"#赋值规则\" class=\"headerlink\" title=\"赋值规则\"></a>赋值规则</h4><p>结构赋值时, 基于 <strong>属性名匹配</strong> 而非顺序.<br>因此, 对象结构的<code>{}</code>内部属性必须和 <strong>对象的属性名</strong> 相对应.</p>\n<p><strong>错误</strong>的示例:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = { <span class=\"attr\">name</span>: <span class=\"string\">\"Alice\"</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> };</span><br><span class=\"line\"><span class=\"keyword\">const</span> { a, b } = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 输出：undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// 输出：undefined</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>重命名属性</strong>的写法:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = { <span class=\"attr\">name</span>: <span class=\"string\">\"Alice\"</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> };</span><br><span class=\"line\"><span class=\"keyword\">const</span> { <span class=\"attr\">name</span>: a, <span class=\"attr\">age</span>: b } = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 输出：Alice</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// 输出：25</span></span><br></pre></td></tr></table></figure></div>\n\n<p><strong>手动赋值</strong>: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = { <span class=\"attr\">name</span>: <span class=\"string\">\"Alice\"</span> };</span><br><span class=\"line\"><span class=\"keyword\">const</span> { name, age = <span class=\"number\">30</span> } = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// 输出：Alice</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age);  <span class=\"comment\">// 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）</span></span><br></pre></td></tr></table></figure></div>\n<h4 id=\"数组的结构赋值\"><a href=\"#数组的结构赋值\" class=\"headerlink\" title=\"数组的结构赋值\"></a>数组的结构赋值</h4><p>上述讨论的结构赋值都是对 <strong>对象</strong> 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— <strong>基于顺序</strong>赋值:</p>\n<div class=\"code-container\" data-rel=\"Js\"><figure class=\"iseeu highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">\"Alice\"</span>, <span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> [a, b] = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 输出：Alice</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// 输出：25</span></span><br></pre></td></tr></table></figure></div>\n","more":"<blockquote>\n<p>JavaScript是一种轻量级、解释型、面向对象的编程语言. 作为前端三件套之一以及TS的基础, JS语言细节十分难嚼. 本文在「<strong>料理的加护</strong>」下, 尽可能将JS处理得更加<strong>可口</strong>一些)</p>\n<img lazyload=\"\" src=\"/images/loading.svg\" data-src=\"/img/料理的加护.jpg\" width=\"35%\"></blockquote>\n<h1 id=\"创建JS代码块\"><a href=\"#创建JS代码块\" class=\"headerlink\" title=\"创建JS代码块\"></a>创建JS代码块</h1><h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"var-or-let\"><a href=\"#var-or-let\" class=\"headerlink\" title=\"var or let?\"></a><code>var</code> or <code>let</code>?</h3><p><code>var</code>先于<code>let</code>的产生, 后者是现代版本的JS中新的关键字.</p>\n<p>使用<code>var</code>, 可以对一个先前已被声明且初始化的变量重新声明, 这不会带来报错, 代码依旧可以工作. 但是<code>let</code>并不适用.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myName = <span class=\"string\">\"Chris\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logName</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myName);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">logName</span>(); <span class=\"comment\">//输出\"Chris\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"Aniya\"</span>;</span><br><span class=\"line\"><span class=\"title function_\">logName</span>(); <span class=\"comment\">//输出\"Aniya\"</span></span><br></pre></td></tr></table></figure>\n\n<p>除此之外, 可以使用<code>var</code>前后声明相同的变量, 这并不会报错:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"Chris\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> myName = <span class=\"string\">\"Bob\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>而<code>let</code>只能声明一次:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myName = <span class=\"string\">\"Chris\"</span>;</span><br><span class=\"line\">myName = <span class=\"string\">\"Bob\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>因此, 在代码编写中应尽量<strong>多使用</strong><code>let</code>而非<code>var</code>, 这可以帮助我们排除无意中重新命名相同变量而导致的错误.</p>\n<h3 id=\"变量命名的规则\"><a href=\"#变量命名的规则\" class=\"headerlink\" title=\"变量命名的规则\"></a>变量命名的规则</h3><p>与C语言类似, 建议以 <strong>字母、数字、下划线</strong> 组成的标识符来命名变量.</p>\n<ul>\n<li>不可用<code>_</code>开头, 因为可能被JS设计为特殊的含义;</li>\n<li>不可用数字开头, 否则引发错误;</li>\n<li>大小写敏感;</li>\n<li>建议采用 <strong>小写驼峰命名法</strong> ,即小写整个命名的第一个字母然后大写剩下单词的首字符;</li>\n<li>避免使用保留字, 比如<code>var</code>,<code>let</code>,<code>for</code>等.</li>\n</ul>\n<h3 id=\"变量类型\"><a href=\"#变量类型\" class=\"headerlink\" title=\"变量类型\"></a>变量类型</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myAge = <span class=\"number\">20</span> ;<span class=\"comment\">// 数字</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dolphinGoodbye = <span class=\"string\">\"So long and thanks for all the fish\"</span>; <span class=\"comment\">// 字符串</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> test = <span class=\"number\">6</span> &lt; <span class=\"number\">3</span>; <span class=\"comment\">//boolean</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//数组类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> myNameArray = [<span class=\"string\">\"Chris\"</span>, <span class=\"string\">\"Bob\"</span>, <span class=\"string\">\"Jim\"</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> myNumberArray = [<span class=\"number\">10</span>, <span class=\"number\">15</span>, <span class=\"number\">40</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//对象类型</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> dog = { <span class=\"attr\">name</span>: <span class=\"string\">\"Spot\"</span>, <span class=\"attr\">breed</span>: <span class=\"string\">\"Dalmatian\"</span> };</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对象类型的访问与结构体相似, <code>dog.name;</code></p>\n</blockquote>\n<p>在上面的几种变量类型中, 我们都采用<code>let</code>关键字声明变量, 这体现了JS是一种 <strong>动态类型语言</strong> ,即无需指定变量包含的数据类型.</p>\n<p>同时, 这也意味着我们可以像<code>python</code>一样对同一个变量先后赋值不同类型的值:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myNumber = <span class=\"string\">\"500\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> myNumber;</span><br><span class=\"line\"><span class=\"comment\">// 输出 'string'</span></span><br><span class=\"line\"></span><br><span class=\"line\">myNumber = <span class=\"number\">500</span>; </span><br><span class=\"line\"><span class=\"keyword\">typeof</span> myNumber;</span><br><span class=\"line\"><span class=\"comment\">//输出'number'</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><ul>\n<li><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">提</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">升</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"2000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"500 148 2000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(6,1)\"></path></svg></g></g></g></g></svg></mjx-container> 解释器在执行代码之前，似乎将函数、变量、类或导入的声明移动到其作用域的顶部的过程.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">exampleFunction</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">exampleFunction</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"函数内\"</span>);</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x);</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于 <strong>提升</strong> 的存在, 上述的函数调用不会出错.</p>\n</blockquote>\n<h3 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h3><p>在编写函数时, 可以通过在参数名称后添加<code>=</code>, 再指定默认值, 这样当调用函数时, 如果没有传入该参数, 则使用默认值。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">greeding</span>(<span class=\"params\">name = <span class=\"string\">\"my friend\"</span></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, <span class=\"subst\">${name}</span>!`</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">hello</span>(); <span class=\"comment\">//Hello, my friend!</span></span><br><span class=\"line\"><span class=\"title function_\">hello</span>(<span class=\"string\">\"world\"</span>); <span class=\"comment\">//Hello, world!</span></span><br></pre></td></tr></table></figure>\n\n<br>\n\n<p>事件处理函数的默认接受值是<code>event</code>:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\">onclick</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\">nothing here</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"button\"</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">para = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"p\"</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\">btn.<span class=\"property\">onclick</span> = click;</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span></span><br><span class=\"line\"><span class=\"language-javascript\"><span class=\"keyword\">function</span> <span class=\"title function_\">click</span>(<span class=\"params\">string</span>){</span></span><br><span class=\"line\"><span class=\"language-javascript\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"clicked!\"</span>)</span></span><br><span class=\"line\"><span class=\"language-javascript\">  para.<span class=\"property\">textContent</span> = string;</span></span><br><span class=\"line\"><span class=\"language-javascript\">}</span></span><br><span class=\"line\"><span class=\"language-javascript\"></span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>上述的<code>btn</code>在点击之后调用函数<code>click</code>, 该函数需要一个参数<code>string</code>, 由于<code>btn.onclick = click;</code>的绑定方式, 我们无法指定传参的值, 因此点击之后的<code>para</code>的内容显示为: <code>[object PointerEvent]</code>;</li>\n<li><code>textContent</code>是属性而非方法, 因此采用赋值实现;</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">btn.<span class=\"property\">onclick</span> = <span class=\"keyword\">function</span> <span class=\"title function_\">click</span>(<span class=\"params\">string</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"clicked!\"</span>)</span><br><span class=\"line\">  para.<span class=\"property\">textContent</span> = <span class=\"string\">\"You have clicked the button!\"</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>将上述的绑定方式如此改写, 可以在<code>btn</code>外对<code>string</code>进行赋值, 然后点击按钮可以传入指定参数供后续处理.</p>\n</blockquote>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>在了解箭头函数的作用之前, 需要先介绍 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">匿</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">名</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">函</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">数</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">myFunction</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">alert</span>(<span class=\"string\">\"你好\"</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 匿名函数</span></span><br><span class=\"line\">(<span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"title function_\">alert</span>(<span class=\"string\">\"你好\"</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>正如其名, 匿名函数没有函数名, 不能被调用, 但可以作为参数传入其他函数中.</p>\n</blockquote>\n<p>如果我们希望在监听某个事件发生时调用简单的函数来处理, 则可以通过调用上述的匿名函数实现:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">logKey</span>(<span class=\"params\">event</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>);</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, logKey);</span><br></pre></td></tr></table></figure>\n<p>这部分代码通过监听html元素的keydown事件, 调用函数输出按下的键盘按键. 我们可以通过匿名函数来简化书写:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, <span class=\"keyword\">function</span> (<span class=\"params\">event</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>只需传入函数体, 而不需要函数名, 就可以实现监听事件并调用函数的功能.</p>\n</blockquote>\n<p>而<strong>箭头函数</strong>则是在此情况下更简洁的函数定义方式:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果函数只接受一个参数, 也可以省略参数周围的括号</span></span><br><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, <span class=\"function\"><span class=\"params\">event</span> =&gt;</span> {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure>\n\n<p>如果只包含一行的<code>return</code>,则可以忽略<code>{}</code>和<code>return</code>关键字:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> originals = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> doubled = originals.<span class=\"title function_\">map</span>(<span class=\"function\"><span class=\"params\">item</span> =&gt;</span> item * <span class=\"number\">2</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(doubled); <span class=\"comment\">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>item =&gt; item * 2</code>等价于:</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">doubleItem</span>(<span class=\"params\">item</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> item * <span class=\"number\">2</span>;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"一个实例\"><a href=\"#一个实例\" class=\"headerlink\" title=\"一个实例\"></a>一个实例</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">input</span> <span class=\"attr\">id</span>=<span class=\"string\">\"textBox\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text\"</span> /&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"output\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> textBox = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"#textBox\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"#output\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">textBox.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"keydown\"</span>, <span class=\"function\">(<span class=\"params\">event</span>) =&gt;</span> {</span><br><span class=\"line\">  output.<span class=\"property\">textContent</span> = <span class=\"string\">`You pressed \"<span class=\"subst\">${event.key}</span>\".`</span>;</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure>\n<p>通过监听输入框的keydown事件, 输出按下的键盘按键.</p>\n<h3 id=\"函数作用域和冲突\"><a href=\"#函数作用域和冲突\" class=\"headerlink\" title=\"函数作用域和冲突\"></a>函数作用域和冲突</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">作</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">用</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">域</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container> 指当前的执行上下文, 在其中的值和表达式可以被访问. </p>\n<ul>\n<li>全局作用域: 脚本模式运行所有代码的默认作用域;</li>\n<li>模块作用域: 模块模式中运行代码的作用域;</li>\n<li>函数作用域: 由函数创建的作用域</li>\n</ul>\n<p>和C语言相似, 在函数外部<code>let</code>定义的变量, 以及<code>const</code>定义的常量可以在函数内部访问.</p>\n<p>如果HTML调用了多个外部JS文件, 其中具有相同的函数名, 那么只能访问的第一个函数, 第二个函数将被忽略:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">&lt;!-- Excerpt from my HTML --&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"first.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span> <span class=\"attr\">src</span>=<span class=\"string\">\"second.js\"</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">script</span>&gt;</span></span><br><span class=\"line\">  greeting();</span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">script</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>如果两个JS文件都定义了<code>greeting</code>函数, 则只有第一个文件中的函数才会被调用.</p>\n</blockquote>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"数字和操作符\"><a href=\"#数字和操作符\" class=\"headerlink\" title=\"数字和操作符\"></a>数字和操作符</h3><p>大部分与C语言相同, 概括需要注意的差异:</p>\n<ul>\n<li>JS当中只有一种数字类型 – <code>number</code>, 对于整型或者浮点数的初始化得到的量, 由<code>typeof</code>均得到<code>number</code>;</li>\n<li>算术运算符: 求幂为<code>**</code>;</li>\n<li>常量无法使用自增或自减,<del>好像也是C语言的 忘了</del></li>\n<li><code>===</code>表示严格等于, <code>!==</code>表示不等于;<blockquote>\n<p>同时存在<code>==</code>和<code>!=</code>来判断是否相等, 但是它们只是测试 <strong>值</strong> 是否相等, 会忽略数据类型的差异; 而上述的比较会同时比较数据类型. 因此推荐使用<code>===</code>和<code>!==</code>来避免类型不一致的错误.</p>\n</blockquote>\n</li>\n</ul>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>创建字符串</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myString = <span class=\"string\">\"A string\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> constString = myString;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(constString);</span><br><span class=\"line\"><span class=\"comment\">//A string</span></span><br></pre></td></tr></table></figure>\n<p>可以使用单引号,双引号和<strong>反引号</strong>来包裹字符串, 但是必须确保字符串的开头和结尾使用相同的字符:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> single = <span class=\"string\">'单引号'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> double = <span class=\"string\">\"双引号\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> backtick = <span class=\"string\">`反引号`</span>;</span><br></pre></td></tr></table></figure>\n\n<p>反引号包裹的字符串称为<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.312ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 5000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">模</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">板</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">字</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">符</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">串</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"5000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1250 148 5000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(15,1)\"></path></svg></g></g></g></g></svg></mjx-container>, 大多数情况下,它与其他两种字符串类似, 但是具有特殊的属性:</p>\n<ul>\n<li>可以嵌入 <strong>JavaScript</strong>;</li>\n<li>可以声明<strong>多行</strong>的模板字面量.</li>\n</ul>\n<h4 id=\"字符串的拼接\"><a href=\"#字符串的拼接\" class=\"headerlink\" title=\"字符串的拼接\"></a>字符串的拼接</h4><p>字符串的拼接有两种方法, 我们先介绍上述提到的模板字符串中的 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">串</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">联</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">法</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"克里斯\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> greeting = <span class=\"string\">`你好，<span class=\"subst\">${name}</span>`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(greeting); <span class=\"comment\">// \"你好，克里斯\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在模板字面量中用<code>${}</code>包装JS的变量或者表达式.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> one = <span class=\"string\">\"你好，\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> two = <span class=\"string\">\"请问最近如何？\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> joined = <span class=\"string\">`<span class=\"subst\">${one}</span><span class=\"subst\">${two}</span>`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(joined); <span class=\"comment\">// \"你好，请问最近如何？\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>连接2个变量.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> song = <span class=\"string\">\"青花瓷\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> score = <span class=\"number\">9</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> highestScore = <span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> output = <span class=\"string\">`我喜欢歌曲《<span class=\"subst\">${song}</span>》。我给它打了 <span class=\"subst\">${</span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">  (score / highestScore) * <span class=\"number\">100</span></span></span></span><br><span class=\"line\"><span class=\"subst\"><span class=\"string\">}</span> 分。`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(output); <span class=\"comment\">// \"我喜欢歌曲《青花瓷》。我给它打了 90 分。\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>在模板字面量的<code>${}</code>内部包含表达式.</p>\n</blockquote>\n<br>\n除此之外,对于普通的字符串(使用单引号或者双引号得到的字符串), 我们可以使用`+`直接连接:\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> greeting = <span class=\"string\">\"你好\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"克里斯\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(greeting + <span class=\"string\">\"，\"</span> + name); <span class=\"comment\">// \"你好，克里斯\"</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多行字符串\"><a href=\"#多行字符串\" class=\"headerlink\" title=\"多行字符串\"></a>多行字符串</h4><p>模板字符串会<strong>保留</strong>源代码中的换行符，因此可以编写跨越多行的字符串:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newline = <span class=\"string\">`终于有一天，</span></span><br><span class=\"line\"><span class=\"string\">你知道了必须做的事情，而且开始……`</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newline);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">终于有一天，</span></span><br><span class=\"line\"><span class=\"comment\">你知道了必须做的事情，而且开始……</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<p>如果希望用普通的字符串得到等效的输出, 必须在字符串中包含<code>\\n</code>,而非直接跨行:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> newline = <span class=\"string\">\"终于有一天，\\n你知道了必须做的事情，而且开始……\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newline);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">终于有一天，</span></span><br><span class=\"line\"><span class=\"comment\">你知道了必须做的事情，而且开始……</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"显示引号\"><a href=\"#显示引号\" class=\"headerlink\" title=\"显示引号\"></a>显示引号</h4><ol>\n<li><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">转</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">义</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"2000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"500 148 2000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(6,1)\"></path></svg></g></g></g></g></svg></mjx-container>  通过在符号前加上反斜杠<code>\\</code>, 可以转义字符串中的特殊字符,包括字符串中的引号:</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> bigmouth = <span class=\"string\">'I\\'ve got no right to take my place…'</span>;</span><br></pre></td></tr></table></figure>\n<ol start=\"2\">\n<li>换用其他字符: 在字面量内用不同于包裹字符串的引号:</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> goodQuotes1 = <span class=\"string\">'She said \"I think so!\"'</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> goodQuotes2 = <span class=\"string\">`She said \"I'm not going in there!\"`</span>;</span><br></pre></td></tr></table></figure>\n\n\n<h4 id=\"常用方法\"><a href=\"#常用方法\" class=\"headerlink\" title=\"常用方法\"></a>常用方法</h4><p>对于字符串对象实例,其常用的方法:</p>\n<ul>\n<li><code>.length</code>: 获取字符串的长度;</li>\n<li><code>[]</code>: 返回字符串中对应索引的字符, 索引同样从<code>0</code>开始;</li>\n<li><code>.indexOf(\"\")</code>: 查找子字符串<ul>\n<li><strong>input</strong>: 希望查找的子字符串;</li>\n<li><strong>output</strong>: 子字符串开始的下标(如果不存在则返回<code>-1</code>);</li>\n</ul>\n</li>\n<li><code>.slice(indedxStart, indexEnd)</code>: 截取字符串<ul>\n<li><strong>input</strong>: 起始下标, 结束下标(不包含该下标). 如果不存在结束下标则提取之后剩余的全部字符;</li>\n<li><strong>output</strong>: 截取的子字符串;</li>\n</ul>\n</li>\n</ul>\n<p>更多的<code>slice</code>知识:</p>\n<ol>\n<li><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.312ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 5000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">标</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">准</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">化</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">负</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">值</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"5000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1250 148 5000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(15,1)\"></path></svg></g></g></g></g></svg></mjx-container> 如果索引是个负数, 取<code>index+str.length</code>进行标准化;</li>\n<li>如果<code>indexStart</code>大于<code>str.length</code>, 返回空字符串;</li>\n<li>如果标准化负值之后, <code>indexStart</code>大于<code>indexEnd</code>, 也返回空字符串;</li>\n</ol>\n<ul>\n<li><code>.toLowerCase()</code> &amp; <code>.toUpperCase()</code>: 转换字符串中的所有字符为小写或大写;</li>\n<li><code>.replace(original, new)</code>: 替换字符串中<code>original</code>子字符串为<code>new</code>;<blockquote>\n<p>此时不会直接改变原字符串的值, 而是返回一个修改之后的字符串. 因此, 如果想要将原来的值替换, 需要用上述方法得到的值去赋值原来的字符串.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"Cases\"><a href=\"#Cases\" class=\"headerlink\" title=\"Cases\"></a>Cases</h4><p>利用 <strong>indexOf</strong> 和 <strong>slice</strong> 方法, 获取新字符串:</p>\n<ul>\n<li><strong>input</strong>: <code>\"str3\"</code>三位长字符串+<code>\"...\"</code>(无关字符串)+<code>\";\"</code>+<code>strLast</code>(剩余字符串);</li>\n<li><strong>output</strong>: <code>\"str3\"+\";\"+strLast</code></li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> stations = [<span class=\"string\">'MAN675847583748sjt567654;Manchester Piccadilly'</span>,</span><br><span class=\"line\">                <span class=\"string\">'GNF576746573fhdg4737dh4;Greenfield'</span>,</span><br><span class=\"line\">                <span class=\"string\">'LIV5hg65hd737456236dch46dg4;Liverpool Lime Street'</span>,</span><br><span class=\"line\">                <span class=\"string\">'SYB4f65hf75f736463;Stalybridge'</span>,</span><br><span class=\"line\">                <span class=\"string\">'HUD5767ghtyfyr4536dh45dg45dg3;Huddersfield'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; stations.<span class=\"property\">length</span>; i++){</span><br><span class=\"line\">    <span class=\"keyword\">var</span> input = stations[i];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> str3 = input.<span class=\"title function_\">slice</span>(<span class=\"number\">0</span>,<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> strLast = input.<span class=\"title function_\">slice</span>(input.<span class=\"title function_\">indexOf</span>(<span class=\"string\">\";\"</span>)+<span class=\"number\">1</span>); <span class=\"comment\">//indexOf获取;位置</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> output = str3 + <span class=\"string\">\";\"</span> + strLast;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>通过 <strong>indexOf</strong> 根据子字符串筛选字符串数组:</p>\n<ul>\n<li><strong>input</strong>: 可能包含 <em>Christmas</em> 的字符串数组;</li>\n<li><strong>output</strong>: 包含 <em>Christmas</em> 的字符串数组;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> list = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'.output ul'</span>);</span><br><span class=\"line\">list.<span class=\"property\">innerHTML</span> = <span class=\"string\">''</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> greetings = [<span class=\"string\">'Happy Birthday!'</span>,</span><br><span class=\"line\">                 <span class=\"string\">'Merry Christmas my love'</span>,</span><br><span class=\"line\">                 <span class=\"string\">'A happy Christmas to all the family'</span>,</span><br><span class=\"line\">                 <span class=\"string\">'You\\'re all I want for Christmas'</span>,</span><br><span class=\"line\">                 <span class=\"string\">'Get well soon'</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; greetings.<span class=\"property\">length</span>; i++) {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> input = greetings[i];</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(greetings[i].<span class=\"title function_\">indexOf</span>(<span class=\"string\">'Christmas'</span>) !== -<span class=\"number\">1</span>) {</span><br><span class=\"line\">    <span class=\"keyword\">var</span> result = input;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> listItem = <span class=\"variable language_\">document</span>.<span class=\"title function_\">createElement</span>(<span class=\"string\">'li'</span>);</span><br><span class=\"line\">    listItem.<span class=\"property\">textContent</span> = result;</span><br><span class=\"line\">    list.<span class=\"title function_\">appendChild</span>(listItem);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数字与字符串\"><a href=\"#数字与字符串\" class=\"headerlink\" title=\"数字与字符串\"></a>数字与字符串</h3><h4 id=\"相互转换\"><a href=\"#相互转换\" class=\"headerlink\" title=\"相互转换\"></a>相互转换</h4><p>非常神奇, 在JS当中, 数字和字符串可以直接通过函数<code>Number()</code>和<code>String()</code>进行转换, 与C语言不同.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myString = <span class=\"string\">\"123\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myNum = <span class=\"title class_\">Number</span>(myString);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> myNum);</span><br><span class=\"line\"><span class=\"comment\">// number</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myNum);</span><br><span class=\"line\"><span class=\"comment\">// 123</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myNum2 = <span class=\"number\">123</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> myString2 = <span class=\"title class_\">String</span>(myNum2);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"keyword\">typeof</span> myString2);</span><br><span class=\"line\"><span class=\"comment\">// string</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myString2);</span><br><span class=\"line\"><span class=\"comment\">// \"123\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>对于浮点数同样成立.</p>\n</blockquote>\n<h4 id=\"前后拼接\"><a href=\"#前后拼接\" class=\"headerlink\" title=\"前后拼接\"></a>前后拼接</h4><p>使用<code>+</code>将字符串类型和数字类型的变量or常量直接拼接, 得到的是以空格相隔的字符串:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> name = <span class=\"string\">\"Front \"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> number = <span class=\"number\">242</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> combine = name + number;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(combine); <span class=\"comment\">//Front 242</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">typeof</span>(combine));  <span class=\"comment\">//string</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><ol>\n<li>存储任意类型元素–字符串，数字，对象，变量，<strong>另一个数组</strong>;</li>\n<li>可以 <strong>混合</strong> 元素类型:</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> random = [<span class=\"string\">\"tree\"</span>, <span class=\"number\">795</span>, [<span class=\"number\">0</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>]];</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>像访问字符串一样, 利用索引访问数组元素;</li>\n<li><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">多</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">维</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">数</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">组</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 包含数组的数组结构称为~</li>\n</ol>\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><ul>\n<li>作用: 将一个字符串根据给定的字符分隔为字符串数组;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myData = <span class=\"string\">\"Manchester,London,Liverpool,Birmingham,Leeds,Carlisle\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myArray = myData.<span class=\"title function_\">split</span>(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myArray);</span><br><span class=\"line\"> <span class=\"comment\">// [\"Manchester\", \"London\", \"Liverpool\", \"Birmingham\", \"Leeds\", \"Carlisle\"]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"join\"><a href=\"#join\" class=\"headerlink\" title=\"join()\"></a>join()</h4><p><code>split</code>的反向操作, 给出分隔符号, 将数组的字符串拼接成一个字符串:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myNewString = myArray.<span class=\"title function_\">join</span>(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">myNewString;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h4><p>与<code>join</code>方法相似, 但是无法自定义分隔符, 默认为<code>,</code>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> dogNames = [<span class=\"string\">\"Rocket\"</span>, <span class=\"string\">\"Flash\"</span>, <span class=\"string\">\"Bella\"</span>, <span class=\"string\">\"Slugger\"</span>];</span><br><span class=\"line\">dogNames.<span class=\"title function_\">toString</span>(); <span class=\"comment\">//Rocket,Flash,Bella,Slugger</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"push-pop\"><a href=\"#push-pop\" class=\"headerlink\" title=\"push & pop\"></a>push &amp; pop</h4><p><code>push()</code>方法可以将1或多个元素添加到数组的 <strong>末尾</strong>:</p>\n<ol>\n<li>将会直接改写原来的数组,不需要重新赋值;</li>\n<li>该方法具有返回值, 且返回的是更新之后的数组长度(包含元素的个数);</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> myArray = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">let</span> newLength = myArray.<span class=\"title function_\">push</span>(<span class=\"number\">4</span>, <span class=\"number\">5</span>,<span class=\"string\">\"string\"</span>);</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myArray); <span class=\"comment\">// [1, 2, 3, 4, 5, \"string\"]</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(newLength); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>.pop()</code>从数组中删除最后一个元素:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">myArray.<span class=\"title function_\">pop</span>(); <span class=\"comment\">//\"string\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myArray); <span class=\"comment\">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>方法调用返回值就是删除的元素本身;</li>\n<li>直接对原始数组操作并赋值, 不需要另外的赋值操作;</li>\n</ol>\n<blockquote>\n<p>shift &amp; unshift:<br>在功能上分别与<code>push</code>和<code>pop</code>相同, 但是作用于数组的开始位置.</p>\n</blockquote>\n<h2 id=\"条件语句\"><a href=\"#条件语句\" class=\"headerlink\" title=\"条件语句\"></a>条件语句</h2><p>JS的条件语句与C语言十分相似, 在此仅给出官方文档的一些例子:</p>\n<h3 id=\"天气预报\"><a href=\"#天气预报\" class=\"headerlink\" title=\"天气预报\"></a>天气预报</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">label</span> <span class=\"attr\">for</span>=<span class=\"string\">\"weather\"</span>&gt;</span>选择今天的天气：&lt;/label</span><br><span class=\"line\">&gt;<span class=\"tag\">&lt;<span class=\"name\">select</span> <span class=\"attr\">id</span>=<span class=\"string\">\"weather\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"\"</span>&gt;</span>--作出选择--<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"sunny\"</span>&gt;</span>晴天<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"rainy\"</span>&gt;</span>雨天<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"snowing\"</span>&gt;</span>雪天<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">option</span> <span class=\"attr\">value</span>=<span class=\"string\">\"overcast\"</span>&gt;</span>阴天<span class=\"tag\">&lt;/<span class=\"name\">option</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">select</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">p</span>&gt;</span><span class=\"tag\">&lt;/<span class=\"name\">p</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>lable</code>当中的<code>for</code>标签与<code>select</code>标签的<code>id</code>属性对应, 用于关联两个标签.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> select = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"select\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> para = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"p\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">select.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"change\"</span>, setWeather);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">setWeather</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> choice = select.<span class=\"property\">value</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (choice) {</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"sunny\"</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> = <span class=\"string\">\"阳光明媚。穿上短裤吧！去海滩，或公园，吃个冰淇淋。\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"rainy\"</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> = <span class=\"string\">\"外面下着雨；带上雨衣和雨伞，不要在外面呆太久。\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"snowing\"</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> =</span><br><span class=\"line\">        <span class=\"string\">\"大雪纷飞，天寒地冻！最好呆在家里喝杯热巧克力，或者去堆个雪人。\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> <span class=\"string\">\"overcast\"</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> =</span><br><span class=\"line\">        <span class=\"string\">\"虽然没有下雨，但天空灰蒙蒙的，随时都可能变天，所以要带一件雨衣以防万一。\"</span>;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"attr\">default</span>:</span><br><span class=\"line\">      para.<span class=\"property\">textContent</span> = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>通过<code>querySelector</code>方法获取<code>select</code>和<code>p</code>标签;</li>\n<li>然后为<code>select</code>标签添加事件监听器, 当内容改变时触发 <strong>change</strong> 事件, 同时调用<code>setWeather</code>函数;</li>\n<li>进而通过 <strong>switch</strong> 语句处理不同天气的情况, 并设置相应的文字内容;<br>在线网页示例:<a class=\"link\" href=\"https://mdn.github.io/learning-area/javascript/building-blocks/simple-switch.html\">simple-switch<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ol>\n</blockquote>\n<h2 id=\"事件介绍\"><a href=\"#事件介绍\" class=\"headerlink\" title=\"事件介绍\"></a>事件介绍</h2><p>什么是<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.525ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 2000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">事</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">件</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"2000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"500 148 2000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(6,1)\"></path></svg></g></g></g></g></svg></mjx-container>? </p>\n<ul>\n<li>用户选择、点击或者光标悬停在某一元素;</li>\n<li>用户在键盘中按下某个按键;</li>\n<li>网页结束加载;</li>\n<li>…</li>\n</ul>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.312ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 5000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">事</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">件</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">处</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">理</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">器</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"5000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1250 148 5000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(15,1)\"></path></svg></g></g></g></g></svg></mjx-container> 为了响应事件, 我们需要编写一份JS代码块用于在事件发生之后运行. 这样的代码块称之为~.</p>\n<h3 id=\"处理点击事件\"><a href=\"#处理点击事件\" class=\"headerlink\" title=\"处理点击事件\"></a>处理点击事件</h3><p>以点击事件为例, 介绍html与js如何进行事件处理的交互:</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">button</span>&gt;</span> 改变颜色 <span class=\"tag\">&lt;/<span class=\"name\">button</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> btn = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"button\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">random</span>(<span class=\"params\">number</span>){</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"title class_\">Math</span>.<span class=\"title function_\">floor</span>(<span class=\"title class_\">Math</span>.<span class=\"title function_\">random</span>()*(number+<span class=\"number\">1</span>));</span><br><span class=\"line\">  </span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">btn.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"click\"</span>, <span class=\"function\">()=&gt;</span>{</span><br><span class=\"line\">  <span class=\"keyword\">const</span> rndCol = <span class=\"string\">`rgb(<span class=\"subst\">${random(<span class=\"number\">255</span>)}</span>,<span class=\"subst\">${random(<span class=\"number\">255</span>)}</span>,<span class=\"subst\">${random(<span class=\"number\">255</span>)}</span>)`</span>;</span><br><span class=\"line\">  <span class=\"variable language_\">document</span>.<span class=\"property\">body</span>.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = rndCol;</span><br><span class=\"line\">})</span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>Math.random()</code>方法生成一个介于[0,1)之间的随机数;</li>\n<li><code>*(number+1)</code>之后利用向下取整的方法<code>Math.floor()</code>将其转换为整数, 范围为[0,number];<blockquote>\n<p>假如输入的number为<code>4</code>, 则<code>random(4)</code>的结果可能为<code>0</code>, <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code>中的一个;<br>假设输入的number为<code>3.6</code>, 则输出的结果还是0~4中的整数.</p>\n</blockquote>\n</li>\n<li><code>rndCol = `rgb(${random(255)},${random(255)},${random(255)})</code> 采用的是在<mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"11.312ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 5000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">模</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">板</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">字</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">符</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">串</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"5000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1250 148 5000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(15,1)\"></path></svg></g></g></g></g></svg></mjx-container>内部使用<code>${}</code>调用函数变量的方法.</li>\n</ol>\n<h3 id=\"addEventListener\"><a href=\"#addEventListener\" class=\"headerlink\" title=\"addEventListener()\"></a>addEventListener()</h3><p><code>adEventListener</code>方法已经在之前的例子中出现过, 现在具体介绍其作用和语法.</p>\n<p>通过<code>EventTarget.adddEventListener()</code>的方法, 将指定的监听器注册到对象上, 具体的语法如下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener);</span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener, options);</span><br><span class=\"line\"><span class=\"title function_\">addEventListener</span>(type, listener, useCapture);</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>type</code>: 事件类型, 如<code>click</code>, <code>mouseover</code>, <code>mouseout</code>, <code>keydown</code>, <code>keyup</code>等;</li>\n<li><code>listener</code>: 事件处理函数, 该函数将在事件发生时被调用;<ul>\n<li>包括 <strong>回调函数</strong> 以及 实现了 <strong>EventListener 接口的对象</strong>;</li>\n</ul>\n</li>\n<li><code>options</code>: 可选参数, 用于配置事件监听器的行为;<blockquote>\n<p>可以为单个事件添加多个事件监听器.</p>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"listener\"><a href=\"#listener\" class=\"headerlink\" title=\"listener\"></a>listener</h4><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">回</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">调</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">函</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">数</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 简单来说, ~指的是当某个事件发生时被调用的一段代码.</p>\n<ul>\n<li>是一个函数, 但是只有等到特定的事件发生时才会执行.</li>\n</ul>\n<p>实现了 EventListener 接口的对象:</p>\n<ul>\n<li><strong>特点</strong>: 以对象作为listener, 对象中具有名为<code>handleEvent()</code>的方法;</li>\n<li><strong>作用</strong>: <ul>\n<li>将事件处理封装到一个对象当中, 可以更好地组织代码;</li>\n<li>便于在对象中保存更多的状态信息;</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> listenerObject = {</span><br><span class=\"line\">    <span class=\"attr\">count</span>: <span class=\"number\">0</span>,</span><br><span class=\"line\">    <span class=\"title function_\">handleEvent</span>(<span class=\"params\">event</span>) {</span><br><span class=\"line\">        <span class=\"variable language_\">this</span>.<span class=\"property\">count</span>++;</span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`事件类型是：<span class=\"subst\">${event.type}</span>，已触发 <span class=\"subst\">${<span class=\"variable language_\">this</span>.count}</span> 次`</span>);</span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> button = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'button'</span>);</span><br><span class=\"line\">button.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, listenerObject);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"options\"><a href=\"#options\" class=\"headerlink\" title=\"options\"></a>options</h4><p>一个指定有关 listener 属性的可选参数对象.</p>\n<h5 id=\"Capture\"><a href=\"#Capture\" class=\"headerlink\" title=\"Capture\"></a>Capture</h5><ul>\n<li><p>含义:</p>\n<ul>\n<li>一个布尔值，表示 listener 会在该类型的事件捕获阶段传播到该 EventTarget 时触发;</li>\n<li>默认为false, 表示只有在冒泡阶段才触发.</li>\n</ul>\n</li>\n<li><p>区别:</p>\n<ul>\n<li><code>capture</code>和<code>useCapture</code>实际上指的都是 <strong>监听器是否在捕获阶段触发</strong> 的布尔值.<blockquote>\n<p>捕获阶段: 从最外层的元素开始, 逐层向内捕获事件, 直到事件到达目标元素.</p>\n</blockquote>\n</li>\n<li>后来DOM的规范更新时引入了<code>options</code>参数, 此后<code>capture</code>取代了<code>useCapture</code>的作用.</li>\n<li>如果<code>addEventListener</code>的第三个参数不指定对象, 只有布尔值, 那么默认是在设置<code>useCapture</code></li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>可以先查看<a href=\"#%E4%BA%8B%E4%BB%B6%E4%BC%A0%E6%92%AD%E7%9A%84%E9%98%B6%E6%AE%B5\">事件传播的阶段</a>来辅助理解不同的阶段.</p>\n</blockquote>\n<h5 id=\"Once\"><a href=\"#Once\" class=\"headerlink\" title=\"Once\"></a>Once</h5><ul>\n<li>含义:<ul>\n<li>一个布尔值，表示 listener 在添加之后最多只调用一次;</li>\n<li>默认为false, 表示可以多次调用.</li>\n</ul>\n</li>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">child.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'子元素 - 目标阶段'</span>);</span><br><span class=\"line\">},{<span class=\"attr\">once</span>: <span class=\"literal\">true</span>});</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>once</code>属性被设置为<code>true</code>, 当调用一次之后事件监听器会被自动清除. 因此只有第一次的点击才会console.</p>\n</blockquote>\n<h5 id=\"Passive\"><a href=\"#Passive\" class=\"headerlink\" title=\"Passive\"></a>Passive</h5><ul>\n<li><p>含义:</p>\n<ul>\n<li>一个布尔值，设置为 true 时，表示 listener 永远不会调用 preventDefault();</li>\n</ul>\n</li>\n<li><p>作用:</p>\n<ul>\n<li>明确不会在<code>listener</code>中不会调用<code>preventDefault()</code>方法, 即不会阻止浏览器的<a href=\"#%E9%BB%98%E8%AE%A4%E8%A1%8C%E4%B8%BA\">默认行为</a>;</li>\n<li>此时, 浏览器可以直接渲染默认行为的结果, 无需等待<code>listener</code>的执行与默认行为的检查, 从而提高了性能.</li>\n</ul>\n</li>\n<li><p>Notice:</p>\n<ul>\n<li>如果设置<code>passive</code>为<code>true</code>, 则<code>listener</code>当中不可出现<code>preventDefault()</code>方法, 否则会报错.</li>\n</ul>\n</li>\n</ul>\n<p>e.g.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'wheel'</span>,<span class=\"function\">()=&gt;</span>{</span><br><span class=\"line\">\tevent.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"scrolling\"</span>);</span><br><span class=\"line\">},{<span class=\"attr\">passive</span>: <span class=\"literal\">false</span>});</span><br></pre></td></tr></table></figure>\n<ul>\n<li><code>wheel</code>事件的默认行为是滚动页面;</li>\n<li><code>event.preventDefault();</code>表示会阻止鼠标滚动带来的页面滚动;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'wheel'</span>,<span class=\"function\">()=&gt;</span>{</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"scrolling\"</span>);</span><br><span class=\"line\">},{<span class=\"attr\">passive</span>: <span class=\"literal\">true</span>});</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>明确不会阻止默认行为, 浏览器可以直接渲染页面的滚动效果, 因此提高了显示的效果.</p>\n</blockquote>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'wheel'</span>,<span class=\"function\">()=&gt;</span>{</span><br><span class=\"line\">  event.<span class=\"title function_\">preventDefault</span>();</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">\"scrolling\"</span>);</span><br><span class=\"line\">},{<span class=\"attr\">passive</span>: <span class=\"literal\">true</span>});</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>passive</code>的设置与<code>listener</code>内部矛盾, 将会报错.</p>\n</blockquote>\n<h5 id=\"Signal\"><a href=\"#Signal\" class=\"headerlink\" title=\"Signal\"></a>Signal</h5><p>用于有条件地移除事件监听器, 具体使用参见<a href=\"#%E5%8F%AF%E8%A2%AB%E7%A7%BB%E9%99%A4%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8\">可被移除的监听器</a>.</p>\n<h3 id=\"事件传播的阶段\"><a href=\"#事件传播的阶段\" class=\"headerlink\" title=\"事件传播的阶段\"></a>事件传播的阶段</h3><ol>\n<li>捕获阶段 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.156ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"13.819ex\" height=\"2.726ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 6108 1205\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><path data-c=\"1D450\" d=\"M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(433,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(962,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1465,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1826,0)\"><path data-c=\"1D462\" d=\"M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2398,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2849,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(3315,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3565,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4068,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4644,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(5173,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(5642,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-659)\"><svg width=\"6108\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1527 148 6108 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(18.324,1)\"></path></svg></g></g></g></g></svg></mjx-container>: 事件从根节点开始向目标节点传播;<blockquote>\n<p>e.g. 点击事件从document开始传播, 经过html,body直到目标元素.</p>\n</blockquote>\n</li>\n<li>目标阶段阶段 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.181ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12.303ex\" height=\"2.751ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 5438 1216\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(361,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(890,0)\"><path data-c=\"1D45F\" d=\"M21 287Q22 290 23 295T28 317T38 348T53 381T73 411T99 433T132 442Q161 442 183 430T214 408T225 388Q227 382 228 382T236 389Q284 441 347 441H350Q398 441 422 400Q430 381 430 363Q430 333 417 315T391 292T366 288Q346 288 334 299T322 328Q322 376 378 392Q356 405 342 405Q286 405 239 331Q229 315 224 298T190 165Q156 25 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 114 189T154 366Q154 405 128 405Q107 405 92 377T68 316T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1341,0)\"><path data-c=\"1D454\" d=\"M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1818,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2284,0)\"><path data-c=\"1D461\" d=\"M26 385Q19 392 19 395Q19 399 22 411T27 425Q29 430 36 430T87 431H140L159 511Q162 522 166 540T173 566T179 586T187 603T197 615T211 624T229 626Q247 625 254 615T261 596Q261 589 252 549T232 470L222 433Q222 431 272 431H323Q330 424 330 420Q330 398 317 385H210L174 240Q135 80 135 68Q135 26 162 26Q197 26 230 60T283 144Q285 150 288 151T303 153H307Q322 153 322 145Q322 142 319 133Q314 117 301 95T267 48T216 6T155 -11Q125 -11 98 4T59 56Q57 64 57 83V101L92 241Q127 382 128 383Q128 385 77 385H26Z\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(2645,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2895,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3398,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3974,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4503,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4972,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-670)\"><svg width=\"5438\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1359.5 148 5438 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(16.314,1)\"></path></svg></g></g></g></g></svg></mjx-container>: 事件到达目标元素;</li>\n<li>冒泡阶段 <mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.156ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"12.253ex\" height=\"2.726ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -694 5416 1205\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><path data-c=\"1D44F\" d=\"M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(429,0)\"><path data-c=\"1D462\" d=\"M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1001,0)\"><path data-c=\"1D44F\" d=\"M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1430,0)\"><path data-c=\"1D44F\" d=\"M73 647Q73 657 77 670T89 683Q90 683 161 688T234 694Q246 694 246 685T212 542Q204 508 195 472T180 418L176 399Q176 396 182 402Q231 442 283 442Q345 442 383 396T422 280Q422 169 343 79T173 -11Q123 -11 82 27T40 150V159Q40 180 48 217T97 414Q147 611 147 623T109 637Q104 637 101 637H96Q86 637 83 637T76 640T73 647ZM336 325V331Q336 405 275 405Q258 405 240 397T207 376T181 352T163 330L157 322L136 236Q114 150 114 114Q114 66 138 42Q154 26 178 26Q211 26 245 58Q270 81 285 114T318 219Q336 291 336 325Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1859,0)\"><path data-c=\"1D459\" d=\"M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2157,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g><g data-mml-node=\"mtext\" transform=\"translate(2623,0)\"><path data-c=\"A0\" d=\"\"></path></g><g data-mml-node=\"mi\" transform=\"translate(2873,0)\"><path data-c=\"1D45D\" d=\"M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3376,0)\"><path data-c=\"210E\" d=\"M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(3952,0)\"><path data-c=\"1D44E\" d=\"M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4481,0)\"><path data-c=\"1D460\" d=\"M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(4950,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-659)\"><svg width=\"5416\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1354 148 5416 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(16.248,1)\"></path></svg></g></g></g></g></svg></mjx-container>: 事件从目标元素开始沿着DOM树向上传播.</li>\n</ol>\n<h4 id=\"Case\"><a href=\"#Case\" class=\"headerlink\" title=\"Case\"></a>Case</h4><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"parent\"</span>&gt;</span></span><br><span class=\"line\">  parent</span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">div</span> <span class=\"attr\">id</span>=<span class=\"string\">\"child\"</span>&gt;</span>child<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parent = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'#parent'</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'#child'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">parent.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父元素 - 冒泡阶段'</span>);</span><br><span class=\"line\">});</span><br><span class=\"line\"></span><br><span class=\"line\">parent.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父元素 - 捕获阶段'</span>);</span><br><span class=\"line\">}, { <span class=\"attr\">capture</span>: <span class=\"literal\">true</span> });</span><br><span class=\"line\"></span><br><span class=\"line\">child.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'子元素 - 目标阶段'</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure>\n<p>上述的<code>child</code>被包裹在<code>parent</code>内部.</p>\n<ul>\n<li>当点击<code>parent</code>时将会显示:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"父元素 - 捕获阶段\"</span></span><br><span class=\"line\"><span class=\"string\">\"父元素 - 冒泡阶段\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>由于设置了在捕获阶段就触发, 所以先触发了捕获阶段的监听器, 然后再触发冒泡阶段的监听器;</p>\n</blockquote>\n<ul>\n<li>当点击<code>child</code>时将会显示:</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"父元素 - 捕获阶段\"</span></span><br><span class=\"line\"><span class=\"string\">\"子元素 - 目标阶段\"</span></span><br><span class=\"line\"><span class=\"string\">\"父元素 - 冒泡阶段\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><code>child</code>是整个事件流的目标元素, 所以触发时机介于二者之间.</p>\n</blockquote>\n<h4 id=\"Notice\"><a href=\"#Notice\" class=\"headerlink\" title=\"Notice\"></a>Notice</h4><ol>\n<li><p>如果将<code>div</code>换成<code>button</code>, 则点击<code>child</code>时可能只会显示 <strong>目标</strong> 阶段的输出.</p>\n<blockquote>\n<p>这是因为, 不同浏览器对于<code>button</code>元素的默认行为不同, 可能默认阻止了捕获阶段和冒泡阶段</p>\n</blockquote>\n</li>\n<li><p><code>event.stopPropagation();</code>加入该<del>咒语</del>代码可以在此停止事件的传播, 比如可以在上述的捕获阶段监听器加入该代码:</p>\n</li>\n</ol>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parent.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'父元素 - 捕获阶段'</span>);</span><br><span class=\"line\">    event.<span class=\"title function_\">stopPropagation</span>();</span><br><span class=\"line\">}, { <span class=\"attr\">capture</span>: <span class=\"literal\">true</span> });</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此时, 点击<code>parent</code>时, 只会触发捕获阶段的监听器, 不会触发冒泡阶段的监听器.</p>\n</blockquote>\n<h3 id=\"可被移除的监听器\"><a href=\"#可被移除的监听器\" class=\"headerlink\" title=\"可被移除的监听器\"></a>可被移除的监听器</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">table</span> <span class=\"attr\">id</span>=<span class=\"string\">\"outside\"</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">id</span>=<span class=\"string\">\"t1\"</span>&gt;</span>one<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">td</span> <span class=\"attr\">id</span>=<span class=\"string\">\"t2\"</span>&gt;</span>two<span class=\"tag\">&lt;/<span class=\"name\">td</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;/<span class=\"name\">tr</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">table</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 为 table 添加可被移除的事件监听器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> controller = <span class=\"keyword\">new</span> <span class=\"title class_\">AbortController</span>();</span><br><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"outside\"</span>);</span><br><span class=\"line\">el.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"click\"</span>, modifyText, { <span class=\"attr\">signal</span>: controller.<span class=\"property\">signal</span> });</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 改变 t2 内容的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">modifyText</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t2 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> === <span class=\"string\">\"three\"</span>) {</span><br><span class=\"line\">    t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> = <span class=\"string\">\"two\"</span>;</span><br><span class=\"line\">  } <span class=\"keyword\">else</span> {</span><br><span class=\"line\">    t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> = <span class=\"string\">\"three\"</span>;</span><br><span class=\"line\">    controller.<span class=\"title function_\">abort</span>(); <span class=\"comment\">// 当值变为 \"three\" 后，移除监听器</span></span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li><code>AbortController</code>是一个构造函数, 用于创建一个可被移除的事件监听器的控制器;</li>\n<li><code>signal</code>属性是一个<code>AbortSignal</code>对象, 用于控制监听器的移除;</li>\n<li><code>controller.abort()</code>方法用于移除监听器;</li>\n<li>当<code>t2</code>的内容变为”three”时, 移除监听器, 使得<code>modifyText</code>函数不再执行. 此后, 点击<code>t2</code>不会触发<code>modifyText</code>函数.</li>\n</ul>\n</blockquote>\n<p>具体的<strong>构造步骤:</strong></p>\n<ol>\n<li>创建一个<code>AbortController</code>实例: <code>const controller = new AbortController();</code></li>\n<li>在事件监听器内的参数中添加<code>signal: controller.signal</code>选项;</li>\n<li>在需要移除监听器的地方调用<code>controller.abort()</code>方法;</li>\n</ol>\n<hr>\n<p>我们也可以直接使用<code>removeEventListener()</code>方法来移除事件监听器:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title function_\">removeEventListener</span>(type, listener);</span><br><span class=\"line\"><span class=\"title function_\">removeEventListener</span>(type, listener, options);</span><br><span class=\"line\"><span class=\"title function_\">removeEventListener</span>(type, listener, useCapture);</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>Notices:<ul>\n<li>如果同一个对象上存在2个事件监听器, 且仅在<code>useCapture</code>参数存在差异, 那么需要先后2次调用<code>removeEventListener()</code>方法才能完全移除其事件监听器;</li>\n<li>如果无法匹配当前注册的事件监听器, 那么该函数将不会起任何作用;</li>\n<li><code>type</code>,<code>listener</code>参数必须完全匹配才能移除事件监听器;</li>\n<li>对于<code>options</code>参数:<ul>\n<li>字段相同: 一定可以移除;</li>\n<li>字段不同: 需要与默认值false匹配才可以移除.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">passive</span>: <span class=\"literal\">true</span> });</span><br><span class=\"line\"></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">passive</span>: <span class=\"literal\">true</span> }); <span class=\"comment\">// 成功</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">capture</span>: <span class=\"literal\">false</span> }); <span class=\"comment\">// 成功</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">capture</span>: <span class=\"literal\">true</span> }); <span class=\"comment\">// 失败</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, { <span class=\"attr\">passive</span>: <span class=\"literal\">false</span> }); <span class=\"comment\">// 成功</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, <span class=\"literal\">false</span>); <span class=\"comment\">// 成功</span></span><br><span class=\"line\">element.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"mousedown\"</span>, handleMouseDown, <span class=\"literal\">true</span>); <span class=\"comment\">// 失败</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p><strong>添加与移除</strong>的结合使用:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> body = <span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">\"body\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> clickTarget = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"click-target\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> mouseOverTarget = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"mouse-over-target\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> toggle = <span class=\"literal\">false</span>;</span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">makeBackgroundYellow</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  body.<span class=\"property\">style</span>.<span class=\"property\">backgroundColor</span> = toggle ? <span class=\"string\">\"white\"</span> : <span class=\"string\">\"yellow\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  toggle = !toggle;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\">clickTarget.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"click\"</span>, makeBackgroundYellow, <span class=\"literal\">false</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">mouseOverTarget.<span class=\"title function_\">addEventListener</span>(<span class=\"string\">\"mouseover\"</span>, <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">  clickTarget.<span class=\"title function_\">removeEventListener</span>(<span class=\"string\">\"click\"</span>, makeBackgroundYellow, <span class=\"literal\">false</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"使用匿名函数\"><a href=\"#使用匿名函数\" class=\"headerlink\" title=\"使用匿名函数\"></a>使用匿名函数</h3><p>在上述<code>html</code>例子下:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改变 t2 内容的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">modifyText</span>(<span class=\"params\">new_text</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">const</span> t2 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">  t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> = new_text;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用匿名函数为 table 添加事件监听器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"outside\"</span>);</span><br><span class=\"line\">el.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">\"click\"</span>,</span><br><span class=\"line\">  <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"title function_\">modifyText</span>(<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"literal\">false</span>,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>通过匿名函数封装代码, 将参数传入函数<code>modifyText</code>, 使得函数可以被调用.</p>\n<h3 id=\"使用箭头函数\"><a href=\"#使用箭头函数\" class=\"headerlink\" title=\"使用箭头函数\"></a>使用箭头函数</h3><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 改变 t2 内容的函数</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">modifyText</span>(<span class=\"params\">new_text</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">var</span> t2 = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"t2\"</span>);</span><br><span class=\"line\">  t2.<span class=\"property\">firstChild</span>.<span class=\"property\">nodeValue</span> = new_text;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 用箭头函数为 table 添加事件监听器</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> el = <span class=\"variable language_\">document</span>.<span class=\"title function_\">getElementById</span>(<span class=\"string\">\"outside\"</span>);</span><br><span class=\"line\">el.<span class=\"title function_\">addEventListener</span>(</span><br><span class=\"line\">  <span class=\"string\">\"click\"</span>,</span><br><span class=\"line\">  <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">    <span class=\"title function_\">modifyText</span>(<span class=\"string\">\"four\"</span>);</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"literal\">false</span>,</span><br><span class=\"line\">);</span><br></pre></td></tr></table></figure>\n<p>通过<code>=&gt;{}</code>形式的箭头函数简化代码书写.</p>\n<hr>\n<h4 id=\"比较匿名与箭头\"><a href=\"#比较匿名与箭头\" class=\"headerlink\" title=\"比较匿名与箭头\"></a>比较匿名与箭头</h4><p>匿名函数与箭头函数在此处的应用基本相同, 但是在<code>this</code>的指向上有所不同:</p>\n<ul>\n<li>匿名函数与其他普通的JS函数:<code>this</code>指向调用它的对象之作用域(如果没有直接调用关系, 默认为全局对象, 且严格模式下为<code>undefined</code>);</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">sayHello</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>); <span class=\"comment\">// 在非严格模式下，this 指向 window</span></span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"title function_\">sayHello</span>();</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>箭头函数的<code>this</code>继承自外部作用域, 即调用该方法的对象.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"ZJU\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">greet</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>); <span class=\"comment\">// this 指向 obj</span></span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\">obj.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 输出：ZJU</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">  <span class=\"attr\">name</span>: <span class=\"string\">\"ZJU\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">getNameWithAnonymous</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">    };</span><br><span class=\"line\">  },</span><br><span class=\"line\">  <span class=\"attr\">getNameWithArrow</span>: <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">() =&gt;</span> {</span><br><span class=\"line\">      <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">name</span>);</span><br><span class=\"line\">    };</span><br><span class=\"line\">  },</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> anonymousFn = obj.<span class=\"title function_\">getNameWithAnonymous</span>();</span><br><span class=\"line\"><span class=\"title function_\">anonymousFn</span>(); <span class=\"comment\">// 输出：undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> arrowFn = obj.<span class=\"title function_\">getNameWithArrow</span>();</span><br><span class=\"line\"><span class=\"title function_\">arrowFn</span>(); <span class=\"comment\">// 输出：ZJU</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>进一步完善.</p>\n</blockquote>\n<h3 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">事</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">件</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">对</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">象</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 在事件处理函数的内部, 以固定指定名称出现的参数, 例如<code>event</code>,<code>e</code>,<code>evt</code>. 它被自动传递给事件处理函数，以提供额外的功能和信息。</p>\n<p><code>e.target</code>始终是对 <strong>事件刚刚发生的元素</strong> 的引用</p>\n<h2 id=\"表达式和运算符\"><a href=\"#表达式和运算符\" class=\"headerlink\" title=\"表达式和运算符\"></a>表达式和运算符</h2><h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new()\"></a>new()</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -0.742ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"4.032ex\" height=\"1.744ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -443 1782 771\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><path data-c=\"1D45B\" d=\"M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(600,0)\"><path data-c=\"1D452\" d=\"M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z\"></path></g><g data-mml-node=\"mi\" transform=\"translate(1066,0)\"><path data-c=\"1D464\" d=\"M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z\"></path></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-476)\"><svg width=\"1782\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"445.5 148 1782 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(5.346,1)\"></path></svg></g></g></g></g></svg></mjx-container> 用来创建对象实例的一个关键字. </p>\n<ul>\n<li>作用: <strong>调用</strong> 一个 构造函数, 并返回一个由该构造函数创建的对象实例.</li>\n</ul>\n<h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> constructor</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title function_\">constructor</span>(<span class=\"params\"></span>)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title function_\">constructor</span>(<span class=\"params\">arg1</span>)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title function_\">constructor</span>(<span class=\"params\">arg1, arg2</span>)</span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"title function_\">constructor</span>(<span class=\"params\">arg1, arg2, <span class=\"comment\">/* …, */</span> argN</span>)</span><br></pre></td></tr></table></figure>\n<ol>\n<li>如果没有指定参数, 默认为在不带参数的情况下调用构造函数. 即<code>new foo</code> 等价于 <code>new foo()</code>;</li>\n<li>构造函数内部的<code>this</code>将被绑定到新建的对象实例上;</li>\n</ol>\n<ul>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\">color, brand</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">color</span> = color;   <span class=\"comment\">// 将 color 赋值给新对象</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">brand</span> = brand;   <span class=\"comment\">// 将 brand 赋值给新对象</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> myCar = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>(<span class=\"string\">\"red\"</span>, <span class=\"string\">\"Toyota\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myCar.<span class=\"property\">color</span>); <span class=\"comment\">// 输出 \"red\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(myCar.<span class=\"property\">brand</span>); <span class=\"comment\">// 输出 \"Toyota\"</span></span><br></pre></td></tr></table></figure>\n\n<p>使用<code>new()</code>的<strong>步骤</strong>:</p>\n<ol>\n<li>定义构造函数;</li>\n<li>使用<code>new()</code>并传入构造函数的参数;</li>\n<li>将返回的对象实例赋值给一个变量;</li>\n</ol>\n<h4 id=\"新增属性\"><a href=\"#新增属性\" class=\"headerlink\" title=\"新增属性\"></a>新增属性</h4><ul>\n<li>为已经定义的对象实例直接新增属性, 但是不会影响其他相同类型的对象和构造函数本身:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">car1.<span class=\"property\">color</span> = <span class=\"string\">\"black\"</span> <span class=\"comment\">//为car1新增color属性</span></span><br></pre></td></tr></table></figure>\n<br>\n\n<ul>\n<li>添加共享属性到构造函数中的<code>prototype</code>:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\"></span>) {}</span><br><span class=\"line\">car1 = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>();</span><br><span class=\"line\">car2 = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car1.<span class=\"property\">color</span>); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Car</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">color</span> = <span class=\"string\">\"原色\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car1.<span class=\"property\">color</span>); <span class=\"comment\">// '原色'</span></span><br><span class=\"line\"></span><br><span class=\"line\">car1.<span class=\"property\">color</span> = <span class=\"string\">\"黑色\"</span>;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car1.<span class=\"property\">color</span>); <span class=\"comment\">// '黑色'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(car1).<span class=\"property\">color</span>); <span class=\"comment\">// '原色'</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title class_\">Object</span>.<span class=\"title function_\">getPrototypeOf</span>(car2).<span class=\"property\">color</span>); <span class=\"comment\">// '原色'</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car1.<span class=\"property\">color</span>); <span class=\"comment\">// '黑色'</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(car2.<span class=\"property\">color</span>); <span class=\"comment\">// '原色'</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>此处的构造函数名为<code>Car</code>, 因此通过<code>Car.prototype</code>可以访问到构造函数的原型对象;</li>\n<li><code>getPrototypeOf</code> 表示获取对象的<strong>原型对象</strong>, 因此此处均为最初定义的 <strong>原色</strong>.</li>\n</ul>\n</blockquote>\n<h4 id=\"new-target\"><a href=\"#new-target\" class=\"headerlink\" title=\"new.target\"></a>new.target</h4><p>函数通过<code>new.target</code>属性可以判断是否通过<code>new</code>关键字调用, 即构造.</p>\n<ul>\n<li><p>如果函数是正常调用, 则返回<code>undefined</code>;</p>\n</li>\n<li><p>如果函数是通过<code>new</code>调用, 返回被调用的构造函数.</p>\n</li>\n<li><p>e.g.</p>\n</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\">color</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!<span class=\"keyword\">new</span>.<span class=\"property\">target</span>) {</span><br><span class=\"line\">    <span class=\"comment\">// 以函数的形式被调用。</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">`<span class=\"subst\">${color}</span>车`</span>;</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">// 通过 new 被调用。</span></span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">color</span> = color;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"title class_\">Car</span>(<span class=\"string\">\"红\"</span>); <span class=\"comment\">// a 是“红车”</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>(<span class=\"string\">\"红\"</span>); <span class=\"comment\">// b 是 `Car { color: \"红\" }`</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对象类型与实例\"><a href=\"#对象类型与实例\" class=\"headerlink\" title=\"对象类型与实例\"></a>对象类型与实例</h4><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">对</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">象</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">类</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">型</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 通过构造函数可以创建一个对象类型:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\">make, model, year</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">make</span> = make;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">model</span> = model;</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">year</span> = year;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">对</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">象</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">实</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">例</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 通过使用<code>new()</code>方法, 由对象类型构造一个对象实例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> myCar = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>(<span class=\"string\">\"鹰牌\"</span>, <span class=\"string\">\"Talon TSi\"</span>, <span class=\"number\">1993</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"类与new\"><a href=\"#类与new\" class=\"headerlink\" title=\"类与new\"></a>类与new</h4><p>在JS当中, 类 <strong>必须</strong> 通过<code>new</code>调用.</p>\n<blockquote>\n<p>可以优先阅读<a href=\"#%E7%B1%BB\">类相关的知识</a></p>\n</blockquote>\n<ul>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Animal</span> {</span><br><span class=\"line\">  <span class=\"comment\">//构造函数</span></span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  }</span><br><span class=\"line\">  <span class=\"comment\">//实例方法</span></span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`你好，我的名字是<span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n<p>对于上述的类, 必须使用如下的调用方式:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> animal = <span class=\"keyword\">new</span> <span class=\"title class_\">Animal</span>(<span class=\"string\">\"Dog\"</span>); <span class=\"comment\">// 正常</span></span><br></pre></td></tr></table></figure>\n<p>而下面这样类似于普通函数的调用方式会抛出错误:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"title class_\">Animal</span>(<span class=\"string\">\"Cat\"</span>); <span class=\"comment\">// TypeError:  Class constructor Animal cannot be invoked without 'new'</span></span><br></pre></td></tr></table></figure>\n<br>\n\n<p>在使用正确方法得到类的实例对象之后, 可以用访问属性的方式来调用实例方法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animal.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 输出 \"你好，我的名字是Dog\"</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>下面给出与普通函数的区别:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Car</span>(<span class=\"params\">model</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">model</span> = model;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> car = <span class=\"keyword\">new</span> <span class=\"title class_\">Car</span>(<span class=\"string\">\"Toyota\"</span>); <span class=\"comment\">// 正常</span></span><br><span class=\"line\"><span class=\"title class_\">Car</span>(<span class=\"string\">\"Honda\"</span>); <span class=\"comment\">// 不抛出错误，但 this 会指向全局对象.</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> anotherCar = <span class=\"title class_\">Car</span>(<span class=\"string\">\"cat\"</span>); <span class=\"comment\">//此时全局对象下的model值为 \"cat\", 覆盖了上一行的定义.</span></span><br></pre></td></tr></table></figure>\n<p>总结:</p>\n<ul>\n<li>以构造函数形式呈现的普通函数, 可以被直接调用, 但是此时内部的参数赋值给了全局对象;</li>\n<li>如果以new方法构造得到对象实例, 依旧正常.</li>\n</ul>\n<hr>\n<h1 id=\"补充\"><a href=\"#补充\" class=\"headerlink\" title=\"补充\"></a>补充</h1><h2 id=\"默认行为\"><a href=\"#默认行为\" class=\"headerlink\" title=\"默认行为\"></a>默认行为</h2><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">默</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">认</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">行</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">为</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 是指浏览器在某些事件发生时，自动执行的内置操作, 是浏览器的“默认反应”.</p>\n<ul>\n<li>比如存在以下的默认行为:<ul>\n<li>滚动事件：触摸屏上滑动手指，页面会滚动;</li>\n<li>拖拽文件到浏览器：浏览器会尝试加载文件;</li>\n<li>点击链接 <code>(&lt;a href=\"...\"&gt;)</code>：跳转到指定的 URL;</li>\n</ul>\n</li>\n</ul>\n<p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"13.575ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 6000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">阻</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">止</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">默</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">认</text></g><g data-mml-node=\"mi\" transform=\"translate(4000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">行</text></g><g data-mml-node=\"mi\" transform=\"translate(5000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">为</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"6000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1500 148 6000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(18,1)\"></path></svg></g></g></g></g></svg></mjx-container> 使用 <code>event.preventDefault()</code> 方法可以阻止事件的默认行为.</p>\n<ul>\n<li>e.g: 阻止链接跳转</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">document</span>.<span class=\"title function_\">querySelector</span>(<span class=\"string\">'a'</span>).<span class=\"title function_\">addEventListener</span>(<span class=\"string\">'click'</span>, <span class=\"keyword\">function</span>(<span class=\"params\">event</span>) {</span><br><span class=\"line\">    event.<span class=\"title function_\">preventDefault</span>(); <span class=\"comment\">// 阻止点击链接时的默认行为</span></span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">'链接被点击，但没有跳转'</span>);</span><br><span class=\"line\">});</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>作用:<ul>\n<li>通过阻止默认行为, 可以实现自定义逻辑.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h2><ul>\n<li><code>this</code>可以视作函数的一个隐参数, 是在函数被执行时创建的绑定;</li>\n<li><code>this</code> 指向的是<strong>当前函数的调用者</strong>，而不是函数内部定义的变量.</li>\n</ul>\n<br>\n\n<ul>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"string\">\"b in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = <span class=\"string\">\"b in the function\"</span>; <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">b</span>); <span class=\"comment\">// 访问 this.b</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"string\">\"b outside of the func\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此处的<code>f</code></p>\n</blockquote>\n<h3 id=\"函数上下文中的this\"><a href=\"#函数上下文中的this\" class=\"headerlink\" title=\"函数上下文中的this\"></a>函数上下文中的this</h3><ul>\n<li><code>this</code>参数的值取决于函数<strong>如何</strong>被调用, 而不是函数如何被定义.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 对象可以作为第一个参数传递给 'call' 或 'apply'，</span></span><br><span class=\"line\"><span class=\"comment\">// 并且 'this' 将被绑定到它。</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = { <span class=\"attr\">a</span>: <span class=\"string\">\"Custom\"</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 var 声明的变量成为 'globalThis' 的属性。</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"Global\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">whatsThis</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>; <span class=\"comment\">// 'this' 取决于函数如何被调用</span></span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title function_\">whatsThis</span>(); <span class=\"comment\">// 'Global'; 在非严格模式下，'this' 参数默认为 'globalThis'</span></span><br><span class=\"line\">obj.<span class=\"property\">whatsThis</span> = whatsThis;</span><br><span class=\"line\">obj.<span class=\"title function_\">whatsThis</span>(); <span class=\"comment\">// 'Custom'; 'this' 参数被绑定到 obj</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li>同样是调用函数<code>whatsThis()</code>, 但是<code>this</code>参数被绑定到不同的对象上, 导致返回值不同;</li>\n<li>在非严格模式下, <code>this</code>参数默认指向<code>globalThis</code>, 即全局对象;</li>\n<li>对于典型函数, <code>this</code>指向函数访问的对象;</li>\n</ol>\n<ul>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">b</span>: <span class=\"string\">\"b in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> b = <span class=\"string\">\"b in the function\"</span>; <span class=\"comment\">// 函数作用域</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"variable language_\">this</span>.<span class=\"property\">b</span>); <span class=\"comment\">// 访问 this.b</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> b = <span class=\"string\">\"b outside of the func\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">obj.<span class=\"title function_\">f</span>();</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此处<code>f</code>作为<code>obj</code>对象的方法被调用, 因此普通函数的<code>this</code>指向<code>obj</code>.</p>\n</blockquote>\n<ul>\n<li>e.g. 直接调用的普通函数<code>this</code>指向全局:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">const</span> funcA = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) { <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> }; <span class=\"comment\">// 普通函数，this 由调用方式决定</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">funcA</span>()); <span class=\"comment\">// 访问 this.a</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"a in the global\"</span>;</span><br><span class=\"line\">obj.<span class=\"title function_\">f</span>(); <span class=\"comment\">// \"a in the global\"</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>此处的<code>funcA</code>并没有类似于作为对象的属性调用(<code>obj.funcA()</code>), 因此其<code>this</code>指向全局作用域(<code>window</code>), 输出<code>undefined</code>, 而是直接调用的形式, 因此其<code>this</code>指向全局作用域.</li>\n</ul>\n</blockquote>\n<h3 id=\"对this传值\"><a href=\"#对this传值\" class=\"headerlink\" title=\"对this传值\"></a>对this传值</h3><p>使用<code>call()</code>以及<code>apply()</code>方法可以将<code>this</code>绑定到其他对象上.</p>\n<h4 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"call()\"></a>call()</h4><ul>\n<li>形式: <code>func.call(thisArg, arg1, arg2, ...)</code></li>\n<li>e.g:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">c, d</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> + c + d;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = { <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数被绑定到隐式的 'this' 参数；</span></span><br><span class=\"line\"><span class=\"comment\">// 剩余的参数被绑定到命名参数。</span></span><br><span class=\"line\">add.<span class=\"title function_\">call</span>(o, <span class=\"number\">5</span>, <span class=\"number\">7</span>); <span class=\"comment\">// 16</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"apply\"><a href=\"#apply\" class=\"headerlink\" title=\"apply()\"></a>apply()</h4><ul>\n<li>形式: <code>func.apply(thisArg, [argsArray])</code></li>\n<li>e.g:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">c, d</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">b</span> + c + d;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = { <span class=\"attr\">a</span>: <span class=\"number\">1</span>, <span class=\"attr\">b</span>: <span class=\"number\">3</span> };</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 第一个参数被绑定到隐式的 'this' 参数；</span></span><br><span class=\"line\"><span class=\"comment\">// 第二个参数是一个数组，其成员被绑定到命名参数。</span></span><br><span class=\"line\">add.<span class=\"title function_\">apply</span>(o, [<span class=\"number\">10</span>, <span class=\"number\">20</span>]); <span class=\"comment\">// 34</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind()\"></a>bind()</h4><ul>\n<li>形式: <code>f.bind(someObject)</code>;</li>\n<li><strong>作用</strong>: <ul>\n<li>创建一个新的函数(需要重新赋值), 具有与<code>f</code>相同的函数体和作用域;</li>\n<li>新函数的<code>this</code>被 <strong>永久地</strong> 绑定到<code>someObject</code>, 不随调用方式的变化而变化.</li>\n</ul>\n</li>\n<li><strong>限制</strong>: <ul>\n<li><code>bind</code>无法多次生效. 即对函数f<code>bind</code>得到的g, 无法继续用<code>bind</code>得到期望的h;</li>\n</ul>\n</li>\n<li>e.g. 多次<code>bind</code>:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = f.<span class=\"title function_\">bind</span>({ <span class=\"attr\">b</span>: <span class=\"string\">\"azerty\"</span> });</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> h = g.<span class=\"title function_\">bind</span>({ <span class=\"attr\">a</span>: <span class=\"string\">\"yoo\"</span> }); <span class=\"comment\">// bind 只能生效一次！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">h</span>()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = { <span class=\"attr\">a</span>: <span class=\"number\">37</span>, f, g, h };</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o.<span class=\"property\">a</span>, o.<span class=\"title function_\">f</span>(), o.<span class=\"title function_\">g</span>(), o.<span class=\"title function_\">h</span>()); <span class=\"comment\">// 37 37 undefined undefined</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li>由于<code>bind</code>只能对一个原始函数作用, 因此由f得到的g无法继续由<code>bind</code>绑定<code>this</code>得到期望的h, 此处h的<code>this</code>依旧是<code>{b: \"azerty\"}</code>, 因此在输出对象<code>a</code>时显示<code>undefined</code>;</li>\n<li><code>o.f()</code>的调用是普通函数的调用, 因此其<code>this</code>继承自对象<code>o</code>, 输出<code>37</code>;</li>\n</ul>\n</blockquote>\n<ul>\n<li>e.g. 对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">f</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span> + <span class=\"string\">\" \"</span> + <span class=\"variable language_\">this</span>.<span class=\"property\">c</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> g = f.<span class=\"title function_\">bind</span>({ <span class=\"attr\">b</span>: <span class=\"string\">\"azerty\"</span> , <span class=\"attr\">c</span>:<span class=\"string\">\"ccc\"</span>});</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">g</span>()); <span class=\"comment\">// \"undefined ccc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> h = g.<span class=\"title function_\">bind</span>({ <span class=\"attr\">a</span>: <span class=\"string\">\"yoo\"</span> }); <span class=\"comment\">// bind 只能生效一次！</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">h</span>()); <span class=\"comment\">// \"undefined ccc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> o = { <span class=\"attr\">a</span>: <span class=\"number\">37</span>, f, g, h };</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(o.<span class=\"property\">a</span>, o.<span class=\"title function_\">f</span>(), o.<span class=\"title function_\">g</span>(), o.<span class=\"title function_\">h</span>()); <span class=\"comment\">// 37 37 azerty azerty</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<ul>\n<li><code>bind</code>绑定的<code>this</code>是永久覆盖, 而非简单叠加;</li>\n<li>由于<code>bind</code>绑定的<code>this</code>不随者调用方式的变化而变化, 因此即使处于对象<code>o</code>当中, <code>g</code>,<code>h</code>依旧不会输出<code>o</code>中的<code>a</code>.</li>\n</ul>\n</blockquote>\n<h3 id=\"箭头函数中的this\"><a href=\"#箭头函数中的this\" class=\"headerlink\" title=\"箭头函数中的this\"></a>箭头函数中的this</h3><p>使用 call()、apply() 或 bind() 调用箭头函数时，传入的 this 值会被忽略，但其他参数仍然会正常传递。</p>\n<p>普通函数:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"string\">\"a in the global\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> foo = <span class=\"keyword\">function</span> (<span class=\"params\"></span>) {<span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\"> <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\"> <span class=\"attr\">f</span>: foo</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>()); <span class=\"comment\">// \"a in the obj\"</span></span><br></pre></td></tr></table></figure>\n\n<p><code>call()</code>、 <code>apply()</code>、 <code>bind()</code> 无法改变箭头函数的<code>this</code>(但是call与apply的其他参数可以正常传递:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo</span> = (<span class=\"params\"></span>)=&gt; <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\"> <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\"> <span class=\"attr\">f</span>: foo.<span class=\"title function_\">bind</span>({<span class=\"attr\">a</span>:<span class=\"string\">\"a in the bind\"</span>}) <span class=\"comment\">// 显式绑定 this 到 obj, 但是无法生效</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>()); <span class=\"comment\">// undefined</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>换成普通函数则输出<code>a in the obj</code>.</p>\n</blockquote>\n<ul>\n<li>全局作用域</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"a in the global\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">foo1</span> = (<span class=\"params\"></span>) =&gt; <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">\t<span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">\t<span class=\"attr\">f</span>: <span class=\"function\">()=&gt;</span> a</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>());</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">作</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">用</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">域</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container> 指当前的执行上下文, 在其中的值和表达式可以被访问. </p>\n<ul>\n<li>全局作用域: 脚本模式运行所有代码的默认作用域;</li>\n<li>模块作用域: 模块模式中运行代码的作用域;</li>\n<li>函数作用域: 由函数创建的作用域</li>\n<li>块级作用域: 由<code>let</code>或<code>const</code>声明的变量的作用域.(对于<code>var</code>无效);</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">{</span><br><span class=\"line\">  <span class=\"keyword\">const</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">}</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(x); <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n\n<p>Notices:</p>\n<ul>\n<li>对象本身并不会创建作用域, 只是一个键值对的集合;</li>\n<li>箭头函数也不会创建自己的作用域, 而是 <strong>继承</strong> 外层作用域中的<code>this</code>;</li>\n</ul>\n<h3 id=\"变量与作用域\"><a href=\"#变量与作用域\" class=\"headerlink\" title=\"变量与作用域\"></a>变量与作用域</h3><ul>\n<li><code>var</code>在全局作用域中声明时会成为 <strong>全局对象</strong> (<code>window</code>或<code>global</code>)的属性;</li>\n<li><code>let</code>和<code>const</code>即使在全局作用域中声明, 也不会成为全局对象的属性;</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"1\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">let</span> b = <span class=\"string\">\"2\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">a</span>; <span class=\"comment\">// \"1\"</span></span><br><span class=\"line\"><span class=\"variable language_\">window</span>.<span class=\"property\">b</span>; <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因此, 建议在全局作用域中不要使用<code>var</code>声明变量, 而使用<code>let</code>或<code>const</code>声明变量. 从而避免导致意外的覆盖和冲突.</p>\n</blockquote>\n<h3 id=\"函数与作用域\"><a href=\"#函数与作用域\" class=\"headerlink\" title=\"函数与作用域\"></a>函数与作用域</h3><h4 id=\"普通函数\"><a href=\"#普通函数\" class=\"headerlink\" title=\"普通函数\"></a>普通函数</h4><p>普通函数和匿名函数的作用域继承自其定义时的作用域.</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">insideObj</span>: {</span><br><span class=\"line\">        <span class=\"attr\">g</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>; <span class=\"comment\">// 普通函数，this 动态绑定到 insideObj</span></span><br><span class=\"line\">        }</span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span>; <span class=\"comment\">// 普通函数，this 动态绑定到 obj</span></span><br><span class=\"line\">    }</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>());        <span class=\"comment\">// \"a in the obj\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">insideObj</span>.<span class=\"title function_\">g</span>()); <span class=\"comment\">// undefined，因为 insideObj 中没有 a</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"箭头函数-1\"><a href=\"#箭头函数-1\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><p>e.g. <strong>箭头函数继承外层作用域</strong>:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"string\">\"a in the global\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = {</span><br><span class=\"line\">    <span class=\"attr\">a</span>: <span class=\"string\">\"a in the obj\"</span>,</span><br><span class=\"line\">    <span class=\"attr\">insideObj</span>: {</span><br><span class=\"line\">        <span class=\"attr\">g</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span></span><br><span class=\"line\">    },</span><br><span class=\"line\">    <span class=\"attr\">f</span>: <span class=\"function\">() =&gt;</span> <span class=\"variable language_\">this</span>.<span class=\"property\">a</span></span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"title function_\">f</span>());        <span class=\"comment\">// \"a in the global\"</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(obj.<span class=\"property\">insideObj</span>.<span class=\"title function_\">g</span>()); <span class=\"comment\">//\"a in the global\"</span></span><br></pre></td></tr></table></figure>\n<p>由于对象不会创建作用域, 因此此处的箭头函数的<code>this</code>继承了外层作用域(window)的<code>this</code>, 且<code>var</code>创建的变量存在于全局作用域中.</p>\n<h2 id=\"语法糖\"><a href=\"#语法糖\" class=\"headerlink\" title=\"语法糖\"></a>语法糖</h2><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"6.787ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 3000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">语</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">法</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">糖</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"3000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"750 148 3000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(9,1)\"></path></svg></g></g></g></g></svg></mjx-container> 一种让代码更简洁、更易读的语法形式.</p>\n<ul>\n<li>本质上没有增加语言的功能, 而是对已有功能的 <strong>包装</strong> 或者优化;</li>\n<li><strong>可读性提升</strong>: <del>让代码更填</del> 使得代码更加容易理解和书写;</li>\n<li><strong>底层实现</strong>: 实质上依旧用基础的语法实现.</li>\n</ul>\n<h3 id=\"类\"><a href=\"#类\" class=\"headerlink\" title=\"类\"></a>类</h3><p>类 <code>class</code> 是 ES6 引入的语法糖, 它提供了面向对象编程的简洁语法. 本质上是对原型继承<code>prototype</code>的封装.</p>\n<p>使用<code>class</code>的写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span> {</span><br><span class=\"line\">  <span class=\"title function_\">constructor</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">  }</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"title function_\">greet</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, my name is <span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">  }</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">\"Alice\"</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 输出：Hello, my name is Alice</span></span><br></pre></td></tr></table></figure>\n\n<p>等价的原型写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">Person</span>(<span class=\"params\">name</span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">this</span>.<span class=\"property\">name</span> = name;</span><br><span class=\"line\">}</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"title class_\">Person</span>.<span class=\"property\"><span class=\"keyword\">prototype</span></span>.<span class=\"property\">greet</span> = <span class=\"keyword\">function</span>(<span class=\"params\"></span>) {</span><br><span class=\"line\">  <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"string\">`Hello, my name is <span class=\"subst\">${<span class=\"variable language_\">this</span>.name}</span>`</span>);</span><br><span class=\"line\">};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> person = <span class=\"keyword\">new</span> <span class=\"title class_\">Person</span>(<span class=\"string\">\"Alice\"</span>);</span><br><span class=\"line\">person.<span class=\"title function_\">greet</span>(); <span class=\"comment\">// 输出：Hello, my name is Alice</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"箭头函数-2\"><a href=\"#箭头函数-2\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><p>箭头函数简化了函数定义的书写, 其本质上依旧是一个普通函数, 因此也是语法糖的一种.</p>\n<ul>\n<li>e.g.</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 使用箭头函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"title function_\">add</span> = (<span class=\"params\">a, b</span>) =&gt; a + b;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等价的普通函数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> add = <span class=\"keyword\">function</span> <span class=\"title function_\">add</span>(<span class=\"params\">a, b</span>) {</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">}</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"结构赋值\"><a href=\"#结构赋值\" class=\"headerlink\" title=\"结构赋值\"></a>结构赋值</h3><p><mjx-container class=\"MathJax\" jax=\"SVG\"><svg style=\"vertical-align: -1.17ex;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"9.05ex\" height=\"2.867ex\" role=\"img\" focusable=\"false\" viewBox=\"0 -750 4000 1267\"><g stroke=\"currentColor\" fill=\"currentColor\" stroke-width=\"0\" transform=\"scale(1,-1)\"><g data-mml-node=\"math\"><g data-mml-node=\"munder\"><g data-mml-node=\"mrow\"><g data-mml-node=\"mi\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">结</text></g><g data-mml-node=\"mi\" transform=\"translate(1000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">构</text></g><g data-mml-node=\"mi\" transform=\"translate(2000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">赋</text></g><g data-mml-node=\"mi\" transform=\"translate(3000,0)\"><text data-variant=\"normal\" transform=\"scale(1,-1)\" font-size=\"884px\" font-family=\"serif\">值</text></g></g><g data-mml-node=\"mo\" transform=\"translate(0,-665)\"><svg width=\"4000\" height=\"237\" x=\"0\" y=\"148\" viewBox=\"1000 148 4000 237\"><path data-c=\"2013\" d=\"M0 248V285H499V248H0Z\" transform=\"scale(12,1)\"></path></svg></g></g></g></g></svg></mjx-container> 手动提取<strong>对象</strong>属性的语法糖.</p>\n<ul>\n<li>使用结构赋值:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = {<span class=\"attr\">name</span>:<span class=\"string\">\"Zhuo\"</span>, <span class=\"attr\">gender</span>:<span class=\"string\">\"male\"</span>};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> {name, gender} = person;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>等价的原型写法:</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = {<span class=\"attr\">name</span>:<span class=\"string\">\"Zhuo\"</span>, <span class=\"attr\">gender</span>:<span class=\"string\">\"male\"</span>};</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> name = person.<span class=\"property\">name</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> gender = person.<span class=\"property\">gender</span>;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"赋值规则\"><a href=\"#赋值规则\" class=\"headerlink\" title=\"赋值规则\"></a>赋值规则</h4><p>结构赋值时, 基于 <strong>属性名匹配</strong> 而非顺序.<br>因此, 对象结构的<code>{}</code>内部属性必须和 <strong>对象的属性名</strong> 相对应.</p>\n<p><strong>错误</strong>的示例:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = { <span class=\"attr\">name</span>: <span class=\"string\">\"Alice\"</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> };</span><br><span class=\"line\"><span class=\"keyword\">const</span> { a, b } = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 输出：undefined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// 输出：undefined</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>重命名属性</strong>的写法:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = { <span class=\"attr\">name</span>: <span class=\"string\">\"Alice\"</span>, <span class=\"attr\">age</span>: <span class=\"number\">25</span> };</span><br><span class=\"line\"><span class=\"keyword\">const</span> { <span class=\"attr\">name</span>: a, <span class=\"attr\">age</span>: b } = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 输出：Alice</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// 输出：25</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>手动赋值</strong>: 对于结构对象中不存在的属性, 可以采取普通赋值的方式与结构赋值相结合:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> person = { <span class=\"attr\">name</span>: <span class=\"string\">\"Alice\"</span> };</span><br><span class=\"line\"><span class=\"keyword\">const</span> { name, age = <span class=\"number\">30</span> } = person;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(name); <span class=\"comment\">// 输出：Alice</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(age);  <span class=\"comment\">// 输出：30 （因为 person 中没有 age 属性，所以使用了默认值）</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"数组的结构赋值\"><a href=\"#数组的结构赋值\" class=\"headerlink\" title=\"数组的结构赋值\"></a>数组的结构赋值</h4><p>上述讨论的结构赋值都是对 <strong>对象</strong> 的结构赋值, 对于数组同样可以结构赋值, 且赋值规则与对象相反—— <strong>基于顺序</strong>赋值:</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"string\">\"Alice\"</span>, <span class=\"number\">25</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> [a, b] = arr;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(a); <span class=\"comment\">// 输出：Alice</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(b); <span class=\"comment\">// 输出：25</span></span><br></pre></td></tr></table></figure>\n","_processedHighlight":true},{"title":"Swift学习摘记","date":"2025-04-17T12:21:21.000Z","excerpt":"学习swift中的基本语法和Swift-UI等框架知识.","thumbnail":"https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094625386.png?imageSlim","_content":"\n\n# 初见\n\n默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用 `_` 表示不使用参数标签:\n\n```swift\nfunc greet(_ person: String, on day: String) -> String {\n    return \"Hello \\(person), today is \\(day).\"\n}\ngreet(\"John\", on: \"Wednesday\")\n```\n\n> 参数标签指的是调用时候的名称, 参数名指的是函数内部.\n\n\n\n函数是第一等类型，这意味着函数可以作为另一个函数的返回值。\n\n```swift\nfunc makeIncrementer() -> ((Int) -> Int) {\n    func addOne(number: Int) -> Int {\n        return 1 + number\n    }\n    return addOne\n}\nvar increment = makeIncrementer()\nincrement(7)\n```\n\n\n\n函数也可以作为另一个函数的输入参数:\n\n```swift\nfunc hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {\n    for item in list {\n        if condition(item) {\n            return true\n        }\n    }\n    return false\n}\nfunc lessThanTen(number: Int) -> Bool {\n    return number < 10\n}\nvar numbers = [20, 19, 7, 12]\nhasAnyMatches(list: numbers, condition: lessThanTen)\n```\n\n\n\n可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。\n\n```swift\nlet sortedNumbers = numbers.sorted { $0 > $1 }\nprint(sortedNumbers)\n```\n\n\n\n\n\n`actor`与 `class`类似, 但是可以序列化访问, 保护共享、可变的数据.\n\n\n\n### 对象和类\n\n#### 构造与析构\n\n使用 `self.`替代 `this->`, 使用  `init` 和  `deinit`分别声明构造和析构函数:\n\n```swift\nclass NamedShape {\n    var numberOfSides: Int = 0\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n\n    func simpleDescription() -> String {\n        return \"A shape with \\(numberOfSides) sides.\"\n    }\n}\n```\n\n\n\n子类如果要重写父类的方法的话，需要用 `override` 标记:\n\n```swift\nclass Square: NamedShape {\n    var sideLength: Double\n\n    init(sideLength: Double, name: String) {\n        self.sideLength = sideLength\n        super.init(name: name)\n        numberOfSides = 4\n    }\n\n    func area() ->  Double {\n        return sideLength * sideLength\n    }\n\n    override func simpleDescription() -> String {\n        return \"A square with sides of length \\(sideLength).\"\n    }\n}\nlet test = Square(sideLength: 5.2, name: \"my test square\")\ntest.area()\ntest.simpleDescription()\n```\n\n> - 使用 `:className`的方法声明父类.\n> - `super.init` 是用来调用父类（超类）的初始化方法的。当创建一个子类的实例时，子类可能需要初始化一些自己的属性，同时还需要确保父类的属性也被正确初始化。这时就需要使用 `super.init` 来调用父类的初始化方法，完成父类的初始化过程\n> - 严格的顺序要求: 子类必须先初始化自己的属性，然后调用 `super.init`，最后才能访问或修改继承来的属性。\n\n\n\n### 计算属性\n\n#### 普通的计算属性\n\n在属性内部使用 `{}`并加上 `return`, 可以让访问这个属性的时候, 返回值由结构体的其他属性计算得到.\n\n```swift\nstruct Temperature {\n  var celsius: Double\n  var fahrenheit: Double{\n    return celsius *1.8 + 32\n  }\n  \n  init(celsius: Double){\n    self.celsius = celsius\n  }\n}\n```\n\n> 1. 此时实例化一个结构体就只需要给出一个属性的值.\n> 2. `self`在上述的Swift代码中是不可或缺的, 因为形参和内部属性的名称相同.\n\n\n\n#### 使用 getter 和 setter 的计算属性:\n\n```swift\nclass EquilateralTriangle: NamedShape {\n    var sideLength: Double = 0.0\n\n    init(sideLength: Double, name: String) {\n        self.sideLength = sideLength\n        super.init(name: name)\n        numberOfSides = 3\n    }\n\n    var perimeter: Double {\n      // 根据存储属性进行计算\n        get {\n            return 3.0 * sideLength\n        }\n      // 设置属性\n        set {\n            sideLength = newValue / 3.0\n        }\n    }\n\n    override func simpleDescription() -> String {\n        return \"An equilateral triangle with sides of length \\(sideLength).\"\n    }\n}\nvar triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\")\nprint(triangle.perimeter)\ntriangle.perimeter = 9.9\nprint(triangle.sideLength)\n```\n\n计算属性同样是一个属性, 但是根据调用方式的不同, 有返回和设置两种方式.\n\n```swift\ntriangle.perimeter = 9.9\nprint(triangle.perimeter)\n```\n\n\n\n### Mutating\n\n默认情况下, 结构体中的方法不能直接修改结构体的属性. 需要显式声明为 `mutating`:\n\n```swift\nstruct User{\n  let username:String\n  var isVisible:Bool = true\n  var friends: [string] = []\n  \n  mutating func addFriend(username: String){\n    friends.append(username)\n  }\n}\n```\n\n\n\n### 属性监视器\n\n\n\n使用 `willSet` 和 `didSet`。写入的代码会在属性值发生改变时调用，但不包含构造器中发生值改变的情况:\n\n- 分别可以使用 `newValue`与 `oldValue`来表示属性将要改变的值以及改变之前的值. \n\ne.g. 确保三角形的边长总是和正方形的边长相同。\n\n```swift\nclass TriangleAndSquare {\n    var triangle: EquilateralTriangle {\n        willSet {\n            square.sideLength = newValue.sideLength\n        }\n    }\n    var square: Square {\n        willSet {\n            triangle.sideLength = newValue.sideLength\n        }\n    }\n    init(size: Double, name: String) {\n        square = Square(sideLength: size, name: name)\n        triangle = EquilateralTriangle(sideLength: size, name: name)\n    }\n}\nvar triangleAndSquare = TriangleAndSquare(size: 10, name: \"another test shape\")\nprint(triangleAndSquare.square.sideLength)\nprint(triangleAndSquare.triangle.sideLength)\ntriangleAndSquare.square = Square(sideLength: 50, name: \"larger square\")\nprint(triangleAndSquare.triangle.sideLength)\n```\n\n\n\n### 枚举\n\n```swift\nenum Rank: Int {\n    case ace = 1\n    case two, three, four, five, six, seven, eight, nine, ten\n    case jack, queen, king\n    func simpleDescription() -> String {\n        switch self {\n        case .ace:\n            return \"ace\"\n        case .jack:\n            return \"jack\"\n        case .queen:\n            return \"queen\"\n        case .king:\n            return \"king\"\n        default:\n            return String(self.rawValue)\n        }\n    }\n}\nlet ace = Rank.ace\nlet aceRawValue = ace.rawValue\n```\n\n- 如果没有设置第一个成员的初始值, 默认从 `0` 开始;\n- 缺省值按照递增处理;\n-  `case`之外可以设置方法. \n\n\n\n使用 `init?(rawValue:)` 初始化构造器来从原始值创建一个枚举实例:\n\n```swift\nif let convertedRank = Rank（rawValue:3）｛\n\tlet threeDescription = convertedRank.simpleDescription（）\n｝\n```\n\n> - `if let`表示可选绑定, 安全地解包可选值\n\n\n\n\n\n#### 解包\n\n1. `if let`解包\n\n```swift\nif let A = B {\n  ...\n}\n```\n\n如果 `B`不是 nil, 就将其赋值给A, 然后执行 `{}`内部的语句. \n\n2. `??`\n\n```swift\nvar score : Int ?  = nil\n\nprint(score ?? default_score)\n// 成绩score不是nil, 就将其打印, 否则输出默认的成绩\n```\n\n\n\n对字典进行索引:\n\n```swift\n// scores是一个Int数组\nfor ( major, scores) in all_scores {\n  for score in scores{\n    ...\n  }\n}\n\n// 如果key没有使用, 可以直接忽略\nfor( _, socres) in all_scores{\n  ...\n}\n```\n\n\n\nswift支持对字典进行更新或者移除的时候, 返回并使用就值:\n\n```swift\nif let oldValue = scores.updateValue(100, forKey:\"fad\"){\n  print(..)\n}else{\n  ...\n}\n\nif let oldValue = scores.removeValue(forKey: \"fad\"){\n  print(\"fad's old value was \\(oldValue)\")\n}\n```\n\n \n\n\n\n- `@IBAction`表示组件交互和代码相绑定(允许在交互的时候执行外部定义的函数);\n- `@IBOutlet`表示允许代码的响应改变组件本身的状态(字体、大小等). \n\n<img src=\"swift.assets/image-20250412115454400.png\" alt=\"image-20250412115454400\" style=\"zoom:57%;\" />\n\n\n\n\n\n\n\n### 概念\n\n#### 闭包\n\n闭包指的是可以在特定位置运行的、不需要名称的函数.\n\n```swift\nscene.setOnStartHandler｛ \n// 闭包的主体\n｝\n```\n\n\n\n- `toggle()`可以自动切换变量的布尔值.\n\n  ```swift\n  Button(\"Press Me\") {\n      isOn.toggle()\n  }\n  ```\n\n\n\n#### 状态属性\n\n- 使用 `@State`在视图之外定义;\n- 当状态属性的值发生改变时, 会自动更新视图中相关的部分.\n\n- 对于状态对象, 使用 `@StateObject`来声明.\n\n#### 绑定\n\n由 `@Binding`声明将属性连接到其他地方, 允许子视图对属性的修改并同步.\n\n在属性的前面增加 `$`，表明会同步修改可信源.\n\n\n\n#### 字符串插值\n\n在较长字符串中使用常量、变量或代码表达式，使它们替换为其当前值以求出字符串的值。\n\n例如，在字符串\"Katy ate a \\（fruit）.\"中，如果fruit 是带有值 \"peach\"的变量，那么在求字符串的值时，\\（fruit）由\"peach\"替换，变为 \"Katy ate a peach.\"。\n\n\n\n### 其他\n\n#### 自动的动画效果\n\n当状态属性发生改变时, 我们希望对应控制的视图元素的变化具有动画效果, 那么可以指定: e.g.\n\n```swift\nCircle()\n    .frame(maxHeight: 200)\n    .foregroundColor( isOn ? .purple : .mint \n    .shadow(color:isOn ? .indigo : .orange , radius: 20)\n    .scaleEffect(isOn ? 1: 0.75)\n    .animation( .default, value: isOn)\n```\n\n> 其中的 `value： isOn`表示追踪的状态属性.\n\n\n\n在一个视图中创建状态对象,  然后在 `app`中声明为环境变量并在子视图中使用.\n\n\n\n# 设计原则\n\nprinciple \n\n\n\n- 需要长按进行交互的组件, 在轻触时ICON放大或者缩小 \n\n\n\n\n\n# 官方手册学习记录\n\n## 基础知识\n\n- Swift 使用*字符串插值*将常量或变量的名称作为占位符包含在较长的字符串中，并提示 Swift 将其替换为该常量或变量的当前值。将名称包在括号中，并在左括号前用反斜杠进行转义：\n\n  ```swift\n  print(\"The current value of friendlyWelcome is \\(friendlyWelcome)\")\n  // 打印 \"The current value of friendlyWelcome is Bonjour！\"\n  ```\n\n- 不必使用 `;`, 但是如果想在一行中编写多个独立语句，则*必须*使用分号：\n\n  ```swift\n  let cat = \"🐱\"; print(cat)\n  // 打印 \"🐱\"\n  ```\n\n- 整数边界: 使用 min, max进行访问\n\n  ```swift\n  let minValue = UInt8.min  // minValue 等于 0，类型为 UInt8\n  let maxValue = UInt8.max  // maxValue 等于 255，类型为 UInt8\n  ```\n\n- 类型别名: `typealias`\n\n  ```swift\n  typealias AudioSample = UInt16\n  \n  var maxAmplitudeFound = AudioSample.min\n  // maxAmplitudeFound 现在为 0\n  \n  ```\n\n### 元组\n\n- 作用: 多个值组合成一个复合值\n\n```swift\nlet http404Error = (404, \"Not Found\")\n// http404Error 的类型为（Int，String），且等于（404，\"Not Found\"）\n```\n\n如果只需要元组的部分值，则在分解元组时使用下划线 (`_`) 忽略不需要的部分\n\n\n\n- 分解元组\n\n  ```swift\n  let (statusCode, statusMessage) = http404Error\n  print(\"The status code is \\(statusCode)\")\n  // 打印 \"The status code is 404\"\n  print(\"The status message is \\(statusMessage)\")\n  // 打印 \"The status message is Not Found\"\n  ```\n\n- 可以在定义元组时为元组中的各个元素命名：\n\n  ```swift\n  let http200Status = (statusCode: 200, description: \"OK\")\n  ```\n\n  然后可以使用元素名访问:\n\n  ```swift\n  print(\"The status code is \\(http200Status.statusCode)\")\n  // 打印 \"The status code is 200\"\n  print(\"The status message is \\(http200Status.description)\")\n  // 打印 \"The status message is OK\"\n  ```\n\n  \n\n- 也可以直接使用从零开始的索引来访问, e.g. `http200Status.0`\n  \n\n---\n\n- <u>可选</u>: 存储这种类型的值或者 `nil`.\n\n- 提供后备值: `??`\n\n  ```swift\n  let name: String? = nil\n  let greeting = \"Hello, \" + (name ?? \"friend\") + \"!\"\n  print(greeting)\n  // 打印 \"Hello, friend!\"\n  ```\n\n  - 如果 `??` 之前的值不是 `nil`, 就会正常解包, 否则选择后备值;\n  - 使用 `()` 包裹.\n\n- <u>隐式解包可选</u>: 安全假定一直都有值时使用\n\n  ```swift\n  let possibleString: String? = \"An optional string.\"\n  let forcedString: String = possibleString! // 需要显式解包\n  \n  let assumedString: String! = \"An implicitly unwrapped optional string.\"\n  let implicitString: String = assumedString // 隐式解包\n  ```\n\n\n\n---\n\n### 错误处理\n\n函数在声明中包含 `throws` 关键字，表示它可以抛出错误。调用可以抛出错误的函数时，要在表达式前加上 `try` 关键字.\n\nSwift 会自动将错误传播到当前作用域之外，直到它们被 `catch` 子句处理为止。\n\n```swift\ndo {\n    try canThrowAnError()\n    // 无错误的情况\n} catch {\n    // 抛出错误的情况\n}\n```\n\n> 细节部分在后面补充\n\n\n\n### 断言和先决条件\n\n#### 使用断言进行调试\n\n```swift\nlet age = -3\nassert(age >= 0, \"A person's age can't be less than zero.\")\n// 该断言失败的原因是 -3 并不 >= 0。\n```\n\n断言的第一个参数是预期的、正确的结果, 如果不满足条件就会显示报错. 但是不会阻止程序继续运行.\n\n\n\n#### 强制执行先决条件\n\n当条件有可能为假，但*必须*为真才能继续执行代码时，请使用先决条件.\n\n向该函数传递一个计算结果为 `true` 或 `false` 的表达式，以及一条在条件结果为 `false` 时显示的信息:\n\n```swift\n// 在下标的实现中...\nprecondition(index > 0, \"Index must be greater than zero.\")\n```\n\n---\n\n## 运算符\n\n### 基本运算符\n\n- 与 C 和 Objective-C 中的赋值运算符不同，Swift 中的赋值运算符本身不返回值。以下语句无效：\n\n  ```swift\n  if x = y { // 这是无效的，因为 x = y 不返回值。\n  }\n  ```\n\n  - 可以防止不小心使用赋值运算符（=） 而非等于运算符（==）.\n\n- 基本的四则运算不允许值的溢出.\n\n\n\n> [!NOTE]\n>\n> 在 Swift 中对负数的处理与模运算符有所不同:\n>\n> 为了确定 `a % b` 的答案，`%` 运算符计算以下等式并返回 `余数` 作为输出：\n>\n> ```\n> a` = (`b` x `某个乘数`) + `余数\n> ```\n>\n> 其中 `某个乘数` 是 `b` 在 `a` 中能容纳的最大倍数。\n>\n> ```swift\n> 9 % 4    // 等于 1\n> \n> -9 % 4   // 等于 -1\n> ```\n\n\n\n- 数值的正负号可以使用前缀 `-` 切换，称为<u>一元负号运算符</u>.\n\n  - 中间没有任何空格.\n\n    ```swift\n    let three = 3\n    let minusThree = -three       // minusThree 等于 -3\n    ```\n\n#### 元组的计算\n\n- 前提: 如果两个元组具有相同的类型和相同数量的值，则可以比较它们.\n- 规则: \n  - 元组是从左到右逐个值进行比较的，直到比较发现两个不相等的值为止。\n  -  这两个值将进行比较，并且该比较的结果决定了整个元组比较的结果。\n  -  如果所有元素都相等，那么这两个元组本身就相等。\n\n> [!NOTE]\n>\n> 只有当给定的运算符可以应用于各自元组中的每个值时，元组才能与该运算符进行比较.\n\n```swift\n(\"blue\", false) < (\"purple\", true)  // 错误，因为 < 不能比较布尔值\n```\n\n\n\n#### 空合并运算符\n\n`a ?? b`的结果与下面的运算相同:\n\n```swift\na != nil ? a! : b\n```\n\n\n\n#### 区间运算\n\n- *闭区间运算符*（`a...b`）定义了一个从 `a` 到 `b` 的范围，包括 `a` 和 `b` 的值。`a` 的值不能大于 `b`;\n\n  - 在需要使用所有值的情况下很有用\n\n  - e.g.\n\n    ```swift\n    for index in 1...5 {\n        print(\"\\(index) 乘以 5 等于 \\(index * 5)\") \n    }\n    ```\n\n- *半开区间运算符*（`a..<b`）定义了一个从 `a` 到 `b` 但不包括 `b` 的范围.\n\n  - 对于处理从基数 0 开始的列表（如数组）时特别有用，因为它可以计数到列表长度（但不包括列表长度）.\n\n  - e.g.\n\n    ```swift\n    let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"] \n    let count = names.count\n    for i in 0..<count {\n        print(\"第 \\(i + 1) 个人叫 \\(names[i])\")\n    }\n    ```\n\n- 闭区间运算符有一种替代形式，用于一直延伸到尽可能远的区间 —— 例如，一个包含从索引 2 到数组末尾所有元素的区间。\n\n  ```swift\n  for name in names[2...] { print(name) }\n  // Brian\n  // Jack\n  ```\n\n- 半开区间运算符也有一种只写最后一个值的单侧形式\n\n  ```swift\n  for name in names[..<2] { print(name) }\n  // Anna\n  // Alex\n  ```\n\n\n\n#### 逻辑运算\n\n> [!NOTE]\n>\n> Swift 逻辑运算符 `&&` 和 `||` 遵循<u>从左到右</u>的结合顺序，这意味着带有多个逻辑运算符的复合表达式会首先评估最左边的子表达式.\n\n\n\n\n\n## 控制流\n\n## 协议\n\n- 如果类需要继承, 需要将父类写在所有的协议之前\n- 不能在协议定义中为方法参数指定默认值。\n- 协议也可以要求遵循协议的类型 <u>实现指定的构造器</u>, 和协议内部的方法一样, 不需要写花括号和构造期的实体\n  - 如果是类, 必须在构造函数的开头加上 `required`修饰符. 这是为了确保所有继承的子类也提供这个构造函数的实现, 从而确保遵守协议;\n  - 但是如果一个类被声明为了 `final`, 也就是无法被继承, 那么就不需要 `required`的声明\n\n\n\n\n\n### 协议的基本用法\n\n协议可以规定属性类型以及属性被操作的权限, 通常和类、结构体和枚举进行绑定, 作为一种强制的约束.\n\n```swift\nprotocol Tax{\n  var national: Double { get } \n  var individual: Double{ set get}\n}\n```\n\n同样可以在协议中使用 `mutating` 来声明一个改变自身属性的方法:\n\n```swift\nprotocol Tax{\n  var national: Double { get } \n  var individual: Double{ set get}\n  \n  mutating func changeTax(newValue: Double)\n}\n```\n\n- 需要注意的是, 结构体内部的方法如果要修改自身属性, 也需要声明 `mutating`, 但是类则不需要额外的声明.\n\n  ```swift\n  struct Taxas: Tax{\n     var national: Double\n    var individual: Double\n    \n    mutating func changeTax(newValue: Double){\n      national = newValue\n    }\n  }\n  ```\n\n\n\n### 补充协议\n\n- 使用 `,` 连接不同的协议\n\n- `extension`可以为协议的函数设置默认方法, 就不需要继续在每一个类、结构体或枚举中重新定义\n\n  - 同样可以补充数据类型\n\n    ```swift\n    extension Int {\n      var abs: Int {\n        get {\n          if self >= 0 {\n            return self\n          }else{\n            return -self\n          }\n        }\n      }\n    }\n    \n    print((-3).abs);\n    // 3\n    ```\n\n\n\n#### 有条件地遵循协议\n\n让 `Array` 类型只要在存储遵循 `TextRepresentable` 协议的元素时，就遵循 `TextRepresentable` 协议:\n\n```swift\nextension Array: TextRepresentable where Element: TextRepresentable {\n    var textualDescription: String {\n        let itemsAsText = self.map { $0.textualDescription }\n        return \"[\" + itemsAsText.joined(separator: \", \") + \"]\"\n    }\n}\nlet myDice = [d6, d12]\nprint(myDice.textualDescription)\n// 打印 \"[A 6-sided dice, A 12-sided dice]\"\n```\n\n\n\n#### 扩展里声明协议遵循\n\n当一个类型已经遵循了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空的扩展来让它遵循该协议:\n\n```swift\nstruct Hamster {\n    var name: String\n    var textualDescription: String {\n        return \"A hamster named \\(name)\"\n    }\n}\nextension Hamster: TextRepresentable {}\n```\n\n\n\n### Error handling \n\n系统提供了 `Error`协议用于错误处理, 主动给予错误的捕捉情况.\n\n使用方法:\n\n1. 定义遵循相关协议的枚举类型, 作为错误的类型;\n2. 定义可能抛出错误的函数;\n3. 使用 `do...catch`块来结构化地处理错误.\n\ne.g.\n\n```swift\n// 定义一个错误类型，遵循 Error 协议\nenum PasswordError: Error {\n    case tooShort\n    case tooWeak\n}\n\n// 一个函数，可能抛出错误\nfunc validate(password: String) throws {\n    if password.count < 6 {\n        throw PasswordError.tooShort\n    }\n    if password == \"123456\" {\n        throw PasswordError.tooWeak\n    }\n}\n\n// 使用 do-catch 捕捉错误\ndo {\n    try validate(password: \"123456\")\n    print(\"密码验证通过 ✅\")\n} catch PasswordError.tooShort {\n    print(\"❌ 密码太短，请至少使用 6 个字符\")\n} catch PasswordError.tooWeak {\n    print(\"❌ 密码太弱，不能使用简单的序列\")\n} catch {\n    print(\"❌ 发生未知错误：\\(error)\")\n}\n\n```\n\n> - throws：在函数声明中标注该函数会抛出错误;\n> - try：在调用可能抛出错误的函数时使用.\n\n\n\n### 其他的协议\n\n#### CaseIterable\n\n用于获取枚举的属性个数, 从而进行遍历.\n\n```swift\nenum Status:CaseIterable{\n    case low,middle,high\n    \n    \n    mutating func change(){\n        switch self{\n        case .high:\n            self = .low\n        case .low:\n            self = .middle\n        case .middle:\n            self = .high\n        }\n    }\n    \n    func ptr(){\n        print(\"Current Status is \\(self)\")\n    }\n}\n\nvar status = Status.low\nfor _ in 0..<Status.allCases.count{\n    status.ptr()\n    status.change()\n}\n```\n\n> `for _ in 0..<` 当中的 `_`表示忽略遍历时候的循环变量的值.\n\n\n\n\n\n## 闭包\n\n#### 闭包的简化推导\n\n相当于匿名函数与 `lambda`.  接下来从普通函数的写法开始简化:\n\n- 普通函数: \n\n  ```swift\n  func changeSign(op: Double) -> Double {\n      return -op\n  }\n  \n  var operation: (Double) -> Double\n  operation = changeSign\n  \n  let result = operation(4.0) // result = -4.0\n  ```\n\n- 将函数的定义下移:\n\n  ```swift\n  var operation: (Double) -> Double\n  operation = (op:Double) -> Double { return -op}\n  \n  let result  = operation(4.0)\n  ```\n\n- 将`｛` 提前，并在原来的位置添加 `in`\n\n  ```swift\n  var operation:(Double) -> Double\n  operation = {(op: Double) -> Double  in return -op}\n  ...\n  ```\n\n- 系统可以推断类型, 所以根据输入的类型简化返回值的类型定义\n\n  ```swift\n  var operation:(Double) -> Double\n  operation = {(op: Double)   in return -op}\n  ...\n  ```\n\n- 可以进一步省略传入的类型\n\n  ```swift\n  var operation:(Double) -> Double\n  operation = { (op) in return -op}\n  ...\n  ```\n\n- 省略返回的标记 `return`:\n\n  ```swift\n  var operation:(Double) -> Double\n  operation = { (op) in  -op}\n  ...\n  ```\n\n最后, 我们可以直接用 `$0`等替代传入的参数, 也就是省略了参数的名称!\n\n```swift\nvar operation:(Double) -> Double\noperation = { -$0 }\n...\n```\n\n\n\n#### 闭包的常见使用\n\ne.g. \n\n![image-20250412170605776](swift.assets/image-20250412170605776.png)\n\n#### Trailing Closure\n\n当闭包是函数的**最后一个参数**时，\n\n```swift\nlet result = applyTwice(3, operation: { $0 * 2 })\n```\n\n可以改写成:\n\n```swift\nlet result = applyTwice(3) { $0 * 2 } // result = 12\n```\n\n\n\n# 慕课学习杂记\n\n#### something\n\n- 去官网学习新出现的技术\n  - codeML\n  - 张克俊老师?\n\n\n\n- 函数也可以赋值给变量 \n\n\n\n#### 省略外部参数名\n\n- 外部参数名: 在函数调用的时候使用, 提高可读性;\n- 内部参数名: 在函数体的内部使用\n\n\n\n如果如此定义:\n\n```swift\nfunc greet(person name: String){\n  print(\"Hello , \\(name)\")\n}\n```\n\n那么在调用的时候必须显示声明外部参数名:\n\n```swift\ngreet( person: \"Alice\")\n```\n\n\n\n如果我们希望省略外部参数名, 就可以在定义函数的时候用 `_`来代替:\n\n```swift\nfunc greet(_ name: String){\n  ...\n}\n```\n\n\n\n#### 高阶函数\n\n我们可以让函数作为另一个函数的输入参数:\n\n```swift\nfunc addTwoInts( _ a: Int, _ b: Int) -> Int{\n  return a+b\n}\n\nvar mathFunction = addTwoInts\n\n// 高阶函数\nfunc printMathResults（_ mathFunction: (Int, Int）-> Int, _ a: Int, _ b: Int){\n  var result = mathFunction(a,b)\n  print(result)\n}\n\n// 调用\nprintMathResults（addTwoInts， 3,5）\n\n```\n\n> 注意函数作为参数的时候, 类型的定义就是输入类型和返回类型, 也是用 `,` 来分隔不同的参数.\n\n\n\n---\n\n\n\n#### 内置的库\n\n`AVFoudation`: 音频播放 \n\n\n\n---\n\n\n\n- 枚举内部也可以设置方法; \n\n- 结构体本身不需要构造函数(因为swift存在对于结构体的默认构造) , 但是如果结构体内部的属性存在这样的属性:\n\n  - 它可能是枚举内部的方法, 跟枚举的属性有关, 可能使用了 `switch`来根据枚举属性赋值.\n\n  ```swift\n  enum Type{\n    case Cike\n    case ...\n    \n    func blood()-> Double{\n      switch self{\n        case .Cike: return 10\n        case .Fashi: return ...\n        ...\n      }\n    }\n    \n  }\n  \n  struct Card {\n    var country: Country\n    vat type: Type\n    var blood: Double\n    \n    init (country: Country, type: Type){\n      self.country = country\n      self.type = type;\n      blood = type.blood\n    }\n  }\n  ```\n\n\n\n- 结构体和枚举属于 <u>值类型</u>, 如果赋值的时候进行拷贝操作;\n  - 如果结构体声明为 `let`, 即使属性是变量, 那么也无法修改内部的属性,\n- 类是引用类型, 赋值的时候使得左值指向了同样的内存区域, 也就是信息保持一致, 更改同步\n  - 如果我们将类声明为常量, 相当于cpp的指针常量, 也就是说类内部的属性可以更改, 但是无法修改这个量指向的内存区域.\n\n\n\n#### 计算属性\n\n访问的时候动态计算得到.\n\n下面通过一个矩形的例子来说明:\n\n```swift\nstruct Point {\n  var x = 0.0\n  var y = 0.0\n}\n\nstruct Size{\n  var width = 0.0\n  var height = 0.0\n}\n\nstruct Rect{\n  var origin = Point()\n  var size = Size()\n  var center: Point{\n    get{\n      let centerX = origin.x + (size.width / 2)\n      let centerY = orgin.y + (size.height /2 )\n      return Point(x: centerX, y: centerY)\n    }\n    set(newCenter){\n      origin.x = newCenter.x - (size.width / 2)\n      origin.y = newCenter.y - (size.height / 2)\n    }\n  }\n}\n```\n\n上述完成了结构体的计算属性的定义, 其中 `get`部分也可以优化为:\n\n```swift\nget{\n\tPoint(x: origin.x + (size.width / 2),\n        y: orgin.y + (size.height /2 ) )\n}\n```\n\n> 这是因为, 如果 `get` 部分只存在一个表达式,  就会自动将其返回, 不需要显式声明 `return`关键字.\n\n然后可以如此应用:\n\n```swift\nvar currCenter = rectElement.center\n\nrectElement.center = Point(x:20, y:50)\n```\n\n\n\n`set`提供了语法糖, 也就是可以直接访问oldValue 和  newValue, 因此我们可以如此改写:\n\n```swift\nset{\n  origin.x = newValue.x - (size.width / 2)\n  origin.y = newValue.y - (size.height / 2)\n}\n```\n\n\n\n> [!NOTE]\n>\n> 对于只读的计算属性, 由于不存在 `set`, 我们可以直接在花括号内定义返回内容.\n\n\n\n---\n\n- 声明 `static` , 表示这个属性或者方法属于整个类型而非某个实例. 此时相应的, 我们使用 `<tyepName>.<strtic attribute>`的方式来访问.\n\n\n\n- 子面量本身是不可修改的, 下面的拓展中, 如果写作  `var someInt = 3.square()`就会报错\n\n```swift\nextension Int{\n    mutating func square(){\n        self = self * self\n    }\n}\n\nvar someInt = 3\nsomeInt.square()\n```\n\n\n\n---\n\n控制器存在5种状态:\n\n- 未加载\n- 将要出现\n- 出现\n- 将要消失\n- 已经消失\n\n\n\nAPP的状态:\n\n<img src=\"swift.assets/image-20250413182851979.png\" alt=\"image-20250413182851979\" style=\"zoom:33%;\" />\n\n`UiSceneDelegate`用于响应基于 `scene` 的生命周期事件.\n\n\n\n可以使用属性的 `didset`来便捷地检测变化并快速修改:\n\n```swift\nvar score = 0{\n  didSet{\n    self.gameScoreLabel.text = \"Score: \\(score)\"\n  }\n}\n```\n\n\n\n- `viewController`是新的页面;\n- `view`是视图, 可以叠加在页面上.\n- `UIAlertController`组件相当于警示的弹窗组件\n\n\n\n### 作图和绘画\n\n#### CG\n\n- `CGFloat`用于二维坐标系中的坐标数据:\n\n  - `let coor_x = CGFloat(10.5)`\n\n- `CGPoint(x: .. , y:...)`\n\n- `CGSize` 包含width和height属性的结构体;\n\n- `CGRect`包含点和尺寸的矩形\n\n  ```swift\n  struct CGRect{\n    var origin: CGPoint\n    var size: CGSize\n  }\n  ```\n\n  - 其他属性\n\n  - e.g.\n\n    ```swift\n    var minX: CGPoint\n    var midY: CGPoint\n    intersects(CGRect) -> Bool // 判断是否存在交集\n    contains(CGPoint) -> Bool // 是否包含点.\n    ```\n\n\n\n最小单元是 `Point`而非像素点.\n\nbound表示视图内部允许绘制的区域:\n\n```swift\nvar bounds: CGRect // 也就是一个矩形\n```\n\nframe\t视图在父视图中的位置:\n\n```swift\nvar frame: CGRect\n```\n\n\n\n#### 自定义视图\n\n绘制自定义视图通常通过创建一个自定义的 UIView 子类，并重写 draw(_:) 方法来实现.\n\nplayGround中的实例:\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass CustomView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = .white // 设置背景颜色\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n\n        // 绘制一个圆形\n        context.setFillColor(UIColor.blue.cgColor) // 设置填充颜色\n        context.fillEllipse(in: rect) // 绘制填充的圆\n\n        // 绘制一个矩形\n        context.setStrokeColor(UIColor.black.withAlphaComponent(0.6).cgColor) // 设置能见度\n        context.setLineWidth(5)\n        context.stroke(rect.insetBy(dx: 10, dy: 10)) // 绘制矩形边框，留出间距\n    }\n}\n\n// 创建自定义视图实例\nlet customView = CustomView(frame: CGRect(x: 0, y: 0, width: 200, height: 200))\n\n// 显示在 Playground 的 live view\nPlaygroundPage.current.liveView = customView\n\n```\n\n\n\n- `touchesBegan`--WWDC\n- `SCNVector3`是三维向量\n- `DispathchQueue`表示创建一个异步的进程\n\n\n\n### 传感器\n\n- 加速度的方向伴随手机的头部旋转保持不变;\n  - 以 `g` 为描述单位;\n  - 面向使用者的方向是 `z` 轴.\n- 陀螺仪\n  - 记录对应用三个轴\n  - roll, pitch, yaw\n\n\n\n### 动画\n\n\n\n## 结绳记事\n\n- [操作演示](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245274&cid=1299836384&contentid=1217938866).\n\n- 按住 `ctrl`将视图中的组件拖放到代码中.\n- 右下角的几个功能:\n  - 约束;\n  - 选择视图 \n- `ctrl + option + cmd + enter` 快速显示代码区域\n- [组件使用](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245274&cid=1299836386&contentid=1217092922)\n  - 50:00 左右介绍了两种类型和交互\n\n- 按住`optional`然后 hover 在类上, 可以显示对应的基础操作.\n\n- 可选值的本质是枚举类型!\n\n  ```swift\n  enum Optional<T>{\n    case none\n    case some(<T>)\n  }\n  ```\n\n- [画图和动画](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245305&sm=1)\n\n- [coreML](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245309&sm=1)\n\n- 在项目中显示Md格式:\n\n  ```swift\n  /*:\n  ...\n  */\n  ```\n\n- 选择在运行时隐藏实际存在的代码:\n\n  ```swift\n  //#-hidden-code\n  import PlaygroundSupport\n  ...\n  //#-end-hidden-code\n  \n  ```\n\n  \n\n\n\n\n\n# Swift UI\n\n- [慕课的链接](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245315&cid=1299836440&contentid=1218091551)\n- [by now](https://www.hackingwithswift.com/100/swiftui/16)\n- SixD: 开箱即用的UI设计等.\n- [术语表](https://www.hackingwithswift.com/glossary)\n\n\n\n## AR\n\n- [helpful links](https://www.createwithswift.com/creating-an-augmented-reality-app-in-swiftui-using-realitykit-and-arkit/)\n- [官方文档](https://developer.apple.com/documentation/realitykit/?ref=createwithswift.com)\n\n\n\n## 动画\n\n#### 缩放变换\n\n```swift\nNavigationLink{\n  BraceletEditor(bracelet)\n  .navigationTransitionStyle(\n  .zoom(\n  \tsourceID:bracelet.id,\n  \tin:braceletList\n  \t)\n  )\n}label:{\n  BraceletPreview(bracelet)\n}\n.matchedTansitionSource(\n\tid:bracelet.id,\n  in:braceletList\n)\n```\n\n\n\n\n\n## Symbol 6\n\n### 动画\n\n- 使用 `晃动` 在复杂的UI中提示可交互性.\n- `旋转`动画来表示正在进行的进程\n\n## 基本语法\n\n#### 磨砂效果\n\n```swift\nVStack {\n}\n.frame(width: 200, height: 200)\n.background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20, style: .continuous))\n```\n\n\n\n#### 搜索栏\n\n- 状态管理:\n\n  ```swift\n  // 存储搜索文本\n  @State private var searchText = \"\"\n  \n  // 可选：跟踪搜索是否处于活动状态\n  @State private var isSearching = false\n  ```\n\n- 数据过滤模式\n\n  ```swift\n  // 基本过滤计算属性模板\n  var filteredItems: [ItemType] {\n      if searchText.isEmpty {\n          return originalItems\n      } else {\n          return originalItems.filter { item in\n              // 根据需要自定义过滤条件\n              item.name.localizedCaseInsensitiveContains(searchText) ||\n              item.description.localizedCaseInsensitiveContains(searchText)\n          }\n      }\n  }\n  \n  // 处理嵌套数据结构的过滤模板\n  var filteredNestedItems: [ParentType] {\n      if searchText.isEmpty {\n          return originalParentItems\n      } else {\n          return originalParentItems.compactMap { parent in\n              let matchedChildren = parent.children.filter { child in\n                  child.name.localizedCaseInsensitiveContains(searchText)\n              }\n              \n              if matchedChildren.isEmpty {\n                  return nil\n              } else {\n                  // 创建包含匹配子项的新父项\n                  return ParentType(id: parent.id, name: parent.name, children: matchedChildren)\n              }\n          }\n      }\n  }\n  ```\n\n- 搜索UI中的实现:\n\n  ```swift\n  NavigationStack {\n      List {\n          // 使用过滤后的数据源\n          ForEach(filteredItems) { item in\n              // 列表项视图\n          }\n      }\n      .navigationTitle(\"标题\")\n      .searchable(text: $searchText, prompt: \"搜索提示文字\")\n      // 可选：添加搜索建议\n      .searchSuggestions {\n          ForEach(suggestions, id: \\.self) { suggestion in\n              Text(suggestion).searchCompletion(suggestion)\n          }\n      }\n  }\n  ```\n\n\n\n\n\n#### 左右适应的外边距\n\n通过 `HStack`与  `space`实现卡片的自适应扩展, 同时利用 `.frame(maxwidth:...)`来设置一个最大的卡片宽度\n\n```swift\nHStack{\n    Spacer(minLength: 10)\n  \n    Text(item.description)\n        .padding()\n        .background(Color(.systemGray6))\n        .overlay(\n            RoundedRectangle(cornerRadius: 10) // 10为圆角半径，可调整\n                .stroke(Color.gray, lineWidth: 1) // 边框颜色和宽度\n        )\n        .clipShape(RoundedRectangle(cornerRadius: 10))\n    // 保证背景和边框都圆角\n    .frame(maxWidth: 400) // 最大宽度限制\n\n    Spacer(minLength: 10)\n}\n```\n\n`Spacer(minLength: 10)` 表示**保证自己不会小于 minLength**. \n\n\n\n上述的 `Spacer`会压缩卡片的内容, 如果希望直接设置卡片在父容器中的左右外边距, 应该在卡片的内部使用 `padding`:\n\n```swift\nText(item.description)\n    .padding(.horizontal, 24) // 卡片内容内边距\n    .padding(.vertical, 12)\n    .background(Color(.systemGray6))\n    .overlay(\n        RoundedRectangle(cornerRadius: 10)\n            .stroke(Color.gray, lineWidth: 2)\n    )\n    .clipShape(RoundedRectangle(cornerRadius: 10))\n    .padding(.horizontal, 20) // 整个卡片距离父视图左右20pt\n```\n\n\n\n#### 全局统一样式\n\n```swift\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .buttonStyle(ShadowButtonStyle(radius: 10))\n        }\n    }\n}\n```\n\n\n\n#### 参数标签和参数名\n\n- 参数标签用于函数调用时;\n- 参数名用于函数内部的参数名称.\n\ne.g.:\n\n```swift\nfunc greet(person atName: String) {\n    print(\"Hello, \\(atName)!\")\n}\ngreet(person: \"Alice\") // 输出：Hello, Alice!\n```\n\n\n\n也可以使用 `_`来省略调用时的参数标签:\n\n```swift\nfunc greet(_ name: String) {\n    print(\"Hello, \\(name)!\")\n}\ngreet(\"Alice\") // 输出：Hello, Alice!\n```\n\n\n\n\n\n#### Alert\n\nswift UI中的弹窗提示同样通过本地的 `@State`变量来实现:\n\n```swift\n@State private var showingPaymentAlert = false\n...\n.alert(\"Order confirmed\", isPresented: $showingPaymentAlert) {\n    // add buttons here\n} message: {\n    Text(\"Your total was \\(totalPrice) – thank you!\")\n}\n```\n\n设置按钮来改变可见的状态:\n\n```swift\nButton(\"Confirm order\") {\n    showingPaymentAlert.toggle()\n}\n```\n\n\n\n#### 自定义绑定\n\n我们也可以使用 `Binding` 类型手动创建绑定，该类型可以提供自定义 `get` 和 `set` 闭包，以便在读取或写入值时运行。\n\n\n\n\n\n#### Foreach\n\n```swift\nForEach(item.restrictions) { restriction in\n    Text(restriction)\n}\n```\n\n此时, 要求 `item.restrictions` 具有可唯一标识的 `id` 字段.\n\n- 如果内容本身就是唯一标识, 比如说遍历的内容是字符串数组, 那么可以如此声明:\n\n  ```swift\n  ForEach(item.restrictions, id: \\.self) { restriction in\n      Text(restriction)\n  }\n  ```\n\n\n\n#### Spacer()\n\n用于填充剩余的空间\n\n\n\n- 使用 `offset(x:.., y:...)`来调节位置, 左上角是原点.\n\n\n\n#### 环境变量\n\n- 作用: 用于存储独立于视图的、长期存在的数据;\n\n- e.g.\n\n  ```swift\n  // App.swift\n  @StateObject var order = Order()\n  ```\n\n- `@StateObject` 属性包装器负责在<u>应用程序的整个生命周期中</u>保持对象处于活动状态。\n\n- 需要在创建视图结构体的时候传递:\n\n  ```swift\n  WindowGroup {\n      ContentView()\n          .environmentObject(order)\n  }\n  ```\n\n- 为了让swift知道什么时候更新视图, 常用的是声明 `@Published`属性包装器——足以让它更新任何正在监视更改的 SwiftUI 视图.\n\n- 同时声明对应的对象遵循可观测协议: **ObservableObject**.\n\n\n\n我们可以使用 `@EnvironmentObject`来访问环境中的共享数据, 也就是传递上一步已经在父视图中创建和管理的对象.\n\ne.g.\n\n```swift\nclass UserData: ObservableObject {\n    @Published var name: String = \"John\"\n}\n\nstruct ContentView: View {\n    @StateObject private var userData = UserData()\n\n    var body: some View {\n        ChildView().environmentObject(userData)\n    }\n}\n\nstruct ChildView: View {\n    @EnvironmentObject var userData: UserData\n\n    var body: some View {\n        Text(userData.name)\n    }\n}\n```\n\n\n\n使用 `@State`来声明简单的本地值——比如整数和字符串.\n\n- 建议将其声明为 `private`, e.g.\n\n  ```swift\n  @State private var paymentType = \"Cash\"\n  ```\n\n  \n\n#### 菜单视图\n\n为了将菜单视图存放在一个选项卡当中, 我们需要新建一个视图, 用来作为容器:\n\n```swift\nstruct MainView: View {\n    var body: some View {\n        TabView {\n            ContentView()\n                .tabItem {\n                    Label(\"Menu\", systemImage: \"list.dash\")\n                }\n\n            OrderView()\n                .tabItem {\n                    Label(\"Order\", systemImage: \"square.and.pencil\")\n                }\n        }\n    }\n}\n```\n\n> 页面级别的切换.\n\n\n\n使用枚举与子页面的内容分区:\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    enum Section {\n        case cats\n        case dogs\n    }\n\n    @State private var selectedTab = Section.cats\n\n    var body: some View {\n        TabView(selection: $selectedTab) {\n            Tab(\"Cats\", systemImage: \"cat\", value: .cats) {\n                Button(\"Go to Dogs\") {\n                    selectedTab = .dogs\n                }\n            }\n            \n            Tab(\"Dogs\", systemImage: \"dog\", value: .dogs) {\n                Button(\"Go to Cats\") {\n                    selectedTab = .cats\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n## 合适的修饰符\n\n- 图像自动调节尺寸:\n\n  ```swift\n  Image(item.mainImage)\n      .resizable()\n      .scaledToFit()\n  ```\n\n\n\n#### 设置阴影\n\n```swift\n.shadow(color: .black.opacity(0.2), \n        radius: 15, x: 0, y: 10)\n```\n\n\n\n#### 为按钮设置动画\n\n```swift\nstruct ContentView: View {\n    @State private var showingWelcome = false\n\n    var body: some View {\n        VStack {\n            Toggle(\"Toggle label\", isOn: $showingWelcome.animation())\n\n            if showingWelcome {\n                Text(\"Hello World\")\n            }\n        }\n    }\n}\n```\n\n可以进一步设置, 比如弹簧的渐入渐出:\n\n```swift\nToggle(\"Toggle label\", isOn: $showingWelcome.animation(.spring()))\n```\n\n\n\n## 基本操作\n\n#### 快捷键\n\n- `ctrl`按住后点击  `VStack`可以快速地将其添加到 `ZStack`当中\n  - 颜色的设置需要通过 `ZStack`来实现.\n- `option`可以显示当前类的介绍\n- \n\n\n\n学习路线:\n\n1. 学习 Swift 基础语法\n2. 上手 SwiftUI 基础控件（Text、Button、Image、List、NavigationStack 等）\n3. 学会使用 @State、@Binding 等状态管理属性\n4. 尝试做一个简单的 App（比如 ToDo List、小笔记本）\n5. 慢慢接触更复杂的功能，比如动画、数据持久化（CoreData）、网络请求（URLSession）\n\n\n\n#### **第二周：SwiftUI 基础入门**\n\n**目标：**\n\n- 理解 SwiftUI 的基本概念和架构。\n- 掌握常用的 SwiftUI 视图和修饰符。\n\n1. **SwiftUI 概述：**\n   - 声明式语法与传统 UIKit 的区别\n   - SwiftUI 的视图层次结构\n2. **常用视图组件：**\n   - Text、Image、Button 等基本控件的使用\n   - 视图修饰符的应用，如 .font()、.foregroundColor()、.padding() 等\n3. **布局系统：**\n   - 使用 HStack、VStack 和 ZStack 进行视图布局\n   - Spacer 和 Divider 的使用\n\n**推荐资源：**\n\n- **Hacking with Swift 的 100 天 SwiftUI：** [100 Days of SwiftUI](https://www.hackingwithswift.com/100/swiftui)\n- **AppCoda 的 SwiftUI 教程：** [AppCoda - Mastering SwiftUI](https://www.appcoda.com/swiftui/)\n\n#### **第三周：状态管理与数据绑定**\n\n**目标：**\n\n- 理解并应用 SwiftUI 的状态管理机制。\n- 掌握数据绑定和视图更新的原理。\n\n**学习内容：**\n\n1. **状态管理：**\n   - 使用 @State 管理视图内部状态\n   - 使用 @Binding 在父子视图之间传递状态\n   - 使用 @ObservedObject 和 @EnvironmentObject 管理复杂数据模型\n2. **数据绑定：**\n   - 双向绑定的实现\n   - 数据变化如何驱动视图更新\n\n**推荐资源：**\n\n- **SwiftUI 官方文档：** [SwiftUI Documentation](https://developer.apple.com/documentation/swiftui)\n- **Design+Code 的 SwiftUI 教程：** [Design+Code - SwiftUI for iOS 17](https://designcode.io/swiftui)\n\n\n\n#### **第四周：导航、列表与高级交互**\n\n**目标：**\n\n- 掌握 SwiftUI 中的导航和列表视图。\n- 实现复杂的用户交互和动画效果\n\n**学习内容：**\n\n1. **导航与路由：**\n   - 使用 NavigationView 和 NavigationLink 实现页面导航\n   - 传递数据到下一个视图\n2. **列表视图：**\n   - 使用 List 展示数据集合\n   - 自定义列表行和支持删除、移动操作\n3. **动画与手势：**\n   - 添加基本动画效果\n   - 处理手势交互，如拖拽、缩放等\n\n**推荐资源：**\n\n- **Raywenderlich 的 SwiftUI 教程：** [Raywenderlich - SwiftUI Apprentice](https://www.raywenderlich.com/books/swiftui-apprentice)\n- **Big Mountain Studio 的免费电子书：** [SwiftUI Views Quick Start](https://www.bigmountainstudio.com/free-swiftui-book)\n\n","source":"_posts/swift.md","raw":"---\ntitle: Swift学习摘记\ndate: 2025-04-17 20:21:21\ntags:\ncategories: 编程语言\nexcerpt: 学习swift中的基本语法和Swift-UI等框架知识.\nthumbnail: https://my-blog-img-1358266118.cos.ap-guangzhou.myqcloud.com/undefined20250509094625386.png?imageSlim\n---\n\n\n# 初见\n\n默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用 `_` 表示不使用参数标签:\n\n```swift\nfunc greet(_ person: String, on day: String) -> String {\n    return \"Hello \\(person), today is \\(day).\"\n}\ngreet(\"John\", on: \"Wednesday\")\n```\n\n> 参数标签指的是调用时候的名称, 参数名指的是函数内部.\n\n\n\n函数是第一等类型，这意味着函数可以作为另一个函数的返回值。\n\n```swift\nfunc makeIncrementer() -> ((Int) -> Int) {\n    func addOne(number: Int) -> Int {\n        return 1 + number\n    }\n    return addOne\n}\nvar increment = makeIncrementer()\nincrement(7)\n```\n\n\n\n函数也可以作为另一个函数的输入参数:\n\n```swift\nfunc hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {\n    for item in list {\n        if condition(item) {\n            return true\n        }\n    }\n    return false\n}\nfunc lessThanTen(number: Int) -> Bool {\n    return number < 10\n}\nvar numbers = [20, 19, 7, 12]\nhasAnyMatches(list: numbers, condition: lessThanTen)\n```\n\n\n\n可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。\n\n```swift\nlet sortedNumbers = numbers.sorted { $0 > $1 }\nprint(sortedNumbers)\n```\n\n\n\n\n\n`actor`与 `class`类似, 但是可以序列化访问, 保护共享、可变的数据.\n\n\n\n### 对象和类\n\n#### 构造与析构\n\n使用 `self.`替代 `this->`, 使用  `init` 和  `deinit`分别声明构造和析构函数:\n\n```swift\nclass NamedShape {\n    var numberOfSides: Int = 0\n    var name: String\n\n    init(name: String) {\n        self.name = name\n    }\n\n    func simpleDescription() -> String {\n        return \"A shape with \\(numberOfSides) sides.\"\n    }\n}\n```\n\n\n\n子类如果要重写父类的方法的话，需要用 `override` 标记:\n\n```swift\nclass Square: NamedShape {\n    var sideLength: Double\n\n    init(sideLength: Double, name: String) {\n        self.sideLength = sideLength\n        super.init(name: name)\n        numberOfSides = 4\n    }\n\n    func area() ->  Double {\n        return sideLength * sideLength\n    }\n\n    override func simpleDescription() -> String {\n        return \"A square with sides of length \\(sideLength).\"\n    }\n}\nlet test = Square(sideLength: 5.2, name: \"my test square\")\ntest.area()\ntest.simpleDescription()\n```\n\n> - 使用 `:className`的方法声明父类.\n> - `super.init` 是用来调用父类（超类）的初始化方法的。当创建一个子类的实例时，子类可能需要初始化一些自己的属性，同时还需要确保父类的属性也被正确初始化。这时就需要使用 `super.init` 来调用父类的初始化方法，完成父类的初始化过程\n> - 严格的顺序要求: 子类必须先初始化自己的属性，然后调用 `super.init`，最后才能访问或修改继承来的属性。\n\n\n\n### 计算属性\n\n#### 普通的计算属性\n\n在属性内部使用 `{}`并加上 `return`, 可以让访问这个属性的时候, 返回值由结构体的其他属性计算得到.\n\n```swift\nstruct Temperature {\n  var celsius: Double\n  var fahrenheit: Double{\n    return celsius *1.8 + 32\n  }\n  \n  init(celsius: Double){\n    self.celsius = celsius\n  }\n}\n```\n\n> 1. 此时实例化一个结构体就只需要给出一个属性的值.\n> 2. `self`在上述的Swift代码中是不可或缺的, 因为形参和内部属性的名称相同.\n\n\n\n#### 使用 getter 和 setter 的计算属性:\n\n```swift\nclass EquilateralTriangle: NamedShape {\n    var sideLength: Double = 0.0\n\n    init(sideLength: Double, name: String) {\n        self.sideLength = sideLength\n        super.init(name: name)\n        numberOfSides = 3\n    }\n\n    var perimeter: Double {\n      // 根据存储属性进行计算\n        get {\n            return 3.0 * sideLength\n        }\n      // 设置属性\n        set {\n            sideLength = newValue / 3.0\n        }\n    }\n\n    override func simpleDescription() -> String {\n        return \"An equilateral triangle with sides of length \\(sideLength).\"\n    }\n}\nvar triangle = EquilateralTriangle(sideLength: 3.1, name: \"a triangle\")\nprint(triangle.perimeter)\ntriangle.perimeter = 9.9\nprint(triangle.sideLength)\n```\n\n计算属性同样是一个属性, 但是根据调用方式的不同, 有返回和设置两种方式.\n\n```swift\ntriangle.perimeter = 9.9\nprint(triangle.perimeter)\n```\n\n\n\n### Mutating\n\n默认情况下, 结构体中的方法不能直接修改结构体的属性. 需要显式声明为 `mutating`:\n\n```swift\nstruct User{\n  let username:String\n  var isVisible:Bool = true\n  var friends: [string] = []\n  \n  mutating func addFriend(username: String){\n    friends.append(username)\n  }\n}\n```\n\n\n\n### 属性监视器\n\n\n\n使用 `willSet` 和 `didSet`。写入的代码会在属性值发生改变时调用，但不包含构造器中发生值改变的情况:\n\n- 分别可以使用 `newValue`与 `oldValue`来表示属性将要改变的值以及改变之前的值. \n\ne.g. 确保三角形的边长总是和正方形的边长相同。\n\n```swift\nclass TriangleAndSquare {\n    var triangle: EquilateralTriangle {\n        willSet {\n            square.sideLength = newValue.sideLength\n        }\n    }\n    var square: Square {\n        willSet {\n            triangle.sideLength = newValue.sideLength\n        }\n    }\n    init(size: Double, name: String) {\n        square = Square(sideLength: size, name: name)\n        triangle = EquilateralTriangle(sideLength: size, name: name)\n    }\n}\nvar triangleAndSquare = TriangleAndSquare(size: 10, name: \"another test shape\")\nprint(triangleAndSquare.square.sideLength)\nprint(triangleAndSquare.triangle.sideLength)\ntriangleAndSquare.square = Square(sideLength: 50, name: \"larger square\")\nprint(triangleAndSquare.triangle.sideLength)\n```\n\n\n\n### 枚举\n\n```swift\nenum Rank: Int {\n    case ace = 1\n    case two, three, four, five, six, seven, eight, nine, ten\n    case jack, queen, king\n    func simpleDescription() -> String {\n        switch self {\n        case .ace:\n            return \"ace\"\n        case .jack:\n            return \"jack\"\n        case .queen:\n            return \"queen\"\n        case .king:\n            return \"king\"\n        default:\n            return String(self.rawValue)\n        }\n    }\n}\nlet ace = Rank.ace\nlet aceRawValue = ace.rawValue\n```\n\n- 如果没有设置第一个成员的初始值, 默认从 `0` 开始;\n- 缺省值按照递增处理;\n-  `case`之外可以设置方法. \n\n\n\n使用 `init?(rawValue:)` 初始化构造器来从原始值创建一个枚举实例:\n\n```swift\nif let convertedRank = Rank（rawValue:3）｛\n\tlet threeDescription = convertedRank.simpleDescription（）\n｝\n```\n\n> - `if let`表示可选绑定, 安全地解包可选值\n\n\n\n\n\n#### 解包\n\n1. `if let`解包\n\n```swift\nif let A = B {\n  ...\n}\n```\n\n如果 `B`不是 nil, 就将其赋值给A, 然后执行 `{}`内部的语句. \n\n2. `??`\n\n```swift\nvar score : Int ?  = nil\n\nprint(score ?? default_score)\n// 成绩score不是nil, 就将其打印, 否则输出默认的成绩\n```\n\n\n\n对字典进行索引:\n\n```swift\n// scores是一个Int数组\nfor ( major, scores) in all_scores {\n  for score in scores{\n    ...\n  }\n}\n\n// 如果key没有使用, 可以直接忽略\nfor( _, socres) in all_scores{\n  ...\n}\n```\n\n\n\nswift支持对字典进行更新或者移除的时候, 返回并使用就值:\n\n```swift\nif let oldValue = scores.updateValue(100, forKey:\"fad\"){\n  print(..)\n}else{\n  ...\n}\n\nif let oldValue = scores.removeValue(forKey: \"fad\"){\n  print(\"fad's old value was \\(oldValue)\")\n}\n```\n\n \n\n\n\n- `@IBAction`表示组件交互和代码相绑定(允许在交互的时候执行外部定义的函数);\n- `@IBOutlet`表示允许代码的响应改变组件本身的状态(字体、大小等). \n\n<img src=\"swift.assets/image-20250412115454400.png\" alt=\"image-20250412115454400\" style=\"zoom:57%;\" />\n\n\n\n\n\n\n\n### 概念\n\n#### 闭包\n\n闭包指的是可以在特定位置运行的、不需要名称的函数.\n\n```swift\nscene.setOnStartHandler｛ \n// 闭包的主体\n｝\n```\n\n\n\n- `toggle()`可以自动切换变量的布尔值.\n\n  ```swift\n  Button(\"Press Me\") {\n      isOn.toggle()\n  }\n  ```\n\n\n\n#### 状态属性\n\n- 使用 `@State`在视图之外定义;\n- 当状态属性的值发生改变时, 会自动更新视图中相关的部分.\n\n- 对于状态对象, 使用 `@StateObject`来声明.\n\n#### 绑定\n\n由 `@Binding`声明将属性连接到其他地方, 允许子视图对属性的修改并同步.\n\n在属性的前面增加 `$`，表明会同步修改可信源.\n\n\n\n#### 字符串插值\n\n在较长字符串中使用常量、变量或代码表达式，使它们替换为其当前值以求出字符串的值。\n\n例如，在字符串\"Katy ate a \\（fruit）.\"中，如果fruit 是带有值 \"peach\"的变量，那么在求字符串的值时，\\（fruit）由\"peach\"替换，变为 \"Katy ate a peach.\"。\n\n\n\n### 其他\n\n#### 自动的动画效果\n\n当状态属性发生改变时, 我们希望对应控制的视图元素的变化具有动画效果, 那么可以指定: e.g.\n\n```swift\nCircle()\n    .frame(maxHeight: 200)\n    .foregroundColor( isOn ? .purple : .mint \n    .shadow(color:isOn ? .indigo : .orange , radius: 20)\n    .scaleEffect(isOn ? 1: 0.75)\n    .animation( .default, value: isOn)\n```\n\n> 其中的 `value： isOn`表示追踪的状态属性.\n\n\n\n在一个视图中创建状态对象,  然后在 `app`中声明为环境变量并在子视图中使用.\n\n\n\n# 设计原则\n\nprinciple \n\n\n\n- 需要长按进行交互的组件, 在轻触时ICON放大或者缩小 \n\n\n\n\n\n# 官方手册学习记录\n\n## 基础知识\n\n- Swift 使用*字符串插值*将常量或变量的名称作为占位符包含在较长的字符串中，并提示 Swift 将其替换为该常量或变量的当前值。将名称包在括号中，并在左括号前用反斜杠进行转义：\n\n  ```swift\n  print(\"The current value of friendlyWelcome is \\(friendlyWelcome)\")\n  // 打印 \"The current value of friendlyWelcome is Bonjour！\"\n  ```\n\n- 不必使用 `;`, 但是如果想在一行中编写多个独立语句，则*必须*使用分号：\n\n  ```swift\n  let cat = \"🐱\"; print(cat)\n  // 打印 \"🐱\"\n  ```\n\n- 整数边界: 使用 min, max进行访问\n\n  ```swift\n  let minValue = UInt8.min  // minValue 等于 0，类型为 UInt8\n  let maxValue = UInt8.max  // maxValue 等于 255，类型为 UInt8\n  ```\n\n- 类型别名: `typealias`\n\n  ```swift\n  typealias AudioSample = UInt16\n  \n  var maxAmplitudeFound = AudioSample.min\n  // maxAmplitudeFound 现在为 0\n  \n  ```\n\n### 元组\n\n- 作用: 多个值组合成一个复合值\n\n```swift\nlet http404Error = (404, \"Not Found\")\n// http404Error 的类型为（Int，String），且等于（404，\"Not Found\"）\n```\n\n如果只需要元组的部分值，则在分解元组时使用下划线 (`_`) 忽略不需要的部分\n\n\n\n- 分解元组\n\n  ```swift\n  let (statusCode, statusMessage) = http404Error\n  print(\"The status code is \\(statusCode)\")\n  // 打印 \"The status code is 404\"\n  print(\"The status message is \\(statusMessage)\")\n  // 打印 \"The status message is Not Found\"\n  ```\n\n- 可以在定义元组时为元组中的各个元素命名：\n\n  ```swift\n  let http200Status = (statusCode: 200, description: \"OK\")\n  ```\n\n  然后可以使用元素名访问:\n\n  ```swift\n  print(\"The status code is \\(http200Status.statusCode)\")\n  // 打印 \"The status code is 200\"\n  print(\"The status message is \\(http200Status.description)\")\n  // 打印 \"The status message is OK\"\n  ```\n\n  \n\n- 也可以直接使用从零开始的索引来访问, e.g. `http200Status.0`\n  \n\n---\n\n- <u>可选</u>: 存储这种类型的值或者 `nil`.\n\n- 提供后备值: `??`\n\n  ```swift\n  let name: String? = nil\n  let greeting = \"Hello, \" + (name ?? \"friend\") + \"!\"\n  print(greeting)\n  // 打印 \"Hello, friend!\"\n  ```\n\n  - 如果 `??` 之前的值不是 `nil`, 就会正常解包, 否则选择后备值;\n  - 使用 `()` 包裹.\n\n- <u>隐式解包可选</u>: 安全假定一直都有值时使用\n\n  ```swift\n  let possibleString: String? = \"An optional string.\"\n  let forcedString: String = possibleString! // 需要显式解包\n  \n  let assumedString: String! = \"An implicitly unwrapped optional string.\"\n  let implicitString: String = assumedString // 隐式解包\n  ```\n\n\n\n---\n\n### 错误处理\n\n函数在声明中包含 `throws` 关键字，表示它可以抛出错误。调用可以抛出错误的函数时，要在表达式前加上 `try` 关键字.\n\nSwift 会自动将错误传播到当前作用域之外，直到它们被 `catch` 子句处理为止。\n\n```swift\ndo {\n    try canThrowAnError()\n    // 无错误的情况\n} catch {\n    // 抛出错误的情况\n}\n```\n\n> 细节部分在后面补充\n\n\n\n### 断言和先决条件\n\n#### 使用断言进行调试\n\n```swift\nlet age = -3\nassert(age >= 0, \"A person's age can't be less than zero.\")\n// 该断言失败的原因是 -3 并不 >= 0。\n```\n\n断言的第一个参数是预期的、正确的结果, 如果不满足条件就会显示报错. 但是不会阻止程序继续运行.\n\n\n\n#### 强制执行先决条件\n\n当条件有可能为假，但*必须*为真才能继续执行代码时，请使用先决条件.\n\n向该函数传递一个计算结果为 `true` 或 `false` 的表达式，以及一条在条件结果为 `false` 时显示的信息:\n\n```swift\n// 在下标的实现中...\nprecondition(index > 0, \"Index must be greater than zero.\")\n```\n\n---\n\n## 运算符\n\n### 基本运算符\n\n- 与 C 和 Objective-C 中的赋值运算符不同，Swift 中的赋值运算符本身不返回值。以下语句无效：\n\n  ```swift\n  if x = y { // 这是无效的，因为 x = y 不返回值。\n  }\n  ```\n\n  - 可以防止不小心使用赋值运算符（=） 而非等于运算符（==）.\n\n- 基本的四则运算不允许值的溢出.\n\n\n\n> [!NOTE]\n>\n> 在 Swift 中对负数的处理与模运算符有所不同:\n>\n> 为了确定 `a % b` 的答案，`%` 运算符计算以下等式并返回 `余数` 作为输出：\n>\n> ```\n> a` = (`b` x `某个乘数`) + `余数\n> ```\n>\n> 其中 `某个乘数` 是 `b` 在 `a` 中能容纳的最大倍数。\n>\n> ```swift\n> 9 % 4    // 等于 1\n> \n> -9 % 4   // 等于 -1\n> ```\n\n\n\n- 数值的正负号可以使用前缀 `-` 切换，称为<u>一元负号运算符</u>.\n\n  - 中间没有任何空格.\n\n    ```swift\n    let three = 3\n    let minusThree = -three       // minusThree 等于 -3\n    ```\n\n#### 元组的计算\n\n- 前提: 如果两个元组具有相同的类型和相同数量的值，则可以比较它们.\n- 规则: \n  - 元组是从左到右逐个值进行比较的，直到比较发现两个不相等的值为止。\n  -  这两个值将进行比较，并且该比较的结果决定了整个元组比较的结果。\n  -  如果所有元素都相等，那么这两个元组本身就相等。\n\n> [!NOTE]\n>\n> 只有当给定的运算符可以应用于各自元组中的每个值时，元组才能与该运算符进行比较.\n\n```swift\n(\"blue\", false) < (\"purple\", true)  // 错误，因为 < 不能比较布尔值\n```\n\n\n\n#### 空合并运算符\n\n`a ?? b`的结果与下面的运算相同:\n\n```swift\na != nil ? a! : b\n```\n\n\n\n#### 区间运算\n\n- *闭区间运算符*（`a...b`）定义了一个从 `a` 到 `b` 的范围，包括 `a` 和 `b` 的值。`a` 的值不能大于 `b`;\n\n  - 在需要使用所有值的情况下很有用\n\n  - e.g.\n\n    ```swift\n    for index in 1...5 {\n        print(\"\\(index) 乘以 5 等于 \\(index * 5)\") \n    }\n    ```\n\n- *半开区间运算符*（`a..<b`）定义了一个从 `a` 到 `b` 但不包括 `b` 的范围.\n\n  - 对于处理从基数 0 开始的列表（如数组）时特别有用，因为它可以计数到列表长度（但不包括列表长度）.\n\n  - e.g.\n\n    ```swift\n    let names = [\"Anna\", \"Alex\", \"Brian\", \"Jack\"] \n    let count = names.count\n    for i in 0..<count {\n        print(\"第 \\(i + 1) 个人叫 \\(names[i])\")\n    }\n    ```\n\n- 闭区间运算符有一种替代形式，用于一直延伸到尽可能远的区间 —— 例如，一个包含从索引 2 到数组末尾所有元素的区间。\n\n  ```swift\n  for name in names[2...] { print(name) }\n  // Brian\n  // Jack\n  ```\n\n- 半开区间运算符也有一种只写最后一个值的单侧形式\n\n  ```swift\n  for name in names[..<2] { print(name) }\n  // Anna\n  // Alex\n  ```\n\n\n\n#### 逻辑运算\n\n> [!NOTE]\n>\n> Swift 逻辑运算符 `&&` 和 `||` 遵循<u>从左到右</u>的结合顺序，这意味着带有多个逻辑运算符的复合表达式会首先评估最左边的子表达式.\n\n\n\n\n\n## 控制流\n\n## 协议\n\n- 如果类需要继承, 需要将父类写在所有的协议之前\n- 不能在协议定义中为方法参数指定默认值。\n- 协议也可以要求遵循协议的类型 <u>实现指定的构造器</u>, 和协议内部的方法一样, 不需要写花括号和构造期的实体\n  - 如果是类, 必须在构造函数的开头加上 `required`修饰符. 这是为了确保所有继承的子类也提供这个构造函数的实现, 从而确保遵守协议;\n  - 但是如果一个类被声明为了 `final`, 也就是无法被继承, 那么就不需要 `required`的声明\n\n\n\n\n\n### 协议的基本用法\n\n协议可以规定属性类型以及属性被操作的权限, 通常和类、结构体和枚举进行绑定, 作为一种强制的约束.\n\n```swift\nprotocol Tax{\n  var national: Double { get } \n  var individual: Double{ set get}\n}\n```\n\n同样可以在协议中使用 `mutating` 来声明一个改变自身属性的方法:\n\n```swift\nprotocol Tax{\n  var national: Double { get } \n  var individual: Double{ set get}\n  \n  mutating func changeTax(newValue: Double)\n}\n```\n\n- 需要注意的是, 结构体内部的方法如果要修改自身属性, 也需要声明 `mutating`, 但是类则不需要额外的声明.\n\n  ```swift\n  struct Taxas: Tax{\n     var national: Double\n    var individual: Double\n    \n    mutating func changeTax(newValue: Double){\n      national = newValue\n    }\n  }\n  ```\n\n\n\n### 补充协议\n\n- 使用 `,` 连接不同的协议\n\n- `extension`可以为协议的函数设置默认方法, 就不需要继续在每一个类、结构体或枚举中重新定义\n\n  - 同样可以补充数据类型\n\n    ```swift\n    extension Int {\n      var abs: Int {\n        get {\n          if self >= 0 {\n            return self\n          }else{\n            return -self\n          }\n        }\n      }\n    }\n    \n    print((-3).abs);\n    // 3\n    ```\n\n\n\n#### 有条件地遵循协议\n\n让 `Array` 类型只要在存储遵循 `TextRepresentable` 协议的元素时，就遵循 `TextRepresentable` 协议:\n\n```swift\nextension Array: TextRepresentable where Element: TextRepresentable {\n    var textualDescription: String {\n        let itemsAsText = self.map { $0.textualDescription }\n        return \"[\" + itemsAsText.joined(separator: \", \") + \"]\"\n    }\n}\nlet myDice = [d6, d12]\nprint(myDice.textualDescription)\n// 打印 \"[A 6-sided dice, A 12-sided dice]\"\n```\n\n\n\n#### 扩展里声明协议遵循\n\n当一个类型已经遵循了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空的扩展来让它遵循该协议:\n\n```swift\nstruct Hamster {\n    var name: String\n    var textualDescription: String {\n        return \"A hamster named \\(name)\"\n    }\n}\nextension Hamster: TextRepresentable {}\n```\n\n\n\n### Error handling \n\n系统提供了 `Error`协议用于错误处理, 主动给予错误的捕捉情况.\n\n使用方法:\n\n1. 定义遵循相关协议的枚举类型, 作为错误的类型;\n2. 定义可能抛出错误的函数;\n3. 使用 `do...catch`块来结构化地处理错误.\n\ne.g.\n\n```swift\n// 定义一个错误类型，遵循 Error 协议\nenum PasswordError: Error {\n    case tooShort\n    case tooWeak\n}\n\n// 一个函数，可能抛出错误\nfunc validate(password: String) throws {\n    if password.count < 6 {\n        throw PasswordError.tooShort\n    }\n    if password == \"123456\" {\n        throw PasswordError.tooWeak\n    }\n}\n\n// 使用 do-catch 捕捉错误\ndo {\n    try validate(password: \"123456\")\n    print(\"密码验证通过 ✅\")\n} catch PasswordError.tooShort {\n    print(\"❌ 密码太短，请至少使用 6 个字符\")\n} catch PasswordError.tooWeak {\n    print(\"❌ 密码太弱，不能使用简单的序列\")\n} catch {\n    print(\"❌ 发生未知错误：\\(error)\")\n}\n\n```\n\n> - throws：在函数声明中标注该函数会抛出错误;\n> - try：在调用可能抛出错误的函数时使用.\n\n\n\n### 其他的协议\n\n#### CaseIterable\n\n用于获取枚举的属性个数, 从而进行遍历.\n\n```swift\nenum Status:CaseIterable{\n    case low,middle,high\n    \n    \n    mutating func change(){\n        switch self{\n        case .high:\n            self = .low\n        case .low:\n            self = .middle\n        case .middle:\n            self = .high\n        }\n    }\n    \n    func ptr(){\n        print(\"Current Status is \\(self)\")\n    }\n}\n\nvar status = Status.low\nfor _ in 0..<Status.allCases.count{\n    status.ptr()\n    status.change()\n}\n```\n\n> `for _ in 0..<` 当中的 `_`表示忽略遍历时候的循环变量的值.\n\n\n\n\n\n## 闭包\n\n#### 闭包的简化推导\n\n相当于匿名函数与 `lambda`.  接下来从普通函数的写法开始简化:\n\n- 普通函数: \n\n  ```swift\n  func changeSign(op: Double) -> Double {\n      return -op\n  }\n  \n  var operation: (Double) -> Double\n  operation = changeSign\n  \n  let result = operation(4.0) // result = -4.0\n  ```\n\n- 将函数的定义下移:\n\n  ```swift\n  var operation: (Double) -> Double\n  operation = (op:Double) -> Double { return -op}\n  \n  let result  = operation(4.0)\n  ```\n\n- 将`｛` 提前，并在原来的位置添加 `in`\n\n  ```swift\n  var operation:(Double) -> Double\n  operation = {(op: Double) -> Double  in return -op}\n  ...\n  ```\n\n- 系统可以推断类型, 所以根据输入的类型简化返回值的类型定义\n\n  ```swift\n  var operation:(Double) -> Double\n  operation = {(op: Double)   in return -op}\n  ...\n  ```\n\n- 可以进一步省略传入的类型\n\n  ```swift\n  var operation:(Double) -> Double\n  operation = { (op) in return -op}\n  ...\n  ```\n\n- 省略返回的标记 `return`:\n\n  ```swift\n  var operation:(Double) -> Double\n  operation = { (op) in  -op}\n  ...\n  ```\n\n最后, 我们可以直接用 `$0`等替代传入的参数, 也就是省略了参数的名称!\n\n```swift\nvar operation:(Double) -> Double\noperation = { -$0 }\n...\n```\n\n\n\n#### 闭包的常见使用\n\ne.g. \n\n![image-20250412170605776](swift.assets/image-20250412170605776.png)\n\n#### Trailing Closure\n\n当闭包是函数的**最后一个参数**时，\n\n```swift\nlet result = applyTwice(3, operation: { $0 * 2 })\n```\n\n可以改写成:\n\n```swift\nlet result = applyTwice(3) { $0 * 2 } // result = 12\n```\n\n\n\n# 慕课学习杂记\n\n#### something\n\n- 去官网学习新出现的技术\n  - codeML\n  - 张克俊老师?\n\n\n\n- 函数也可以赋值给变量 \n\n\n\n#### 省略外部参数名\n\n- 外部参数名: 在函数调用的时候使用, 提高可读性;\n- 内部参数名: 在函数体的内部使用\n\n\n\n如果如此定义:\n\n```swift\nfunc greet(person name: String){\n  print(\"Hello , \\(name)\")\n}\n```\n\n那么在调用的时候必须显示声明外部参数名:\n\n```swift\ngreet( person: \"Alice\")\n```\n\n\n\n如果我们希望省略外部参数名, 就可以在定义函数的时候用 `_`来代替:\n\n```swift\nfunc greet(_ name: String){\n  ...\n}\n```\n\n\n\n#### 高阶函数\n\n我们可以让函数作为另一个函数的输入参数:\n\n```swift\nfunc addTwoInts( _ a: Int, _ b: Int) -> Int{\n  return a+b\n}\n\nvar mathFunction = addTwoInts\n\n// 高阶函数\nfunc printMathResults（_ mathFunction: (Int, Int）-> Int, _ a: Int, _ b: Int){\n  var result = mathFunction(a,b)\n  print(result)\n}\n\n// 调用\nprintMathResults（addTwoInts， 3,5）\n\n```\n\n> 注意函数作为参数的时候, 类型的定义就是输入类型和返回类型, 也是用 `,` 来分隔不同的参数.\n\n\n\n---\n\n\n\n#### 内置的库\n\n`AVFoudation`: 音频播放 \n\n\n\n---\n\n\n\n- 枚举内部也可以设置方法; \n\n- 结构体本身不需要构造函数(因为swift存在对于结构体的默认构造) , 但是如果结构体内部的属性存在这样的属性:\n\n  - 它可能是枚举内部的方法, 跟枚举的属性有关, 可能使用了 `switch`来根据枚举属性赋值.\n\n  ```swift\n  enum Type{\n    case Cike\n    case ...\n    \n    func blood()-> Double{\n      switch self{\n        case .Cike: return 10\n        case .Fashi: return ...\n        ...\n      }\n    }\n    \n  }\n  \n  struct Card {\n    var country: Country\n    vat type: Type\n    var blood: Double\n    \n    init (country: Country, type: Type){\n      self.country = country\n      self.type = type;\n      blood = type.blood\n    }\n  }\n  ```\n\n\n\n- 结构体和枚举属于 <u>值类型</u>, 如果赋值的时候进行拷贝操作;\n  - 如果结构体声明为 `let`, 即使属性是变量, 那么也无法修改内部的属性,\n- 类是引用类型, 赋值的时候使得左值指向了同样的内存区域, 也就是信息保持一致, 更改同步\n  - 如果我们将类声明为常量, 相当于cpp的指针常量, 也就是说类内部的属性可以更改, 但是无法修改这个量指向的内存区域.\n\n\n\n#### 计算属性\n\n访问的时候动态计算得到.\n\n下面通过一个矩形的例子来说明:\n\n```swift\nstruct Point {\n  var x = 0.0\n  var y = 0.0\n}\n\nstruct Size{\n  var width = 0.0\n  var height = 0.0\n}\n\nstruct Rect{\n  var origin = Point()\n  var size = Size()\n  var center: Point{\n    get{\n      let centerX = origin.x + (size.width / 2)\n      let centerY = orgin.y + (size.height /2 )\n      return Point(x: centerX, y: centerY)\n    }\n    set(newCenter){\n      origin.x = newCenter.x - (size.width / 2)\n      origin.y = newCenter.y - (size.height / 2)\n    }\n  }\n}\n```\n\n上述完成了结构体的计算属性的定义, 其中 `get`部分也可以优化为:\n\n```swift\nget{\n\tPoint(x: origin.x + (size.width / 2),\n        y: orgin.y + (size.height /2 ) )\n}\n```\n\n> 这是因为, 如果 `get` 部分只存在一个表达式,  就会自动将其返回, 不需要显式声明 `return`关键字.\n\n然后可以如此应用:\n\n```swift\nvar currCenter = rectElement.center\n\nrectElement.center = Point(x:20, y:50)\n```\n\n\n\n`set`提供了语法糖, 也就是可以直接访问oldValue 和  newValue, 因此我们可以如此改写:\n\n```swift\nset{\n  origin.x = newValue.x - (size.width / 2)\n  origin.y = newValue.y - (size.height / 2)\n}\n```\n\n\n\n> [!NOTE]\n>\n> 对于只读的计算属性, 由于不存在 `set`, 我们可以直接在花括号内定义返回内容.\n\n\n\n---\n\n- 声明 `static` , 表示这个属性或者方法属于整个类型而非某个实例. 此时相应的, 我们使用 `<tyepName>.<strtic attribute>`的方式来访问.\n\n\n\n- 子面量本身是不可修改的, 下面的拓展中, 如果写作  `var someInt = 3.square()`就会报错\n\n```swift\nextension Int{\n    mutating func square(){\n        self = self * self\n    }\n}\n\nvar someInt = 3\nsomeInt.square()\n```\n\n\n\n---\n\n控制器存在5种状态:\n\n- 未加载\n- 将要出现\n- 出现\n- 将要消失\n- 已经消失\n\n\n\nAPP的状态:\n\n<img src=\"swift.assets/image-20250413182851979.png\" alt=\"image-20250413182851979\" style=\"zoom:33%;\" />\n\n`UiSceneDelegate`用于响应基于 `scene` 的生命周期事件.\n\n\n\n可以使用属性的 `didset`来便捷地检测变化并快速修改:\n\n```swift\nvar score = 0{\n  didSet{\n    self.gameScoreLabel.text = \"Score: \\(score)\"\n  }\n}\n```\n\n\n\n- `viewController`是新的页面;\n- `view`是视图, 可以叠加在页面上.\n- `UIAlertController`组件相当于警示的弹窗组件\n\n\n\n### 作图和绘画\n\n#### CG\n\n- `CGFloat`用于二维坐标系中的坐标数据:\n\n  - `let coor_x = CGFloat(10.5)`\n\n- `CGPoint(x: .. , y:...)`\n\n- `CGSize` 包含width和height属性的结构体;\n\n- `CGRect`包含点和尺寸的矩形\n\n  ```swift\n  struct CGRect{\n    var origin: CGPoint\n    var size: CGSize\n  }\n  ```\n\n  - 其他属性\n\n  - e.g.\n\n    ```swift\n    var minX: CGPoint\n    var midY: CGPoint\n    intersects(CGRect) -> Bool // 判断是否存在交集\n    contains(CGPoint) -> Bool // 是否包含点.\n    ```\n\n\n\n最小单元是 `Point`而非像素点.\n\nbound表示视图内部允许绘制的区域:\n\n```swift\nvar bounds: CGRect // 也就是一个矩形\n```\n\nframe\t视图在父视图中的位置:\n\n```swift\nvar frame: CGRect\n```\n\n\n\n#### 自定义视图\n\n绘制自定义视图通常通过创建一个自定义的 UIView 子类，并重写 draw(_:) 方法来实现.\n\nplayGround中的实例:\n\n```swift\nimport UIKit\nimport PlaygroundSupport\n\nclass CustomView: UIView {\n    override init(frame: CGRect) {\n        super.init(frame: frame)\n        self.backgroundColor = .white // 设置背景颜色\n    }\n\n    required init?(coder: NSCoder) {\n        fatalError(\"init(coder:) has not been implemented\")\n    }\n\n    override func draw(_ rect: CGRect) {\n        guard let context = UIGraphicsGetCurrentContext() else { return }\n\n        // 绘制一个圆形\n        context.setFillColor(UIColor.blue.cgColor) // 设置填充颜色\n        context.fillEllipse(in: rect) // 绘制填充的圆\n\n        // 绘制一个矩形\n        context.setStrokeColor(UIColor.black.withAlphaComponent(0.6).cgColor) // 设置能见度\n        context.setLineWidth(5)\n        context.stroke(rect.insetBy(dx: 10, dy: 10)) // 绘制矩形边框，留出间距\n    }\n}\n\n// 创建自定义视图实例\nlet customView = CustomView(frame: CGRect(x: 0, y: 0, width: 200, height: 200))\n\n// 显示在 Playground 的 live view\nPlaygroundPage.current.liveView = customView\n\n```\n\n\n\n- `touchesBegan`--WWDC\n- `SCNVector3`是三维向量\n- `DispathchQueue`表示创建一个异步的进程\n\n\n\n### 传感器\n\n- 加速度的方向伴随手机的头部旋转保持不变;\n  - 以 `g` 为描述单位;\n  - 面向使用者的方向是 `z` 轴.\n- 陀螺仪\n  - 记录对应用三个轴\n  - roll, pitch, yaw\n\n\n\n### 动画\n\n\n\n## 结绳记事\n\n- [操作演示](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245274&cid=1299836384&contentid=1217938866).\n\n- 按住 `ctrl`将视图中的组件拖放到代码中.\n- 右下角的几个功能:\n  - 约束;\n  - 选择视图 \n- `ctrl + option + cmd + enter` 快速显示代码区域\n- [组件使用](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245274&cid=1299836386&contentid=1217092922)\n  - 50:00 左右介绍了两种类型和交互\n\n- 按住`optional`然后 hover 在类上, 可以显示对应的基础操作.\n\n- 可选值的本质是枚举类型!\n\n  ```swift\n  enum Optional<T>{\n    case none\n    case some(<T>)\n  }\n  ```\n\n- [画图和动画](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245305&sm=1)\n\n- [coreML](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245309&sm=1)\n\n- 在项目中显示Md格式:\n\n  ```swift\n  /*:\n  ...\n  */\n  ```\n\n- 选择在运行时隐藏实际存在的代码:\n\n  ```swift\n  //#-hidden-code\n  import PlaygroundSupport\n  ...\n  //#-end-hidden-code\n  \n  ```\n\n  \n\n\n\n\n\n# Swift UI\n\n- [慕课的链接](https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245315&cid=1299836440&contentid=1218091551)\n- [by now](https://www.hackingwithswift.com/100/swiftui/16)\n- SixD: 开箱即用的UI设计等.\n- [术语表](https://www.hackingwithswift.com/glossary)\n\n\n\n## AR\n\n- [helpful links](https://www.createwithswift.com/creating-an-augmented-reality-app-in-swiftui-using-realitykit-and-arkit/)\n- [官方文档](https://developer.apple.com/documentation/realitykit/?ref=createwithswift.com)\n\n\n\n## 动画\n\n#### 缩放变换\n\n```swift\nNavigationLink{\n  BraceletEditor(bracelet)\n  .navigationTransitionStyle(\n  .zoom(\n  \tsourceID:bracelet.id,\n  \tin:braceletList\n  \t)\n  )\n}label:{\n  BraceletPreview(bracelet)\n}\n.matchedTansitionSource(\n\tid:bracelet.id,\n  in:braceletList\n)\n```\n\n\n\n\n\n## Symbol 6\n\n### 动画\n\n- 使用 `晃动` 在复杂的UI中提示可交互性.\n- `旋转`动画来表示正在进行的进程\n\n## 基本语法\n\n#### 磨砂效果\n\n```swift\nVStack {\n}\n.frame(width: 200, height: 200)\n.background(.ultraThinMaterial, in: RoundedRectangle(cornerRadius: 20, style: .continuous))\n```\n\n\n\n#### 搜索栏\n\n- 状态管理:\n\n  ```swift\n  // 存储搜索文本\n  @State private var searchText = \"\"\n  \n  // 可选：跟踪搜索是否处于活动状态\n  @State private var isSearching = false\n  ```\n\n- 数据过滤模式\n\n  ```swift\n  // 基本过滤计算属性模板\n  var filteredItems: [ItemType] {\n      if searchText.isEmpty {\n          return originalItems\n      } else {\n          return originalItems.filter { item in\n              // 根据需要自定义过滤条件\n              item.name.localizedCaseInsensitiveContains(searchText) ||\n              item.description.localizedCaseInsensitiveContains(searchText)\n          }\n      }\n  }\n  \n  // 处理嵌套数据结构的过滤模板\n  var filteredNestedItems: [ParentType] {\n      if searchText.isEmpty {\n          return originalParentItems\n      } else {\n          return originalParentItems.compactMap { parent in\n              let matchedChildren = parent.children.filter { child in\n                  child.name.localizedCaseInsensitiveContains(searchText)\n              }\n              \n              if matchedChildren.isEmpty {\n                  return nil\n              } else {\n                  // 创建包含匹配子项的新父项\n                  return ParentType(id: parent.id, name: parent.name, children: matchedChildren)\n              }\n          }\n      }\n  }\n  ```\n\n- 搜索UI中的实现:\n\n  ```swift\n  NavigationStack {\n      List {\n          // 使用过滤后的数据源\n          ForEach(filteredItems) { item in\n              // 列表项视图\n          }\n      }\n      .navigationTitle(\"标题\")\n      .searchable(text: $searchText, prompt: \"搜索提示文字\")\n      // 可选：添加搜索建议\n      .searchSuggestions {\n          ForEach(suggestions, id: \\.self) { suggestion in\n              Text(suggestion).searchCompletion(suggestion)\n          }\n      }\n  }\n  ```\n\n\n\n\n\n#### 左右适应的外边距\n\n通过 `HStack`与  `space`实现卡片的自适应扩展, 同时利用 `.frame(maxwidth:...)`来设置一个最大的卡片宽度\n\n```swift\nHStack{\n    Spacer(minLength: 10)\n  \n    Text(item.description)\n        .padding()\n        .background(Color(.systemGray6))\n        .overlay(\n            RoundedRectangle(cornerRadius: 10) // 10为圆角半径，可调整\n                .stroke(Color.gray, lineWidth: 1) // 边框颜色和宽度\n        )\n        .clipShape(RoundedRectangle(cornerRadius: 10))\n    // 保证背景和边框都圆角\n    .frame(maxWidth: 400) // 最大宽度限制\n\n    Spacer(minLength: 10)\n}\n```\n\n`Spacer(minLength: 10)` 表示**保证自己不会小于 minLength**. \n\n\n\n上述的 `Spacer`会压缩卡片的内容, 如果希望直接设置卡片在父容器中的左右外边距, 应该在卡片的内部使用 `padding`:\n\n```swift\nText(item.description)\n    .padding(.horizontal, 24) // 卡片内容内边距\n    .padding(.vertical, 12)\n    .background(Color(.systemGray6))\n    .overlay(\n        RoundedRectangle(cornerRadius: 10)\n            .stroke(Color.gray, lineWidth: 2)\n    )\n    .clipShape(RoundedRectangle(cornerRadius: 10))\n    .padding(.horizontal, 20) // 整个卡片距离父视图左右20pt\n```\n\n\n\n#### 全局统一样式\n\n```swift\n@main\nstruct MyApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n                .buttonStyle(ShadowButtonStyle(radius: 10))\n        }\n    }\n}\n```\n\n\n\n#### 参数标签和参数名\n\n- 参数标签用于函数调用时;\n- 参数名用于函数内部的参数名称.\n\ne.g.:\n\n```swift\nfunc greet(person atName: String) {\n    print(\"Hello, \\(atName)!\")\n}\ngreet(person: \"Alice\") // 输出：Hello, Alice!\n```\n\n\n\n也可以使用 `_`来省略调用时的参数标签:\n\n```swift\nfunc greet(_ name: String) {\n    print(\"Hello, \\(name)!\")\n}\ngreet(\"Alice\") // 输出：Hello, Alice!\n```\n\n\n\n\n\n#### Alert\n\nswift UI中的弹窗提示同样通过本地的 `@State`变量来实现:\n\n```swift\n@State private var showingPaymentAlert = false\n...\n.alert(\"Order confirmed\", isPresented: $showingPaymentAlert) {\n    // add buttons here\n} message: {\n    Text(\"Your total was \\(totalPrice) – thank you!\")\n}\n```\n\n设置按钮来改变可见的状态:\n\n```swift\nButton(\"Confirm order\") {\n    showingPaymentAlert.toggle()\n}\n```\n\n\n\n#### 自定义绑定\n\n我们也可以使用 `Binding` 类型手动创建绑定，该类型可以提供自定义 `get` 和 `set` 闭包，以便在读取或写入值时运行。\n\n\n\n\n\n#### Foreach\n\n```swift\nForEach(item.restrictions) { restriction in\n    Text(restriction)\n}\n```\n\n此时, 要求 `item.restrictions` 具有可唯一标识的 `id` 字段.\n\n- 如果内容本身就是唯一标识, 比如说遍历的内容是字符串数组, 那么可以如此声明:\n\n  ```swift\n  ForEach(item.restrictions, id: \\.self) { restriction in\n      Text(restriction)\n  }\n  ```\n\n\n\n#### Spacer()\n\n用于填充剩余的空间\n\n\n\n- 使用 `offset(x:.., y:...)`来调节位置, 左上角是原点.\n\n\n\n#### 环境变量\n\n- 作用: 用于存储独立于视图的、长期存在的数据;\n\n- e.g.\n\n  ```swift\n  // App.swift\n  @StateObject var order = Order()\n  ```\n\n- `@StateObject` 属性包装器负责在<u>应用程序的整个生命周期中</u>保持对象处于活动状态。\n\n- 需要在创建视图结构体的时候传递:\n\n  ```swift\n  WindowGroup {\n      ContentView()\n          .environmentObject(order)\n  }\n  ```\n\n- 为了让swift知道什么时候更新视图, 常用的是声明 `@Published`属性包装器——足以让它更新任何正在监视更改的 SwiftUI 视图.\n\n- 同时声明对应的对象遵循可观测协议: **ObservableObject**.\n\n\n\n我们可以使用 `@EnvironmentObject`来访问环境中的共享数据, 也就是传递上一步已经在父视图中创建和管理的对象.\n\ne.g.\n\n```swift\nclass UserData: ObservableObject {\n    @Published var name: String = \"John\"\n}\n\nstruct ContentView: View {\n    @StateObject private var userData = UserData()\n\n    var body: some View {\n        ChildView().environmentObject(userData)\n    }\n}\n\nstruct ChildView: View {\n    @EnvironmentObject var userData: UserData\n\n    var body: some View {\n        Text(userData.name)\n    }\n}\n```\n\n\n\n使用 `@State`来声明简单的本地值——比如整数和字符串.\n\n- 建议将其声明为 `private`, e.g.\n\n  ```swift\n  @State private var paymentType = \"Cash\"\n  ```\n\n  \n\n#### 菜单视图\n\n为了将菜单视图存放在一个选项卡当中, 我们需要新建一个视图, 用来作为容器:\n\n```swift\nstruct MainView: View {\n    var body: some View {\n        TabView {\n            ContentView()\n                .tabItem {\n                    Label(\"Menu\", systemImage: \"list.dash\")\n                }\n\n            OrderView()\n                .tabItem {\n                    Label(\"Order\", systemImage: \"square.and.pencil\")\n                }\n        }\n    }\n}\n```\n\n> 页面级别的切换.\n\n\n\n使用枚举与子页面的内容分区:\n\n```swift\nimport SwiftUI\n\nstruct ContentView: View {\n    enum Section {\n        case cats\n        case dogs\n    }\n\n    @State private var selectedTab = Section.cats\n\n    var body: some View {\n        TabView(selection: $selectedTab) {\n            Tab(\"Cats\", systemImage: \"cat\", value: .cats) {\n                Button(\"Go to Dogs\") {\n                    selectedTab = .dogs\n                }\n            }\n            \n            Tab(\"Dogs\", systemImage: \"dog\", value: .dogs) {\n                Button(\"Go to Cats\") {\n                    selectedTab = .cats\n                }\n            }\n        }\n    }\n}\n```\n\n\n\n\n\n## 合适的修饰符\n\n- 图像自动调节尺寸:\n\n  ```swift\n  Image(item.mainImage)\n      .resizable()\n      .scaledToFit()\n  ```\n\n\n\n#### 设置阴影\n\n```swift\n.shadow(color: .black.opacity(0.2), \n        radius: 15, x: 0, y: 10)\n```\n\n\n\n#### 为按钮设置动画\n\n```swift\nstruct ContentView: View {\n    @State private var showingWelcome = false\n\n    var body: some View {\n        VStack {\n            Toggle(\"Toggle label\", isOn: $showingWelcome.animation())\n\n            if showingWelcome {\n                Text(\"Hello World\")\n            }\n        }\n    }\n}\n```\n\n可以进一步设置, 比如弹簧的渐入渐出:\n\n```swift\nToggle(\"Toggle label\", isOn: $showingWelcome.animation(.spring()))\n```\n\n\n\n## 基本操作\n\n#### 快捷键\n\n- `ctrl`按住后点击  `VStack`可以快速地将其添加到 `ZStack`当中\n  - 颜色的设置需要通过 `ZStack`来实现.\n- `option`可以显示当前类的介绍\n- \n\n\n\n学习路线:\n\n1. 学习 Swift 基础语法\n2. 上手 SwiftUI 基础控件（Text、Button、Image、List、NavigationStack 等）\n3. 学会使用 @State、@Binding 等状态管理属性\n4. 尝试做一个简单的 App（比如 ToDo List、小笔记本）\n5. 慢慢接触更复杂的功能，比如动画、数据持久化（CoreData）、网络请求（URLSession）\n\n\n\n#### **第二周：SwiftUI 基础入门**\n\n**目标：**\n\n- 理解 SwiftUI 的基本概念和架构。\n- 掌握常用的 SwiftUI 视图和修饰符。\n\n1. **SwiftUI 概述：**\n   - 声明式语法与传统 UIKit 的区别\n   - SwiftUI 的视图层次结构\n2. **常用视图组件：**\n   - Text、Image、Button 等基本控件的使用\n   - 视图修饰符的应用，如 .font()、.foregroundColor()、.padding() 等\n3. **布局系统：**\n   - 使用 HStack、VStack 和 ZStack 进行视图布局\n   - Spacer 和 Divider 的使用\n\n**推荐资源：**\n\n- **Hacking with Swift 的 100 天 SwiftUI：** [100 Days of SwiftUI](https://www.hackingwithswift.com/100/swiftui)\n- **AppCoda 的 SwiftUI 教程：** [AppCoda - Mastering SwiftUI](https://www.appcoda.com/swiftui/)\n\n#### **第三周：状态管理与数据绑定**\n\n**目标：**\n\n- 理解并应用 SwiftUI 的状态管理机制。\n- 掌握数据绑定和视图更新的原理。\n\n**学习内容：**\n\n1. **状态管理：**\n   - 使用 @State 管理视图内部状态\n   - 使用 @Binding 在父子视图之间传递状态\n   - 使用 @ObservedObject 和 @EnvironmentObject 管理复杂数据模型\n2. **数据绑定：**\n   - 双向绑定的实现\n   - 数据变化如何驱动视图更新\n\n**推荐资源：**\n\n- **SwiftUI 官方文档：** [SwiftUI Documentation](https://developer.apple.com/documentation/swiftui)\n- **Design+Code 的 SwiftUI 教程：** [Design+Code - SwiftUI for iOS 17](https://designcode.io/swiftui)\n\n\n\n#### **第四周：导航、列表与高级交互**\n\n**目标：**\n\n- 掌握 SwiftUI 中的导航和列表视图。\n- 实现复杂的用户交互和动画效果\n\n**学习内容：**\n\n1. **导航与路由：**\n   - 使用 NavigationView 和 NavigationLink 实现页面导航\n   - 传递数据到下一个视图\n2. **列表视图：**\n   - 使用 List 展示数据集合\n   - 自定义列表行和支持删除、移动操作\n3. **动画与手势：**\n   - 添加基本动画效果\n   - 处理手势交互，如拖拽、缩放等\n\n**推荐资源：**\n\n- **Raywenderlich 的 SwiftUI 教程：** [Raywenderlich - SwiftUI Apprentice](https://www.raywenderlich.com/books/swiftui-apprentice)\n- **Big Mountain Studio 的免费电子书：** [SwiftUI Views Quick Start](https://www.bigmountainstudio.com/free-swiftui-book)\n\n","slug":"swift","published":1,"updated":"2025-05-09T01:46:42.574Z","comments":1,"layout":"post","photos":[],"_id":"cmag5d8ah000v2xqg8f4ngtgw","content":"<h1 id=\"初见\"><a href=\"#初见\" class=\"headerlink\" title=\"初见\"></a>初见</h1><p>默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用 <code>_</code> 表示不使用参数标签:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"keyword\">_</span> <span class=\"params\">person</span>: <span class=\"type\">String</span>, <span class=\"params\">on</span> <span class=\"params\">day</span>: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello <span class=\"subst\">\\(person)</span>, today is <span class=\"subst\">\\(day)</span>.&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(<span class=\"string\">&quot;John&quot;</span>, on: <span class=\"string\">&quot;Wednesday&quot;</span>)</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>参数标签指的是调用时候的名称, 参数名指的是函数内部.</p>\n</blockquote>\n<p>函数是第一等类型，这意味着函数可以作为另一个函数的返回值。</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">makeIncrementer</span>() -&gt; ((<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">addOne</span>(<span class=\"params\">number</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"operator\">+</span> number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addOne</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> increment <span class=\"operator\">=</span> makeIncrementer()</span><br><span class=\"line\">increment(<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>函数也可以作为另一个函数的输入参数:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">hasAnyMatches</span>(<span class=\"params\">list</span>: [<span class=\"type\">Int</span>], <span class=\"params\">condition</span>: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> list &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> condition(item) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">lessThanTen</span>(<span class=\"params\">number</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> number <span class=\"operator\">&lt;</span> <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">20</span>, <span class=\"number\">19</span>, <span class=\"number\">7</span>, <span class=\"number\">12</span>]</span><br><span class=\"line\">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sortedNumbers <span class=\"operator\">=</span> numbers.sorted &#123; <span class=\"variable\">$0</span> <span class=\"operator\">&gt;</span> <span class=\"variable\">$1</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(sortedNumbers)</span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n<p><code>actor</code>与 <code>class</code>类似, 但是可以序列化访问, 保护共享、可变的数据.</p>\n<h3 id=\"对象和类\"><a href=\"#对象和类\" class=\"headerlink\" title=\"对象和类\"></a>对象和类</h3><h4 id=\"构造与析构\"><a href=\"#构造与析构\" class=\"headerlink\" title=\"构造与析构\"></a>构造与析构</h4><p>使用 <code>self.</code>替代 <code>this-&gt;</code>, 使用  <code>init</code> 和  <code>deinit</code>分别声明构造和析构函数:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NamedShape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> numberOfSides: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">simpleDescription</span>() -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;A shape with <span class=\"subst\">\\(numberOfSides)</span> sides.&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>子类如果要重写父类的方法的话，需要用 <code>override</code> 标记:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Square</span>: <span class=\"title class_ inherited__\">NamedShape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sideLength: <span class=\"type\">Double</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">sideLength</span>: <span class=\"type\">Double</span>, <span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sideLength <span class=\"operator\">=</span> sideLength</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</span><br><span class=\"line\">        numberOfSides <span class=\"operator\">=</span> <span class=\"number\">4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">area</span>() -&gt;  <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sideLength <span class=\"operator\">*</span> sideLength</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">simpleDescription</span>() -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;A square with sides of length <span class=\"subst\">\\(sideLength)</span>.&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> test <span class=\"operator\">=</span> <span class=\"type\">Square</span>(sideLength: <span class=\"number\">5.2</span>, name: <span class=\"string\">&quot;my test square&quot;</span>)</span><br><span class=\"line\">test.area()</span><br><span class=\"line\">test.simpleDescription()</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ul>\n<li>使用 <code>:className</code>的方法声明父类.</li>\n<li><code>super.init</code> 是用来调用父类（超类）的初始化方法的。当创建一个子类的实例时，子类可能需要初始化一些自己的属性，同时还需要确保父类的属性也被正确初始化。这时就需要使用 <code>super.init</code> 来调用父类的初始化方法，完成父类的初始化过程</li>\n<li>严格的顺序要求: 子类必须先初始化自己的属性，然后调用 <code>super.init</code>，最后才能访问或修改继承来的属性。</li>\n</ul>\n</blockquote>\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><h4 id=\"普通的计算属性\"><a href=\"#普通的计算属性\" class=\"headerlink\" title=\"普通的计算属性\"></a>普通的计算属性</h4><p>在属性内部使用 <code>&#123;&#125;</code>并加上 <code>return</code>, 可以让访问这个属性的时候, 返回值由结构体的其他属性计算得到.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Temperature</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> celsius: <span class=\"type\">Double</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fahrenheit: <span class=\"type\">Double</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> celsius <span class=\"operator\">*</span><span class=\"number\">1.8</span> <span class=\"operator\">+</span> <span class=\"number\">32</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">init</span>(<span class=\"params\">celsius</span>: <span class=\"type\">Double</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.celsius <span class=\"operator\">=</span> celsius</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ol>\n<li>此时实例化一个结构体就只需要给出一个属性的值.</li>\n<li><code>self</code>在上述的Swift代码中是不可或缺的, 因为形参和内部属性的名称相同.</li>\n</ol>\n</blockquote>\n<h4 id=\"使用-getter-和-setter-的计算属性\"><a href=\"#使用-getter-和-setter-的计算属性\" class=\"headerlink\" title=\"使用 getter 和 setter 的计算属性:\"></a>使用 getter 和 setter 的计算属性:</h4><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EquilateralTriangle</span>: <span class=\"title class_ inherited__\">NamedShape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sideLength: <span class=\"type\">Double</span> <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">sideLength</span>: <span class=\"type\">Double</span>, <span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sideLength <span class=\"operator\">=</span> sideLength</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</span><br><span class=\"line\">        numberOfSides <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> perimeter: <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 根据存储属性进行计算</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">3.0</span> <span class=\"operator\">*</span> sideLength</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            sideLength <span class=\"operator\">=</span> newValue <span class=\"operator\">/</span> <span class=\"number\">3.0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">simpleDescription</span>() -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;An equilateral triangle with sides of length <span class=\"subst\">\\(sideLength)</span>.&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> triangle <span class=\"operator\">=</span> <span class=\"type\">EquilateralTriangle</span>(sideLength: <span class=\"number\">3.1</span>, name: <span class=\"string\">&quot;a triangle&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangle.perimeter)</span><br><span class=\"line\">triangle.perimeter <span class=\"operator\">=</span> <span class=\"number\">9.9</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangle.sideLength)</span><br></pre></td></tr></table></figure></div>\n\n<p>计算属性同样是一个属性, 但是根据调用方式的不同, 有返回和设置两种方式.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triangle.perimeter <span class=\"operator\">=</span> <span class=\"number\">9.9</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangle.perimeter)</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"Mutating\"><a href=\"#Mutating\" class=\"headerlink\" title=\"Mutating\"></a>Mutating</h3><p>默认情况下, 结构体中的方法不能直接修改结构体的属性. 需要显式声明为 <code>mutating</code>:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> username:<span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> isVisible:<span class=\"type\">Bool</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> friends: [string] <span class=\"operator\">=</span> []</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">addFriend</span>(<span class=\"params\">username</span>: <span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">    friends.append(username)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"属性监视器\"><a href=\"#属性监视器\" class=\"headerlink\" title=\"属性监视器\"></a>属性监视器</h3><p>使用 <code>willSet</code> 和 <code>didSet</code>。写入的代码会在属性值发生改变时调用，但不包含构造器中发生值改变的情况:</p>\n<ul>\n<li>分别可以使用 <code>newValue</code>与 <code>oldValue</code>来表示属性将要改变的值以及改变之前的值.</li>\n</ul>\n<p>e.g. 确保三角形的边长总是和正方形的边长相同。</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TriangleAndSquare</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> triangle: <span class=\"type\">EquilateralTriangle</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">willSet</span> &#123;</span><br><span class=\"line\">            square.sideLength <span class=\"operator\">=</span> newValue.sideLength</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> square: <span class=\"type\">Square</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">willSet</span> &#123;</span><br><span class=\"line\">            triangle.sideLength <span class=\"operator\">=</span> newValue.sideLength</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">size</span>: <span class=\"type\">Double</span>, <span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        square <span class=\"operator\">=</span> <span class=\"type\">Square</span>(sideLength: size, name: name)</span><br><span class=\"line\">        triangle <span class=\"operator\">=</span> <span class=\"type\">EquilateralTriangle</span>(sideLength: size, name: name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> triangleAndSquare <span class=\"operator\">=</span> <span class=\"type\">TriangleAndSquare</span>(size: <span class=\"number\">10</span>, name: <span class=\"string\">&quot;another test shape&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangleAndSquare.square.sideLength)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class=\"line\">triangleAndSquare.square <span class=\"operator\">=</span> <span class=\"type\">Square</span>(sideLength: <span class=\"number\">50</span>, name: <span class=\"string\">&quot;larger square&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangleAndSquare.triangle.sideLength)</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Rank</span>: <span class=\"title class_ inherited__\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ace <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> two, three, four, five, six, seven, eight, nine, ten</span><br><span class=\"line\">    <span class=\"keyword\">case</span> jack, queen, king</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">simpleDescription</span>() -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .ace:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;ace&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> .jack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;jack&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> .queen:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;queen&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> .king:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;king&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">String</span>(<span class=\"keyword\">self</span>.rawValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> ace <span class=\"operator\">=</span> <span class=\"type\">Rank</span>.ace</span><br><span class=\"line\"><span class=\"keyword\">let</span> aceRawValue <span class=\"operator\">=</span> ace.rawValue</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>如果没有设置第一个成员的初始值, 默认从 <code>0</code> 开始;</li>\n<li>缺省值按照递增处理;</li>\n<li><code>case</code>之外可以设置方法.</li>\n</ul>\n<p>使用 <code>init?(rawValue:)</code> 初始化构造器来从原始值创建一个枚举实例:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> convertedRank <span class=\"operator\">=</span> <span class=\"type\">Rank（rawValue</span>:<span class=\"number\">3</span>）｛</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> threeDescription <span class=\"operator\">=</span> convertedRank.simpleDescription（）</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ul>\n<li><code>if let</code>表示可选绑定, 安全地解包可选值</li>\n</ul>\n</blockquote>\n<h4 id=\"解包\"><a href=\"#解包\" class=\"headerlink\" title=\"解包\"></a>解包</h4><ol>\n<li><code>if let</code>解包</li>\n</ol>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"type\">A</span> <span class=\"operator\">=</span> <span class=\"type\">B</span> &#123;</span><br><span class=\"line\">  <span class=\"operator\">...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>如果 <code>B</code>不是 nil, 就将其赋值给A, 然后执行 <code>&#123;&#125;</code>内部的语句. </p>\n<ol start=\"2\">\n<li><code>??</code></li>\n</ol>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score : <span class=\"type\">Int</span> <span class=\"operator\">?</span>  <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(score <span class=\"operator\">??</span> default_score)</span><br><span class=\"line\"><span class=\"comment\">// 成绩score不是nil, 就将其打印, 否则输出默认的成绩</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>对字典进行索引:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// scores是一个Int数组</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( major, scores) <span class=\"keyword\">in</span> all_scores &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> score <span class=\"keyword\">in</span> scores&#123;</span><br><span class=\"line\">    <span class=\"operator\">...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果key没有使用, 可以直接忽略</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">_</span>, socres) <span class=\"keyword\">in</span> all_scores&#123;</span><br><span class=\"line\">  <span class=\"operator\">...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>swift支持对字典进行更新或者移除的时候, 返回并使用就值:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue <span class=\"operator\">=</span> scores.updateValue(<span class=\"number\">100</span>, forKey:<span class=\"string\">&quot;fad&quot;</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"operator\">..</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"operator\">...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue <span class=\"operator\">=</span> scores.removeValue(forKey: <span class=\"string\">&quot;fad&quot;</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;fad&#x27;s old value was <span class=\"subst\">\\(oldValue)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><code>@IBAction</code>表示组件交互和代码相绑定(允许在交互的时候执行外部定义的函数);</li>\n<li><code>@IBOutlet</code>表示允许代码的响应改变组件本身的状态(字体、大小等).</li>\n</ul>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"swift.assets/image-20250412115454400.png\"\n                      alt=\"image-20250412115454400\" style=\"zoom:57%;\" \n                >\n\n\n\n\n\n\n\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>闭包指的是可以在特定位置运行的、不需要名称的函数.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scene.setOnStartHandler｛ </span><br><span class=\"line\"><span class=\"comment\">// 闭包的主体</span></span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure></div>\n\n\n\n<ul>\n<li><p><code>toggle()</code>可以自动切换变量的布尔值.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Button</span>(<span class=\"string\">&quot;Press Me&quot;</span>) &#123;</span><br><span class=\"line\">    isOn.toggle()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h4 id=\"状态属性\"><a href=\"#状态属性\" class=\"headerlink\" title=\"状态属性\"></a>状态属性</h4><ul>\n<li><p>使用 <code>@State</code>在视图之外定义;</p>\n</li>\n<li><p>当状态属性的值发生改变时, 会自动更新视图中相关的部分.</p>\n</li>\n<li><p>对于状态对象, 使用 <code>@StateObject</code>来声明.</p>\n</li>\n</ul>\n<h4 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h4><p>由 <code>@Binding</code>声明将属性连接到其他地方, 允许子视图对属性的修改并同步.</p>\n<p>在属性的前面增加 <code>$</code>，表明会同步修改可信源.</p>\n<h4 id=\"字符串插值\"><a href=\"#字符串插值\" class=\"headerlink\" title=\"字符串插值\"></a>字符串插值</h4><p>在较长字符串中使用常量、变量或代码表达式，使它们替换为其当前值以求出字符串的值。</p>\n<p>例如，在字符串”Katy ate a \\（fruit）.”中，如果fruit 是带有值 “peach”的变量，那么在求字符串的值时，\\（fruit）由”peach”替换，变为 “Katy ate a peach.”。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自动的动画效果\"><a href=\"#自动的动画效果\" class=\"headerlink\" title=\"自动的动画效果\"></a>自动的动画效果</h4><p>当状态属性发生改变时, 我们希望对应控制的视图元素的变化具有动画效果, 那么可以指定: e.g.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Circle</span>()</span><br><span class=\"line\">    .frame(maxHeight: <span class=\"number\">200</span>)</span><br><span class=\"line\">    .foregroundColor( isOn <span class=\"operator\">?</span> .purple : .mint </span><br><span class=\"line\">    .shadow(color:isOn <span class=\"operator\">?</span> .indigo : .orange , radius: <span class=\"number\">20</span>)</span><br><span class=\"line\">    .scaleEffect(isOn <span class=\"operator\">?</span> <span class=\"number\">1</span>: <span class=\"number\">0.75</span>)</span><br><span class=\"line\">    .animation( .default, value: isOn)</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>其中的 <code>value： isOn</code>表示追踪的状态属性.</p>\n</blockquote>\n<p>在一个视图中创建状态对象,  然后在 <code>app</code>中声明为环境变量并在子视图中使用.</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>principle </p>\n<ul>\n<li>需要长按进行交互的组件, 在轻触时ICON放大或者缩小</li>\n</ul>\n<h1 id=\"官方手册学习记录\"><a href=\"#官方手册学习记录\" class=\"headerlink\" title=\"官方手册学习记录\"></a>官方手册学习记录</h1><h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><ul>\n<li><p>Swift 使用<em>字符串插值</em>将常量或变量的名称作为占位符包含在较长的字符串中，并提示 Swift 将其替换为该常量或变量的当前值。将名称包在括号中，并在左括号前用反斜杠进行转义：</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The current value of friendlyWelcome is <span class=\"subst\">\\(friendlyWelcome)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The current value of friendlyWelcome is Bonjour！&quot;</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>不必使用 <code>;</code>, 但是如果想在一行中编写多个独立语句，则<em>必须</em>使用分号：</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cat <span class=\"operator\">=</span> <span class=\"string\">&quot;🐱&quot;</span>; <span class=\"built_in\">print</span>(cat)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;🐱&quot;</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>整数边界: 使用 min, max进行访问</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> minValue <span class=\"operator\">=</span> <span class=\"type\">UInt8</span>.min  <span class=\"comment\">// minValue 等于 0，类型为 UInt8</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> maxValue <span class=\"operator\">=</span> <span class=\"type\">UInt8</span>.max  <span class=\"comment\">// maxValue 等于 255，类型为 UInt8</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>类型别名: <code>typealias</code></p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">AudioSample</span> <span class=\"operator\">=</span> <span class=\"type\">UInt16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxAmplitudeFound <span class=\"operator\">=</span> <span class=\"type\">AudioSample</span>.min</span><br><span class=\"line\"><span class=\"comment\">// maxAmplitudeFound 现在为 0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><ul>\n<li>作用: 多个值组合成一个复合值</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> http404Error <span class=\"operator\">=</span> (<span class=\"number\">404</span>, <span class=\"string\">&quot;Not Found&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// http404Error 的类型为（Int，String），且等于（404，&quot;Not Found&quot;）</span></span><br></pre></td></tr></table></figure></div>\n\n<p>如果只需要元组的部分值，则在分解元组时使用下划线 (<code>_</code>) 忽略不需要的部分</p>\n<ul>\n<li><p>分解元组</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> (statusCode, statusMessage) <span class=\"operator\">=</span> http404Error</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The status code is <span class=\"subst\">\\(statusCode)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The status code is 404&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The status message is <span class=\"subst\">\\(statusMessage)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The status message is Not Found&quot;</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>可以在定义元组时为元组中的各个元素命名：</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> http200Status <span class=\"operator\">=</span> (statusCode: <span class=\"number\">200</span>, description: <span class=\"string\">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure></div>\n\n<p>然后可以使用元素名访问:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The status code is <span class=\"subst\">\\(http200Status.statusCode)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The status code is 200&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The status message is <span class=\"subst\">\\(http200Status.description)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The status message is OK&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n\n</li>\n<li><p>也可以直接使用从零开始的索引来访问, e.g. <code>http200Status.0</code></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p><u>可选</u>: 存储这种类型的值或者 <code>nil</code>.</p>\n</li>\n<li><p>提供后备值: <code>??</code></p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"type\">String</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeting <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello, &quot;</span> <span class=\"operator\">+</span> (name <span class=\"operator\">??</span> <span class=\"string\">&quot;friend&quot;</span>) <span class=\"operator\">+</span> <span class=\"string\">&quot;!&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(greeting)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;Hello, friend!&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>如果 <code>??</code> 之前的值不是 <code>nil</code>, 就会正常解包, 否则选择后备值;</li>\n<li>使用 <code>()</code> 包裹.</li>\n</ul>\n</li>\n<li><p><u>隐式解包可选</u>: 安全假定一直都有值时使用</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> possibleString: <span class=\"type\">String</span>? <span class=\"operator\">=</span> <span class=\"string\">&quot;An optional string.&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> forcedString: <span class=\"type\">String</span> <span class=\"operator\">=</span> possibleString<span class=\"operator\">!</span> <span class=\"comment\">// 需要显式解包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> assumedString: <span class=\"type\">String</span>! <span class=\"operator\">=</span> <span class=\"string\">&quot;An implicitly unwrapped optional string.&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> implicitString: <span class=\"type\">String</span> <span class=\"operator\">=</span> assumedString <span class=\"comment\">// 隐式解包</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<hr>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>函数在声明中包含 <code>throws</code> 关键字，表示它可以抛出错误。调用可以抛出错误的函数时，要在表达式前加上 <code>try</code> 关键字.</p>\n<p>Swift 会自动将错误传播到当前作用域之外，直到它们被 <code>catch</code> 子句处理为止。</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> canThrowAnError()</span><br><span class=\"line\">    <span class=\"comment\">// 无错误的情况</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 抛出错误的情况</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>细节部分在后面补充</p>\n</blockquote>\n<h3 id=\"断言和先决条件\"><a href=\"#断言和先决条件\" class=\"headerlink\" title=\"断言和先决条件\"></a>断言和先决条件</h3><h4 id=\"使用断言进行调试\"><a href=\"#使用断言进行调试\" class=\"headerlink\" title=\"使用断言进行调试\"></a>使用断言进行调试</h4><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age <span class=\"operator\">=</span> <span class=\"operator\">-</span><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">assert</span>(age <span class=\"operator\">&gt;=</span> <span class=\"number\">0</span>, <span class=\"string\">&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 该断言失败的原因是 -3 并不 &gt;= 0。</span></span><br></pre></td></tr></table></figure></div>\n\n<p>断言的第一个参数是预期的、正确的结果, 如果不满足条件就会显示报错. 但是不会阻止程序继续运行.</p>\n<h4 id=\"强制执行先决条件\"><a href=\"#强制执行先决条件\" class=\"headerlink\" title=\"强制执行先决条件\"></a>强制执行先决条件</h4><p>当条件有可能为假，但<em>必须</em>为真才能继续执行代码时，请使用先决条件.</p>\n<p>向该函数传递一个计算结果为 <code>true</code> 或 <code>false</code> 的表达式，以及一条在条件结果为 <code>false</code> 时显示的信息:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在下标的实现中...</span></span><br><span class=\"line\"><span class=\"built_in\">precondition</span>(index <span class=\"operator\">&gt;</span> <span class=\"number\">0</span>, <span class=\"string\">&quot;Index must be greater than zero.&quot;</span>)</span><br></pre></td></tr></table></figure></div>\n\n<hr>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h3><ul>\n<li><p>与 C 和 Objective-C 中的赋值运算符不同，Swift 中的赋值运算符本身不返回值。以下语句无效：</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x <span class=\"operator\">=</span> y &#123; <span class=\"comment\">// 这是无效的，因为 x = y 不返回值。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li>可以防止不小心使用赋值运算符（&#x3D;） 而非等于运算符（&#x3D;&#x3D;）.</li>\n</ul>\n</li>\n<li><p>基本的四则运算不允许值的溢出.</p>\n</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>在 Swift 中对负数的处理与模运算符有所不同:</p>\n<p>为了确定 <code>a % b</code> 的答案，<code>%</code> 运算符计算以下等式并返回 <code>余数</code> 作为输出：</p>\n<div class=\"code-container\" data-rel=\"Plaintext\"><figure class=\"iseeu highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a` = (`b` x `某个乘数`) + `余数</span><br></pre></td></tr></table></figure></div>\n\n<p>其中 <code>某个乘数</code> 是 <code>b</code> 在 <code>a</code> 中能容纳的最大倍数。</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">9</span> <span class=\"operator\">%</span> <span class=\"number\">4</span>    <span class=\"comment\">// 等于 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span><span class=\"number\">9</span> <span class=\"operator\">%</span> <span class=\"number\">4</span>   <span class=\"comment\">// 等于 -1</span></span><br></pre></td></tr></table></figure></div></blockquote>\n<ul>\n<li><p>数值的正负号可以使用前缀 <code>-</code> 切换，称为<u>一元负号运算符</u>.</p>\n<ul>\n<li><p>中间没有任何空格.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> three <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> minusThree <span class=\"operator\">=</span> <span class=\"operator\">-</span>three       <span class=\"comment\">// minusThree 等于 -3</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"元组的计算\"><a href=\"#元组的计算\" class=\"headerlink\" title=\"元组的计算\"></a>元组的计算</h4><ul>\n<li>前提: 如果两个元组具有相同的类型和相同数量的值，则可以比较它们.</li>\n<li>规则: <ul>\n<li>元组是从左到右逐个值进行比较的，直到比较发现两个不相等的值为止。</li>\n<li>这两个值将进行比较，并且该比较的结果决定了整个元组比较的结果。</li>\n<li>如果所有元素都相等，那么这两个元组本身就相等。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>只有当给定的运算符可以应用于各自元组中的每个值时，元组才能与该运算符进行比较.</p>\n</blockquote>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"string\">&quot;blue&quot;</span>, <span class=\"literal\">false</span>) <span class=\"operator\">&lt;</span> (<span class=\"string\">&quot;purple&quot;</span>, <span class=\"literal\">true</span>)  <span class=\"comment\">// 错误，因为 &lt; 不能比较布尔值</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"空合并运算符\"><a href=\"#空合并运算符\" class=\"headerlink\" title=\"空合并运算符\"></a>空合并运算符</h4><p><code>a ?? b</code>的结果与下面的运算相同:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a <span class=\"operator\">!=</span> <span class=\"literal\">nil</span> <span class=\"operator\">?</span> a<span class=\"operator\">!</span> : b</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"区间运算\"><a href=\"#区间运算\" class=\"headerlink\" title=\"区间运算\"></a>区间运算</h4><ul>\n<li><p><em>闭区间运算符</em>（<code>a...b</code>）定义了一个从 <code>a</code> 到 <code>b</code> 的范围，包括 <code>a</code> 和 <code>b</code> 的值。<code>a</code> 的值不能大于 <code>b</code>;</p>\n<ul>\n<li><p>在需要使用所有值的情况下很有用</p>\n</li>\n<li><p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">5</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;<span class=\"subst\">\\(index)</span> 乘以 5 等于 <span class=\"subst\">\\(index <span class=\"operator\">*</span> <span class=\"number\">5</span>)</span>&quot;</span>) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n<li><p><em>半开区间运算符</em>（<code>a..&lt;b</code>）定义了一个从 <code>a</code> 到 <code>b</code> 但不包括 <code>b</code> 的范围.</p>\n<ul>\n<li><p>对于处理从基数 0 开始的列表（如数组）时特别有用，因为它可以计数到列表长度（但不包括列表长度）.</p>\n</li>\n<li><p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names <span class=\"operator\">=</span> [<span class=\"string\">&quot;Anna&quot;</span>, <span class=\"string\">&quot;Alex&quot;</span>, <span class=\"string\">&quot;Brian&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>] </span><br><span class=\"line\"><span class=\"keyword\">let</span> count <span class=\"operator\">=</span> names.count</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span><span class=\"operator\">..&lt;</span>count &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;第 <span class=\"subst\">\\(i <span class=\"operator\">+</span> <span class=\"number\">1</span>)</span> 个人叫 <span class=\"subst\">\\(names[i])</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n<li><p>闭区间运算符有一种替代形式，用于一直延伸到尽可能远的区间 —— 例如，一个包含从索引 2 到数组末尾所有元素的区间。</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names[<span class=\"number\">2</span><span class=\"operator\">...</span>] &#123; <span class=\"built_in\">print</span>(name) &#125;</span><br><span class=\"line\"><span class=\"comment\">// Brian</span></span><br><span class=\"line\"><span class=\"comment\">// Jack</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>半开区间运算符也有一种只写最后一个值的单侧形式</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names[<span class=\"operator\">..&lt;</span><span class=\"number\">2</span>] &#123; <span class=\"built_in\">print</span>(name) &#125;</span><br><span class=\"line\"><span class=\"comment\">// Anna</span></span><br><span class=\"line\"><span class=\"comment\">// Alex</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h4 id=\"逻辑运算\"><a href=\"#逻辑运算\" class=\"headerlink\" title=\"逻辑运算\"></a>逻辑运算</h4><blockquote>\n<p>[!NOTE]</p>\n<p>Swift 逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 遵循<u>从左到右</u>的结合顺序，这意味着带有多个逻辑运算符的复合表达式会首先评估最左边的子表达式.</p>\n</blockquote>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><ul>\n<li>如果类需要继承, 需要将父类写在所有的协议之前</li>\n<li>不能在协议定义中为方法参数指定默认值。</li>\n<li>协议也可以要求遵循协议的类型 <u>实现指定的构造器</u>, 和协议内部的方法一样, 不需要写花括号和构造期的实体<ul>\n<li>如果是类, 必须在构造函数的开头加上 <code>required</code>修饰符. 这是为了确保所有继承的子类也提供这个构造函数的实现, 从而确保遵守协议;</li>\n<li>但是如果一个类被声明为了 <code>final</code>, 也就是无法被继承, 那么就不需要 <code>required</code>的声明</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"协议的基本用法\"><a href=\"#协议的基本用法\" class=\"headerlink\" title=\"协议的基本用法\"></a>协议的基本用法</h3><p>协议可以规定属性类型以及属性被操作的权限, 通常和类、结构体和枚举进行绑定, 作为一种强制的约束.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">Tax</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> national: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> individual: <span class=\"type\">Double</span>&#123; <span class=\"keyword\">set</span> <span class=\"keyword\">get</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>同样可以在协议中使用 <code>mutating</code> 来声明一个改变自身属性的方法:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">Tax</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> national: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> individual: <span class=\"type\">Double</span>&#123; <span class=\"keyword\">set</span> <span class=\"keyword\">get</span>&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">changeTax</span>(<span class=\"params\">newValue</span>: <span class=\"type\">Double</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><p>需要注意的是, 结构体内部的方法如果要修改自身属性, 也需要声明 <code>mutating</code>, 但是类则不需要额外的声明.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Taxas</span>: <span class=\"title class_ inherited__\">Tax</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> national: <span class=\"type\">Double</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> individual: <span class=\"type\">Double</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">changeTax</span>(<span class=\"params\">newValue</span>: <span class=\"type\">Double</span>)&#123;</span><br><span class=\"line\">    national <span class=\"operator\">=</span> newValue</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h3 id=\"补充协议\"><a href=\"#补充协议\" class=\"headerlink\" title=\"补充协议\"></a>补充协议</h3><ul>\n<li><p>使用 <code>,</code> 连接不同的协议</p>\n</li>\n<li><p><code>extension</code>可以为协议的函数设置默认方法, 就不需要继续在每一个类、结构体或枚举中重新定义</p>\n<ul>\n<li><p>同样可以补充数据类型</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">Int</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> abs: <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> <span class=\"keyword\">self</span> <span class=\"operator\">&gt;=</span> <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"operator\">-</span><span class=\"keyword\">self</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>((<span class=\"operator\">-</span><span class=\"number\">3</span>).abs);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有条件地遵循协议\"><a href=\"#有条件地遵循协议\" class=\"headerlink\" title=\"有条件地遵循协议\"></a>有条件地遵循协议</h4><p>让 <code>Array</code> 类型只要在存储遵循 <code>TextRepresentable</code> 协议的元素时，就遵循 <code>TextRepresentable</code> 协议:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">Array</span>: <span class=\"title class_ inherited__\">TextRepresentable</span> <span class=\"keyword\">where</span> <span class=\"title class_ inherited__\">Element</span>: <span class=\"title class_ inherited__\">TextRepresentable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> itemsAsText <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.map &#123; <span class=\"variable\">$0</span>.textualDescription &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;[&quot;</span> <span class=\"operator\">+</span> itemsAsText.joined(separator: <span class=\"string\">&quot;, &quot;</span>) <span class=\"operator\">+</span> <span class=\"string\">&quot;]&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myDice <span class=\"operator\">=</span> [d6, d12]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myDice.textualDescription)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"扩展里声明协议遵循\"><a href=\"#扩展里声明协议遵循\" class=\"headerlink\" title=\"扩展里声明协议遵循\"></a>扩展里声明协议遵循</h4><p>当一个类型已经遵循了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空的扩展来让它遵循该协议:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Hamster</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;A hamster named <span class=\"subst\">\\(name)</span>&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">Hamster</span>: <span class=\"title class_ inherited__\">TextRepresentable</span> &#123;&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h3 id=\"Error-handling\"><a href=\"#Error-handling\" class=\"headerlink\" title=\"Error handling\"></a>Error handling</h3><p>系统提供了 <code>Error</code>协议用于错误处理, 主动给予错误的捕捉情况.</p>\n<p>使用方法:</p>\n<ol>\n<li>定义遵循相关协议的枚举类型, 作为错误的类型;</li>\n<li>定义可能抛出错误的函数;</li>\n<li>使用 <code>do...catch</code>块来结构化地处理错误.</li>\n</ol>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个错误类型，遵循 Error 协议</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">PasswordError</span>: <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> tooShort</span><br><span class=\"line\">    <span class=\"keyword\">case</span> tooWeak</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个函数，可能抛出错误</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">validate</span>(<span class=\"params\">password</span>: <span class=\"type\">String</span>) <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> password.count <span class=\"operator\">&lt;</span> <span class=\"number\">6</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">PasswordError</span>.tooShort</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> password <span class=\"operator\">==</span> <span class=\"string\">&quot;123456&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">PasswordError</span>.tooWeak</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 do-catch 捕捉错误</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> validate(password: <span class=\"string\">&quot;123456&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;密码验证通过 ✅&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">PasswordError</span>.tooShort &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 密码太短，请至少使用 6 个字符&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">PasswordError</span>.tooWeak &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 密码太弱，不能使用简单的序列&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 发生未知错误：<span class=\"subst\">\\(error)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<ul>\n<li>throws：在函数声明中标注该函数会抛出错误;</li>\n<li>try：在调用可能抛出错误的函数时使用.</li>\n</ul>\n</blockquote>\n<h3 id=\"其他的协议\"><a href=\"#其他的协议\" class=\"headerlink\" title=\"其他的协议\"></a>其他的协议</h3><h4 id=\"CaseIterable\"><a href=\"#CaseIterable\" class=\"headerlink\" title=\"CaseIterable\"></a>CaseIterable</h4><p>用于获取枚举的属性个数, 从而进行遍历.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Status</span>:<span class=\"title class_ inherited__\">CaseIterable</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> low,middle,high</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">change</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .high:</span><br><span class=\"line\">            <span class=\"keyword\">self</span> <span class=\"operator\">=</span> .low</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .low:</span><br><span class=\"line\">            <span class=\"keyword\">self</span> <span class=\"operator\">=</span> .middle</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .middle:</span><br><span class=\"line\">            <span class=\"keyword\">self</span> <span class=\"operator\">=</span> .high</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">ptr</span>()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Current Status is <span class=\"subst\">\\(<span class=\"keyword\">self</span>)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> status <span class=\"operator\">=</span> <span class=\"type\">Status</span>.low</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span><span class=\"operator\">..&lt;</span><span class=\"type\">Status</span>.allCases.count&#123;</span><br><span class=\"line\">    status.ptr()</span><br><span class=\"line\">    status.change()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p><code>for _ in 0..&lt;</code> 当中的 <code>_</code>表示忽略遍历时候的循环变量的值.</p>\n</blockquote>\n<h2 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h4 id=\"闭包的简化推导\"><a href=\"#闭包的简化推导\" class=\"headerlink\" title=\"闭包的简化推导\"></a>闭包的简化推导</h4><p>相当于匿名函数与 <code>lambda</code>.  接下来从普通函数的写法开始简化:</p>\n<ul>\n<li><p>普通函数: </p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">changeSign</span>(<span class=\"params\">op</span>: <span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> operation: (<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> changeSign</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> operation(<span class=\"number\">4.0</span>) <span class=\"comment\">// result = -4.0</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>将函数的定义下移:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation: (<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> (op:<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result  <span class=\"operator\">=</span> operation(<span class=\"number\">4.0</span>)</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>将<code>｛</code> 提前，并在原来的位置添加 <code>in</code></p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123;(op: <span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span>  <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>系统可以推断类型, 所以根据输入的类型简化返回值的类型定义</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123;(op: <span class=\"type\">Double</span>)   <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>可以进一步省略传入的类型</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123; (op) <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>省略返回的标记 <code>return</code>:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123; (op) <span class=\"keyword\">in</span>  <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<p>最后, 我们可以直接用 <code>$0</code>等替代传入的参数, 也就是省略了参数的名称!</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123; <span class=\"operator\">-</span><span class=\"variable\">$0</span> &#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"闭包的常见使用\"><a href=\"#闭包的常见使用\" class=\"headerlink\" title=\"闭包的常见使用\"></a>闭包的常见使用</h4><p>e.g. </p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/swift.assets/image-20250412170605776.png\"\n                      alt=\"image-20250412170605776\"\n                ></p>\n<h4 id=\"Trailing-Closure\"><a href=\"#Trailing-Closure\" class=\"headerlink\" title=\"Trailing Closure\"></a>Trailing Closure</h4><p>当闭包是函数的<strong>最后一个参数</strong>时，</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> applyTwice(<span class=\"number\">3</span>, operation: &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125;)</span><br></pre></td></tr></table></figure></div>\n\n<p>可以改写成:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> applyTwice(<span class=\"number\">3</span>) &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125; <span class=\"comment\">// result = 12</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h1 id=\"慕课学习杂记\"><a href=\"#慕课学习杂记\" class=\"headerlink\" title=\"慕课学习杂记\"></a>慕课学习杂记</h1><h4 id=\"something\"><a href=\"#something\" class=\"headerlink\" title=\"something\"></a>something</h4><ul>\n<li><p>去官网学习新出现的技术</p>\n<ul>\n<li>codeML</li>\n<li>张克俊老师?</li>\n</ul>\n</li>\n<li><p>函数也可以赋值给变量</p>\n</li>\n</ul>\n<h4 id=\"省略外部参数名\"><a href=\"#省略外部参数名\" class=\"headerlink\" title=\"省略外部参数名\"></a>省略外部参数名</h4><ul>\n<li>外部参数名: 在函数调用的时候使用, 提高可读性;</li>\n<li>内部参数名: 在函数体的内部使用</li>\n</ul>\n<p>如果如此定义:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello , <span class=\"subst\">\\(name)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>那么在调用的时候必须显示声明外部参数名:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">greet( person: <span class=\"string\">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>如果我们希望省略外部参数名, 就可以在定义函数的时候用 <code>_</code>来代替:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"keyword\">_</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">  <span class=\"operator\">...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>我们可以让函数作为另一个函数的输入参数:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">addTwoInts</span>( <span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">b</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a<span class=\"operator\">+</span>b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mathFunction <span class=\"operator\">=</span> addTwoInts</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 高阶函数</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">printMathResults（_</span> mathFunction: (<span class=\"type\">Int</span>, <span class=\"type\">Int）</span>-&gt; <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> a: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> b: <span class=\"type\">Int</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result <span class=\"operator\">=</span> mathFunction(a,b)</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">printMathResults（addTwoInts， <span class=\"number\">3</span>,<span class=\"number\">5</span>）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>注意函数作为参数的时候, 类型的定义就是输入类型和返回类型, 也是用 <code>,</code> 来分隔不同的参数.</p>\n</blockquote>\n<hr>\n<h4 id=\"内置的库\"><a href=\"#内置的库\" class=\"headerlink\" title=\"内置的库\"></a>内置的库</h4><p><code>AVFoudation</code>: 音频播放 </p>\n<hr>\n<ul>\n<li><p>枚举内部也可以设置方法; </p>\n</li>\n<li><p>结构体本身不需要构造函数(因为swift存在对于结构体的默认构造) , 但是如果结构体内部的属性存在这样的属性:</p>\n<ul>\n<li>它可能是枚举内部的方法, 跟枚举的属性有关, 可能使用了 <code>switch</code>来根据枚举属性赋值.</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Type</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">Cike</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"operator\">...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">func</span> <span class=\"title function_\">blood</span>()-&gt; <span class=\"type\">Double</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> .<span class=\"type\">Cike</span>: <span class=\"keyword\">return</span> <span class=\"number\">10</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> .<span class=\"type\">Fashi</span>: <span class=\"keyword\">return</span> <span class=\"operator\">...</span></span><br><span class=\"line\">      <span class=\"operator\">...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Card</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> country: <span class=\"type\">Country</span></span><br><span class=\"line\">  vat type: <span class=\"type\">Type</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> blood: <span class=\"type\">Double</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">init</span> (<span class=\"params\">country</span>: <span class=\"type\">Country</span>, <span class=\"params\">type</span>: <span class=\"type\">Type</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.country <span class=\"operator\">=</span> country</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.type <span class=\"operator\">=</span> type;</span><br><span class=\"line\">    blood <span class=\"operator\">=</span> type.blood</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n</li>\n<li><p>结构体和枚举属于 <u>值类型</u>, 如果赋值的时候进行拷贝操作;</p>\n<ul>\n<li>如果结构体声明为 <code>let</code>, 即使属性是变量, 那么也无法修改内部的属性,</li>\n</ul>\n</li>\n<li><p>类是引用类型, 赋值的时候使得左值指向了同样的内存区域, 也就是信息保持一致, 更改同步</p>\n<ul>\n<li>如果我们将类声明为常量, 相当于cpp的指针常量, 也就是说类内部的属性可以更改, 但是无法修改这个量指向的内存区域.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"计算属性-1\"><a href=\"#计算属性-1\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h4><p>访问的时候动态计算得到.</p>\n<p>下面通过一个矩形的例子来说明:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> y <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Size</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> width <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> height <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rect</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> origin <span class=\"operator\">=</span> <span class=\"type\">Point</span>()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> size <span class=\"operator\">=</span> <span class=\"type\">Size</span>()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> center: <span class=\"type\">Point</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> centerX <span class=\"operator\">=</span> origin.x <span class=\"operator\">+</span> (size.width <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> centerY <span class=\"operator\">=</span> orgin.y <span class=\"operator\">+</span> (size.height <span class=\"operator\">/</span><span class=\"number\">2</span> )</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"type\">Point</span>(x: centerX, y: centerY)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(newCenter)&#123;</span><br><span class=\"line\">      origin.x <span class=\"operator\">=</span> newCenter.x <span class=\"operator\">-</span> (size.width <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">      origin.y <span class=\"operator\">=</span> newCenter.y <span class=\"operator\">-</span> (size.height <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>上述完成了结构体的计算属性的定义, 其中 <code>get</code>部分也可以优化为:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">get</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">Point</span>(x: origin.x <span class=\"operator\">+</span> (size.width <span class=\"operator\">/</span> <span class=\"number\">2</span>),</span><br><span class=\"line\">        y: orgin.y <span class=\"operator\">+</span> (size.height <span class=\"operator\">/</span><span class=\"number\">2</span> ) )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>这是因为, 如果 <code>get</code> 部分只存在一个表达式,  就会自动将其返回, 不需要显式声明 <code>return</code>关键字.</p>\n</blockquote>\n<p>然后可以如此应用:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currCenter <span class=\"operator\">=</span> rectElement.center</span><br><span class=\"line\"></span><br><span class=\"line\">rectElement.center <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x:<span class=\"number\">20</span>, y:<span class=\"number\">50</span>)</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p><code>set</code>提供了语法糖, 也就是可以直接访问oldValue 和  newValue, 因此我们可以如此改写:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>&#123;</span><br><span class=\"line\">  origin.x <span class=\"operator\">=</span> newValue.x <span class=\"operator\">-</span> (size.width <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">  origin.y <span class=\"operator\">=</span> newValue.y <span class=\"operator\">-</span> (size.height <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<blockquote>\n<p>[!NOTE]</p>\n<p>对于只读的计算属性, 由于不存在 <code>set</code>, 我们可以直接在花括号内定义返回内容.</p>\n</blockquote>\n<hr>\n<ul>\n<li><p>声明 <code>static</code> , 表示这个属性或者方法属于整个类型而非某个实例. 此时相应的, 我们使用 <code>&lt;tyepName&gt;.&lt;strtic attribute&gt;</code>的方式来访问.</p>\n</li>\n<li><p>子面量本身是不可修改的, 下面的拓展中, 如果写作  <code>var someInt = 3.square()</code>就会报错</p>\n</li>\n</ul>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">Int</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">square</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"keyword\">self</span> <span class=\"operator\">*</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someInt <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\">someInt.square()</span><br></pre></td></tr></table></figure></div>\n\n\n\n<hr>\n<p>控制器存在5种状态:</p>\n<ul>\n<li>未加载</li>\n<li>将要出现</li>\n<li>出现</li>\n<li>将要消失</li>\n<li>已经消失</li>\n</ul>\n<p>APP的状态:</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"swift.assets/image-20250413182851979.png\"\n                      alt=\"image-20250413182851979\" style=\"zoom:33%;\" \n                >\n\n<p><code>UiSceneDelegate</code>用于响应基于 <code>scene</code> 的生命周期事件.</p>\n<p>可以使用属性的 <code>didset</code>来便捷地检测变化并快速修改:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score <span class=\"operator\">=</span> <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">didSet</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gameScoreLabel.text <span class=\"operator\">=</span> <span class=\"string\">&quot;Score: <span class=\"subst\">\\(score)</span>&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<ul>\n<li><code>viewController</code>是新的页面;</li>\n<li><code>view</code>是视图, 可以叠加在页面上.</li>\n<li><code>UIAlertController</code>组件相当于警示的弹窗组件</li>\n</ul>\n<h3 id=\"作图和绘画\"><a href=\"#作图和绘画\" class=\"headerlink\" title=\"作图和绘画\"></a>作图和绘画</h3><h4 id=\"CG\"><a href=\"#CG\" class=\"headerlink\" title=\"CG\"></a>CG</h4><ul>\n<li><p><code>CGFloat</code>用于二维坐标系中的坐标数据:</p>\n<ul>\n<li><code>let coor_x = CGFloat(10.5)</code></li>\n</ul>\n</li>\n<li><p><code>CGPoint(x: .. , y:...)</code></p>\n</li>\n<li><p><code>CGSize</code> 包含width和height属性的结构体;</p>\n</li>\n<li><p><code>CGRect</code>包含点和尺寸的矩形</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CGRect</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> origin: <span class=\"type\">CGPoint</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> size: <span class=\"type\">CGSize</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<ul>\n<li><p>其他属性</p>\n</li>\n<li><p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> minX: <span class=\"type\">CGPoint</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> midY: <span class=\"type\">CGPoint</span></span><br><span class=\"line\">intersects(<span class=\"type\">CGRect</span>) -&gt; <span class=\"type\">Bool</span> <span class=\"comment\">// 判断是否存在交集</span></span><br><span class=\"line\">contains(<span class=\"type\">CGPoint</span>) -&gt; <span class=\"type\">Bool</span> <span class=\"comment\">// 是否包含点.</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n</li>\n</ul>\n<p>最小单元是 <code>Point</code>而非像素点.</p>\n<p>bound表示视图内部允许绘制的区域:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bounds: <span class=\"type\">CGRect</span> <span class=\"comment\">// 也就是一个矩形</span></span><br></pre></td></tr></table></figure></div>\n\n<p>frame\t视图在父视图中的位置:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> frame: <span class=\"type\">CGRect</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"自定义视图\"><a href=\"#自定义视图\" class=\"headerlink\" title=\"自定义视图\"></a>自定义视图</h4><p>绘制自定义视图通常通过创建一个自定义的 UIView 子类，并重写 draw(_:) 方法来实现.</p>\n<p>playGround中的实例:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomView</span>: <span class=\"title class_ inherited__\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>(<span class=\"params\">frame</span>: <span class=\"type\">CGRect</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(frame: frame)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.backgroundColor <span class=\"operator\">=</span> .white <span class=\"comment\">// 设置背景颜色</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init?</span>(<span class=\"params\">coder</span>: <span class=\"type\">NSCoder</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">&quot;init(coder:) has not been implemented&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">draw</span>(<span class=\"keyword\">_</span> <span class=\"params\">rect</span>: <span class=\"type\">CGRect</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> context <span class=\"operator\">=</span> <span class=\"type\">UIGraphicsGetCurrentContext</span>() <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绘制一个圆形</span></span><br><span class=\"line\">        context.setFillColor(<span class=\"type\">UIColor</span>.blue.cgColor) <span class=\"comment\">// 设置填充颜色</span></span><br><span class=\"line\">        context.fillEllipse(in: rect) <span class=\"comment\">// 绘制填充的圆</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绘制一个矩形</span></span><br><span class=\"line\">        context.setStrokeColor(<span class=\"type\">UIColor</span>.black.withAlphaComponent(<span class=\"number\">0.6</span>).cgColor) <span class=\"comment\">// 设置能见度</span></span><br><span class=\"line\">        context.setLineWidth(<span class=\"number\">5</span>)</span><br><span class=\"line\">        context.stroke(rect.insetBy(dx: <span class=\"number\">10</span>, dy: <span class=\"number\">10</span>)) <span class=\"comment\">// 绘制矩形边框，留出间距</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建自定义视图实例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> customView <span class=\"operator\">=</span> <span class=\"type\">CustomView</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">200</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 显示在 Playground 的 live view</span></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView <span class=\"operator\">=</span> customView</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div>\n\n\n\n<ul>\n<li><code>touchesBegan</code>–WWDC</li>\n<li><code>SCNVector3</code>是三维向量</li>\n<li><code>DispathchQueue</code>表示创建一个异步的进程</li>\n</ul>\n<h3 id=\"传感器\"><a href=\"#传感器\" class=\"headerlink\" title=\"传感器\"></a>传感器</h3><ul>\n<li>加速度的方向伴随手机的头部旋转保持不变;<ul>\n<li>以 <code>g</code> 为描述单位;</li>\n<li>面向使用者的方向是 <code>z</code> 轴.</li>\n</ul>\n</li>\n<li>陀螺仪<ul>\n<li>记录对应用三个轴</li>\n<li>roll, pitch, yaw</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><h2 id=\"结绳记事\"><a href=\"#结绳记事\" class=\"headerlink\" title=\"结绳记事\"></a>结绳记事</h2><ul>\n<li><p><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245274&cid=1299836384&contentid=1217938866\" >操作演示<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>.</p>\n</li>\n<li><p>按住 <code>ctrl</code>将视图中的组件拖放到代码中.</p>\n</li>\n<li><p>右下角的几个功能:</p>\n<ul>\n<li>约束;</li>\n<li>选择视图</li>\n</ul>\n</li>\n<li><p><code>ctrl + option + cmd + enter</code> 快速显示代码区域</p>\n</li>\n<li><p><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245274&cid=1299836386&contentid=1217092922\" >组件使用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<ul>\n<li>50:00 左右介绍了两种类型和交互</li>\n</ul>\n</li>\n<li><p>按住<code>optional</code>然后 hover 在类上, 可以显示对应的基础操作.</p>\n</li>\n<li><p>可选值的本质是枚举类型!</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Optional</span>&lt;<span class=\"type\">T</span>&gt;&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> none</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">some</span>(<span class=\"operator\">&lt;</span><span class=\"type\">T</span><span class=\"operator\">&gt;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245305&sm=1\" >画图和动画<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n</li>\n<li><p><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245309&sm=1\" >coreML<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n</li>\n<li><p>在项目中显示Md格式:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*:</span></span><br><span class=\"line\"><span class=\"comment\">...</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>选择在运行时隐藏实际存在的代码:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#-hidden-code</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br><span class=\"line\"><span class=\"comment\">//#-end-hidden-code</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h1 id=\"Swift-UI\"><a href=\"#Swift-UI\" class=\"headerlink\" title=\"Swift UI\"></a>Swift UI</h1><ul>\n<li><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245315&cid=1299836440&contentid=1218091551\" >慕课的链接<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.hackingwithswift.com/100/swiftui/16\" >by now<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li>SixD: 开箱即用的UI设计等.</li>\n<li><a class=\"link\"   href=\"https://www.hackingwithswift.com/glossary\" >术语表<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h2 id=\"AR\"><a href=\"#AR\" class=\"headerlink\" title=\"AR\"></a>AR</h2><ul>\n<li><a class=\"link\"   href=\"https://www.createwithswift.com/creating-an-augmented-reality-app-in-swiftui-using-realitykit-and-arkit/\" >helpful links<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.apple.com/documentation/realitykit/?ref=createwithswift.com\" >官方文档<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h2 id=\"动画-1\"><a href=\"#动画-1\" class=\"headerlink\" title=\"动画\"></a>动画</h2><h4 id=\"缩放变换\"><a href=\"#缩放变换\" class=\"headerlink\" title=\"缩放变换\"></a>缩放变换</h4><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NavigationLink</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">BraceletEditor</span>(bracelet)</span><br><span class=\"line\">  .navigationTransitionStyle(</span><br><span class=\"line\">  .zoom(</span><br><span class=\"line\">  \tsourceID:bracelet.id,</span><br><span class=\"line\">  \tin:braceletList</span><br><span class=\"line\">  \t)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;label:&#123;</span><br><span class=\"line\">  <span class=\"type\">BraceletPreview</span>(bracelet)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.matchedTansitionSource(</span><br><span class=\"line\">\tid:bracelet.id,</span><br><span class=\"line\">  in:braceletList</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n<h2 id=\"Symbol-6\"><a href=\"#Symbol-6\" class=\"headerlink\" title=\"Symbol 6\"></a>Symbol 6</h2><h3 id=\"动画-2\"><a href=\"#动画-2\" class=\"headerlink\" title=\"动画\"></a>动画</h3><ul>\n<li>使用 <code>晃动</code> 在复杂的UI中提示可交互性.</li>\n<li><code>旋转</code>动画来表示正在进行的进程</li>\n</ul>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h4 id=\"磨砂效果\"><a href=\"#磨砂效果\" class=\"headerlink\" title=\"磨砂效果\"></a>磨砂效果</h4><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">VStack</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.frame(width: <span class=\"number\">200</span>, height: <span class=\"number\">200</span>)</span><br><span class=\"line\">.background(.ultraThinMaterial, in: <span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">20</span>, style: .continuous))</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"搜索栏\"><a href=\"#搜索栏\" class=\"headerlink\" title=\"搜索栏\"></a>搜索栏</h4><ul>\n<li><p>状态管理:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储搜索文本</span></span><br><span class=\"line\"><span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> searchText <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可选：跟踪搜索是否处于活动状态</span></span><br><span class=\"line\"><span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> isSearching <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>数据过滤模式</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本过滤计算属性模板</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> filteredItems: [<span class=\"type\">ItemType</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> searchText.isEmpty &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalItems</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalItems.filter &#123; item <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">// 根据需要自定义过滤条件</span></span><br><span class=\"line\">            item.name.localizedCaseInsensitiveContains(searchText) <span class=\"operator\">||</span></span><br><span class=\"line\">            item.description.localizedCaseInsensitiveContains(searchText)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理嵌套数据结构的过滤模板</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> filteredNestedItems: [<span class=\"type\">ParentType</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> searchText.isEmpty &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalParentItems</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalParentItems.compactMap &#123; parent <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> matchedChildren <span class=\"operator\">=</span> parent.children.filter &#123; child <span class=\"keyword\">in</span></span><br><span class=\"line\">                child.name.localizedCaseInsensitiveContains(searchText)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> matchedChildren.isEmpty &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 创建包含匹配子项的新父项</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">ParentType</span>(id: parent.id, name: parent.name, children: matchedChildren)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>搜索UI中的实现:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NavigationStack</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">List</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用过滤后的数据源</span></span><br><span class=\"line\">        <span class=\"type\">ForEach</span>(filteredItems) &#123; item <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">// 列表项视图</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .navigationTitle(<span class=\"string\">&quot;标题&quot;</span>)</span><br><span class=\"line\">    .searchable(text: <span class=\"variable\">$searchText</span>, prompt: <span class=\"string\">&quot;搜索提示文字&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 可选：添加搜索建议</span></span><br><span class=\"line\">    .searchSuggestions &#123;</span><br><span class=\"line\">        <span class=\"type\">ForEach</span>(suggestions, id: \\.<span class=\"keyword\">self</span>) &#123; suggestion <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"type\">Text</span>(suggestion).searchCompletion(suggestion)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h4 id=\"左右适应的外边距\"><a href=\"#左右适应的外边距\" class=\"headerlink\" title=\"左右适应的外边距\"></a>左右适应的外边距</h4><p>通过 <code>HStack</code>与  <code>space</code>实现卡片的自适应扩展, 同时利用 <code>.frame(maxwidth:...)</code>来设置一个最大的卡片宽度</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">HStack</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Spacer</span>(minLength: <span class=\"number\">10</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"type\">Text</span>(item.description)</span><br><span class=\"line\">        .padding()</span><br><span class=\"line\">        .background(<span class=\"type\">Color</span>(.systemGray6))</span><br><span class=\"line\">        .overlay(</span><br><span class=\"line\">            <span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">10</span>) <span class=\"comment\">// 10为圆角半径，可调整</span></span><br><span class=\"line\">                .stroke(<span class=\"type\">Color</span>.gray, lineWidth: <span class=\"number\">1</span>) <span class=\"comment\">// 边框颜色和宽度</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">        .clipShape(<span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">10</span>))</span><br><span class=\"line\">    <span class=\"comment\">// 保证背景和边框都圆角</span></span><br><span class=\"line\">    .frame(maxWidth: <span class=\"number\">400</span>) <span class=\"comment\">// 最大宽度限制</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Spacer</span>(minLength: <span class=\"number\">10</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p><code>Spacer(minLength: 10)</code> 表示<strong>保证自己不会小于 minLength</strong>. </p>\n<p>上述的 <code>Spacer</code>会压缩卡片的内容, 如果希望直接设置卡片在父容器中的左右外边距, 应该在卡片的内部使用 <code>padding</code>:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Text</span>(item.description)</span><br><span class=\"line\">    .padding(.horizontal, <span class=\"number\">24</span>) <span class=\"comment\">// 卡片内容内边距</span></span><br><span class=\"line\">    .padding(.vertical, <span class=\"number\">12</span>)</span><br><span class=\"line\">    .background(<span class=\"type\">Color</span>(.systemGray6))</span><br><span class=\"line\">    .overlay(</span><br><span class=\"line\">        <span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">10</span>)</span><br><span class=\"line\">            .stroke(<span class=\"type\">Color</span>.gray, lineWidth: <span class=\"number\">2</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .clipShape(<span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">10</span>))</span><br><span class=\"line\">    .padding(.horizontal, <span class=\"number\">20</span>) <span class=\"comment\">// 整个卡片距离父视图左右20pt</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"全局统一样式\"><a href=\"#全局统一样式\" class=\"headerlink\" title=\"全局统一样式\"></a>全局统一样式</h4><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@main</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyApp</span>: <span class=\"title class_ inherited__\">App</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">Scene</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">WindowGroup</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ContentView</span>()</span><br><span class=\"line\">                .buttonStyle(<span class=\"type\">ShadowButtonStyle</span>(radius: <span class=\"number\">10</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"参数标签和参数名\"><a href=\"#参数标签和参数名\" class=\"headerlink\" title=\"参数标签和参数名\"></a>参数标签和参数名</h4><ul>\n<li>参数标签用于函数调用时;</li>\n<li>参数名用于函数内部的参数名称.</li>\n</ul>\n<p>e.g.:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person</span> <span class=\"params\">atName</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello, <span class=\"subst\">\\(atName)</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(person: <span class=\"string\">&quot;Alice&quot;</span>) <span class=\"comment\">// 输出：Hello, Alice!</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>也可以使用 <code>_</code>来省略调用时的参数标签:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"keyword\">_</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello, <span class=\"subst\">\\(name)</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(<span class=\"string\">&quot;Alice&quot;</span>) <span class=\"comment\">// 输出：Hello, Alice!</span></span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n<h4 id=\"Alert\"><a href=\"#Alert\" class=\"headerlink\" title=\"Alert\"></a>Alert</h4><p>swift UI中的弹窗提示同样通过本地的 <code>@State</code>变量来实现:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> showingPaymentAlert <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"operator\">...</span></span><br><span class=\"line\">.alert(<span class=\"string\">&quot;Order confirmed&quot;</span>, isPresented: <span class=\"variable\">$showingPaymentAlert</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add buttons here</span></span><br><span class=\"line\">&#125; message: &#123;</span><br><span class=\"line\">    <span class=\"type\">Text</span>(<span class=\"string\">&quot;Your total was <span class=\"subst\">\\(totalPrice)</span> – thank you!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>设置按钮来改变可见的状态:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Button</span>(<span class=\"string\">&quot;Confirm order&quot;</span>) &#123;</span><br><span class=\"line\">    showingPaymentAlert.toggle()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"自定义绑定\"><a href=\"#自定义绑定\" class=\"headerlink\" title=\"自定义绑定\"></a>自定义绑定</h4><p>我们也可以使用 <code>Binding</code> 类型手动创建绑定，该类型可以提供自定义 <code>get</code> 和 <code>set</code> 闭包，以便在读取或写入值时运行。</p>\n<h4 id=\"Foreach\"><a href=\"#Foreach\" class=\"headerlink\" title=\"Foreach\"></a>Foreach</h4><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ForEach</span>(item.restrictions) &#123; restriction <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"type\">Text</span>(restriction)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>此时, 要求 <code>item.restrictions</code> 具有可唯一标识的 <code>id</code> 字段.</p>\n<ul>\n<li><p>如果内容本身就是唯一标识, 比如说遍历的内容是字符串数组, 那么可以如此声明:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ForEach</span>(item.restrictions, id: \\.<span class=\"keyword\">self</span>) &#123; restriction <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"type\">Text</span>(restriction)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h4 id=\"Spacer\"><a href=\"#Spacer\" class=\"headerlink\" title=\"Spacer()\"></a>Spacer()</h4><p>用于填充剩余的空间</p>\n<ul>\n<li>使用 <code>offset(x:.., y:...)</code>来调节位置, 左上角是原点.</li>\n</ul>\n<h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><ul>\n<li><p>作用: 用于存储独立于视图的、长期存在的数据;</p>\n</li>\n<li><p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.swift</span></span><br><span class=\"line\"><span class=\"meta\">@StateObject</span> <span class=\"keyword\">var</span> order <span class=\"operator\">=</span> <span class=\"type\">Order</span>()</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p><code>@StateObject</code> 属性包装器负责在<u>应用程序的整个生命周期中</u>保持对象处于活动状态。</p>\n</li>\n<li><p>需要在创建视图结构体的时候传递:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WindowGroup</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ContentView</span>()</span><br><span class=\"line\">        .environmentObject(order)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n</li>\n<li><p>为了让swift知道什么时候更新视图, 常用的是声明 <code>@Published</code>属性包装器——足以让它更新任何正在监视更改的 SwiftUI 视图.</p>\n</li>\n<li><p>同时声明对应的对象遵循可观测协议: <strong>ObservableObject</strong>.</p>\n</li>\n</ul>\n<p>我们可以使用 <code>@EnvironmentObject</code>来访问环境中的共享数据, 也就是传递上一步已经在父视图中创建和管理的对象.</p>\n<p>e.g.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserData</span>: <span class=\"title class_ inherited__\">ObservableObject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Published</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;John&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@StateObject</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> userData <span class=\"operator\">=</span> <span class=\"type\">UserData</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ChildView</span>().environmentObject(userData)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ChildView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@EnvironmentObject</span> <span class=\"keyword\">var</span> userData: <span class=\"type\">UserData</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Text</span>(userData.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n<p>使用 <code>@State</code>来声明简单的本地值——比如整数和字符串.</p>\n<ul>\n<li><p>建议将其声明为 <code>private</code>, e.g.</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> paymentType <span class=\"operator\">=</span> <span class=\"string\">&quot;Cash&quot;</span></span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h4 id=\"菜单视图\"><a href=\"#菜单视图\" class=\"headerlink\" title=\"菜单视图\"></a>菜单视图</h4><p>为了将菜单视图存放在一个选项卡当中, 我们需要新建一个视图, 用来作为容器:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MainView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TabView</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ContentView</span>()</span><br><span class=\"line\">                .tabItem &#123;</span><br><span class=\"line\">                    <span class=\"type\">Label</span>(<span class=\"string\">&quot;Menu&quot;</span>, systemImage: <span class=\"string\">&quot;list.dash&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">OrderView</span>()</span><br><span class=\"line\">                .tabItem &#123;</span><br><span class=\"line\">                    <span class=\"type\">Label</span>(<span class=\"string\">&quot;Order&quot;</span>, systemImage: <span class=\"string\">&quot;square.and.pencil&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<blockquote>\n<p>页面级别的切换.</p>\n</blockquote>\n<p>使用枚举与子页面的内容分区:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> SwiftUI</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">Section</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> cats</span><br><span class=\"line\">        <span class=\"keyword\">case</span> dogs</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> selectedTab <span class=\"operator\">=</span> <span class=\"type\">Section</span>.cats</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TabView</span>(selection: <span class=\"variable\">$selectedTab</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Tab</span>(<span class=\"string\">&quot;Cats&quot;</span>, systemImage: <span class=\"string\">&quot;cat&quot;</span>, value: .cats) &#123;</span><br><span class=\"line\">                <span class=\"type\">Button</span>(<span class=\"string\">&quot;Go to Dogs&quot;</span>) &#123;</span><br><span class=\"line\">                    selectedTab <span class=\"operator\">=</span> .dogs</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">Tab</span>(<span class=\"string\">&quot;Dogs&quot;</span>, systemImage: <span class=\"string\">&quot;dog&quot;</span>, value: .dogs) &#123;</span><br><span class=\"line\">                <span class=\"type\">Button</span>(<span class=\"string\">&quot;Go to Cats&quot;</span>) &#123;</span><br><span class=\"line\">                    selectedTab <span class=\"operator\">=</span> .cats</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n\n\n\n\n<h2 id=\"合适的修饰符\"><a href=\"#合适的修饰符\" class=\"headerlink\" title=\"合适的修饰符\"></a>合适的修饰符</h2><ul>\n<li><p>图像自动调节尺寸:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Image</span>(item.mainImage)</span><br><span class=\"line\">    .resizable()</span><br><span class=\"line\">    .scaledToFit()</span><br></pre></td></tr></table></figure></div></li>\n</ul>\n<h4 id=\"设置阴影\"><a href=\"#设置阴影\" class=\"headerlink\" title=\"设置阴影\"></a>设置阴影</h4><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.shadow(color: .black.opacity(<span class=\"number\">0.2</span>), </span><br><span class=\"line\">        radius: <span class=\"number\">15</span>, x: <span class=\"number\">0</span>, y: <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h4 id=\"为按钮设置动画\"><a href=\"#为按钮设置动画\" class=\"headerlink\" title=\"为按钮设置动画\"></a>为按钮设置动画</h4><div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> showingWelcome <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">VStack</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Toggle</span>(<span class=\"string\">&quot;Toggle label&quot;</span>, isOn: <span class=\"variable\">$showingWelcome</span>.animation())</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> showingWelcome &#123;</span><br><span class=\"line\">                <span class=\"type\">Text</span>(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></div>\n\n<p>可以进一步设置, 比如弹簧的渐入渐出:</p>\n<div class=\"code-container\" data-rel=\"Swift\"><figure class=\"iseeu highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Toggle</span>(<span class=\"string\">&quot;Toggle label&quot;</span>, isOn: <span class=\"variable\">$showingWelcome</span>.animation(.spring()))</span><br></pre></td></tr></table></figure></div>\n\n\n\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><h4 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h4><ul>\n<li><code>ctrl</code>按住后点击  <code>VStack</code>可以快速地将其添加到 <code>ZStack</code>当中<ul>\n<li>颜色的设置需要通过 <code>ZStack</code>来实现.</li>\n</ul>\n</li>\n<li><code>option</code>可以显示当前类的介绍</li>\n<li></li>\n</ul>\n<p>学习路线:</p>\n<ol>\n<li>学习 Swift 基础语法</li>\n<li>上手 SwiftUI 基础控件（Text、Button、Image、List、NavigationStack 等）</li>\n<li>学会使用 @State、@Binding 等状态管理属性</li>\n<li>尝试做一个简单的 App（比如 ToDo List、小笔记本）</li>\n<li>慢慢接触更复杂的功能，比如动画、数据持久化（CoreData）、网络请求（URLSession）</li>\n</ol>\n<h4 id=\"第二周：SwiftUI-基础入门\"><a href=\"#第二周：SwiftUI-基础入门\" class=\"headerlink\" title=\"第二周：SwiftUI 基础入门\"></a><strong>第二周：SwiftUI 基础入门</strong></h4><p><strong>目标：</strong></p>\n<ul>\n<li>理解 SwiftUI 的基本概念和架构。</li>\n<li>掌握常用的 SwiftUI 视图和修饰符。</li>\n</ul>\n<ol>\n<li><strong>SwiftUI 概述：</strong><ul>\n<li>声明式语法与传统 UIKit 的区别</li>\n<li>SwiftUI 的视图层次结构</li>\n</ul>\n</li>\n<li><strong>常用视图组件：</strong><ul>\n<li>Text、Image、Button 等基本控件的使用</li>\n<li>视图修饰符的应用，如 .font()、.foregroundColor()、.padding() 等</li>\n</ul>\n</li>\n<li><strong>布局系统：</strong><ul>\n<li>使用 HStack、VStack 和 ZStack 进行视图布局</li>\n<li>Spacer 和 Divider 的使用</li>\n</ul>\n</li>\n</ol>\n<p><strong>推荐资源：</strong></p>\n<ul>\n<li><strong>Hacking with Swift 的 100 天 SwiftUI：</strong> <a class=\"link\"   href=\"https://www.hackingwithswift.com/100/swiftui\" >100 Days of SwiftUI<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>AppCoda 的 SwiftUI 教程：</strong> <a class=\"link\"   href=\"https://www.appcoda.com/swiftui/\" >AppCoda - Mastering SwiftUI<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h4 id=\"第三周：状态管理与数据绑定\"><a href=\"#第三周：状态管理与数据绑定\" class=\"headerlink\" title=\"第三周：状态管理与数据绑定\"></a><strong>第三周：状态管理与数据绑定</strong></h4><p><strong>目标：</strong></p>\n<ul>\n<li>理解并应用 SwiftUI 的状态管理机制。</li>\n<li>掌握数据绑定和视图更新的原理。</li>\n</ul>\n<p><strong>学习内容：</strong></p>\n<ol>\n<li><strong>状态管理：</strong><ul>\n<li>使用 @State 管理视图内部状态</li>\n<li>使用 @Binding 在父子视图之间传递状态</li>\n<li>使用 @ObservedObject 和 @EnvironmentObject 管理复杂数据模型</li>\n</ul>\n</li>\n<li><strong>数据绑定：</strong><ul>\n<li>双向绑定的实现</li>\n<li>数据变化如何驱动视图更新</li>\n</ul>\n</li>\n</ol>\n<p><strong>推荐资源：</strong></p>\n<ul>\n<li><strong>SwiftUI 官方文档：</strong> <a class=\"link\"   href=\"https://developer.apple.com/documentation/swiftui\" >SwiftUI Documentation<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>Design+Code 的 SwiftUI 教程：</strong> <a class=\"link\"   href=\"https://designcode.io/swiftui\" >Design+Code - SwiftUI for iOS 17<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h4 id=\"第四周：导航、列表与高级交互\"><a href=\"#第四周：导航、列表与高级交互\" class=\"headerlink\" title=\"第四周：导航、列表与高级交互\"></a><strong>第四周：导航、列表与高级交互</strong></h4><p><strong>目标：</strong></p>\n<ul>\n<li>掌握 SwiftUI 中的导航和列表视图。</li>\n<li>实现复杂的用户交互和动画效果</li>\n</ul>\n<p><strong>学习内容：</strong></p>\n<ol>\n<li><strong>导航与路由：</strong><ul>\n<li>使用 NavigationView 和 NavigationLink 实现页面导航</li>\n<li>传递数据到下一个视图</li>\n</ul>\n</li>\n<li><strong>列表视图：</strong><ul>\n<li>使用 List 展示数据集合</li>\n<li>自定义列表行和支持删除、移动操作</li>\n</ul>\n</li>\n<li><strong>动画与手势：</strong><ul>\n<li>添加基本动画效果</li>\n<li>处理手势交互，如拖拽、缩放等</li>\n</ul>\n</li>\n</ol>\n<p><strong>推荐资源：</strong></p>\n<ul>\n<li><strong>Raywenderlich 的 SwiftUI 教程：</strong> <a class=\"link\"   href=\"https://www.raywenderlich.com/books/swiftui-apprentice\" >Raywenderlich - SwiftUI Apprentice<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>Big Mountain Studio 的免费电子书：</strong> <a class=\"link\"   href=\"https://www.bigmountainstudio.com/free-swiftui-book\" >SwiftUI Views Quick Start<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n","more":"<h1 id=\"初见\"><a href=\"#初见\" class=\"headerlink\" title=\"初见\"></a>初见</h1><p>默认情况下，函数使用它们的参数名称作为它们参数的标签，在参数名称前可以自定义参数标签，或者使用 <code>_</code> 表示不使用参数标签:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"keyword\">_</span> <span class=\"params\">person</span>: <span class=\"type\">String</span>, <span class=\"params\">on</span> <span class=\"params\">day</span>: <span class=\"type\">String</span>) -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Hello <span class=\"subst\">\\(person)</span>, today is <span class=\"subst\">\\(day)</span>.&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(<span class=\"string\">&quot;John&quot;</span>, on: <span class=\"string\">&quot;Wednesday&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>参数标签指的是调用时候的名称, 参数名指的是函数内部.</p>\n</blockquote>\n<p>函数是第一等类型，这意味着函数可以作为另一个函数的返回值。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">makeIncrementer</span>() -&gt; ((<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">addOne</span>(<span class=\"params\">number</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span> <span class=\"operator\">+</span> number</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> addOne</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> increment <span class=\"operator\">=</span> makeIncrementer()</span><br><span class=\"line\">increment(<span class=\"number\">7</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>函数也可以作为另一个函数的输入参数:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">hasAnyMatches</span>(<span class=\"params\">list</span>: [<span class=\"type\">Int</span>], <span class=\"params\">condition</span>: (<span class=\"type\">Int</span>) -&gt; <span class=\"type\">Bool</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> list &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> condition(item) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">true</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">lessThanTen</span>(<span class=\"params\">number</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Bool</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> number <span class=\"operator\">&lt;</span> <span class=\"number\">10</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> numbers <span class=\"operator\">=</span> [<span class=\"number\">20</span>, <span class=\"number\">19</span>, <span class=\"number\">7</span>, <span class=\"number\">12</span>]</span><br><span class=\"line\">hasAnyMatches(list: numbers, condition: lessThanTen)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以通过参数位置而不是参数名字来引用参数——这个方法在非常短的闭包中非常有用。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> sortedNumbers <span class=\"operator\">=</span> numbers.sorted &#123; <span class=\"variable\">$0</span> <span class=\"operator\">&gt;</span> <span class=\"variable\">$1</span> &#125;</span><br><span class=\"line\"><span class=\"built_in\">print</span>(sortedNumbers)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p><code>actor</code>与 <code>class</code>类似, 但是可以序列化访问, 保护共享、可变的数据.</p>\n<h3 id=\"对象和类\"><a href=\"#对象和类\" class=\"headerlink\" title=\"对象和类\"></a>对象和类</h3><h4 id=\"构造与析构\"><a href=\"#构造与析构\" class=\"headerlink\" title=\"构造与析构\"></a>构造与析构</h4><p>使用 <code>self.</code>替代 <code>this-&gt;</code>, 使用  <code>init</code> 和  <code>deinit</code>分别声明构造和析构函数:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">NamedShape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> numberOfSides: <span class=\"type\">Int</span> <span class=\"operator\">=</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name <span class=\"operator\">=</span> name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">simpleDescription</span>() -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;A shape with <span class=\"subst\">\\(numberOfSides)</span> sides.&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>子类如果要重写父类的方法的话，需要用 <code>override</code> 标记:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Square</span>: <span class=\"title class_ inherited__\">NamedShape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sideLength: <span class=\"type\">Double</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">sideLength</span>: <span class=\"type\">Double</span>, <span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sideLength <span class=\"operator\">=</span> sideLength</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</span><br><span class=\"line\">        numberOfSides <span class=\"operator\">=</span> <span class=\"number\">4</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">area</span>() -&gt;  <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sideLength <span class=\"operator\">*</span> sideLength</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">simpleDescription</span>() -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;A square with sides of length <span class=\"subst\">\\(sideLength)</span>.&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> test <span class=\"operator\">=</span> <span class=\"type\">Square</span>(sideLength: <span class=\"number\">5.2</span>, name: <span class=\"string\">&quot;my test square&quot;</span>)</span><br><span class=\"line\">test.area()</span><br><span class=\"line\">test.simpleDescription()</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>使用 <code>:className</code>的方法声明父类.</li>\n<li><code>super.init</code> 是用来调用父类（超类）的初始化方法的。当创建一个子类的实例时，子类可能需要初始化一些自己的属性，同时还需要确保父类的属性也被正确初始化。这时就需要使用 <code>super.init</code> 来调用父类的初始化方法，完成父类的初始化过程</li>\n<li>严格的顺序要求: 子类必须先初始化自己的属性，然后调用 <code>super.init</code>，最后才能访问或修改继承来的属性。</li>\n</ul>\n</blockquote>\n<h3 id=\"计算属性\"><a href=\"#计算属性\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h3><h4 id=\"普通的计算属性\"><a href=\"#普通的计算属性\" class=\"headerlink\" title=\"普通的计算属性\"></a>普通的计算属性</h4><p>在属性内部使用 <code>&#123;&#125;</code>并加上 <code>return</code>, 可以让访问这个属性的时候, 返回值由结构体的其他属性计算得到.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Temperature</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> celsius: <span class=\"type\">Double</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> fahrenheit: <span class=\"type\">Double</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> celsius <span class=\"operator\">*</span><span class=\"number\">1.8</span> <span class=\"operator\">+</span> <span class=\"number\">32</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">init</span>(<span class=\"params\">celsius</span>: <span class=\"type\">Double</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.celsius <span class=\"operator\">=</span> celsius</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ol>\n<li>此时实例化一个结构体就只需要给出一个属性的值.</li>\n<li><code>self</code>在上述的Swift代码中是不可或缺的, 因为形参和内部属性的名称相同.</li>\n</ol>\n</blockquote>\n<h4 id=\"使用-getter-和-setter-的计算属性\"><a href=\"#使用-getter-和-setter-的计算属性\" class=\"headerlink\" title=\"使用 getter 和 setter 的计算属性:\"></a>使用 getter 和 setter 的计算属性:</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">EquilateralTriangle</span>: <span class=\"title class_ inherited__\">NamedShape</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> sideLength: <span class=\"type\">Double</span> <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">sideLength</span>: <span class=\"type\">Double</span>, <span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.sideLength <span class=\"operator\">=</span> sideLength</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(name: name)</span><br><span class=\"line\">        numberOfSides <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> perimeter: <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 根据存储属性进行计算</span></span><br><span class=\"line\">        <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">3.0</span> <span class=\"operator\">*</span> sideLength</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 设置属性</span></span><br><span class=\"line\">        <span class=\"keyword\">set</span> &#123;</span><br><span class=\"line\">            sideLength <span class=\"operator\">=</span> newValue <span class=\"operator\">/</span> <span class=\"number\">3.0</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">simpleDescription</span>() -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;An equilateral triangle with sides of length <span class=\"subst\">\\(sideLength)</span>.&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> triangle <span class=\"operator\">=</span> <span class=\"type\">EquilateralTriangle</span>(sideLength: <span class=\"number\">3.1</span>, name: <span class=\"string\">&quot;a triangle&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangle.perimeter)</span><br><span class=\"line\">triangle.perimeter <span class=\"operator\">=</span> <span class=\"number\">9.9</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangle.sideLength)</span><br></pre></td></tr></table></figure>\n\n<p>计算属性同样是一个属性, 但是根据调用方式的不同, 有返回和设置两种方式.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triangle.perimeter <span class=\"operator\">=</span> <span class=\"number\">9.9</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangle.perimeter)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Mutating\"><a href=\"#Mutating\" class=\"headerlink\" title=\"Mutating\"></a>Mutating</h3><p>默认情况下, 结构体中的方法不能直接修改结构体的属性. 需要显式声明为 <code>mutating</code>:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">User</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> username:<span class=\"type\">String</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> isVisible:<span class=\"type\">Bool</span> <span class=\"operator\">=</span> <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> friends: [string] <span class=\"operator\">=</span> []</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">addFriend</span>(<span class=\"params\">username</span>: <span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">    friends.append(username)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"属性监视器\"><a href=\"#属性监视器\" class=\"headerlink\" title=\"属性监视器\"></a>属性监视器</h3><p>使用 <code>willSet</code> 和 <code>didSet</code>。写入的代码会在属性值发生改变时调用，但不包含构造器中发生值改变的情况:</p>\n<ul>\n<li>分别可以使用 <code>newValue</code>与 <code>oldValue</code>来表示属性将要改变的值以及改变之前的值.</li>\n</ul>\n<p>e.g. 确保三角形的边长总是和正方形的边长相同。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">TriangleAndSquare</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> triangle: <span class=\"type\">EquilateralTriangle</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">willSet</span> &#123;</span><br><span class=\"line\">            square.sideLength <span class=\"operator\">=</span> newValue.sideLength</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> square: <span class=\"type\">Square</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">willSet</span> &#123;</span><br><span class=\"line\">            triangle.sideLength <span class=\"operator\">=</span> newValue.sideLength</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">init</span>(<span class=\"params\">size</span>: <span class=\"type\">Double</span>, <span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">        square <span class=\"operator\">=</span> <span class=\"type\">Square</span>(sideLength: size, name: name)</span><br><span class=\"line\">        triangle <span class=\"operator\">=</span> <span class=\"type\">EquilateralTriangle</span>(sideLength: size, name: name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> triangleAndSquare <span class=\"operator\">=</span> <span class=\"type\">TriangleAndSquare</span>(size: <span class=\"number\">10</span>, name: <span class=\"string\">&quot;another test shape&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangleAndSquare.square.sideLength)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangleAndSquare.triangle.sideLength)</span><br><span class=\"line\">triangleAndSquare.square <span class=\"operator\">=</span> <span class=\"type\">Square</span>(sideLength: <span class=\"number\">50</span>, name: <span class=\"string\">&quot;larger square&quot;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(triangleAndSquare.triangle.sideLength)</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h3><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Rank</span>: <span class=\"title class_ inherited__\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> ace <span class=\"operator\">=</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">case</span> two, three, four, five, six, seven, eight, nine, ten</span><br><span class=\"line\">    <span class=\"keyword\">case</span> jack, queen, king</span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">simpleDescription</span>() -&gt; <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .ace:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;ace&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> .jack:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;jack&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> .queen:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;queen&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">case</span> .king:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;king&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"type\">String</span>(<span class=\"keyword\">self</span>.rawValue)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> ace <span class=\"operator\">=</span> <span class=\"type\">Rank</span>.ace</span><br><span class=\"line\"><span class=\"keyword\">let</span> aceRawValue <span class=\"operator\">=</span> ace.rawValue</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果没有设置第一个成员的初始值, 默认从 <code>0</code> 开始;</li>\n<li>缺省值按照递增处理;</li>\n<li><code>case</code>之外可以设置方法.</li>\n</ul>\n<p>使用 <code>init?(rawValue:)</code> 初始化构造器来从原始值创建一个枚举实例:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> convertedRank <span class=\"operator\">=</span> <span class=\"type\">Rank（rawValue</span>:<span class=\"number\">3</span>）｛</span><br><span class=\"line\">\t<span class=\"keyword\">let</span> threeDescription <span class=\"operator\">=</span> convertedRank.simpleDescription（）</span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li><code>if let</code>表示可选绑定, 安全地解包可选值</li>\n</ul>\n</blockquote>\n<h4 id=\"解包\"><a href=\"#解包\" class=\"headerlink\" title=\"解包\"></a>解包</h4><ol>\n<li><code>if let</code>解包</li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> <span class=\"type\">A</span> <span class=\"operator\">=</span> <span class=\"type\">B</span> &#123;</span><br><span class=\"line\">  <span class=\"operator\">...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果 <code>B</code>不是 nil, 就将其赋值给A, 然后执行 <code>&#123;&#125;</code>内部的语句. </p>\n<ol start=\"2\">\n<li><code>??</code></li>\n</ol>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score : <span class=\"type\">Int</span> <span class=\"operator\">?</span>  <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(score <span class=\"operator\">??</span> default_score)</span><br><span class=\"line\"><span class=\"comment\">// 成绩score不是nil, 就将其打印, 否则输出默认的成绩</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>对字典进行索引:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// scores是一个Int数组</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> ( major, scores) <span class=\"keyword\">in</span> all_scores &#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> score <span class=\"keyword\">in</span> scores&#123;</span><br><span class=\"line\">    <span class=\"operator\">...</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果key没有使用, 可以直接忽略</span></span><br><span class=\"line\"><span class=\"keyword\">for</span>( <span class=\"keyword\">_</span>, socres) <span class=\"keyword\">in</span> all_scores&#123;</span><br><span class=\"line\">  <span class=\"operator\">...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>swift支持对字典进行更新或者移除的时候, 返回并使用就值:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue <span class=\"operator\">=</span> scores.updateValue(<span class=\"number\">100</span>, forKey:<span class=\"string\">&quot;fad&quot;</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"operator\">..</span>)</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"operator\">...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"keyword\">let</span> oldValue <span class=\"operator\">=</span> scores.removeValue(forKey: <span class=\"string\">&quot;fad&quot;</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;fad&#x27;s old value was <span class=\"subst\">\\(oldValue)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><code>@IBAction</code>表示组件交互和代码相绑定(允许在交互的时候执行外部定义的函数);</li>\n<li><code>@IBOutlet</code>表示允许代码的响应改变组件本身的状态(字体、大小等).</li>\n</ul>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"swift.assets/image-20250412115454400.png\"\n                      alt=\"image-20250412115454400\" style=\"zoom:57%;\" \n                >\n\n\n\n\n\n\n\n<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><p>闭包指的是可以在特定位置运行的、不需要名称的函数.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scene.setOnStartHandler｛ </span><br><span class=\"line\"><span class=\"comment\">// 闭包的主体</span></span><br><span class=\"line\">｝</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><p><code>toggle()</code>可以自动切换变量的布尔值.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Button</span>(<span class=\"string\">&quot;Press Me&quot;</span>) &#123;</span><br><span class=\"line\">    isOn.toggle()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"状态属性\"><a href=\"#状态属性\" class=\"headerlink\" title=\"状态属性\"></a>状态属性</h4><ul>\n<li><p>使用 <code>@State</code>在视图之外定义;</p>\n</li>\n<li><p>当状态属性的值发生改变时, 会自动更新视图中相关的部分.</p>\n</li>\n<li><p>对于状态对象, 使用 <code>@StateObject</code>来声明.</p>\n</li>\n</ul>\n<h4 id=\"绑定\"><a href=\"#绑定\" class=\"headerlink\" title=\"绑定\"></a>绑定</h4><p>由 <code>@Binding</code>声明将属性连接到其他地方, 允许子视图对属性的修改并同步.</p>\n<p>在属性的前面增加 <code>$</code>，表明会同步修改可信源.</p>\n<h4 id=\"字符串插值\"><a href=\"#字符串插值\" class=\"headerlink\" title=\"字符串插值\"></a>字符串插值</h4><p>在较长字符串中使用常量、变量或代码表达式，使它们替换为其当前值以求出字符串的值。</p>\n<p>例如，在字符串”Katy ate a \\（fruit）.”中，如果fruit 是带有值 “peach”的变量，那么在求字符串的值时，\\（fruit）由”peach”替换，变为 “Katy ate a peach.”。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><h4 id=\"自动的动画效果\"><a href=\"#自动的动画效果\" class=\"headerlink\" title=\"自动的动画效果\"></a>自动的动画效果</h4><p>当状态属性发生改变时, 我们希望对应控制的视图元素的变化具有动画效果, 那么可以指定: e.g.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Circle</span>()</span><br><span class=\"line\">    .frame(maxHeight: <span class=\"number\">200</span>)</span><br><span class=\"line\">    .foregroundColor( isOn <span class=\"operator\">?</span> .purple : .mint </span><br><span class=\"line\">    .shadow(color:isOn <span class=\"operator\">?</span> .indigo : .orange , radius: <span class=\"number\">20</span>)</span><br><span class=\"line\">    .scaleEffect(isOn <span class=\"operator\">?</span> <span class=\"number\">1</span>: <span class=\"number\">0.75</span>)</span><br><span class=\"line\">    .animation( .default, value: isOn)</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>其中的 <code>value： isOn</code>表示追踪的状态属性.</p>\n</blockquote>\n<p>在一个视图中创建状态对象,  然后在 <code>app</code>中声明为环境变量并在子视图中使用.</p>\n<h1 id=\"设计原则\"><a href=\"#设计原则\" class=\"headerlink\" title=\"设计原则\"></a>设计原则</h1><p>principle </p>\n<ul>\n<li>需要长按进行交互的组件, 在轻触时ICON放大或者缩小</li>\n</ul>\n<h1 id=\"官方手册学习记录\"><a href=\"#官方手册学习记录\" class=\"headerlink\" title=\"官方手册学习记录\"></a>官方手册学习记录</h1><h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><ul>\n<li><p>Swift 使用<em>字符串插值</em>将常量或变量的名称作为占位符包含在较长的字符串中，并提示 Swift 将其替换为该常量或变量的当前值。将名称包在括号中，并在左括号前用反斜杠进行转义：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The current value of friendlyWelcome is <span class=\"subst\">\\(friendlyWelcome)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The current value of friendlyWelcome is Bonjour！&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不必使用 <code>;</code>, 但是如果想在一行中编写多个独立语句，则<em>必须</em>使用分号：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> cat <span class=\"operator\">=</span> <span class=\"string\">&quot;🐱&quot;</span>; <span class=\"built_in\">print</span>(cat)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;🐱&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>整数边界: 使用 min, max进行访问</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> minValue <span class=\"operator\">=</span> <span class=\"type\">UInt8</span>.min  <span class=\"comment\">// minValue 等于 0，类型为 UInt8</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> maxValue <span class=\"operator\">=</span> <span class=\"type\">UInt8</span>.max  <span class=\"comment\">// maxValue 等于 255，类型为 UInt8</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类型别名: <code>typealias</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typealias</span> <span class=\"type\">AudioSample</span> <span class=\"operator\">=</span> <span class=\"type\">UInt16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> maxAmplitudeFound <span class=\"operator\">=</span> <span class=\"type\">AudioSample</span>.min</span><br><span class=\"line\"><span class=\"comment\">// maxAmplitudeFound 现在为 0</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><ul>\n<li>作用: 多个值组合成一个复合值</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> http404Error <span class=\"operator\">=</span> (<span class=\"number\">404</span>, <span class=\"string\">&quot;Not Found&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// http404Error 的类型为（Int，String），且等于（404，&quot;Not Found&quot;）</span></span><br></pre></td></tr></table></figure>\n\n<p>如果只需要元组的部分值，则在分解元组时使用下划线 (<code>_</code>) 忽略不需要的部分</p>\n<ul>\n<li><p>分解元组</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> (statusCode, statusMessage) <span class=\"operator\">=</span> http404Error</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The status code is <span class=\"subst\">\\(statusCode)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The status code is 404&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The status message is <span class=\"subst\">\\(statusMessage)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The status message is Not Found&quot;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以在定义元组时为元组中的各个元素命名：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> http200Status <span class=\"operator\">=</span> (statusCode: <span class=\"number\">200</span>, description: <span class=\"string\">&quot;OK&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>然后可以使用元素名访问:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The status code is <span class=\"subst\">\\(http200Status.statusCode)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The status code is 200&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;The status message is <span class=\"subst\">\\(http200Status.description)</span>&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;The status message is OK&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>也可以直接使用从零开始的索引来访问, e.g. <code>http200Status.0</code></p>\n</li>\n</ul>\n<hr>\n<ul>\n<li><p><u>可选</u>: 存储这种类型的值或者 <code>nil</code>.</p>\n</li>\n<li><p>提供后备值: <code>??</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> name: <span class=\"type\">String</span>? <span class=\"operator\">=</span> <span class=\"literal\">nil</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> greeting <span class=\"operator\">=</span> <span class=\"string\">&quot;Hello, &quot;</span> <span class=\"operator\">+</span> (name <span class=\"operator\">??</span> <span class=\"string\">&quot;friend&quot;</span>) <span class=\"operator\">+</span> <span class=\"string\">&quot;!&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(greeting)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;Hello, friend!&quot;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果 <code>??</code> 之前的值不是 <code>nil</code>, 就会正常解包, 否则选择后备值;</li>\n<li>使用 <code>()</code> 包裹.</li>\n</ul>\n</li>\n<li><p><u>隐式解包可选</u>: 安全假定一直都有值时使用</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> possibleString: <span class=\"type\">String</span>? <span class=\"operator\">=</span> <span class=\"string\">&quot;An optional string.&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> forcedString: <span class=\"type\">String</span> <span class=\"operator\">=</span> possibleString<span class=\"operator\">!</span> <span class=\"comment\">// 需要显式解包</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> assumedString: <span class=\"type\">String</span>! <span class=\"operator\">=</span> <span class=\"string\">&quot;An implicitly unwrapped optional string.&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> implicitString: <span class=\"type\">String</span> <span class=\"operator\">=</span> assumedString <span class=\"comment\">// 隐式解包</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h3 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h3><p>函数在声明中包含 <code>throws</code> 关键字，表示它可以抛出错误。调用可以抛出错误的函数时，要在表达式前加上 <code>try</code> 关键字.</p>\n<p>Swift 会自动将错误传播到当前作用域之外，直到它们被 <code>catch</code> 子句处理为止。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> canThrowAnError()</span><br><span class=\"line\">    <span class=\"comment\">// 无错误的情况</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 抛出错误的情况</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>细节部分在后面补充</p>\n</blockquote>\n<h3 id=\"断言和先决条件\"><a href=\"#断言和先决条件\" class=\"headerlink\" title=\"断言和先决条件\"></a>断言和先决条件</h3><h4 id=\"使用断言进行调试\"><a href=\"#使用断言进行调试\" class=\"headerlink\" title=\"使用断言进行调试\"></a>使用断言进行调试</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> age <span class=\"operator\">=</span> <span class=\"operator\">-</span><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">assert</span>(age <span class=\"operator\">&gt;=</span> <span class=\"number\">0</span>, <span class=\"string\">&quot;A person&#x27;s age can&#x27;t be less than zero.&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">// 该断言失败的原因是 -3 并不 &gt;= 0。</span></span><br></pre></td></tr></table></figure>\n\n<p>断言的第一个参数是预期的、正确的结果, 如果不满足条件就会显示报错. 但是不会阻止程序继续运行.</p>\n<h4 id=\"强制执行先决条件\"><a href=\"#强制执行先决条件\" class=\"headerlink\" title=\"强制执行先决条件\"></a>强制执行先决条件</h4><p>当条件有可能为假，但<em>必须</em>为真才能继续执行代码时，请使用先决条件.</p>\n<p>向该函数传递一个计算结果为 <code>true</code> 或 <code>false</code> 的表达式，以及一条在条件结果为 <code>false</code> 时显示的信息:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在下标的实现中...</span></span><br><span class=\"line\"><span class=\"built_in\">precondition</span>(index <span class=\"operator\">&gt;</span> <span class=\"number\">0</span>, <span class=\"string\">&quot;Index must be greater than zero.&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><h3 id=\"基本运算符\"><a href=\"#基本运算符\" class=\"headerlink\" title=\"基本运算符\"></a>基本运算符</h3><ul>\n<li><p>与 C 和 Objective-C 中的赋值运算符不同，Swift 中的赋值运算符本身不返回值。以下语句无效：</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> x <span class=\"operator\">=</span> y &#123; <span class=\"comment\">// 这是无效的，因为 x = y 不返回值。</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以防止不小心使用赋值运算符（&#x3D;） 而非等于运算符（&#x3D;&#x3D;）.</li>\n</ul>\n</li>\n<li><p>基本的四则运算不允许值的溢出.</p>\n</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>在 Swift 中对负数的处理与模运算符有所不同:</p>\n<p>为了确定 <code>a % b</code> 的答案，<code>%</code> 运算符计算以下等式并返回 <code>余数</code> 作为输出：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a` = (`b` x `某个乘数`) + `余数</span><br></pre></td></tr></table></figure>\n\n<p>其中 <code>某个乘数</code> 是 <code>b</code> 在 <code>a</code> 中能容纳的最大倍数。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">9</span> <span class=\"operator\">%</span> <span class=\"number\">4</span>    <span class=\"comment\">// 等于 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"operator\">-</span><span class=\"number\">9</span> <span class=\"operator\">%</span> <span class=\"number\">4</span>   <span class=\"comment\">// 等于 -1</span></span><br></pre></td></tr></table></figure></blockquote>\n<ul>\n<li><p>数值的正负号可以使用前缀 <code>-</code> 切换，称为<u>一元负号运算符</u>.</p>\n<ul>\n<li><p>中间没有任何空格.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> three <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> minusThree <span class=\"operator\">=</span> <span class=\"operator\">-</span>three       <span class=\"comment\">// minusThree 等于 -3</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"元组的计算\"><a href=\"#元组的计算\" class=\"headerlink\" title=\"元组的计算\"></a>元组的计算</h4><ul>\n<li>前提: 如果两个元组具有相同的类型和相同数量的值，则可以比较它们.</li>\n<li>规则: <ul>\n<li>元组是从左到右逐个值进行比较的，直到比较发现两个不相等的值为止。</li>\n<li>这两个值将进行比较，并且该比较的结果决定了整个元组比较的结果。</li>\n<li>如果所有元素都相等，那么这两个元组本身就相等。</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>[!NOTE]</p>\n<p>只有当给定的运算符可以应用于各自元组中的每个值时，元组才能与该运算符进行比较.</p>\n</blockquote>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"string\">&quot;blue&quot;</span>, <span class=\"literal\">false</span>) <span class=\"operator\">&lt;</span> (<span class=\"string\">&quot;purple&quot;</span>, <span class=\"literal\">true</span>)  <span class=\"comment\">// 错误，因为 &lt; 不能比较布尔值</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"空合并运算符\"><a href=\"#空合并运算符\" class=\"headerlink\" title=\"空合并运算符\"></a>空合并运算符</h4><p><code>a ?? b</code>的结果与下面的运算相同:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a <span class=\"operator\">!=</span> <span class=\"literal\">nil</span> <span class=\"operator\">?</span> a<span class=\"operator\">!</span> : b</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"区间运算\"><a href=\"#区间运算\" class=\"headerlink\" title=\"区间运算\"></a>区间运算</h4><ul>\n<li><p><em>闭区间运算符</em>（<code>a...b</code>）定义了一个从 <code>a</code> 到 <code>b</code> 的范围，包括 <code>a</code> 和 <code>b</code> 的值。<code>a</code> 的值不能大于 <code>b</code>;</p>\n<ul>\n<li><p>在需要使用所有值的情况下很有用</p>\n</li>\n<li><p>e.g.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> index <span class=\"keyword\">in</span> <span class=\"number\">1</span><span class=\"operator\">...</span><span class=\"number\">5</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;<span class=\"subst\">\\(index)</span> 乘以 5 等于 <span class=\"subst\">\\(index <span class=\"operator\">*</span> <span class=\"number\">5</span>)</span>&quot;</span>) </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p><em>半开区间运算符</em>（<code>a..&lt;b</code>）定义了一个从 <code>a</code> 到 <code>b</code> 但不包括 <code>b</code> 的范围.</p>\n<ul>\n<li><p>对于处理从基数 0 开始的列表（如数组）时特别有用，因为它可以计数到列表长度（但不包括列表长度）.</p>\n</li>\n<li><p>e.g.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> names <span class=\"operator\">=</span> [<span class=\"string\">&quot;Anna&quot;</span>, <span class=\"string\">&quot;Alex&quot;</span>, <span class=\"string\">&quot;Brian&quot;</span>, <span class=\"string\">&quot;Jack&quot;</span>] </span><br><span class=\"line\"><span class=\"keyword\">let</span> count <span class=\"operator\">=</span> names.count</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"number\">0</span><span class=\"operator\">..&lt;</span>count &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;第 <span class=\"subst\">\\(i <span class=\"operator\">+</span> <span class=\"number\">1</span>)</span> 个人叫 <span class=\"subst\">\\(names[i])</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>闭区间运算符有一种替代形式，用于一直延伸到尽可能远的区间 —— 例如，一个包含从索引 2 到数组末尾所有元素的区间。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names[<span class=\"number\">2</span><span class=\"operator\">...</span>] &#123; <span class=\"built_in\">print</span>(name) &#125;</span><br><span class=\"line\"><span class=\"comment\">// Brian</span></span><br><span class=\"line\"><span class=\"comment\">// Jack</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>半开区间运算符也有一种只写最后一个值的单侧形式</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> name <span class=\"keyword\">in</span> names[<span class=\"operator\">..&lt;</span><span class=\"number\">2</span>] &#123; <span class=\"built_in\">print</span>(name) &#125;</span><br><span class=\"line\"><span class=\"comment\">// Anna</span></span><br><span class=\"line\"><span class=\"comment\">// Alex</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"逻辑运算\"><a href=\"#逻辑运算\" class=\"headerlink\" title=\"逻辑运算\"></a>逻辑运算</h4><blockquote>\n<p>[!NOTE]</p>\n<p>Swift 逻辑运算符 <code>&amp;&amp;</code> 和 <code>||</code> 遵循<u>从左到右</u>的结合顺序，这意味着带有多个逻辑运算符的复合表达式会首先评估最左边的子表达式.</p>\n</blockquote>\n<h2 id=\"控制流\"><a href=\"#控制流\" class=\"headerlink\" title=\"控制流\"></a>控制流</h2><h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><ul>\n<li>如果类需要继承, 需要将父类写在所有的协议之前</li>\n<li>不能在协议定义中为方法参数指定默认值。</li>\n<li>协议也可以要求遵循协议的类型 <u>实现指定的构造器</u>, 和协议内部的方法一样, 不需要写花括号和构造期的实体<ul>\n<li>如果是类, 必须在构造函数的开头加上 <code>required</code>修饰符. 这是为了确保所有继承的子类也提供这个构造函数的实现, 从而确保遵守协议;</li>\n<li>但是如果一个类被声明为了 <code>final</code>, 也就是无法被继承, 那么就不需要 <code>required</code>的声明</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"协议的基本用法\"><a href=\"#协议的基本用法\" class=\"headerlink\" title=\"协议的基本用法\"></a>协议的基本用法</h3><p>协议可以规定属性类型以及属性被操作的权限, 通常和类、结构体和枚举进行绑定, 作为一种强制的约束.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">Tax</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> national: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> individual: <span class=\"type\">Double</span>&#123; <span class=\"keyword\">set</span> <span class=\"keyword\">get</span>&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样可以在协议中使用 <code>mutating</code> 来声明一个改变自身属性的方法:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">protocol</span> <span class=\"title class_\">Tax</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> national: <span class=\"type\">Double</span> &#123; <span class=\"keyword\">get</span> &#125; </span><br><span class=\"line\">  <span class=\"keyword\">var</span> individual: <span class=\"type\">Double</span>&#123; <span class=\"keyword\">set</span> <span class=\"keyword\">get</span>&#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">changeTax</span>(<span class=\"params\">newValue</span>: <span class=\"type\">Double</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>需要注意的是, 结构体内部的方法如果要修改自身属性, 也需要声明 <code>mutating</code>, 但是类则不需要额外的声明.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Taxas</span>: <span class=\"title class_ inherited__\">Tax</span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">var</span> national: <span class=\"type\">Double</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> individual: <span class=\"type\">Double</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">changeTax</span>(<span class=\"params\">newValue</span>: <span class=\"type\">Double</span>)&#123;</span><br><span class=\"line\">    national <span class=\"operator\">=</span> newValue</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"补充协议\"><a href=\"#补充协议\" class=\"headerlink\" title=\"补充协议\"></a>补充协议</h3><ul>\n<li><p>使用 <code>,</code> 连接不同的协议</p>\n</li>\n<li><p><code>extension</code>可以为协议的函数设置默认方法, 就不需要继续在每一个类、结构体或枚举中重新定义</p>\n<ul>\n<li><p>同样可以补充数据类型</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">Int</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> abs: <span class=\"type\">Int</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> <span class=\"keyword\">self</span> <span class=\"operator\">&gt;=</span> <span class=\"number\">0</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">      &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"operator\">-</span><span class=\"keyword\">self</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>((<span class=\"operator\">-</span><span class=\"number\">3</span>).abs);</span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"有条件地遵循协议\"><a href=\"#有条件地遵循协议\" class=\"headerlink\" title=\"有条件地遵循协议\"></a>有条件地遵循协议</h4><p>让 <code>Array</code> 类型只要在存储遵循 <code>TextRepresentable</code> 协议的元素时，就遵循 <code>TextRepresentable</code> 协议:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">Array</span>: <span class=\"title class_ inherited__\">TextRepresentable</span> <span class=\"keyword\">where</span> <span class=\"title class_ inherited__\">Element</span>: <span class=\"title class_ inherited__\">TextRepresentable</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">let</span> itemsAsText <span class=\"operator\">=</span> <span class=\"keyword\">self</span>.map &#123; <span class=\"variable\">$0</span>.textualDescription &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;[&quot;</span> <span class=\"operator\">+</span> itemsAsText.joined(separator: <span class=\"string\">&quot;, &quot;</span>) <span class=\"operator\">+</span> <span class=\"string\">&quot;]&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">let</span> myDice <span class=\"operator\">=</span> [d6, d12]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(myDice.textualDescription)</span><br><span class=\"line\"><span class=\"comment\">// 打印 &quot;[A 6-sided dice, A 12-sided dice]&quot;</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"扩展里声明协议遵循\"><a href=\"#扩展里声明协议遵循\" class=\"headerlink\" title=\"扩展里声明协议遵循\"></a>扩展里声明协议遵循</h4><p>当一个类型已经遵循了某个协议中的所有要求，却还没有声明遵循该协议时，可以通过空的扩展来让它遵循该协议:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Hamster</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> name: <span class=\"type\">String</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> textualDescription: <span class=\"type\">String</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;A hamster named <span class=\"subst\">\\(name)</span>&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">Hamster</span>: <span class=\"title class_ inherited__\">TextRepresentable</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Error-handling\"><a href=\"#Error-handling\" class=\"headerlink\" title=\"Error handling\"></a>Error handling</h3><p>系统提供了 <code>Error</code>协议用于错误处理, 主动给予错误的捕捉情况.</p>\n<p>使用方法:</p>\n<ol>\n<li>定义遵循相关协议的枚举类型, 作为错误的类型;</li>\n<li>定义可能抛出错误的函数;</li>\n<li>使用 <code>do...catch</code>块来结构化地处理错误.</li>\n</ol>\n<p>e.g.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个错误类型，遵循 Error 协议</span></span><br><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">PasswordError</span>: <span class=\"title class_ inherited__\">Error</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> tooShort</span><br><span class=\"line\">    <span class=\"keyword\">case</span> tooWeak</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 一个函数，可能抛出错误</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">validate</span>(<span class=\"params\">password</span>: <span class=\"type\">String</span>) <span class=\"keyword\">throws</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> password.count <span class=\"operator\">&lt;</span> <span class=\"number\">6</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">PasswordError</span>.tooShort</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> password <span class=\"operator\">==</span> <span class=\"string\">&quot;123456&quot;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"type\">PasswordError</span>.tooWeak</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 do-catch 捕捉错误</span></span><br><span class=\"line\"><span class=\"keyword\">do</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> validate(password: <span class=\"string\">&quot;123456&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;密码验证通过 ✅&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">PasswordError</span>.tooShort &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 密码太短，请至少使用 6 个字符&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> <span class=\"type\">PasswordError</span>.tooWeak &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 密码太弱，不能使用简单的序列&quot;</span>)</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;❌ 发生未知错误：<span class=\"subst\">\\(error)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<ul>\n<li>throws：在函数声明中标注该函数会抛出错误;</li>\n<li>try：在调用可能抛出错误的函数时使用.</li>\n</ul>\n</blockquote>\n<h3 id=\"其他的协议\"><a href=\"#其他的协议\" class=\"headerlink\" title=\"其他的协议\"></a>其他的协议</h3><h4 id=\"CaseIterable\"><a href=\"#CaseIterable\" class=\"headerlink\" title=\"CaseIterable\"></a>CaseIterable</h4><p>用于获取枚举的属性个数, 从而进行遍历.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Status</span>:<span class=\"title class_ inherited__\">CaseIterable</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> low,middle,high</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">change</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .high:</span><br><span class=\"line\">            <span class=\"keyword\">self</span> <span class=\"operator\">=</span> .low</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .low:</span><br><span class=\"line\">            <span class=\"keyword\">self</span> <span class=\"operator\">=</span> .middle</span><br><span class=\"line\">        <span class=\"keyword\">case</span> .middle:</span><br><span class=\"line\">            <span class=\"keyword\">self</span> <span class=\"operator\">=</span> .high</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">func</span> <span class=\"title function_\">ptr</span>()&#123;</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Current Status is <span class=\"subst\">\\(<span class=\"keyword\">self</span>)</span>&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> status <span class=\"operator\">=</span> <span class=\"type\">Status</span>.low</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">_</span> <span class=\"keyword\">in</span> <span class=\"number\">0</span><span class=\"operator\">..&lt;</span><span class=\"type\">Status</span>.allCases.count&#123;</span><br><span class=\"line\">    status.ptr()</span><br><span class=\"line\">    status.change()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p><code>for _ in 0..&lt;</code> 当中的 <code>_</code>表示忽略遍历时候的循环变量的值.</p>\n</blockquote>\n<h2 id=\"闭包-1\"><a href=\"#闭包-1\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><h4 id=\"闭包的简化推导\"><a href=\"#闭包的简化推导\" class=\"headerlink\" title=\"闭包的简化推导\"></a>闭包的简化推导</h4><p>相当于匿名函数与 <code>lambda</code>.  接下来从普通函数的写法开始简化:</p>\n<ul>\n<li><p>普通函数: </p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">changeSign</span>(<span class=\"params\">op</span>: <span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> operation: (<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> changeSign</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> operation(<span class=\"number\">4.0</span>) <span class=\"comment\">// result = -4.0</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将函数的定义下移:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation: (<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> (op:<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span> &#123; <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">let</span> result  <span class=\"operator\">=</span> operation(<span class=\"number\">4.0</span>)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>将<code>｛</code> 提前，并在原来的位置添加 <code>in</code></p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123;(op: <span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span>  <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>系统可以推断类型, 所以根据输入的类型简化返回值的类型定义</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123;(op: <span class=\"type\">Double</span>)   <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>可以进一步省略传入的类型</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123; (op) <span class=\"keyword\">in</span> <span class=\"keyword\">return</span> <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>省略返回的标记 <code>return</code>:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123; (op) <span class=\"keyword\">in</span>  <span class=\"operator\">-</span>op&#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<p>最后, 我们可以直接用 <code>$0</code>等替代传入的参数, 也就是省略了参数的名称!</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> operation:(<span class=\"type\">Double</span>) -&gt; <span class=\"type\">Double</span></span><br><span class=\"line\">operation <span class=\"operator\">=</span> &#123; <span class=\"operator\">-</span><span class=\"variable\">$0</span> &#125;</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"闭包的常见使用\"><a href=\"#闭包的常见使用\" class=\"headerlink\" title=\"闭包的常见使用\"></a>闭包的常见使用</h4><p>e.g. </p>\n<p><img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"/swift.assets/image-20250412170605776.png\"\n                      alt=\"image-20250412170605776\"\n                ></p>\n<h4 id=\"Trailing-Closure\"><a href=\"#Trailing-Closure\" class=\"headerlink\" title=\"Trailing Closure\"></a>Trailing Closure</h4><p>当闭包是函数的<strong>最后一个参数</strong>时，</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> applyTwice(<span class=\"number\">3</span>, operation: &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>可以改写成:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> result <span class=\"operator\">=</span> applyTwice(<span class=\"number\">3</span>) &#123; <span class=\"variable\">$0</span> <span class=\"operator\">*</span> <span class=\"number\">2</span> &#125; <span class=\"comment\">// result = 12</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"慕课学习杂记\"><a href=\"#慕课学习杂记\" class=\"headerlink\" title=\"慕课学习杂记\"></a>慕课学习杂记</h1><h4 id=\"something\"><a href=\"#something\" class=\"headerlink\" title=\"something\"></a>something</h4><ul>\n<li><p>去官网学习新出现的技术</p>\n<ul>\n<li>codeML</li>\n<li>张克俊老师?</li>\n</ul>\n</li>\n<li><p>函数也可以赋值给变量</p>\n</li>\n</ul>\n<h4 id=\"省略外部参数名\"><a href=\"#省略外部参数名\" class=\"headerlink\" title=\"省略外部参数名\"></a>省略外部参数名</h4><ul>\n<li>外部参数名: 在函数调用的时候使用, 提高可读性;</li>\n<li>内部参数名: 在函数体的内部使用</li>\n</ul>\n<p>如果如此定义:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello , <span class=\"subst\">\\(name)</span>&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>那么在调用的时候必须显示声明外部参数名:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">greet( person: <span class=\"string\">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果我们希望省略外部参数名, 就可以在定义函数的时候用 <code>_</code>来代替:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"keyword\">_</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>)&#123;</span><br><span class=\"line\">  <span class=\"operator\">...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h4><p>我们可以让函数作为另一个函数的输入参数:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">addTwoInts</span>( <span class=\"keyword\">_</span> <span class=\"params\">a</span>: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> <span class=\"params\">b</span>: <span class=\"type\">Int</span>) -&gt; <span class=\"type\">Int</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a<span class=\"operator\">+</span>b</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> mathFunction <span class=\"operator\">=</span> addTwoInts</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 高阶函数</span></span><br><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">printMathResults（_</span> mathFunction: (<span class=\"type\">Int</span>, <span class=\"type\">Int）</span>-&gt; <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> a: <span class=\"type\">Int</span>, <span class=\"keyword\">_</span> b: <span class=\"type\">Int</span>)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> result <span class=\"operator\">=</span> mathFunction(a,b)</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(result)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 调用</span></span><br><span class=\"line\">printMathResults（addTwoInts， <span class=\"number\">3</span>,<span class=\"number\">5</span>）</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意函数作为参数的时候, 类型的定义就是输入类型和返回类型, 也是用 <code>,</code> 来分隔不同的参数.</p>\n</blockquote>\n<hr>\n<h4 id=\"内置的库\"><a href=\"#内置的库\" class=\"headerlink\" title=\"内置的库\"></a>内置的库</h4><p><code>AVFoudation</code>: 音频播放 </p>\n<hr>\n<ul>\n<li><p>枚举内部也可以设置方法; </p>\n</li>\n<li><p>结构体本身不需要构造函数(因为swift存在对于结构体的默认构造) , 但是如果结构体内部的属性存在这样的属性:</p>\n<ul>\n<li>它可能是枚举内部的方法, 跟枚举的属性有关, 可能使用了 <code>switch</code>来根据枚举属性赋值.</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Type</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"type\">Cike</span></span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"operator\">...</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">func</span> <span class=\"title function_\">blood</span>()-&gt; <span class=\"type\">Double</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">switch</span> <span class=\"keyword\">self</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">case</span> .<span class=\"type\">Cike</span>: <span class=\"keyword\">return</span> <span class=\"number\">10</span></span><br><span class=\"line\">      <span class=\"keyword\">case</span> .<span class=\"type\">Fashi</span>: <span class=\"keyword\">return</span> <span class=\"operator\">...</span></span><br><span class=\"line\">      <span class=\"operator\">...</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Card</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> country: <span class=\"type\">Country</span></span><br><span class=\"line\">  vat type: <span class=\"type\">Type</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> blood: <span class=\"type\">Double</span></span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">init</span> (<span class=\"params\">country</span>: <span class=\"type\">Country</span>, <span class=\"params\">type</span>: <span class=\"type\">Type</span>)&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.country <span class=\"operator\">=</span> country</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.type <span class=\"operator\">=</span> type;</span><br><span class=\"line\">    blood <span class=\"operator\">=</span> type.blood</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n</li>\n<li><p>结构体和枚举属于 <u>值类型</u>, 如果赋值的时候进行拷贝操作;</p>\n<ul>\n<li>如果结构体声明为 <code>let</code>, 即使属性是变量, 那么也无法修改内部的属性,</li>\n</ul>\n</li>\n<li><p>类是引用类型, 赋值的时候使得左值指向了同样的内存区域, 也就是信息保持一致, 更改同步</p>\n<ul>\n<li>如果我们将类声明为常量, 相当于cpp的指针常量, 也就是说类内部的属性可以更改, 但是无法修改这个量指向的内存区域.</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"计算属性-1\"><a href=\"#计算属性-1\" class=\"headerlink\" title=\"计算属性\"></a>计算属性</h4><p>访问的时候动态计算得到.</p>\n<p>下面通过一个矩形的例子来说明:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Point</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> y <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Size</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> width <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> height <span class=\"operator\">=</span> <span class=\"number\">0.0</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">Rect</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> origin <span class=\"operator\">=</span> <span class=\"type\">Point</span>()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> size <span class=\"operator\">=</span> <span class=\"type\">Size</span>()</span><br><span class=\"line\">  <span class=\"keyword\">var</span> center: <span class=\"type\">Point</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">get</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> centerX <span class=\"operator\">=</span> origin.x <span class=\"operator\">+</span> (size.width <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">      <span class=\"keyword\">let</span> centerY <span class=\"operator\">=</span> orgin.y <span class=\"operator\">+</span> (size.height <span class=\"operator\">/</span><span class=\"number\">2</span> )</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"type\">Point</span>(x: centerX, y: centerY)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">set</span>(newCenter)&#123;</span><br><span class=\"line\">      origin.x <span class=\"operator\">=</span> newCenter.x <span class=\"operator\">-</span> (size.width <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">      origin.y <span class=\"operator\">=</span> newCenter.y <span class=\"operator\">-</span> (size.height <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>上述完成了结构体的计算属性的定义, 其中 <code>get</code>部分也可以优化为:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">get</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">Point</span>(x: origin.x <span class=\"operator\">+</span> (size.width <span class=\"operator\">/</span> <span class=\"number\">2</span>),</span><br><span class=\"line\">        y: orgin.y <span class=\"operator\">+</span> (size.height <span class=\"operator\">/</span><span class=\"number\">2</span> ) )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>这是因为, 如果 <code>get</code> 部分只存在一个表达式,  就会自动将其返回, 不需要显式声明 <code>return</code>关键字.</p>\n</blockquote>\n<p>然后可以如此应用:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> currCenter <span class=\"operator\">=</span> rectElement.center</span><br><span class=\"line\"></span><br><span class=\"line\">rectElement.center <span class=\"operator\">=</span> <span class=\"type\">Point</span>(x:<span class=\"number\">20</span>, y:<span class=\"number\">50</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<p><code>set</code>提供了语法糖, 也就是可以直接访问oldValue 和  newValue, 因此我们可以如此改写:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">set</span>&#123;</span><br><span class=\"line\">  origin.x <span class=\"operator\">=</span> newValue.x <span class=\"operator\">-</span> (size.width <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">  origin.y <span class=\"operator\">=</span> newValue.y <span class=\"operator\">-</span> (size.height <span class=\"operator\">/</span> <span class=\"number\">2</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<blockquote>\n<p>[!NOTE]</p>\n<p>对于只读的计算属性, 由于不存在 <code>set</code>, 我们可以直接在花括号内定义返回内容.</p>\n</blockquote>\n<hr>\n<ul>\n<li><p>声明 <code>static</code> , 表示这个属性或者方法属于整个类型而非某个实例. 此时相应的, 我们使用 <code>&lt;tyepName&gt;.&lt;strtic attribute&gt;</code>的方式来访问.</p>\n</li>\n<li><p>子面量本身是不可修改的, 下面的拓展中, 如果写作  <code>var someInt = 3.square()</code>就会报错</p>\n</li>\n</ul>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extension</span> <span class=\"title class_\">Int</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">mutating</span> <span class=\"keyword\">func</span> <span class=\"title function_\">square</span>()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">self</span> <span class=\"operator\">=</span> <span class=\"keyword\">self</span> <span class=\"operator\">*</span> <span class=\"keyword\">self</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> someInt <span class=\"operator\">=</span> <span class=\"number\">3</span></span><br><span class=\"line\">someInt.square()</span><br></pre></td></tr></table></figure>\n\n\n\n<hr>\n<p>控制器存在5种状态:</p>\n<ul>\n<li>未加载</li>\n<li>将要出现</li>\n<li>出现</li>\n<li>将要消失</li>\n<li>已经消失</li>\n</ul>\n<p>APP的状态:</p>\n<img  \n                     lazyload\n                     src=\"/images/loading.svg\"\n                     data-src=\"swift.assets/image-20250413182851979.png\"\n                      alt=\"image-20250413182851979\" style=\"zoom:33%;\" \n                >\n\n<p><code>UiSceneDelegate</code>用于响应基于 <code>scene</code> 的生命周期事件.</p>\n<p>可以使用属性的 <code>didset</code>来便捷地检测变化并快速修改:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> score <span class=\"operator\">=</span> <span class=\"number\">0</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">didSet</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">self</span>.gameScoreLabel.text <span class=\"operator\">=</span> <span class=\"string\">&quot;Score: <span class=\"subst\">\\(score)</span>&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><code>viewController</code>是新的页面;</li>\n<li><code>view</code>是视图, 可以叠加在页面上.</li>\n<li><code>UIAlertController</code>组件相当于警示的弹窗组件</li>\n</ul>\n<h3 id=\"作图和绘画\"><a href=\"#作图和绘画\" class=\"headerlink\" title=\"作图和绘画\"></a>作图和绘画</h3><h4 id=\"CG\"><a href=\"#CG\" class=\"headerlink\" title=\"CG\"></a>CG</h4><ul>\n<li><p><code>CGFloat</code>用于二维坐标系中的坐标数据:</p>\n<ul>\n<li><code>let coor_x = CGFloat(10.5)</code></li>\n</ul>\n</li>\n<li><p><code>CGPoint(x: .. , y:...)</code></p>\n</li>\n<li><p><code>CGSize</code> 包含width和height属性的结构体;</p>\n</li>\n<li><p><code>CGRect</code>包含点和尺寸的矩形</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">CGRect</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> origin: <span class=\"type\">CGPoint</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> size: <span class=\"type\">CGSize</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>其他属性</p>\n</li>\n<li><p>e.g.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> minX: <span class=\"type\">CGPoint</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> midY: <span class=\"type\">CGPoint</span></span><br><span class=\"line\">intersects(<span class=\"type\">CGRect</span>) -&gt; <span class=\"type\">Bool</span> <span class=\"comment\">// 判断是否存在交集</span></span><br><span class=\"line\">contains(<span class=\"type\">CGPoint</span>) -&gt; <span class=\"type\">Bool</span> <span class=\"comment\">// 是否包含点.</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n<p>最小单元是 <code>Point</code>而非像素点.</p>\n<p>bound表示视图内部允许绘制的区域:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> bounds: <span class=\"type\">CGRect</span> <span class=\"comment\">// 也就是一个矩形</span></span><br></pre></td></tr></table></figure>\n\n<p>frame\t视图在父视图中的位置:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> frame: <span class=\"type\">CGRect</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"自定义视图\"><a href=\"#自定义视图\" class=\"headerlink\" title=\"自定义视图\"></a>自定义视图</h4><p>绘制自定义视图通常通过创建一个自定义的 UIView 子类，并重写 draw(_:) 方法来实现.</p>\n<p>playGround中的实例:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> UIKit</span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">CustomView</span>: <span class=\"title class_ inherited__\">UIView</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">init</span>(<span class=\"params\">frame</span>: <span class=\"type\">CGRect</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.<span class=\"keyword\">init</span>(frame: frame)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.backgroundColor <span class=\"operator\">=</span> .white <span class=\"comment\">// 设置背景颜色</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">required</span> <span class=\"keyword\">init?</span>(<span class=\"params\">coder</span>: <span class=\"type\">NSCoder</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">fatalError</span>(<span class=\"string\">&quot;init(coder:) has not been implemented&quot;</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">override</span> <span class=\"keyword\">func</span> <span class=\"title function_\">draw</span>(<span class=\"keyword\">_</span> <span class=\"params\">rect</span>: <span class=\"type\">CGRect</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">guard</span> <span class=\"keyword\">let</span> context <span class=\"operator\">=</span> <span class=\"type\">UIGraphicsGetCurrentContext</span>() <span class=\"keyword\">else</span> &#123; <span class=\"keyword\">return</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绘制一个圆形</span></span><br><span class=\"line\">        context.setFillColor(<span class=\"type\">UIColor</span>.blue.cgColor) <span class=\"comment\">// 设置填充颜色</span></span><br><span class=\"line\">        context.fillEllipse(in: rect) <span class=\"comment\">// 绘制填充的圆</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 绘制一个矩形</span></span><br><span class=\"line\">        context.setStrokeColor(<span class=\"type\">UIColor</span>.black.withAlphaComponent(<span class=\"number\">0.6</span>).cgColor) <span class=\"comment\">// 设置能见度</span></span><br><span class=\"line\">        context.setLineWidth(<span class=\"number\">5</span>)</span><br><span class=\"line\">        context.stroke(rect.insetBy(dx: <span class=\"number\">10</span>, dy: <span class=\"number\">10</span>)) <span class=\"comment\">// 绘制矩形边框，留出间距</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建自定义视图实例</span></span><br><span class=\"line\"><span class=\"keyword\">let</span> customView <span class=\"operator\">=</span> <span class=\"type\">CustomView</span>(frame: <span class=\"type\">CGRect</span>(x: <span class=\"number\">0</span>, y: <span class=\"number\">0</span>, width: <span class=\"number\">200</span>, height: <span class=\"number\">200</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 显示在 Playground 的 live view</span></span><br><span class=\"line\"><span class=\"type\">PlaygroundPage</span>.current.liveView <span class=\"operator\">=</span> customView</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<ul>\n<li><code>touchesBegan</code>–WWDC</li>\n<li><code>SCNVector3</code>是三维向量</li>\n<li><code>DispathchQueue</code>表示创建一个异步的进程</li>\n</ul>\n<h3 id=\"传感器\"><a href=\"#传感器\" class=\"headerlink\" title=\"传感器\"></a>传感器</h3><ul>\n<li>加速度的方向伴随手机的头部旋转保持不变;<ul>\n<li>以 <code>g</code> 为描述单位;</li>\n<li>面向使用者的方向是 <code>z</code> 轴.</li>\n</ul>\n</li>\n<li>陀螺仪<ul>\n<li>记录对应用三个轴</li>\n<li>roll, pitch, yaw</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"动画\"><a href=\"#动画\" class=\"headerlink\" title=\"动画\"></a>动画</h3><h2 id=\"结绳记事\"><a href=\"#结绳记事\" class=\"headerlink\" title=\"结绳记事\"></a>结绳记事</h2><ul>\n<li><p><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245274&cid=1299836384&contentid=1217938866\" >操作演示<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a>.</p>\n</li>\n<li><p>按住 <code>ctrl</code>将视图中的组件拖放到代码中.</p>\n</li>\n<li><p>右下角的几个功能:</p>\n<ul>\n<li>约束;</li>\n<li>选择视图</li>\n</ul>\n</li>\n<li><p><code>ctrl + option + cmd + enter</code> 快速显示代码区域</p>\n</li>\n<li><p><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245274&cid=1299836386&contentid=1217092922\" >组件使用<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n<ul>\n<li>50:00 左右介绍了两种类型和交互</li>\n</ul>\n</li>\n<li><p>按住<code>optional</code>然后 hover 在类上, 可以显示对应的基础操作.</p>\n</li>\n<li><p>可选值的本质是枚举类型!</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">enum</span> <span class=\"title class_\">Optional</span>&lt;<span class=\"type\">T</span>&gt;&#123;</span><br><span class=\"line\">  <span class=\"keyword\">case</span> none</span><br><span class=\"line\">  <span class=\"keyword\">case</span> <span class=\"keyword\">some</span>(<span class=\"operator\">&lt;</span><span class=\"type\">T</span><span class=\"operator\">&gt;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245305&sm=1\" >画图和动画<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n</li>\n<li><p><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245309&sm=1\" >coreML<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></p>\n</li>\n<li><p>在项目中显示Md格式:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*:</span></span><br><span class=\"line\"><span class=\"comment\">...</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>选择在运行时隐藏实际存在的代码:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#-hidden-code</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> PlaygroundSupport</span><br><span class=\"line\"><span class=\"operator\">...</span></span><br><span class=\"line\"><span class=\"comment\">//#-end-hidden-code</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h1 id=\"Swift-UI\"><a href=\"#Swift-UI\" class=\"headerlink\" title=\"Swift UI\"></a>Swift UI</h1><ul>\n<li><a class=\"link\"   href=\"https://www.icourse163.org/learn/ZJU-1450024180?tid=1474143513#/learn/content?type=detail&id=1262245315&cid=1299836440&contentid=1218091551\" >慕课的链接<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://www.hackingwithswift.com/100/swiftui/16\" >by now<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li>SixD: 开箱即用的UI设计等.</li>\n<li><a class=\"link\"   href=\"https://www.hackingwithswift.com/glossary\" >术语表<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h2 id=\"AR\"><a href=\"#AR\" class=\"headerlink\" title=\"AR\"></a>AR</h2><ul>\n<li><a class=\"link\"   href=\"https://www.createwithswift.com/creating-an-augmented-reality-app-in-swiftui-using-realitykit-and-arkit/\" >helpful links<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><a class=\"link\"   href=\"https://developer.apple.com/documentation/realitykit/?ref=createwithswift.com\" >官方文档<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h2 id=\"动画-1\"><a href=\"#动画-1\" class=\"headerlink\" title=\"动画\"></a>动画</h2><h4 id=\"缩放变换\"><a href=\"#缩放变换\" class=\"headerlink\" title=\"缩放变换\"></a>缩放变换</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NavigationLink</span>&#123;</span><br><span class=\"line\">  <span class=\"type\">BraceletEditor</span>(bracelet)</span><br><span class=\"line\">  .navigationTransitionStyle(</span><br><span class=\"line\">  .zoom(</span><br><span class=\"line\">  \tsourceID:bracelet.id,</span><br><span class=\"line\">  \tin:braceletList</span><br><span class=\"line\">  \t)</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;label:&#123;</span><br><span class=\"line\">  <span class=\"type\">BraceletPreview</span>(bracelet)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.matchedTansitionSource(</span><br><span class=\"line\">\tid:bracelet.id,</span><br><span class=\"line\">  in:braceletList</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"Symbol-6\"><a href=\"#Symbol-6\" class=\"headerlink\" title=\"Symbol 6\"></a>Symbol 6</h2><h3 id=\"动画-2\"><a href=\"#动画-2\" class=\"headerlink\" title=\"动画\"></a>动画</h3><ul>\n<li>使用 <code>晃动</code> 在复杂的UI中提示可交互性.</li>\n<li><code>旋转</code>动画来表示正在进行的进程</li>\n</ul>\n<h2 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h2><h4 id=\"磨砂效果\"><a href=\"#磨砂效果\" class=\"headerlink\" title=\"磨砂效果\"></a>磨砂效果</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">VStack</span> &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.frame(width: <span class=\"number\">200</span>, height: <span class=\"number\">200</span>)</span><br><span class=\"line\">.background(.ultraThinMaterial, in: <span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">20</span>, style: .continuous))</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"搜索栏\"><a href=\"#搜索栏\" class=\"headerlink\" title=\"搜索栏\"></a>搜索栏</h4><ul>\n<li><p>状态管理:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 存储搜索文本</span></span><br><span class=\"line\"><span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> searchText <span class=\"operator\">=</span> <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 可选：跟踪搜索是否处于活动状态</span></span><br><span class=\"line\"><span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> isSearching <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>数据过滤模式</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 基本过滤计算属性模板</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> filteredItems: [<span class=\"type\">ItemType</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> searchText.isEmpty &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalItems</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalItems.filter &#123; item <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">// 根据需要自定义过滤条件</span></span><br><span class=\"line\">            item.name.localizedCaseInsensitiveContains(searchText) <span class=\"operator\">||</span></span><br><span class=\"line\">            item.description.localizedCaseInsensitiveContains(searchText)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 处理嵌套数据结构的过滤模板</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> filteredNestedItems: [<span class=\"type\">ParentType</span>] &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> searchText.isEmpty &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalParentItems</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> originalParentItems.compactMap &#123; parent <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"keyword\">let</span> matchedChildren <span class=\"operator\">=</span> parent.children.filter &#123; child <span class=\"keyword\">in</span></span><br><span class=\"line\">                child.name.localizedCaseInsensitiveContains(searchText)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"keyword\">if</span> matchedChildren.isEmpty &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">nil</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// 创建包含匹配子项的新父项</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"type\">ParentType</span>(id: parent.id, name: parent.name, children: matchedChildren)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>搜索UI中的实现:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">NavigationStack</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">List</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 使用过滤后的数据源</span></span><br><span class=\"line\">        <span class=\"type\">ForEach</span>(filteredItems) &#123; item <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"comment\">// 列表项视图</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .navigationTitle(<span class=\"string\">&quot;标题&quot;</span>)</span><br><span class=\"line\">    .searchable(text: <span class=\"variable\">$searchText</span>, prompt: <span class=\"string\">&quot;搜索提示文字&quot;</span>)</span><br><span class=\"line\">    <span class=\"comment\">// 可选：添加搜索建议</span></span><br><span class=\"line\">    .searchSuggestions &#123;</span><br><span class=\"line\">        <span class=\"type\">ForEach</span>(suggestions, id: \\.<span class=\"keyword\">self</span>) &#123; suggestion <span class=\"keyword\">in</span></span><br><span class=\"line\">            <span class=\"type\">Text</span>(suggestion).searchCompletion(suggestion)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"左右适应的外边距\"><a href=\"#左右适应的外边距\" class=\"headerlink\" title=\"左右适应的外边距\"></a>左右适应的外边距</h4><p>通过 <code>HStack</code>与  <code>space</code>实现卡片的自适应扩展, 同时利用 <code>.frame(maxwidth:...)</code>来设置一个最大的卡片宽度</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">HStack</span>&#123;</span><br><span class=\"line\">    <span class=\"type\">Spacer</span>(minLength: <span class=\"number\">10</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"type\">Text</span>(item.description)</span><br><span class=\"line\">        .padding()</span><br><span class=\"line\">        .background(<span class=\"type\">Color</span>(.systemGray6))</span><br><span class=\"line\">        .overlay(</span><br><span class=\"line\">            <span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">10</span>) <span class=\"comment\">// 10为圆角半径，可调整</span></span><br><span class=\"line\">                .stroke(<span class=\"type\">Color</span>.gray, lineWidth: <span class=\"number\">1</span>) <span class=\"comment\">// 边框颜色和宽度</span></span><br><span class=\"line\">        )</span><br><span class=\"line\">        .clipShape(<span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">10</span>))</span><br><span class=\"line\">    <span class=\"comment\">// 保证背景和边框都圆角</span></span><br><span class=\"line\">    .frame(maxWidth: <span class=\"number\">400</span>) <span class=\"comment\">// 最大宽度限制</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"type\">Spacer</span>(minLength: <span class=\"number\">10</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>Spacer(minLength: 10)</code> 表示<strong>保证自己不会小于 minLength</strong>. </p>\n<p>上述的 <code>Spacer</code>会压缩卡片的内容, 如果希望直接设置卡片在父容器中的左右外边距, 应该在卡片的内部使用 <code>padding</code>:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Text</span>(item.description)</span><br><span class=\"line\">    .padding(.horizontal, <span class=\"number\">24</span>) <span class=\"comment\">// 卡片内容内边距</span></span><br><span class=\"line\">    .padding(.vertical, <span class=\"number\">12</span>)</span><br><span class=\"line\">    .background(<span class=\"type\">Color</span>(.systemGray6))</span><br><span class=\"line\">    .overlay(</span><br><span class=\"line\">        <span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">10</span>)</span><br><span class=\"line\">            .stroke(<span class=\"type\">Color</span>.gray, lineWidth: <span class=\"number\">2</span>)</span><br><span class=\"line\">    )</span><br><span class=\"line\">    .clipShape(<span class=\"type\">RoundedRectangle</span>(cornerRadius: <span class=\"number\">10</span>))</span><br><span class=\"line\">    .padding(.horizontal, <span class=\"number\">20</span>) <span class=\"comment\">// 整个卡片距离父视图左右20pt</span></span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"全局统一样式\"><a href=\"#全局统一样式\" class=\"headerlink\" title=\"全局统一样式\"></a>全局统一样式</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">@main</span></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MyApp</span>: <span class=\"title class_ inherited__\">App</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">Scene</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">WindowGroup</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ContentView</span>()</span><br><span class=\"line\">                .buttonStyle(<span class=\"type\">ShadowButtonStyle</span>(radius: <span class=\"number\">10</span>))</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"参数标签和参数名\"><a href=\"#参数标签和参数名\" class=\"headerlink\" title=\"参数标签和参数名\"></a>参数标签和参数名</h4><ul>\n<li>参数标签用于函数调用时;</li>\n<li>参数名用于函数内部的参数名称.</li>\n</ul>\n<p>e.g.:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"params\">person</span> <span class=\"params\">atName</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello, <span class=\"subst\">\\(atName)</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(person: <span class=\"string\">&quot;Alice&quot;</span>) <span class=\"comment\">// 输出：Hello, Alice!</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>也可以使用 <code>_</code>来省略调用时的参数标签:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">func</span> <span class=\"title function_\">greet</span>(<span class=\"keyword\">_</span> <span class=\"params\">name</span>: <span class=\"type\">String</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;Hello, <span class=\"subst\">\\(name)</span>!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">greet(<span class=\"string\">&quot;Alice&quot;</span>) <span class=\"comment\">// 输出：Hello, Alice!</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h4 id=\"Alert\"><a href=\"#Alert\" class=\"headerlink\" title=\"Alert\"></a>Alert</h4><p>swift UI中的弹窗提示同样通过本地的 <code>@State</code>变量来实现:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> showingPaymentAlert <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"><span class=\"operator\">...</span></span><br><span class=\"line\">.alert(<span class=\"string\">&quot;Order confirmed&quot;</span>, isPresented: <span class=\"variable\">$showingPaymentAlert</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// add buttons here</span></span><br><span class=\"line\">&#125; message: &#123;</span><br><span class=\"line\">    <span class=\"type\">Text</span>(<span class=\"string\">&quot;Your total was <span class=\"subst\">\\(totalPrice)</span> – thank you!&quot;</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>设置按钮来改变可见的状态:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Button</span>(<span class=\"string\">&quot;Confirm order&quot;</span>) &#123;</span><br><span class=\"line\">    showingPaymentAlert.toggle()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"自定义绑定\"><a href=\"#自定义绑定\" class=\"headerlink\" title=\"自定义绑定\"></a>自定义绑定</h4><p>我们也可以使用 <code>Binding</code> 类型手动创建绑定，该类型可以提供自定义 <code>get</code> 和 <code>set</code> 闭包，以便在读取或写入值时运行。</p>\n<h4 id=\"Foreach\"><a href=\"#Foreach\" class=\"headerlink\" title=\"Foreach\"></a>Foreach</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ForEach</span>(item.restrictions) &#123; restriction <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"type\">Text</span>(restriction)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>此时, 要求 <code>item.restrictions</code> 具有可唯一标识的 <code>id</code> 字段.</p>\n<ul>\n<li><p>如果内容本身就是唯一标识, 比如说遍历的内容是字符串数组, 那么可以如此声明:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ForEach</span>(item.restrictions, id: \\.<span class=\"keyword\">self</span>) &#123; restriction <span class=\"keyword\">in</span></span><br><span class=\"line\">    <span class=\"type\">Text</span>(restriction)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"Spacer\"><a href=\"#Spacer\" class=\"headerlink\" title=\"Spacer()\"></a>Spacer()</h4><p>用于填充剩余的空间</p>\n<ul>\n<li>使用 <code>offset(x:.., y:...)</code>来调节位置, 左上角是原点.</li>\n</ul>\n<h4 id=\"环境变量\"><a href=\"#环境变量\" class=\"headerlink\" title=\"环境变量\"></a>环境变量</h4><ul>\n<li><p>作用: 用于存储独立于视图的、长期存在的数据;</p>\n</li>\n<li><p>e.g.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// App.swift</span></span><br><span class=\"line\"><span class=\"meta\">@StateObject</span> <span class=\"keyword\">var</span> order <span class=\"operator\">=</span> <span class=\"type\">Order</span>()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>@StateObject</code> 属性包装器负责在<u>应用程序的整个生命周期中</u>保持对象处于活动状态。</p>\n</li>\n<li><p>需要在创建视图结构体的时候传递:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">WindowGroup</span> &#123;</span><br><span class=\"line\">    <span class=\"type\">ContentView</span>()</span><br><span class=\"line\">        .environmentObject(order)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>为了让swift知道什么时候更新视图, 常用的是声明 <code>@Published</code>属性包装器——足以让它更新任何正在监视更改的 SwiftUI 视图.</p>\n</li>\n<li><p>同时声明对应的对象遵循可观测协议: <strong>ObservableObject</strong>.</p>\n</li>\n</ul>\n<p>我们可以使用 <code>@EnvironmentObject</code>来访问环境中的共享数据, 也就是传递上一步已经在父视图中创建和管理的对象.</p>\n<p>e.g.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">UserData</span>: <span class=\"title class_ inherited__\">ObservableObject</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Published</span> <span class=\"keyword\">var</span> name: <span class=\"type\">String</span> <span class=\"operator\">=</span> <span class=\"string\">&quot;John&quot;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@StateObject</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> userData <span class=\"operator\">=</span> <span class=\"type\">UserData</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ChildView</span>().environmentObject(userData)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ChildView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@EnvironmentObject</span> <span class=\"keyword\">var</span> userData: <span class=\"type\">UserData</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">Text</span>(userData.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>使用 <code>@State</code>来声明简单的本地值——比如整数和字符串.</p>\n<ul>\n<li><p>建议将其声明为 <code>private</code>, e.g.</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> paymentType <span class=\"operator\">=</span> <span class=\"string\">&quot;Cash&quot;</span></span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"菜单视图\"><a href=\"#菜单视图\" class=\"headerlink\" title=\"菜单视图\"></a>菜单视图</h4><p>为了将菜单视图存放在一个选项卡当中, 我们需要新建一个视图, 用来作为容器:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">MainView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TabView</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">ContentView</span>()</span><br><span class=\"line\">                .tabItem &#123;</span><br><span class=\"line\">                    <span class=\"type\">Label</span>(<span class=\"string\">&quot;Menu&quot;</span>, systemImage: <span class=\"string\">&quot;list.dash&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"type\">OrderView</span>()</span><br><span class=\"line\">                .tabItem &#123;</span><br><span class=\"line\">                    <span class=\"type\">Label</span>(<span class=\"string\">&quot;Order&quot;</span>, systemImage: <span class=\"string\">&quot;square.and.pencil&quot;</span>)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>页面级别的切换.</p>\n</blockquote>\n<p>使用枚举与子页面的内容分区:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> SwiftUI</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">enum</span> <span class=\"title class_\">Section</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> cats</span><br><span class=\"line\">        <span class=\"keyword\">case</span> dogs</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> selectedTab <span class=\"operator\">=</span> <span class=\"type\">Section</span>.cats</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">TabView</span>(selection: <span class=\"variable\">$selectedTab</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">Tab</span>(<span class=\"string\">&quot;Cats&quot;</span>, systemImage: <span class=\"string\">&quot;cat&quot;</span>, value: .cats) &#123;</span><br><span class=\"line\">                <span class=\"type\">Button</span>(<span class=\"string\">&quot;Go to Dogs&quot;</span>) &#123;</span><br><span class=\"line\">                    selectedTab <span class=\"operator\">=</span> .dogs</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">            <span class=\"type\">Tab</span>(<span class=\"string\">&quot;Dogs&quot;</span>, systemImage: <span class=\"string\">&quot;dog&quot;</span>, value: .dogs) &#123;</span><br><span class=\"line\">                <span class=\"type\">Button</span>(<span class=\"string\">&quot;Go to Cats&quot;</span>) &#123;</span><br><span class=\"line\">                    selectedTab <span class=\"operator\">=</span> .cats</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"合适的修饰符\"><a href=\"#合适的修饰符\" class=\"headerlink\" title=\"合适的修饰符\"></a>合适的修饰符</h2><ul>\n<li><p>图像自动调节尺寸:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Image</span>(item.mainImage)</span><br><span class=\"line\">    .resizable()</span><br><span class=\"line\">    .scaledToFit()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"设置阴影\"><a href=\"#设置阴影\" class=\"headerlink\" title=\"设置阴影\"></a>设置阴影</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.shadow(color: .black.opacity(<span class=\"number\">0.2</span>), </span><br><span class=\"line\">        radius: <span class=\"number\">15</span>, x: <span class=\"number\">0</span>, y: <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"为按钮设置动画\"><a href=\"#为按钮设置动画\" class=\"headerlink\" title=\"为按钮设置动画\"></a>为按钮设置动画</h4><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">ContentView</span>: <span class=\"title class_ inherited__\">View</span> &#123;</span><br><span class=\"line\">    <span class=\"meta\">@State</span> <span class=\"keyword\">private</span> <span class=\"keyword\">var</span> showingWelcome <span class=\"operator\">=</span> <span class=\"literal\">false</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">var</span> body: <span class=\"keyword\">some</span> <span class=\"type\">View</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">VStack</span> &#123;</span><br><span class=\"line\">            <span class=\"type\">Toggle</span>(<span class=\"string\">&quot;Toggle label&quot;</span>, isOn: <span class=\"variable\">$showingWelcome</span>.animation())</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span> showingWelcome &#123;</span><br><span class=\"line\">                <span class=\"type\">Text</span>(<span class=\"string\">&quot;Hello World&quot;</span>)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以进一步设置, 比如弹簧的渐入渐出:</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">Toggle</span>(<span class=\"string\">&quot;Toggle label&quot;</span>, isOn: <span class=\"variable\">$showingWelcome</span>.animation(.spring()))</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"基本操作\"><a href=\"#基本操作\" class=\"headerlink\" title=\"基本操作\"></a>基本操作</h2><h4 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h4><ul>\n<li><code>ctrl</code>按住后点击  <code>VStack</code>可以快速地将其添加到 <code>ZStack</code>当中<ul>\n<li>颜色的设置需要通过 <code>ZStack</code>来实现.</li>\n</ul>\n</li>\n<li><code>option</code>可以显示当前类的介绍</li>\n<li></li>\n</ul>\n<p>学习路线:</p>\n<ol>\n<li>学习 Swift 基础语法</li>\n<li>上手 SwiftUI 基础控件（Text、Button、Image、List、NavigationStack 等）</li>\n<li>学会使用 @State、@Binding 等状态管理属性</li>\n<li>尝试做一个简单的 App（比如 ToDo List、小笔记本）</li>\n<li>慢慢接触更复杂的功能，比如动画、数据持久化（CoreData）、网络请求（URLSession）</li>\n</ol>\n<h4 id=\"第二周：SwiftUI-基础入门\"><a href=\"#第二周：SwiftUI-基础入门\" class=\"headerlink\" title=\"第二周：SwiftUI 基础入门\"></a><strong>第二周：SwiftUI 基础入门</strong></h4><p><strong>目标：</strong></p>\n<ul>\n<li>理解 SwiftUI 的基本概念和架构。</li>\n<li>掌握常用的 SwiftUI 视图和修饰符。</li>\n</ul>\n<ol>\n<li><strong>SwiftUI 概述：</strong><ul>\n<li>声明式语法与传统 UIKit 的区别</li>\n<li>SwiftUI 的视图层次结构</li>\n</ul>\n</li>\n<li><strong>常用视图组件：</strong><ul>\n<li>Text、Image、Button 等基本控件的使用</li>\n<li>视图修饰符的应用，如 .font()、.foregroundColor()、.padding() 等</li>\n</ul>\n</li>\n<li><strong>布局系统：</strong><ul>\n<li>使用 HStack、VStack 和 ZStack 进行视图布局</li>\n<li>Spacer 和 Divider 的使用</li>\n</ul>\n</li>\n</ol>\n<p><strong>推荐资源：</strong></p>\n<ul>\n<li><strong>Hacking with Swift 的 100 天 SwiftUI：</strong> <a class=\"link\"   href=\"https://www.hackingwithswift.com/100/swiftui\" >100 Days of SwiftUI<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>AppCoda 的 SwiftUI 教程：</strong> <a class=\"link\"   href=\"https://www.appcoda.com/swiftui/\" >AppCoda - Mastering SwiftUI<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h4 id=\"第三周：状态管理与数据绑定\"><a href=\"#第三周：状态管理与数据绑定\" class=\"headerlink\" title=\"第三周：状态管理与数据绑定\"></a><strong>第三周：状态管理与数据绑定</strong></h4><p><strong>目标：</strong></p>\n<ul>\n<li>理解并应用 SwiftUI 的状态管理机制。</li>\n<li>掌握数据绑定和视图更新的原理。</li>\n</ul>\n<p><strong>学习内容：</strong></p>\n<ol>\n<li><strong>状态管理：</strong><ul>\n<li>使用 @State 管理视图内部状态</li>\n<li>使用 @Binding 在父子视图之间传递状态</li>\n<li>使用 @ObservedObject 和 @EnvironmentObject 管理复杂数据模型</li>\n</ul>\n</li>\n<li><strong>数据绑定：</strong><ul>\n<li>双向绑定的实现</li>\n<li>数据变化如何驱动视图更新</li>\n</ul>\n</li>\n</ol>\n<p><strong>推荐资源：</strong></p>\n<ul>\n<li><strong>SwiftUI 官方文档：</strong> <a class=\"link\"   href=\"https://developer.apple.com/documentation/swiftui\" >SwiftUI Documentation<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>Design+Code 的 SwiftUI 教程：</strong> <a class=\"link\"   href=\"https://designcode.io/swiftui\" >Design+Code - SwiftUI for iOS 17<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n<h4 id=\"第四周：导航、列表与高级交互\"><a href=\"#第四周：导航、列表与高级交互\" class=\"headerlink\" title=\"第四周：导航、列表与高级交互\"></a><strong>第四周：导航、列表与高级交互</strong></h4><p><strong>目标：</strong></p>\n<ul>\n<li>掌握 SwiftUI 中的导航和列表视图。</li>\n<li>实现复杂的用户交互和动画效果</li>\n</ul>\n<p><strong>学习内容：</strong></p>\n<ol>\n<li><strong>导航与路由：</strong><ul>\n<li>使用 NavigationView 和 NavigationLink 实现页面导航</li>\n<li>传递数据到下一个视图</li>\n</ul>\n</li>\n<li><strong>列表视图：</strong><ul>\n<li>使用 List 展示数据集合</li>\n<li>自定义列表行和支持删除、移动操作</li>\n</ul>\n</li>\n<li><strong>动画与手势：</strong><ul>\n<li>添加基本动画效果</li>\n<li>处理手势交互，如拖拽、缩放等</li>\n</ul>\n</li>\n</ol>\n<p><strong>推荐资源：</strong></p>\n<ul>\n<li><strong>Raywenderlich 的 SwiftUI 教程：</strong> <a class=\"link\"   href=\"https://www.raywenderlich.com/books/swiftui-apprentice\" >Raywenderlich - SwiftUI Apprentice<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n<li><strong>Big Mountain Studio 的免费电子书：</strong> <a class=\"link\"   href=\"https://www.bigmountainstudio.com/free-swiftui-book\" >SwiftUI Views Quick Start<i class=\"fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon\"></i></a></li>\n</ul>\n","_processedHighlight":true}],"PostAsset":[],"PostCategory":[{"post_id":"cmag5d8a600012xqg6r8phc1l","category_id":"cmag5d8a800032xqgftg131vl","_id":"cmag5d8ab000a2xqg7iyuevgw"},{"post_id":"cmag5d8ac000b2xqg59vt8b9j","category_id":"cmag5d8a800032xqgftg131vl","_id":"cmag5d8ae000h2xqghfro7c44"},{"post_id":"cmag5d8ad000c2xqg96faa0z1","category_id":"cmag5d8ae000f2xqg6j7xgg0i","_id":"cmag5d8ag000r2xqgh5kqdrg9"},{"post_id":"cmag5d8ad000e2xqg7zf10hz5","category_id":"cmag5d8ae000f2xqg6j7xgg0i","_id":"cmag5d8ah000w2xqgh4n119a3"},{"post_id":"cmag5d8ag000t2xqgb0ynaimp","category_id":"cmag5d8ag000q2xqg4p8j6051","_id":"cmag5d8ah000z2xqgdvky3nw1"},{"post_id":"cmag5d8ae000g2xqg44rq0ue4","category_id":"cmag5d8ag000q2xqg4p8j6051","_id":"cmag5d8ai00122xqg6a2n18rn"},{"post_id":"cmag5d8ae000i2xqghw0ygtux","category_id":"cmag5d8ag000q2xqg4p8j6051","_id":"cmag5d8ai00162xqggukrd3gy"},{"post_id":"cmag5d8af000n2xqg7963hbb1","category_id":"cmag5d8ag000q2xqg4p8j6051","_id":"cmag5d8ai00182xqgdbph6vo2"},{"post_id":"cmag5d8ah000v2xqg8f4ngtgw","category_id":"cmag5d8ai00152xqg87m00t6g","_id":"cmag5d8aj001f2xqg5jam63o2"},{"post_id":"cmag5d8ag000p2xqg2xo846pm","category_id":"cmag5d8ai00152xqg87m00t6g","_id":"cmag5d8aj001j2xqgakse9ww1"},{"post_id":"cmag5d8ag000p2xqg2xo846pm","category_id":"cmag5d8ai001d2xqg4n0f15l5","_id":"cmag5d8aj001k2xqgbkts51ux"}],"PostTag":[{"post_id":"cmag5d8a600012xqg6r8phc1l","tag_id":"cmag5d8aa00042xqgaaigcdlh","_id":"cmag5d8ab00082xqg8khe8hrh"},{"post_id":"cmag5d8ac000b2xqg59vt8b9j","tag_id":"cmag5d8ad000d2xqg7aie04d1","_id":"cmag5d8ae000k2xqg7tzr1qk0"},{"post_id":"cmag5d8ad000c2xqg96faa0z1","tag_id":"cmag5d8ae000j2xqgb6t30og7","_id":"cmag5d8ag000s2xqg8ndxfp91"},{"post_id":"cmag5d8ad000e2xqg7zf10hz5","tag_id":"cmag5d8ae000j2xqgb6t30og7","_id":"cmag5d8ai00112xqgale2aef7"},{"post_id":"cmag5d8ad000e2xqg7zf10hz5","tag_id":"cmag5d8ah000u2xqg82fa5dcp","_id":"cmag5d8ai00132xqg8chggk4l"},{"post_id":"cmag5d8ae000g2xqg44rq0ue4","tag_id":"cmag5d8ah000y2xqg8kkf07d1","_id":"cmag5d8ai001a2xqg5xzogpht"},{"post_id":"cmag5d8ae000g2xqg44rq0ue4","tag_id":"cmag5d8ai00142xqg588t504t","_id":"cmag5d8ai001b2xqg3zdo8mvr"},{"post_id":"cmag5d8ae000i2xqghw0ygtux","tag_id":"cmag5d8ai00172xqg9ovt6bry","_id":"cmag5d8ai001e2xqg9jn6d6ye"},{"post_id":"cmag5d8ae000l2xqg65pwekqj","tag_id":"cmag5d8ai001c2xqg2o8g42xx","_id":"cmag5d8aj001h2xqg13iwavwy"},{"post_id":"cmag5d8af000n2xqg7963hbb1","tag_id":"cmag5d8ai001c2xqg2o8g42xx","_id":"cmag5d8aj001m2xqg0iqe3v38"},{"post_id":"cmag5d8af000n2xqg7963hbb1","tag_id":"cmag5d8aj001i2xqg136agfyu","_id":"cmag5d8aj001n2xqg19aa2eiz"},{"post_id":"cmag5d8ag000t2xqgb0ynaimp","tag_id":"cmag5d8ai001c2xqg2o8g42xx","_id":"cmag5d8aj001p2xqg0wc93phc"},{"post_id":"cmag5d8ag000t2xqgb0ynaimp","tag_id":"cmag5d8aj001o2xqg2nso88w2","_id":"cmag5d8aj001q2xqgfc9xfjrc"}],"Tag":[{"name":"数据库","_id":"cmag5d8aa00042xqgaaigcdlh"},{"name":"奇思妙想","_id":"cmag5d8ad000d2xqg7aie04d1"},{"name":"短诗","_id":"cmag5d8ae000j2xqgb6t30og7"},{"name":"自然","_id":"cmag5d8ah000u2xqg82fa5dcp"},{"name":"前后端交互","_id":"cmag5d8ah000y2xqg8kkf07d1"},{"name":"网站开发","_id":"cmag5d8ai00142xqg588t504t"},{"name":"杂记","_id":"cmag5d8ai00172xqg9ovt6bry"},{"name":"前端","_id":"cmag5d8ai001c2xqg2o8g42xx"},{"name":"CSS","_id":"cmag5d8aj001i2xqg136agfyu"},{"name":"JS","_id":"cmag5d8aj001o2xqg2nso88w2"}]}}